:: Player Phase [nobr battle]
<<set _destinationQueue = []>>
<<specialcheck>>
<<if $B.specialdeath.length > 0>>
	<<set _specialmsg = true>>
	<<set _destinationQueue.push($B.specialdeath.shift())>>
<<else>>
	<<victorycheck>>
<</if>>
<<if _destinationQueue.length > 0>>
	<<goto `_destinationQueue[0]`>>
<</if>>

<<set $B.phase = "selection">>

<<if setup.TURN_MODEL.toLowerCase() === "free">>
	<<set _doneCount = 0>>
	<<for _puppet range puppets()>>
		<<if (!_puppet.active || _puppet.dead || _puppet.noact) && !_puppet.down>>
			<<set _doneCount++>>
		<</if>>
	<</for>>
	<<if !(_destinationQueue.length > 0 || _specialmsg)>>
		<<if setup.AUTO_ENDTURN === true && _doneCount == puppets().length>>
			<<endRound>>
		<<elseif setup.TURN_EXCHANGE === true && $B.enemyTurns > 0>>
			<<set $B.phase = null>>
			<<goto "Enemy Phase">>
		<</if>>
	<</if>>
<</if>>

<span id="status">
<<include status>>
</span>

<<liveblock>>
<span id="content">
<span id="actorlist">
<<include "actorlist">>
</span>
<div id="phase">

</div>
</span>
<</liveblock>>

:: actorlist [nobr]
/* setup */
<<set _queue = new Set()>>
<<set _enemiesClass = "actors enemies">>
<<set _puppetsClass = "actors">>
<<include "battle display mods actorlist">>

<<if setup.BATTLE_GRID === true>>
	<<set _enemiesClass += " grid"; _puppetsClass += " grid">>
<</if>>

<div id="enemies">
<<include "actorlist enemies">>
</div>

<div id="battlelines">
<<include "special battle lines">>
</div>

<div id="puppets">
<<include "actorlist puppets">>
</div>

:: actorlist enemies[nobr]
<div @class="_enemiesClass">
<<set _martyr = enemies().find(function (e) { return e.martyr})>> /* check if an enemy martyr exists; used in targeting */
<<if setup.BATTLE_GRID === true>>
	<<include "grid actorlist enemies">>
<<else>>

<<for _i, _enemy range $enemies>>
	<<set _enemyClass = "enemy">>
	<<if !_enemy.hidden>>
		<<actorBox _enemy _enemyClass>>
	<<else>>
		/* display nothing */
	<</if>> /* end hidden if */
<</for>>

<</if>>
</div>

:: actorlist puppets[nobr]
<<if setup.BATTLE_GRID === true>>
	<<include "grid actorlist puppets">>
<<else>>
<div @class="_puppetsClass">

<<if $B.phase === "command">>
	<div style="position:absolute; top:0; right:0"><<backbtn>></div>
	<<actorBox $subject>>
<<else>>
	<<for _i, _puppet range $puppets>>
		<<set _puppetClass = "">>
		<<actorBox _puppet _puppetClass>>
	<</for>>
	<br/>
<</if>>
</div>

<<if $B.phase == "selection">>
	<<if setup.TURN_MODEL.toLowerCase() === "free">>
		<br/>
		<div id="endturn">
		<center>
		<<include "End Turn Button">>
		</center>
		</div>
		<div id="roundCounter">ROUND <<print $B.turnCounter>></div>
	<</if>>
	<br/>
	<br/>
	<span id="quit"><<include "Quit Button">></span>
<<elseif $B.phase == "command">>
	<br/>
	<<include "commands">>
<</if>>

<</if>>

:: End Turn Button [nobr]
<<if $B.enemyTurns == 0 || _doneCount == puppets().length>>
	<<button "END TURN">>
		<<endRound>>
	<</button>>
<<else>>
	<<button "ADVANCE TURN">>
		<<set $B.phase = null>>
		<<goto "Enemy Phase">>
	<</button>>
<</if>>

:: Quit Button [nobr]
<<if $scenario === "Tutorial">>
	<<button "Return">>
		<<replace "#quit">>Really quit? [[Yes|Defeat]] | <<link "No">><<replace "#quit">><<include "Quit Button">><</replace>><</link>><</replace>>
	<</button>>
<<else>>
	<<button "Surrender">>
		<<replace "#quit">>Really quit? [[Yes|Defeat]] | <<link "No">><<replace "#quit">><<include "Quit Button">><</replace>><</link>><</replace>>
	<</button>>
<</if>>

:: commands[nobr]
<div class="commandcontainer">
<div class="commands">
	<span id="actbtn"><<act $subject>></span><br />
	<span id="restbtn"><<rest $subject>></span><br />
	<span id="itembtn"><<items $subject>></span><br />
	<<if setup.BATTLE_GRID === true>><span id="movebtn"><<move $subject>></span><br /><</if>>
	<<if $B.surrender is true>>
		<<spare $subject>><br/>
	<</if>>
</div>
</div>

:: status [nobr]
<<if def $B.actor && $B.actor !== null>>

<div class="statusname">$B.actor.name</div>
<<if setup.TURN_MODEL.toLowerCase() === "action">>
	<span class="statname">ACT TIME:</span>
	<span class="stat">
		<<print $B.actor.actTime>><<if Number.isInteger(setup.TIME_THRESHOLD)>> / <<print setup.TIME_THRESHOLD>><</if>>
	</span>
	<br/>
<</if>>
<div style="float: right;">
<<if def setup.STATUS_SCREENS.battle && setup.STATUS_SCREENS.battle.length > 0>>
<span id="statusback">
<<link "<">>
	<<set $stScreen-->>
	<<if $stScreen < 1>>
		<<set $stScreen = setup.STATUS_SCREENS.battle.length+1>>
	<</if>>
	<<if setup.STATUS_SCREENS.battle[$stScreen-2] == "aggression" && $B.actor instanceof Puppet>>
		<<set $stScreen-->>
	<</if>>
	<<replace "#status">><<include "status">><</replace>>
<</link>>
</span>
<span id="statusforward">
<<link ">">>
	<<set $stScreen++>>
	<<if setup.STATUS_SCREENS.battle[$stScreen-2] == "aggression" && $B.actor instanceof Puppet>>
		<<set $stScreen++>>
	<</if>>
	<<if $stScreen > setup.STATUS_SCREENS.battle.length+1>>
		<<set $stScreen = 1>>
	<</if>>
	<<replace "#status">><<include "status">><</replace>>
<</link>>
</span>
<</if>>
</div>
<br/>
<<include "Status Screens">>
<br/>
<<effectinfo>>

<</if>>

:: actions [nobr battle]
<<set $B.phase = "actions">>
<span class="hotkey monospace">
[Q] = basic action
<<if typeof(subject().lastAction) === "string">> |
	<<if new Action(subject().lastAction).check(subject())>>
		<<set _style = "color:gray">>
	<<else>>
		<<set _style = "">>
	<</if>>
	<span @style=_style> [W] = last action (<<print subject().lastAction>>)</span>
<</if>>
<<if subject().crisis instanceof Array && subject().crisis.length > 0>> |
	<<if subject().crisisPoints >= 100>>
		<<set _style = "font-weight:bold">>
	<<else>>
		<<set _style = "color:gray">>
	<</if>>
<span @style=_style> [E] = <<crisisLink>></span>
<</if>>
</span><br/><br/>

<<if setup.COMPRESSED_ACTIONS === true>>
	<<set _actionClass = "compressed">>
	<div id="actionBox">
	</div>
<<else>>
	<<set _actionClass = "">>
<</if>>
<div id="actionList" @class="_actionClass">
<<actionListBattle>>
</div>

:: crisis actions [nobr]
<<set $B.phase = "crisis">>
<span class="hotkey monospace">
[E] = <span id="regularActions">
<<link "Regular Actions">>
	<<replace "#phase">><<include "actions">><</replace>>
<</link>></span>
</span><br/><br/>

<<if setup.COMPRESSED_ACTIONS === true>>
	<<set _actionClass = "compressed">>
	<div id="actionInfo">
	</div>
<<else>>
	<<set _actionClass = "">>
<</if>>
<div id="actionList" @class="_actionClass">
<<actionListBattle $subject "crisis">>
</div>

:: items [nobr battle]
<<set $B.phase = "items">>

<div class="abilities-header" style="text-align:center">ITEMS</div>
<<if setup.COMPRESSED_ACTIONS === true>>
	<<set _actionClass = "compressed itemActions">>
	<div id="actionBox">
	</div>
<<else>>
	<<set _actionClass = "">>
<</if>>
<div id="actionList" @class="_actionClass">
<<itemList>>
</div>

:: action box default [nobr]
<div class="actionBoxHelp">Hover over an action to see info</div>

:: Targeting Phase [nobr battle]
<<set $B.phase = "targeting">>
<<replace "#actorlist">><<include "actorlist">><</replace>>
<<if $action.target == "enemy">>
	<<addclass "#puppets" "invisible">>
<<elseif $action.target == "ally">>
	<<addclass "#enemies" "invisible">>
<</if>>
<<backbtn>>

Select a target. <span class="hotkey monospace">[hotkeys: 1-0] <<if $B.reverse_display>>[enemies are displayed in reverse order]<</if>></span><br/>
<br/>
<<if $action.target == "all">>
<<set _targetingEnemy = true>>
<span class="hotkey monospace" id="target_help">
[Hotkeys targeting <<if _targetingEnemy === true>>enemies<<else>>allies<</if>>. Press Shift to switch targets.]
</span>
<</if>>

:: Confirm Phase [nobr battle]
<<replace "#actorlist">><</replace>>
<<if setup.SHOW_CONFIRM>>
<<set $B.phase = "confirm">>
<<backbtn>>

<<include "Confirm Text">>
&nbsp;
<span id="confirmLink">
<<link "Confirm?">>
	<<include "Action Handler">>
<</link>>
</span><br />
<span class="preview">
<<if $action.preview instanceof Function>>
	<<print $action.preview()>>
<<elseif $action.preview === null>>
	/* blank */
<<else>>
	<<print $action.preview>>
<</if>>
</span>
<<else>>
	<<include "Action Handler">> /* See turn models folder */
<</if>>

:: Battle Continue Button [nobr]
<center id="continue">
<<if passage() == "Anim Test Live">>
	<<button "Return to Landing" "Start">><</button>>
<<else>>
	<<button "Continue...">>
		/* If there are actions still in the queue, we must allow them to execute by re-running the Action Queue. */
		<<if $B.actionQueue.length > 0>>
			<<replace "#content" "t8n">>
				<<include "Action Queue">>
				<<timed 0s>><<include "animation activator">><</timed>>
			<</replace>>
		/* Otherwise, the turn is over and we move the player to the next phase. */
		<<else>>
			<<switch setup.TURN_MODEL.toLowerCase()>>
				<<case "free">>
					<<if passage() == "Enemy Phase" && ($B.enemyTurns > 0 || $B.turn == "enemy")>>
					/* As long as there are enemy turns remaining (or the enemy's turn is active), continue refreshing the Enemy Phase until the enemies are all done. */
						<<goto "Enemy Phase">>
					<<else>>
						<<goto "Player Phase">>
					<</if>>
				<<case "timeline">>
					<<goto "Advance Timeline">>
				<<case "ranked">>
					<<goto "Advance Turns">>
				<<case "action">>
					<<goto "Advance Time">>
			<</switch>>
		<</if>>
	<</button>>
<</if>>
</center>

:: Action Phase [nobr battle]
/* This phase is ONLY FOR PLAYERS. Enemy actions only run "action effects" (see below) */
<<set $B.phase = null>>
<<run $(document).trigger(":action-performed")>>
<span id="status">
<<include "status">>
</span>
<span id="content">

/* Some abilities (such as AoE attacks) don't always end with the same target as the one they started with. This saves the initial target if you want to use it for something, e.g. a reaction scene. */
<<set _initialTarget = $target>>

/* Saves the number of kills from before the action. By comparing this to the kills array afterwards, you can identify whether or not a kill happened during the action. */
<<set _initialKills = $B.kills.length>>

/* Tracks characters who have counterattacked this action. Required to enable counters. */
<<set _counters = []>>

<<if $action.name == "spare">>
	<<run $enemy_to_spare.surrender()>>
<</if>>

/* Add any bonus threat from the action. */
<<if setup.THREAT_TARGETING === true && target() instanceof Enemy && subject() instanceof Puppet>>
	<<run target().threat.inc(subject().name,$action.threat)>>
<</if>>

<<include "action effects">>

/* mark turn done for Puppets */
<<if $action.instant>>
	/* do nothing */
<<elseif $subject.inspired>>
	<<set $subject.inspired = false>>
<<else>>
	<<set $subject.active = false>>
	<<if setup.TURN_MODEL.toLowerCase() === "free">>
		<<set $B.enemyTurns++>>
	<</if>>
<</if>>

/* Remember this action for the last action shortcut: */
<<if !$action.nosave && !$action.passagejump && !($action.name == "struggle" || $action.name == "spare")>>
	<<set _lastAction = subject().actions.find(function (a) { return a && a.name == $action.saveMod })>>
	<<if _lastAction instanceof Action>>
		<<set subject().lastAction = _lastAction.name>>
	<</if>>
<</if>>

/* Record this action as seen by the enemy */
<<set $B.actionsSeen.pushUnique($action.name)>>

<br/>
<<include "Battle Continue Button">>

</span>

:: preAction [nobr]
/* Run in "action effects". Variable adjustments made before action execution. */

/* Subtract action cost */
<<if typeof(subject().en) == "number">>
	<<if $action instanceof ItemAction>>
		<<set $B.item_used = true>>
		<<if $subject.crafty>>
			<<set $action._cost = Math.round(setup.ITEM_COST/2)>>
		<<else>>
			<<set $action._cost = setup.ITEM_COST>>
		<</if>>
	<</if>>
	<<if (subject() instanceof Enemy) || $action.waitTime === 0>>
		<<set $subject.en -= $action.cost>>
	<</if>>
<</if>>

/* Subtract HP cost */
<<if $action.hpcost > 0>>
	<<set subject().hp -= $action.hpcost>>
<</if>>

/* Prime delayed action if one exists */
<<if typeof($action.setupAction) == "string">>
	<<set _action = new Action($action.setupAction)>>
	<<if setup.TURN_MODEL.toLowerCase() === "timeline">>
		<<set _action.delayCounter = 0>>
		<<set subject().ticks += $action.waitTime>>
	<<else>>
		<<set _action.delayCounter = $action.setupDelay>>
	<</if>>
	<<set subject().delayedAction = _action>>
<</if>>

/* For Enemies, set cooldown for the action */
<<if subject() instanceof Enemy && Number.isInteger($action.enemyCD)>>
	<<run subject().cd.set($action.nameCD,$action.enemyCD)>>
<</if>>

<<set $target = Hitlist.protectionCheck($target,$action.targetMod)>>
/* see targeting.js for protectionCheck details */

:: postAction [nobr]
/* Run in "action effects". Variable adjustments made before action execution. */

/* If action was a Crisis, reset crisis points */
<<if $action.crisis && def subject().crisisPoints>>
	<<set subject().crisisPoints = 0>>
<</if>>

/* If action was an item, decrement item stock and reset item flag */
<<if subject() instanceof Puppet && $action instanceof ItemAction && !$action.free>>
	<<run $inventory.decItem($action.name)>>
<</if>>

/* Set last element for e.g. Artist's attacks */
<<if typeof($action.element) == 'string'>>
	<<set subject().lastUsed = $action.element>>
<</if>>

<<if setup.TURN_MODEL.toLowerCase() === "timeline">>
	<<include "Tick Formula">>
<</if>>

<<if subject() instanceof Puppet>>
	/* If action has limited uses, decrement that */
	<<if def $action.uses>>
		<<run subject().actions.find(function(a) { return a && a.name == $action.name }).uses -= 1>>
		/* Have to perform a search because $action is a clone of the original, reducing its uses will not reduce the uses of the action in the subject's actions list */
	<</if>>

	/* If action has a cooldown, reset it */
	<<if def $action.cd>>
		<<run subject().actions.find(function(a) { return a && a.name == $action.name }).resetCD()>>
		/* Have to perform a search because $action is a clone of the original */
	<</if>>

	<<if $action.oncePerTurn>>
		<<run subject().actions.find(function(a) { return a && a.name == $action.name }).used = true>>
	<</if>>
<</if>>

/* Additional code goes here */
<<include "postAction custom">>

<<if $B.surrender && def $action.name>>
	<<print $enemy_to_spare.surrenderCheck()>>
<</if>>

:: action effects [nobr]
/* Where the action actually happens. Kept separate from Action Phase for modularity purposes. */
<<include "battle interruptions">>

<<include "preAction">>

<<if $action.silent === true>>
	<<if $action.act instanceof Function>>
		<<print $action.act()>>
	<<else>>
		<<print $action.act>>
	<</if>>
	<<switch setup.TURN_MODEL.toLowerCase()>>
		<<case "timeline">>
			<<goto "Advance Timeline">>
		<<case "ranked">>
			<<goto "Advance Turns">>
		<<case "action">>
			<<goto "Advance Time">>
		<<default>>
			<<goto "Player Phase">>
	<</switch>>

<<else>>

<<set _queue = new Set()>> /* Queue for damage popups. */

<div style="display:flex; flex-direction:column"> /* container for action display components */

/* Gameplay effect of the action. This will be displayed last (see actions.css), but must be run first because later portions depend on the results. */
<<if $action.act !== null>>
<div id="actEffect">

<<if def _targetingMsg>>
/* This section covers text that has to be generated elsewhere for various reasons, such as the alert for a Protector covering another character. */
<<print _targetingMsg>>
<<unset _targetingMsg>>
<</if>>

<<if $action.noRedundant>>
	<<set _list = [target().name]>>
	<<if ($target.ownParty.length - deadCount($target.ownParty)) < $action.hits>>
		<<set $action.hits = $target.ownParty.length - deadCount($target.ownParty)>>
	<</if>>
<</if>>
<<for _hitNo = 1; _hitNo <= $action.hits; _hitNo++>>
	<<set _hit = true>>
	<<if $action.spread && _hitNo > 1>>
		<<if $action.noRedundant && _list.length < $target.ownParty.length>>
			<<set _keepGoing = true>>
			<<for _keepGoing>>
				<<set $target = Hitlist.targetEnemy($action.targetMod)>>
				<<if _list.includes(target().name)>>
					<<set _keepGoing = true>>
				<<else>>
					<<set _keepGoing = false; _list.push(target().name)>>
				<</if>>
			<</for>>
		<<else>>
			<<set $target = Hitlist.targetEnemy($action.targetMod)>>
		<</if>>
	<</if>>
	<<if _queue instanceof Set>>
		<<run _queue.add($target)>>
	<</if>>
	<<accuracyCheck>>
	<<if _hit === true>>
		<<if !$action.targetMod.includes("unblockable")>>
			<<shieldCheck>>
		<</if>>
		<<if _hit === true>>
			<<if _hitNo === $action.hits && $action.finisher instanceof Function>>
				<<print $action.finisher()>>
			<<else>>
				<<if $action.act instanceof Function>>
					<<print $action.act()>>
				<<else>>
					<<print $action.act>>
				<</if>>
			<</if>>
		<</if>>
	<<else>>
		<<print setup.MISS_MESSAGE>>
		<<set target().battleMsg.push({shake: false, content:"MISS"})>>
		<<if $action.onMiss instanceof Function>>
			<<print $action.onMiss()>>
		<</if>>
	<</if>>
<</for>>

</div> /* close action effects div */
<</if>>

/* Flavor text relating to the action. It is a div element, making it a separate block from the gameplay effects. By default, it has a bottom margin of 1em to create a separator between flavor text and gameplay text. */

<div id="actFlavor">

/* First is action use text. A regular action takes the form "Actor uses..." Items take the form "Actor uses a/n..." This is a div element, which means it creates an automatic line break. */

<<if !($action.useText === null || ($action.useText instanceof Function && $action.useText() === null))>>
/* Set useText to null to bypass this element. This is useful if you only want one of the two areas to display. */
<div id="useText">
<<if $action.useText instanceof Function>>
	<<print $action.useText()>>
<<else>>
	<<print $action.useText>>
<</if>>
</div>
<</if>>

/* Special "interrupt" field, for battle interruptions, displayed after the use text but before the act text. To populate it, in "battle interruptions", target "#interrupt" with the replace macro, and remember to remove the "invisible" class with removeClass. Note that as with all DOM macros, the element must be rendered before code is executed, so this will likely require wrapping the code in a timed 0s macro. */
<div id="interrupt"></div>

/* Then descriptive text. This is a div element, so it creates an automatic line break. */

<<if $action.actText != null>>
/* Set actText to null to bypass this element. This is useful if you only want one of the two areas to display. */
<div id="actText">
<<if $action.actText instanceof Function>>
	<<print $action.actText(_hit)>>
<<else>>
	<<print $action.actText>>
<</if>>
</div>
<</if>>

</div> /* close flavor text div */

<<if setup.ANIMATIONS === true && _queue.size > 0>>
<div class="actors animationContainer">
<<set _animationActive = true>>

<<for _i, _p range _queue>>
  <div style="position:relative">
    <div @id="'dmgBox'+_i" style="display:inline-block">
		<<capture _p>>
		<<liveblock>>
    	<<actorBox _p "" "simplified" "dmgDisplay">>
		<</liveblock>>
		<</capture>>
    </div>
		<<for _x, _m range _p.battleMsg>>
	    <div @id="'dmg'+_i+'-'+_x" class="dmgPopup">
				<<print _m.content>>
	    </div>
		<</for>>
  </div>
<</for>>

</div>
<</if>>

</div> /* close container */

<</if>> /* end silent check */

<<include "postAction">>

<<if def _OG>>
	<<set $subject = _OG.subject; $target = _OG.target; $action = _OG.action>>
	<<unset _OG>>
<</if>>

:: Spell Phase [nobr battle]
<<set $B.phase = "spell">>
<<backbtn>>

<<if isNaN($action.cost)>>
You need to input a number.<br/>
<<elseif $action.cost < $B.mincost>>
Spell requires at least $B.mincost Energy.<br/>
<<elseif $subject.en < $action.cost>>
Not enough Energy!<br/>
<</if>>

How much Energy do you want to put into $action.name? (Minimum $B.mincost)<br />
<<numberboxplus "$action._cost" $B.mincost autofocus>>
<<include "spell check">>
<</numberboxplus>><br/>
(Press Enter to confirm.)<br/>

:: spell check[nobr]
<<run $action._cost *= 1>>
<<if ($action.cost < $B.mincost) or ($subject.en < $action.cost) or isNaN($action.cost)>>
<<replace "#phase">><<include "Spell Phase">><</replace>>
<<else>>

<<run $action.spellMod()>>

<<if $action.phase != "Confirm Phase">>
	<<set $B.targeting = $action.target>>
	<<replace "#phase">><<include "Targeting Phase">><</replace>>
<<else>>
	<<replace "#phase">><<include $action.phase>><</replace>>
<</if>>

<</if>>

:: RoundEnd [nobr battle]
<span id="status">
<<include status>>
</span>

<span id="content">

<<if setup.TURN_MODEL === "free">>

<<if $B.turn == "player">>
/* If the turn reads "player", it's because the enemy round just finished. Run end of turn for enemies. */
	/* If it's a new player turn, it's a "true" new round, so need to update and reset controller variables. */
	<<set $B.turnCounter++; $B.embargo--; $B.enemyTurns = 0>>
	<<endTurn $enemies>>
	<<newTurn $puppets>>
	<<if _message>>
		<<button "Continue..." "Player Phase">><</button>>
	<<else>>
		<<goto "Player Phase">>
	<</if>>

<<elseif $B.turn == "enemy">>
/* If the turn reads "enemy", the player turn just finished. Run end of turn for player. */
	<<endTurn $puppets>>
	<<if _message>>
		<br/><<button "Continue..." "Enemy Phase">><</button>>
	<<else>>
		<<goto "Enemy Phase">>
	<</if>>
<</if>>

<<elseif setup.TURN_MODEL === "ranked">>
	<<set $B.turnCounter++; $B.embargo-->>
	<<endTurn $puppets>>
	<<endTurn $enemies>>
	<<newTurn $puppets>>
	<<initTurnsRanked>>
	<<if _message>>
		<<button "Continue...">><<forwarder>><</button>>
	<<else>>
		<<forwarder>>
	<</if>>
<</if>>
</span>

:: Enemy Phase [nobr battle]
<<victorycheck>>

<span id="status">
<<include status>>
</span>

<span id="content">
<<if (deadCount() == puppets().length)>>
/* If all puppets are dead, it's game over -- no point in finishing this passage, just let victorycheck do its thing. */
<<else>>

	<<if $B.ambush>>
		<<set $B.ambush = false; $B.turn = "enemy">>
		<center style="font-weight:bold">AMBUSHED!</center><br/>
	<</if>>

	<<set _start = $B.enemyTurns>>

	<<set _enemy = enemies().sort(function(a,b) { return a.priority - b.priority; })
		.find(function (e) { return e && e.active && (!e.dead || e.actionReady) })>>
	/* Returns the first active enemy that is not dead */
	/* Exception is made for enemies that are dead but have a persistent delayed action */
	<<if _enemy instanceof Enemy>>
	/* If first check fails, could not find a valid enemy -- all enemies have acted */
		<<set $subject = _enemy>>
		<<set $target = null>>
		<<set $action = null>>
		<<if !(setup.TURN_MODEL.toLowerCase() === "timeline" || setup.TURN_MODEL.toLowerCase() === "action") && _enemy.isFirstAction>>
			<<newTurn `[_enemy]`>>
		<<elseif setup.TURN_MODEL.toLowerCase() === "timeline">>
			<<run $B.actionsThisTurn[_enemy.id] = []>>
		<</if>>

		<<if !_enemy.fakedeath || _enemy.actionReady>>

			<<if _enemy.noact && !_enemy.actionReady>>
				<<set _effect = _enemy.effects.sort(function(a,b) { return a.priority - b.priority; })
					.find(function (e) { return e && e.holdAction instanceof Function })>>
				/* Sorts effects by priority and returns the first hold effect (one with a holdAction) */
				<<run console.assert(_effect !== undefined,`ERROR in Enemy Phase: ${_enemy.name} has noact but no hold effect`)>>
				<<set $action = _effect.holdAction()>>
				<<include "action effects">><br/>

			<<else>>
				<<set _counters = []>>
				<<run console.log("enemy turn for "+_enemy.name+"; has delayed action?"); console.log(_enemy.delayedAction); console.log(_enemy.actionReady)>>
				<<if _enemy.actionReady>>
					<<set $action = _enemy.delayedAction>>
					<<set _enemy.delayedAction = null>>
				<<else>>
					<<run _enemy.actions()>>
				<</if>>
				<<run $B.actionsThisTurn[_enemy.id].push($action.name)>>
				<<if !($target instanceof Actor) && $action.targetMethod instanceof Function>>
					/* If a target hasn't already been selected, use the action's targetMethod (defaults to Hitlist methods) */
					<<set $target = $action.targetMethod()>>
				<</if>>
				<<run console.assert($target instanceof Actor,"ERROR in Enemy Phase: no target found for "+$action.name+". Check the action's targeting logic for errors, e.g. all targets in Stasis when trying to apply an effect.")>>
				<<if !_targetfail>>
					<<include "action effects">><br/>
				<</if>>
				<<if $action.fullround === true>>
					/* Full-round actions use up all remaining attacks. */
					<<run _enemy.noAttacks = 0>>
				<<elseif !$action.instant>>
					/* Otherwise, noAttacks is reduced by 1, unless the action was instant. */
					<<run _enemy.noAttacks-->>
				<</if>>
				<<if _enemy.noAttacks <= 0 && setup.TURN_MODEL.toLowerCase() === "free">>
					/* If out of actions, enemy's turn is done. If the model is free-action, we need to remove their turn from the pool. */
					<<run $B.actionsThisTurn[_enemy.id] = []>>
					<<run $B.enemyTurns -= 1>>
				<</if>>
			<</if>>

		<<else>>
		/* If faking death, enemies should do nothing, so just go to the next enemy.
			All code outside this if/else such as newTurn and threat decay will still execute. */
			<<goto "Enemy Phase">>
		<</if>> /* end fakedeath if */

		/* End turn by setting active to false. Exception: If the enemy took an action this turn (so, did not experience special clauses like stuns or fakedeath) and still has attacks remaining, keep active set to true so they get another turn when this passage is called again. */
		<<if !($B.actionsThisTurn[_enemy.id].length > 0 && _enemy.noAttacks > 0)>>
			<<set _enemy.active = false>>
		<</if>>
		<<run _enemy.decayThreat()>>

	<<else>>
	/* If this check failed, the enemy turn is done. Advance the round. */
		<<switch setup.TURN_MODEL.toLowerCase()>>
			<<case "timeline">>
				<<goto "Advance Timeline">>
			<<case "ranked">>
				<<goto "Advance Turns">>
			<<case "action">>
				<<goto "Advance Time">>
			<<case "free">>
				<<set $B.turn = "player">>
				<<goto "RoundEnd">>
		<</switch>>
	<</if>>

	<<include "Battle Continue Button">>

<</if>>
</span>
