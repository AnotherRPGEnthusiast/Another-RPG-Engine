:: Additional Features[text info]
This passage will discuss non-essential RPG features with only skeletal implementations in the default engine, but which may be of interest. This will contain rather advanced discussion of code and will build on the principles discussed in the design passage, so it is recommended you read [[Documentation|Documentation (Advanced)]] and [[Design]] first.

<h1>Table of Contents</h1>
><a href="#flow">Battle Flow and Turn Order</a>
>><a href="#flow.1">Method 1: Ranked Order</a>
>>><a href="#flow.1.a">Adding Variance</a>
>><a href="#flow.2">Method 2: Action Time</a>
>>><a href="#flow.2.a">Action Time with Threshold</a>
>><a href="#flow.3">Method 3: Timeline</a>
>>><a href="#flow.3.a">Duel (One-Character) Systems</a>
>><a href="#flow.4">Transparency</a>
><a href="#progress">Progression and Leveling Up</a>
>><a href="#progress.levels">Levels</a>
>>><a href="#progress.levels.1">Calculating XP Requirements</a>
>>><a href="#progress.levels.2">What Do Levels Do?</a>
>>><a href="#progress.levels.code">Implementation</a>
>><a href="#progress.pointbuy">Point-Buy</a>
>>><a href="#progress.pointbuy.code">Implementation</a>
>><a href="#progress.equip">Equipment-Based Progression</a>
><a href="#battlegrid">Battle Grid</a>
>><a href="#battlegrid.1">Setup</a>
>><a href="#battlegrid.2">Features</a>
><a href="#missMechanics">Misses and Critical Hits</a>
>><a href="#misses">Accuracy and Misses</a>
>><a href="#crits">Critical Hits</a>
><a href="#bestiaryDocs">Bestiary/Enemy Encyclopedia</a>
>><a href="#bestiaryClass">Bestiary Class</a>
>><a href="#bestiaryEntryClass">BestiaryEntry Class</a>
><a href="#crisis">Crisis/Limit Breaks</a>
>><a href="#crisis.code">Implementation</a>
>><a href="#crisis.stash">Stash</a>

<h2 id="flow">Battle Flow and Turn Order</h2>
In <i>Cartoon Battle</i>, everyone can take their turns in any order, and each party's turn happens all at once. This system is very simple to implement and balance: everyone gets the same number of actions and acts at the same rate. I recommend it to novice developers for this reason.

This is not the only way to structure turn order, however. Many RPGs include a "speed" or "agility" stat that makes some characters act before others.

<h3 id="flow.1">Method 1: Ranked Order</h3>
The simplest way to implement this is to have everyone act in order of decreasing Speed. So, for instance, if we have three characters with 10, 5, and 4 Speed and an enemy with 9 Speed, every round will go in the order of Character A - Enemy - Character B - Character C. If we boost the enemy to 11 speed, they'd now go before any player characters, which could make them quite tricky! Under this model, everyone would still get the same number of turns -- after each round, we'd just repeat the queue. This means balancing actions is still fairly simple. However, we do gain added complexity by fixing characters' positions in the turn order -- especially if there are actions that can assist or set up other characters' abilities, such as buff and debuff effects. Players will need to construct their strategy around the turn order instead of being able to change when it suits them. Assuming a gradual increase in stats over the course of the game, players are also encouraged to increase their Speed to act before enemies and gain the advantage.

Below is an example of how to implement this system in SugarCube:

First, we will need to place every battling character into one array. In the default system, enemies and player characters are completely separate. One method that would work would be to create an <i>array of arrays</i> that links both enemy and player arrays into one object. That would look like this:
{{{
<<set $actors = [$puppets,$enemies]>>
}}}
If you run a {{{for}}} loop over {{{$actors}}}, you can iterate over both enemy and player parties at once -- as well as potential other parties, if you want to design complex multi-front battles.

Then you'd want to use the code in the "Initiative Model: Ranked Order" passage, which is copied here:
{{{
<<set _initiative = -1>>
/* The -1 is necessary if you want a Speed of 0 to be possible. */
<<for _i, _party range $actors>>
	<<for _j, _actor range _party>>
		<<if not _actor.dead and not _actor.stunned>>
		/* If you have more paralysis effects, you'll need to add each here. Consider adding a convenient "can't act" attribute flipped by all of them if this becomes prohibitive.
			<<if not _actor.isDone and _actor.speed > _initiative>>
			/* (not _actor.isDone) prevents us from selecting characters who have already acted this round. They'll be skipped over, and the next-fastest character will get the initiative. */
				<<set _subj = [_i,_j]>>
				<<set _initiative = _actor.speed>>
				/* This sets the current character's Speed as the new bar to clear. If no one's faster, no one else will pass the if check above and this character will remain the current subject. If someone else is faster, they'll become the subject and the _initiative variable will be updated to match their Speed. This ensures that subject status will be granted to the fastest character. */
			<<elseif not _actor.isDone and _actor.speed == _initiative>>
			/* You'll need a handler for this case, or else the character with the higher index order will get the initiative in the case of a match. This handler can be anything, including nothing at all. If you want to be nice, you could automatically give the player the initiative in the case of a tie. Here I've provided the fairest possible option: a coin flip. */
				<<set _r = random(1,2)>>
				<<if _r == 1>>
					<<set _subj = [_i,_j]>>
				<</if>>
			<</if>>
		<</if>>
	<</for>>
<</for>>

<<if ndef _subj>>
(You should write an error message here.)
<<else>>
	<<if _subj[0] == $actors.indexOf($puppets)>>
		<<set $subject = [$puppets[_j],"$puppets["+_j+"]"]>>
	<<elseif _subj[0] == $actors.indexOf($enemies)>>
		<<set $subject = [$enemies[_j],"$enemies["+_j+"]"]>>
		<<set $B.turn = "enemy">>
	<<else>>
		(You should write an error message here.)
	<</if>>
<</if>>
}}}
(This is far more complicated than it needs to be because Twine does not preserve object references. In a proper coding engine we could just {{{
<<set $subject = _actor>>
}}} within the loop and be done with it, but Twine necessitates the second section.)

Note that this assumes a character's Speed stat will never go below 0.

You can make this a widget, or another passage that is run after every character's turn. Presumably, you would also modify the "Battle!" passage to only display commands for the active subject, with a handler in case the enemy has the active turn (probably forwarding the player to another passage for the enemy turn).

<h4 id="flow.1.a">Adding Variance</h4>
Unfortunately, the above model has a weakness: Speed has a binary, rather than variable, effect. With stats such as Attack and Defense, every point matters, because it contributes to a numerical value. But once you have more Speed than the enemy, there's no benefit to gaining more Speed. This can lead to Speed losing value compared to other stats, and making Speed-focused characters weaker overall.

Some games patch this problem by making the rules less rigid: instead of being determined by the absolute Speed values every time, initiative is  instead determined through a random formula influenced by the Speed stat. Some games, such as <i>Dungeons & Dragons</i>, can use quite variable formulas, but for this example I will model a simpler one, varying characters' Speed stats by a certain percentage of their base values.

In SugarCube, you could implement this feature like so:
{{{
<<for _party range $actors>>
	<<for _actor range _party>>
		<<if not _actor.dead and not _actor.stunned>>
			<<set _actor.initiative = _actor.speed>>
			<<set _variance = random(-$VARIANCE_BOUND,$VARIANCE_BOUND)>>
			<<set _variance /= 100>>
			/* Twine's random() function requires integer bounds, but we (presumably) plan to vary characters' Speed stats by a small proportion. We can do this by setting $VARIANCE_BOUND to an integer percentage value (probably in StoryInit) and dividing by 100 to get the decimal value. */
			<<set _actor.initiative += _actor.speed * _variance>>
		<</if>>
	<</for>>
<</for>>
}}}
You can then use the same code as in the previous section, except you would compare {{{_initative}}} to {{{_actor.initiative}}} instead of {{{_actor.speed}}}.

As an example, let us say we set {{{$VARIANCE_BOUND}}} to 10. This would give {{{_variance}}} a random value from anywhere between -10 and 10. We then convert it into a decimal, making it a random value between -.1 and .1. We then take {{{_actor.initiative}}}, which is initialized at the same value as {{{_actor.speed}}}, and add a fraction of {{{_actor.speed}}} to get the character's final initiative value. The size and sign of the fraction is determined by {{{_variance}}}.

If the character had 100 Speed, their initiative value could be anywhere between 90 and 110. This means a character with 90 Speed could beat them in the turn order, if they rolled high and the 100 Speed character rolled low. However, the 100 Speed character would still get the first turn more often than not. Additionally, a character with 81 Speed would never beat them in turn order even if they got the maximum bonus and the 100 Speed character got the maximum penalty: {{{81 + (81*0.1) = 89.1}}} is less than {{{100 + (100*-0.1) = 90}}}.

You can add more randomness by increasing the variance bound.

This variance makes a Speed focus a more optimal gameplay decision: even if you're fast, more Speed increases the chance you'll get the initiative, rather than ceasing to matter once you get 1 point more than your opponent.

I, personally, hate this method with a burning passion, because I feel turn order is too important of a thing to leave up to chance, and makes it nigh-impossible for the player to implement long-term strategy if they cannot predict the turn order.

Some games feel this still leaves Speed a suboptimal stat, and have it influence other aspects of battle as well, such as accuracy, evasion, and critical hit rates. (These features are not in the default engine because I despise them, but I may include a tutorial on implementing them if there is demand.)

<h3 id="flow.2">Method 2: Action Time</h3>
If you've played any <i>Final Fantasy</i> game after <i>Final Fantasy III</i>, or any game made in RPG Maker 2003, you will be familiar with this system. (Yes, even <i>Final Fantasy X</i>.)

The most familiar form, seen in the examples I mentioned, is an odd method of merging turn-based RPGs with reaction-based action games: characters have gauges that fill up in real time, and characters can take an action when it's full. Usually this process pauses while you choose your action, but sometimes you have to choose quick while enemies are still getting turns.

Such a real-time, image-based system is obviously not suited for Twine. You could theoretically do it with {{{<<timed>>}}} and {{{<<repeat>>}}} macros, maybe...? But your time would almost certainly be better spent in another environment entirely.

What I've described is just an abstraction, though. If we look at the variables underneath, we can create a similar system even in our static Twine.

First, we're going to increment a separate "initiative" attribute based on some formula. The formula can include anything, including random variance, but for the purposes of this example let's just make the increment equal to the Speed stat:
{{{
<<for _party range $actors>>
	<<for _actor range _party>>
		<<if not _actor.dead>>
			<<set _actor.initiative += _actor.speed>>
		<</if>>
	<</for>>
<</for>>
}}}
We then use a modified form of our code from <a class="noExternal" href="#flow.1">Method 1</a>:
{{{
<<set _initiative = -1>>
<<for _i, _party range $actors>>
	<<for _j, _actor range _party>>
		<<if not _actor.dead>>
			<<if _actor.initiative > _initiative>>
				<<set _subj = [_i,_j]>>
				<<set _initiative = _actor.initiative>>
			<<elseif _actor.initiative == _initiative>>
				<<set _r = random(1,2)>>
				<<if _r == 1>>
					<<set _subj = [_i,_j]>>
				<</if>>
			<</if>>
		<</if>>
	<</for>>
<</for>>

<<if ndef _subj>>
(You should write an error message here.)
<<else>>
	<<if _subj[0] == $actors.indexOf($puppets)>>
		<<set $subject = [$puppets[_j],"$puppets["+_j+"]"]>>
	<<elseif _subj[0] == $actors.indexOf($enemies)>>
		<<set $subject = [$enemies[_j],"$enemies["+_j+"]"]>>
		<<set $B.turn = "enemy">>
	<<else>>
		(You should write an error message here.)
	<</if>>
	<<set $subject[0].initiative = 0>>
<</if>>
}}}
This assumes every character's "initiative" attribute is set to 0 at the start of battle.

To keep things simple, the current subject's initiative is set to 0 when they take their turn. In this code, this automatically happens as soon as they're selected; you may want to make this happen in the action phase instead, if you want some actions to drain initiative by different amounts. Maybe there's a "wait" option that only halves it, for instance?

The main difference here is that we do not ignore characters who have acted in the round already: if someone gains more initiative, they can get more turns than another character. This effectively eliminates the concept of "rounds" entirely; characters will just keep taking turns, in no fixed order.

This system will be functionally similar to Method 1 when there is little difference between characters' Speed stats. For example, let's look at a battle where Character A has 11 Speed, Enemy B has 10 Speed, and Character C has 9 Speed:

Initiative at turn 0:
A = 11
B = 10
C = 9

A gets the turn. Their initiative goes to 0.

Initiative at turn 1:
A (1 turn) = 11
B (0 turns) = 20
C (0 turns) = 18

B gets the turn. Their initiative goes to 0.

Initiative at turn 2:
A (1 turn) = 22
B (1 turn) = 10
C (0 turns) = 27

C gets the turn. Their initiative goes to 0.

Initiative at turn 3:
A (1 turn) = 33
B (1 turn) = 20
C (1 turn) = 9

A gets the turn.

Initiative at turn 4:
A (2 turns) = 11
B (1 turn) = 30
C (1 turn) = 18

B gets the turn.

Initiative at turn 5:
A (2 turns) = 22
B (2 turns) = 10
C (1 turn) = 27

C gets the turn. Notice that the initiative values are identical to those on turn 2: we've completed a loop. The characters will continue taking turns in this pattern, which is identical to the pattern in Method 1: characters will act in order of descending Speed, and then repeat.

But that was when the Speed values only differed by 1. Let's look at what happens with bigger differences: A now has 30, B now has 20, and C now has 10.

Initiative at turn 0:
A = 30
B = 20
C = 10

A gets the turn.

Initiative at turn 1:
A (1 turn) = 30
B (0 turns) = 40
C (0 turns) = 20

B gets the turn.

Initiative at turn 2:
A (1 turn) = 60
B (1 turn) = 20
C (0 turns) = 30

A gets the turn. But wait! C hasn't gotten a single turn, but A has now moved twice! That's the key difference in an action time system: faster characters will get more turns total, instead of everyone getting the same number of actions. This is much, <i>much</i> harder to balance. If A gets twice as many turns as B, they've effectively doubled all their stats by only doubling one: even if all their other stats are the same as B's, they're attacking twice as often, defending twice as often, using utility skills twice as often. If Method 1 undervalued Speed, action time <i>overvalues</i> it -- Speed can come to dominate all other stats, because more turns are almost always more desirable than fewer but stronger turns. This can be mitigated in a subtractive defense system where more attacks don't necessarily correlate with more results, but is exacerbated by skills that don't depend on other stats, such as most status effects.

You can still balance this through careful tweaking of the formulas -- maybe initiative gain is only half Speed, for instance -- but it's not a task I recommend for novice developers. It's much easier to include this sort of "multi-turn" functionality through specific actions you can control directly. For example, in <i>Cartoon Battle</i> Rogue's basic attack hits twice, but is weaker than the other basic attacks.

<h4 id="flow.2.a">Action Time with Threshold</h4>
If you're interested in more accurately modeling the version seen in <i>Final Fantasy</i>, you can choose turns based on whose initiative crosses a "finish line" first. <i>Bonfire</i> uses this method, and its algorithm is explained <a href="http://bonfire-game.wikia.com/wiki/Turn_Order" target="_blank">here</a>. Implementation in SugarCube would look something like this:
{{{
<<set _threshold = $ACTION_THRESHOLD>> /* You would set $ACTION_THRESHOLD to some constant in StoryInit. */
<<set _pastThreshold = false>>

/* check for characters already at threshold */

<<for _party range $actors>>
	<<if _pastThreshold>>
		<<break>>
	<</if>>
	<<for _actor range _party>>
		<<if not _actor.dead>>
			<<if _actor.initiative >= _threshold>>
				<<set _pastThreshold = true>>
				<<break>>
			<</if>>
		<</if>>
	<</for>>
<</for>>

/* initiative gain */

<<for not _pastThreshold>>
	<<for _party range $actors>>
		<<for _actor range _party>>
			<<if not _actor.dead>>
				<<set _actor.initiative += 20 + 0.2 * _actor.speed>>
				/* This is the Bonfire formula, but you can add your own */
				<<if _actor.initiative >= _threshold>>
					<<set _pastThreshold = true>>
				<</if>>
			<</if>>
		<</for>>
	<</for>>
<</for>>

/* initiative comparison */

<<for _i, _party range $actors>>
	<<for _j, _actor range _party>>
		<<if not _actor.dead>>
			<<if _actor.initiative > _threshold>>
				<<set _subj = [_i,_j]>>
				<<set _threshold = _actor.initiative>>
			<<elseif _actor.initiative == _threshold>>
				<<if def _subj>>
					<<set _r = random(1,2)>>
					<<if _r == 1>>
						<<set _subj = [_i,_j]>>
					<</if>>
				<<else>>
					<<set _subj = [_i,_j]>>
				<</if>>
			<</if>>
		<</if>>
	<</for>>
<</for>>

<<if ndef _subj>>
(You should write an error message here.)
<<else>>
	<<if _subj[0] == $actors.indexOf($puppets)>>
		<<set $subject = [$puppets[_j],"$puppets["+_j+"]"]>>
	<<elseif _subj[0] == $actors.indexOf($enemies)>>
		<<set $subject = [$enemies[_j],"$enemies["+_j+"]"]>>
		<<set $B.turn = "enemy">>
	<<else>>
		(You should write an error message here.)
	<</if>>
	<<set $subject[0].initiative -= $ACTION_THRESHOLD>>
<</if>>
}}}
To show an example of what this would look like, we'll use the fastest enemy in <i>Bonfire</i>, the Bladewolf, which has 70 Speed; the fastest hero in <i>Bonfire</i>, Assassin, who starts with 40 Speed; and the slowest hero in <i>Bonfire</i>, Knight, who starts with 15 Speed.

Turn 1:
B: 34 - 68 - <b>102</b>
A: 28 - 56 - 84
K: 23 - 46 - 69

Bladewolf gets the turn, and loses 100 initiative. Bladewolf has taken <b>1 turn.</b>

Turn 2:
B: 02 - 36
A: 84 - <b>112</b>
K: 69 - 92

Assassin gets the turn. Turn order so far is <b>B, A</b>.

Turn 3:
B: 36 - 70
A: 12 - 40
K: 92 - <b>115</b>

Knight gets the turn. Turn order so far is <b>B, A, K</b>.

Turn 4:
B: 70 - <b>104</b>
A: 40 - 68
K: 15 - 38

Turn order so far is <b>B, A, K, B</b>.

Turn 5:
B: 04 - 38 - 72
A: 68 - 96 - <b>124</b>
K: 38 - 61 - 84

Turn order so far is <b>B, A, K, B, A</b>.

Turn 6:
B: 72 - 106
A: 24 - 52
K: 84 - <b>107</b>

Knight will get the turn, then Bladewolf. Turn order so far is <b>B, A, K, B, A, K, B</b>.

Turn 8:
B: 06 - 40 - 74 - 108
A: 52 - 80 - 98 - <b>126</b>
K: 07 - 30 - 53 - 76

Assassin will get the turn, then Bladewolf. Turn order so far is <b>B, A, K, B, A, K, B, A, B</b>. Bladewolf lapped Knight after 9 turns.

Compared to straight highest-wins initiative:

Turn 1:
B: <b>34</b>
A: 28
K: 23

Turn order: <b>B</b>.

Turn 2:
B: 34
A: <b>56</b>
K: 46

Turn order: <b>B, A</b>.

Turn 3:
B: 68
A: 28
K: <b>69</b>

Turn order: <b>B, A, K</b>.

Turn 4:
B: <b>102</b>
A: 56
K: 23

Turn order: <b>B, A, K, B</b>.

Turn 5:
B: 34
A: <b>84</b>
K: 46

Turn order: <b>B, A, K, B, A</b>.

Turn 6:
B: 68
A: 28
K: <b>69</b>

Turn order: <b>B, A, K, B, A, K</b>. Notice that this distribution is identical to that of turn 3, which means we have entered a stable loop. Bladewolf will never lap Knight in this scenario.

The key difference here is that the simple method always resets initiative to 0 when the subject takes a turn no matter how much they accumulated, but the threshold method allows initiative to carry over if the threshold is overshot. This gives greater weight to differences in Speed stats and makes stable loops less likely. However, designing the correct threshold is itself a challenge; if we were to use a straight gain = Speed formula, anyone with 100 Speed would be able to take turns continuously! The threshold method is best suited to slow gain formulas with less dependence on stats, for this reason. You could also make the threshold flexible, such as tying it to three times the fastest or slowest character's gain rate, but this runs an even greater risk of making stat differences get out of hand.

<h3 id="flow.3">Method 3: Timeline</h3>
Characters' turns are placed at certain points in a timeline. When time advances to their point, they take their turn, and are then placed at another point.

This method is similar to action time, but works in reverse in terms of algorithm: we have everyone's initiative values count <i>down</i>, and characters take their turns when it hits 0.

We'd first need some way of creating an initial turn order. For now, let's assume whoever has the highest Speed stat goes first, and everyone lower than them goes 1 "tick" later for every point of Speed difference. So with characters of Speed 10, 8, 5, and 4, our starting timeline would look like this:
{{{
[A]-[B]--[C][D]
}}}
where dashes are empty ticks.

From here, A would take an action and be placed at a later point in the timeline. This determination could be based on Speed, but it's more commonly based on action; some actions will require the characters to wait longer before they can act again. For instance, attacking with a heavy greatsword might push a character back 6 ticks, while attacking with a knife only pushes them back 4. Maybe casting a spell only pushes them back 3 ticks, but requires 2 additional ticks of wind-up time while they chant the incantation, during which time they may be vulnerable.

After their action, A would be placed ahead in the timeline, and the timeline would advance; everyone's initiative would go down by 1. There's no one in the next tick space, so we'd skip it and run another iteration until the next character appears, in this case, B. They'd take an action, then get pushed ahead to a new slot. The battle would continue like this.

To implement this system, you'd do something very similar to an <a class="noExternal" href="#flow.2.a">action time with threshold</a> system. Only the threshold value and incrementor system would need to be changed. An example model is provided in the "Initiative Model: Timeline" passage.

This is a fairly intuitive system, and superb if you want a battle system based around timing and actions with variable speeds. This system meshes well with features such as charged attacks and delayed effects, as those features can be placed in tick squares as well. However, it's a lot to keep track of, and all the balance problems associated with an action time system still apply. You'll also have to come up with your own system for initial turn order, as I can't think of a good one off the top of my head. (Make a separate "initiative" stat that's either fixed for every character or can only be increased rarely, maybe?)

I took this system from <i>Exalted</i>, a fantasy tabletop RPG that's very different from the popular <i>Dungeons and Dragons</i>. <i>Exalted</i>'s system is massively more complicated than the simple model I've outlined here, but could be a good jumping-off point for you to design your own system. <i>Exalted</i> players often bemoan how hard it is to keep track of all the variables at play, but that's no problem for a computer!

<i>Exalted</i> fan Jye Nicolson created <a href="https://mengtzu.github.io/exalted/sakuya.html" target="_blank">a tutorial game</a> using JavaScript, if you would like to see how the system works in action. Because Twine operates in JavaScript, the game plays very similarly!

<h4 id="flow.3.a">Duel (One-Character) Systems</h4>
Some RPGs, or just some parts of some RPGs, forgo a party system and only give you one player character for battles. From a narrative standpoint this can be very cool: a climactic one-on-one duel with the hero's personal nemesis! But from a gameplay perspective, it often falls flat, because a big part of RPG gameplay is the synergy between multiple characters and actions. If you and the enemy are just trading blows, your options are much more limited; you (usually) can't heal and attack at the same time, for instance.

A timeline system works very well for fixing these issues. If the player can act multiple times for every action of the enemy's, you can still have tactics and synergy even with only one character. Perhaps there is a puzzle-like mechanic of matching different attacks to different enemies or guard states and you must carefully time your actions to attack and defend, almost simulating a more action-focused game? It's something worth considering if you want to use a duel system.

Noteworthy examples:
<ul>
<li><i><a href="https://store.steampowered.com/app/418190/Helens_Mysterious_Castle/" target="_blank">Helen's Mysterious Castle</a></i> is an example of an action-adventure-like system. You can choose various weapons on your turn, and each has a different speed, attack, defense value. Strategy consists of timing your attacks so that you attack when the enemy is weak and shield yourself when the enemy is attacking.</li>
<li><i><a href="https://rpgmaker.net/games/8032/" target="_blank">Red Syndrome</a></i> is a simpler example: all enemies must wait multiple turns between actions, creating a system where you have several turns to prepare for a coming onslaught.</li>
</ul>
<h3 id="flow.4">Transparency</h3>
If you use a turn ordering system, it's beneficial if you can show the turn order to the player. This will allow them to plan in advance by understanding when, say, they need to guard against an enemy's attack or when they should buff a certain character.

Doing this in a ranked order system is very simple: instead of running the selector every time a new character's turn comes up, make an array of all the characters in descending initiative order every round. You can display the array somewhere in the battle screen, and run through it as the round progresses.

Timeline systems are also fairly straightforward: you can display everyone's initiative as "ticks until next action" in their status pane or elsewhere. Ideally, with enough knowledge of CSS, you could create a visual representation showing everyone's placement in the timeline.

Action time systems are a little trickier. You'd need to simulate another round of initiative gain and use that to determine the next actor. This is both algorithmically difficult and processor-intensive to do for more than one or two predictions, so don't worry if you can't give the player an extended prognosis. This will be even tricker if you have skills that alter speed stats or initiative values, as you'll have to redo the prediction every time that happens.

Simplistic models of these preview systems are proposed in the "preview model" passages, found next to the initiative model passages. However, they are untested, and may not be suitable for all your needs. You can tweak them as necessary.

<i>Final Fantasy X</i> has an extremely robust preview system, with an extended prognosis and real-time feedback whenever an ability that would affect the turn order is used. You can try mimicking it if you -- and your processor -- are feeling ambitious!

<h2 id="progress">Progression and Leveling Up</h2>
Leveling up is traditionally one of the core features of the RPG. As you win battles or complete tasks, you will gain experience points that will eventually award you a new level, increasing your stats and giving you access to new abilities. This gives the player a sense of progress throughout the game, and also allows the designer to introduce new mechanics and tactical complexity at a gradual pace, ensuring that the player can become familiar with every one of their tools before they're given a new one. And, let's be honest -- it's just fun to watch numbers go up.

However, even if you've played RPGs before, you've probably never stopped to think about how, exactly, these features are designed. Exactly how does the game calculate how many experience points you need to get to the next level? Exactly how does the game calculate how to increase your stats on a level up?

As with everything in this list, the answer is, "It depends on what experience you, the designer, want to cultivate!" However, that's easier said than done. Progression mechanics are some of the hardest things to design and balance, because they have impacts throughout the entire game. You should also understand that leveling up isn't the only way to accomplish this! We'll discuss alternative progression methods as well, such as point-buy and equipment-based systems.

You may notice that <i>Cartoon Battle</i> doesn't feature any progression mechanics. That's because implementing and balancing this is actually very tricky! You will need to plan very far ahead, and balance your game not only for one state but for situations where the player's capabilities will change over time.

For further reading, see the video "<a href="https://www.youtube.com/watch?v=Ae_zvm0-CQU&list=PL8K0_g1wdQepKF0a8eh_4dhhivcSrSKyO&index=20" target="_blank">What Makes a Good Level Up System?</a>" by Design Doc, which provides another designer's opinions on the progression systems discussed here.

<h3 id="progress.levels">Levels</h3>
We'll start with the one you're likely most familiar with: Characters gain experience points, or XP, from succeeding at gameplay challenges (often killing monsters, but possibly also solving puzzles, navigating conversations, or completing quests). When a character's XP reaches a certain value, they level up and gain increments to various stats. They may gain new abilities as well, but <a class="noExternal" href="#progress.skills">that is another discussion entirely</a>.

Predetermined levels, where the player has no control over the bonuses of a level up, are common in Japanese-style RPGs such as <i>Dragon Quest</i>. (Western RPGs such as <i>Baldur's Gate</i> tend to favor a more open-ended format where levels will give the player some choice over their desired bonus, but that is discussed under <a class="noExternal" href="#progress.pointbuy">point-buy systems</a>.) This method requires the least engagement from the player, as most of the decisions -- when their characters will get stronger and by how much -- are made for them, with all the pros and cons that implies. This method is probably the easiest to balance, as it is easy to predict a player's capability at a given point in the game when their progression is fixed. However, it also means you'll have to plan out every character's progression yourself, which can be a big task!

You should be able to identify two important design questions here: <b>How much XP do characters need to level up?</b> and <b>What are the exact benefits of a level up?</b> There is a potential third question, related to the first, which is what situations will provide XP and how much.

<h4 id="progress.levels.1">Calculating XP Requirements</h4>
You could, in theory, design unique XP requirement values for every single level. However, this is not what most games do, and it is not recommended. It's much easier to design a formula that will generate XP requirements for every level automatically.

The simplest scenario would be no variable formula at all: every level requires the same amount of XP. However, this doesn't make much sense as a design principle. If you're guaranteed a level up every time you, say, kill 10 of the enemies in the starting area, yet each level makes you stronger, you'll kill enemies faster and gain levels faster with each level up, all without even needing to leave the starting area. This model is sometimes viable in certain RPGs with "elastic" difficulty, where enemies have their own levels and become stronger with the player characters, maintaining the same relative difficulty no matter the player's level. However, this is rather complicated to implement, and not the playstyle most RPGs aim for.

You might think the best method would be a linear scale: If going from level 1 to level 2 requires 1000 XP, then from 2 to 3 requires 2000 and from 3 to 4 requires 3000, etc. This can work, but it still tends to make leveling too rapid and players too complacent. To really force players to move on to harder challenges, you need an <b>exponential</b> scale, meaning the difference <i>of</i> the difference in XP requirements becomes greater with every level.

As an example, here is the XP formula for <i>Dungeons and Dragons 3rd Edition</i>:

<div class="formula">XP to next level = 500 * (level ^ 2) - 500 * level</div>
(Technically, this function is quadratic, not exponential, but the principle still applies.)

Here's what that looks like graphically:

[img[setup.ImagePath + "documentation/levels1.PNG"]]

Notice that this growth curve is extremely steep; we can't even see the XP requirement for the maximum level, 20, without extending the Y-axis. After only 4 levels, the XP requirement is 10 times that of level 2.

This is because, in <i>Dungeons & Dragons</i>, every level is intended as a rare and major accomplishment. You might only gain one or two levels during a "chapter" of the story, and you're unlikely to go all the way from level 1 to level 20 in anything but the longest campaigns. <i>Dungeons & Dragons</i> also provides the bulk of its XP rewards through major, one-time accomplishments, such as completing quests, rather than many repetitive actions such as killing individual monsters. A steep formula such as this encourages players to focus on big actions such as pursuing side quests, and rewards close engagement with the world to find such opportunities.

You tend to see steep formulas like these in Western RPGs, which are more directly based on <i>Dungeons & Dragons</i>, than in Japanese-style RPGs such as <i>Dragon Quest</i>. Twine's structure is actually well-suited to the style of a Western RPG, so this formula may be worth considering.

On the opposite end of the scale, we have the "medium fast" XP formula from <i>Pokemon</i>. Different Pokemon use different formulas, but this one is the most common:

<div class="formula">XP to next level = (level ^ 3)</div>
Or graphically:

[img[setup.ImagePath + "documentation/levels2.PNG"]]

This curve is <i>much</i> shallower. While the first formula exceeded our graph's bounds almost immediately, we can fit 20 levels on this scale no problem. (There's no trickery here: the axes have the same scaling as before.)

The reason for this is quite simple: In <i>Pokemon</i>, level ups are meant to be frequent. Not only is the max level (100) much higher than in D&D, but as a monster-collecting game, you are encouraged to raise a large number of "party members". Players are supposed to vary their team and swap out Pokemon over the course of the game. To incentivize this, the game has to make it easy for lower-level Pokemon to catch up if they've been off the team for a while. Thus, low XP requirements.

Shallow formulas are common in Japanese-style RPGs, which tend to make levels more frequent but less individually significant. This incentivizes the player to pursue many small-scale actions that result in incremental rewards, rather than big jumps. You should pick this formula if you want a "grindy" game designed around repetitive actions with frequent payouts.

You don't strictly need a formula at all: it's also possible to use a lookup table with unique values for every single level. But a formula is probably a good starting point if you're new to designing these mechanics.

It should be noted that this is all a <i>gross</i> oversimplification that only scratches the surface of this topic. Things get vastly more complicated if you want more nuance, such as different leveling rates for different characters (older versions of D&D did this, making wizards require more XP per level because they got more out of levels), or elastic leveling where the difference between the hero and enemy's levels affects the payout (useful for discouraging grinding and catching up low-level characters). You'll need to ask around (and learn some math) if you want to tweak your leveling mechanics for something particular. I'd recommend starting by looking up the mechanics from your favorite games -- famous ones such as <i>Dragon Quest</i>, <i>Pokemon</i>, and <i>Dungeons & Dragons</i> are usually well-documented. Break them down by thinking about what you liked and disliked about them, and work from there.

<h4 id="progress.levels.2">What Do Levels Do?</h4>
So say a character has leveled up. What happens now, exactly? Generally, the character's stats are supposed to increase. But by how much?

Some games make stat gains random. I hate this with the intensity of a thousand burning suns and will speak no more of it here. Go to <a href="http://howtomakeanrpg.com/a/how-to-make-an-rpg-levels.html">How to Make an RPG</a> if you wish to pursue this heathen practice.

If you wish to be <i>sensible</i> and make your stat gains totally deterministic, then like XP gain, there are two ways to do this: either through a formula, or by manually setting stats for every level through a lookup table. To effectively design the latter you will need to understand the former, so that's what I will discuss.

The principles for designing a stat growth formula will depend, obviously, on what those stats do and the progression you want to see over the course of the game. In some games, even a single point of a stat can be significant, while in others, stats only have a noticeable effect at high values. You're going to want to review your damage formula and anything else stats might affect, such as status effects and <a class="noExternal" href="#flow">turn order</a>. There is also the matter of "power creep", discussed in the damage formula section: you likely want things to get bigger and flashier as the game progresses, but by how much? Do you want average attack damage to increase at a gradual, linear rate, or at an exponential one that makes the endgame feel like a totally different world than the beginning? This will also be influenced by the XP gain model you're using: if levels are rare, you will probably want them to provide big gains, while if levels are frequent, you will probably want smaller gains per level.

If you want to preserve character specializations, you'll also want these formulas to be different for different characters. A wizard should probably gain Defense more slowly than Magic, for instance.

RPG Maker has default formulas for calculating stat growth of various character archetypes, though I cannot find good documentation for this. If you would like to devise your own, I recommend starting with a small-scale game where each stat point matters, and making stat gains very small. This will be easier to test and balance, as even small changes will have highly visible effects. Learning from example is harder here, as most commercial RPGs use random stat gains. If it works for them and you don't want to bother with complex math you could consider trying it I GUESS.

More atypical arrangements have been devised by some games. You could make stat growth dependent on one or more other variables, as seen with <i>Pokemon</i>'s IV and EV values. (That's detailed <a href="https://bulbapedia.bulbagarden.net/wiki/Statistic#Determination_of_stats" target="_blank">here</a>, for the curious.) You could also decrease the influence of stats by making level a factor in gameplay formulas that use stats, maybe only increasing stats rarely or through other means. This is particularly useful for player-determined stat growth systems, as it gives you a general power level to expect for balance testing, even if the player uses a build you hadn't thought of.

<h4 id="progress.levels.code">Implementation</h4>
Skeleton code for levels and growth tables are included but not detailed in the story JavaScript at the end of the "Puppet" class definition. To actually implement a level up feature, you'd create a widget or another passage that checks the character's current XP against the next level's requirement, and run it whenever a character gets XP. (To save yourself time, you could even make it part of the same code that gives a character XP.) Within this function, you'd determine the stat gains through your formulas or through a lookup table, and do the same to find the XP requirement for the next level.

(A word of warning if you're using a lookup table: while the most intuitive method is to have the lookup value correspond to the <i>absolute</i> stat values you want at that level, if you have events that change base stats through means other than leveling, the lookup table will overwrite those changes! You will have to either store those changes through a separate value, or make the lookup table point to increments instead of absolute values.)

Example widgets for this implementation are provided in the "Widgets: Leveling Up" passage.

<h3 id="progress.pointbuy">Point-Buy</h3>
This is an alternate form of stat progression used by several RPGs, including famous franchises like <i>Shin Megami Tensei</i> and tabletop RPGs like <i>Exalted</i>. Instead of stats being automatically incremented at fixed rates, the player is given control over which attributes they want to improve. You can combine this with a regular leveling system, with every level up giving one or more stat points, or allow players to spend XP on stat upgrades directly.

(If you do the former, however, it's recommended you don't make the number of points per level up divisible by the total number of stats. A lot of players will want to give the same amount of points to all stats just because that's the simplest option. You'll get more engagement if you force them to make a choice.)

This system is popular for the freedom it gives to players, but it can be very difficult to balance due to the many stat arrangements possible as the game progresses. If you design challenges assuming players will add points in a specific arrangement and then a specific player creates a build you didn't expect, the player could have a very hard time. You'll need to do a lot of balance testing to ensure it isn't possible for the player to push themselves into a corner. Ideally, no build should be universally better than another; the player should be allowed to choose a build based on their preferred playstyle, not bite their nails over if they've made the objectively best option.

Some games that use this system allow the player to undo their investments and reconfigure their build. This eliminates the possibility of locking the player into a non-viable build, but potentially eliminates some strategic depth as well. It can be a purposeful design decision to make certain builds more optimal in certain situations and less optimal in others; if the player can just respec to find the optimal build in every situation, the game might become too easy or too uniform. However, you may like this idea as a "puzzle" aspect, forcing the player to think about the optimal allocation of their resources for difficult challenges.

One possible drawback to this system is the elimination of character specialties. Characters in RPGs typically have differing stat layouts that lead to different roles. However, if the player has total control over characters' stat layouts, these specialties can disappear; there's nothing stopping them from putting all the wizard's points into Strength or all the fighter's into Intelligence. Sometimes it can be fun to see how these non-standard builds play out, but sometimes you do want to keep a role fixed. You could enforce this through a "soft" method by giving characters or classes fixed capabilities that draw on specific stats, encouraging players to invest in certain stats over others. (If a fighter can't use magic, for instance, there's no reason to increase their Magic Attack even if you technically can.) Alternatively, you could use a "hard" method of making certain stat improvements cost more for certain characters. It might actually be a good idea to pump up the wizard's Defense, but if that costs twice as many stat points as improving Magic, you won't be able to do it as often. Alternatively, you could make stat improvements small compared to initial stats -- this makes it hard for low stats to "catch up" with high ones even if there is no cost weighting.

The other thing you'll need to watch out for is whether or not it's possible to get everyone to perfect stats eventually. If everyone can be fully maxed out, that's the end goal players will shoot for -- and at that point, everyone's the same! (<i>Final Fantasy X</i> famously had this issue, where the advancement grid was shared by everyone, allowing characters to gain the exact same stats and skills as other characters if they leveled up enough.) It's easy enough to fix this if you don't want it -- as you'd define a level cap in a leveling system, you can create a cap on either stat totals or number of stat purchases -- though you'll probably want to make this clear to the player! You could also make experience points a limited resource.

This system has a lot of potential variations, so it's worth looking at lots of different games that use it. You can have fun tradeoff mechanics by making "stat experience" useful for other things as well -- most commonly, the mechanic is framed as paying a trainer to improve your skills, which means you have to choose between items and stat improvement when deciding how to spend your money.

<h4 id="progress.pointbuy.code">Implementation</h4>
Combining this feature with a level up system is easy: just add a "stat point" attribute to the Puppet class and increment it on level up. Then you just have to add another passage/menu where players can spend them. (Note that you will need to save the total points accumulated in a separate attribute from the character's spendable points if you want to provide a respec option.)

The passage "Point-buy interface example" provides an example of how you might implement this in a menu.

A "free buy" system is a little trickier, but is fundamentally similar to the code used to calculate XP requirements for levels: you would create a widget or JavaScript function to calculate the XP cost, and pass it the necessary variables. It's recommended you make XP costs increase at higher stat values, just as levels have increasing XP requirements. You could make every improvement increase the cost of all future improvements, or make it a function of the current stat only. The latter method disincentivizes overspecialization and encourages players to spread out their improvements. As with a stat-points-by-level-up system, you would need to record total XP separately if you want to enable a respec system. You might also want to make the cost growth dependent on <i>upgraded</i> rather than <i>total</i> stats, which would necessitate another variable for storage.

An example of such a calculation function is provided in the story JavaScript as a method function of the Puppet class.

<i>Bonfire</i> has an example of a point-buy system: though heroes level up within individual game stages, they restart at level 1 whenever they start a new stage. The only way to permanently improve their stats is to buy upgrades with gold accumulated from journeys. A chart of the upgrade costs is <a href="http://bonfire-game.wikia.com/wiki/Upgrading_Heroes" target="_blank">here</a>, though no clear function has been derived; it is likely a complex piecewise function, or a lookup table of unique values.

<h3 id="progress.equip">Equipment-Based Progression</h3>
Most RPGs feature an equipment system of some kind in addition to levels. In effect, this can create two simultaneous paths of power progression: you can improve your abilities both by leveling up and by buying better equipment.

I mentioned in [[the design page|Design]] that I tend not to like this model, as it feels redundant: not only does the player usually improve equipment through the exact same methods as you improve levels -- killing monsters and doing quests usually give you both XP and money -- but equipment often conveys the same benefits as level ups (stat boosts, more damage, etc.). What this means is that not only are you never forced to choose between levels and equipment, there wouldn't be much significance to the choice even if you were.

To avoid this problem, I recommend giving equipment and levels categorically distinct contributions to the character. They shouldn't improve power in exactly the same way all the time. This can be seen in <i>Dungeons & Dragons</i>, where levels tend to grant qualitative changes -- additional actions to take, bonus to circumstantial situations, etc. -- while equipment is one of the only ways to obtain quantitative improvements, such as better damage and armor. This can make choosing between gold and XP a meaningful choice that forces the player to think about exactly how they want to improve their character. That kind of engagement typically makes for a more enjoyable experience, so it's something you should shoot for.

Some games go even farther, and make equipment the <i>only</i> method of power progression. Under this model, there are no levels or inherent bonuses: all your growth comes from finding better equipment. Want stronger attacks? Get a better weapon, or you're out of luck. This can create an interesting effect where your characters are completely modular, especially if you make equipment govern <i>actions</i> as well. At any point, you can completely reinvent a character, swapping their capabilities with another. Such games typically give characters some unique stat or ability differences to avoid making them completely interchangeable, but the system will still be highly mutable.

One potential downside of this system is that it can remove the incentives from normal gameplay, if you adopt a jRPG model of many mundane, grindy tasks. Even if you reward players with money with which to buy more equipment, players will typically hit a ceiling very quickly and find themselves with nothing to spend it on until they reach the next area with better equipment. This can shatter the Skinner-box action-to-reward mentality that many games run on, and leave players feeling bored and frustrated. On the other hand, this may be better for more narrative-driven experiences that revolve around a small number of set-piece challenges.

Additionally, this method must be balanced more carefully than usual, due to something obvious but often overlooked: If players start with no equipment at all, they will hit what feels like a ceiling as soon as they fill all their slots. Where before everything was an absolute improvement, now they must make tradeoffs to progress further. You will have to structure your game carefully such that equipment continues to improve at a consistent rate, and that this is communicated to the player. For this reason, this system tends to be better suited to shorter games where this issue will not become as pronounced.

Narratively, this is an effective way to convey a sense of realism. In real life, people don't just magically get tougher, stronger, and faster by being really good at something; the skills obtained through training and practice tend to pale in comparison to the advantages of getting better weapons and technology. Outsourcing all the player's power to something else reminds them of that fragility, especially if you do something cruel like letting enemies steal or destroy their items. This can be very good for an RPG in a modern setting, or one with a strong focus on technology.

Notable examples:
* <i><a href="https://rpgmaker.net/games/5904/" target="_blank">Czarina Must Die!</a></i> tends to run into the problems I outlined towards the end; it unfortunately uses random encounters <i>as well as</i> quickly making equipment purchased with money obsolete, giving the player little incentive to fight monsters.
* <i><a href="https://rpgmaker.net/games/4526/" target="_blank">Wine & Roses</a></i> and some of the other games in the same "genre" by the same developer use equipment for both stat and skill advancement. Inherent bonuses sometimes feature as well, but they are rare and minor in comparison.
* <i><a href="https://rpgmaker.net/games/5132/" target="_blank">In Search of Immortality</a></i> uses a very literal approach: all equipment is just literally a stat boost, with stronger boosts dropped by monsters as you progress.

<h3 id="progress.statgrind">Stat Grinding</h3>
There is another progression method known as "activity-based leveling" or, more colloquially, "stat grinding". The premise of stat grinding is that, unlike with experience levels, which give you across-the-board improvements at intervals, you improve your stats or skills individually by performing actions related to them. For example, attacking with a weapon may improve your skill with that weapon type, or getting hit might improve your defense score.

This approach can feel a lot more "realistic" than experience levels, as it's much closer to how you improve skills in real life. It can also provide more organic gameplay and character progression, as characters will naturally get better at whatever playstyle you prefer to use for them. It can be fun to start with a party of very similar "blank slate" characters and watch them diverge based on how you use them, and also adds replay value when every character has so many potential builds. (Note that you don't <i>need</i> for every character to start the same, though! Especially in multi-character setups, you can still encourage growth in one direction or another by making it easier or harder for certain characters to improve skills.)

In practice, however, this approach has a lot of problems and pitfalls. Optimum play under this system often turns out to be unintutive and highly bizarre. An infamous example is from <i>Finaly Fantasy II</i>, where players were incentivized to attack their own characters to gain HP bonuses. Depending on how broad the system and statistics are, this can also encourage tedious and repetitive actions; another infamous example is players constantly jumping to improve their acrobatics skill in <i>The Elder Scrolls</i>. Even aside from this, issues of scale crop up: How does a developer encourage the player to move on to stronger enemies, if the rewards of battle are based on the player's actions and not the difficulty of the encounter? Experience levels can easily deal with this problem by progressively increasing experience requirements and rewards, but with stat grinding the solutions are less obvious.

One solution is indeed to make stats and skills function just like levels, with increasing experience requirements for each improvement. This is the method used by <i>The Elder Scrolls</i> series. However, the details of this can be complicated. Do you want different stats to have different experience curves? What about different gain rates? How do you determine how much experience to give per action? If you keep the hit-to-kill ratio constant throughout the game -- as you probably should -- then surely stat improvement will slow down as the player takes the same number of actions per battle but requires more actions to level up? <a class="noExternal" href="#progress.levels.1">All the questions and calculations you have to make for experience levels</a> will now have to be made for <i>every single stat</i>. This can be a daunting task!

Another method is to still use levels behind the scenes. This is the method used by <i>Final Fantasy II</i>: Every enemy is assigned a hidden "rank" statistic that is added to the experience points awarded for every action in battle. The experience reward is, in turn, <i>decreased</i> by the rank of the skill used (weapon or spell), requiring the player to fight stronger enemies to improve their skills. In this system, every skill level requires the same amount of experience to improve; it is the experience per action that changes to create a progression curve.

If you plan to use this system, I recommend looking at examples of games that have tried it before. Observe their strengths, pitfalls, and different methods of implementation. This is a very delicate and finnicky system, and will require a lot of care to balance properly. One area in particular I'd recommend looking into is the problem of defensive stats: Stat grinding works well for actions that the player can make directly, such as attacks, but invites difficult questions when it comes to passive abilities. Unless you use something like [[an aggro system|Design]], the player has no control over who gets hit by attacks -- unless, of course, they attack their own characters, which is nonsensical. And even if you do have an aggro system, placing fragile characters away from danger can actually be a bad idea, as it prevents them from ever getting tougher, leaving them increasingly vulnerable to area attacks and the like. (This was another infamous problem with <i>Final Fantasy II</i>, and in large part why the friendly fire method of training was necessary.) <i>The Elder Scolls</i> sidesteps this issue by divorcing HP gain from the standard stat grinding model and instead granting the player an automatic bonus after they have improved enough skills; I would recommend doing something similar.

Notable examples:
* <i>The Elder Scrolls</i> is one of the most famous RPGs of this type. Though the very first game used standard experience levels, later games used a stat grinding system based around gameplay-relevant skills. The series has extensive fan documentation via <a href="http://en.uesp.net/wiki/Main_Page" target="_blank">its wiki</a>, with pages detailing the advancement mechanics for the <a href="http://en.uesp.net/wiki/Daggerfall:Leveling_and_Skills" target="_blank">second</a>, <a href="http://en.uesp.net/wiki/Morrowind:Skills" target="_blank">third</a>, <a href="http://en.uesp.net/wiki/Oblivion:Increasing_Skills" target="_blank">fourth</a>, and <a href="http://en.uesp.net/wiki/Skyrim:Leveling" target="_blank">fifth</a> games in the series.
* <i>Final Fantasy II</i> and its spritual successor, the <i>SaGa</i> series, are famous jRPG examples of this type. The mechanics are documented fairly comprehensively <a href="https://guides.gamercorner.net/ffii/systems/" target="_blank">here</a>. Note that statistic improvements were very different (and much simpler) than skill and spell improvements, with actions simply giving the character a random chance of improving the stat by 1 point.
* <i>Pokemon</i>, though primarily an experience level system, uses a form of this. Pokemon have an "Effort Value" (sometimes called "stat experience" by players) associated with each stat that is used to calculate the effective stat through <a href="https://bulbapedia.bulbagarden.net/wiki/Statistic#Formula" target="_blank">a complicated formula</a>. In addition to each stat having a maximum possible Effort Value, the <i>total</i> Effort Value points a Pokemon can have is also limited, creating a specialized distribution of stats. However, unlike most stat grinding systems, stat experience is gained not by performing relevant actions, but by defeating enemy Pokemon. Like many mechanics in <i>Pokemon</i>, almost none of this is explained to the player in the game and the whole system is very opaque, a fact that has generated much frustration among players. Don't be like <i>Pokemon</i>: be clear and transparent if you use a system like this.

<h3 id="progress.fixed">Fixed or Story-Based Progression</h3>
Some games take the control out of the player's hands, and provide improvements only at fixed points in the game. You may only gain a new ability or stat boost after beating a boss, reaching the next area, or progressing the story.

This is a very direct way of implementing a progression system, but also a bare-bones one. A big benefit of an experience and leveling system is that the player will always gain a tangible reward for engaging with the game; take that away, and they may just feel like the game's challenges are a waste of time. (Of course, you should be making your game intrinsically rewarding to play <i>anyway</i> -- if you can kill a player's motivation by taking away an extrinsic reward, you're not making a very fun game.) It does, however, give the designer immense control over the player's experience. You don't have to worry about a player being over- or underleveled, or picking a weird build; you know exactly what state they'll be in going into every battle. Used well, this method can therefore be used to craft tighter and more complex challenges, and to ensure no player is left behind.

Some games will mix this concept with more standard progression systems. For instance, the game may use a leveling system for most of its mechanics, but the player may also be given a special ability for reaching a certain point in the story. You can also strike a compromise of still allowing the player control over their progression by making experience points a limited resource only awarded at certain benchmarks in the game.

Equipment-based progression is often a subtle form of this, as better equipment usually can't be obtained until the player progresses in the game.

This method can work well for narrative-heavy RPGs that revolve around a small number of set-piece battles rather than many less significant encounters, and can even be used to tie the gameplay and story together by justifying the characters' improvement through in-story beats. I also recommend some form of this for RPGs with puzzle-like encounters that are balanced assuming the player has access to a specific ability.

Notable examples:
* <i><a href="https://rpgmaker.net/games/6554/" target="_blank">Null Regrets</a></i> and <i><a href="https://laburatory.itch.io/lgd" target="_blank">Long Gone Days</a></i> both eschew levels entirely and award new skills only after clearing chapters of the story. However, this has led to the criticism that players feel little point in fighting non-critical battles.
* Games from the developer Craze, such as <a href="https://rpgmaker.net/games/4526/" target="_blank">Wine & Roses</a>, use a non-linear form of this. There is no leveling system, but every battle rewards the player with a specific new ability or powerup. The choice of what fights to tackle and when give the player immense control over their progression despite its fixed nature, making the game feel similar to a Metroidvania.
* <i><a href="https://en.wikipedia.org/wiki/Torment:_Tides_of_Numenera" target="_blank">Torment: Tides of Numenera</a></i> makes experience points a limited resource. They are primarily gained by completing quests and advancing the story, but players can also gain a few points by finding secrets in the world. You can comfortably reach the max level if you are diligent at completing quests, but your specific capabilities are determined by the choices you made at each level up.

<h3 id="progress.skills">Skill Progression</h3>
Most RPGs don't just improve characters' stats as the game progresses; they provide the player with new abilities as well. Fighters gain new feats such as Power Attack, wizards gain new spells, rogues gain new skill points, and so on. This is crucial for keeping the player engaged, as it makes the game and the player's experience evolve in complexity over time.

However, there is the question of how fast you introduce new abilities, what abilities you introduce, and if you want a creeping power curve of stronger abilities over time. If you give the player too many abilities too quickly, they will be overwhelmed, and individual abilities won't have time to shine. If you dole out abilities too slowly, players may lose interest and find the game repetitive.

You should generally gate more complex abilities behind later progression markers. This is why many RPGs either start you with fighter-type characters or with only a few basic spells. The player needs time to master the basic mechanics of the game before they can be introduced to new twists like limited resources, elemental weaknesses, and status effects. In turn, give the player time to get used to each new mechanic before introducing them to another.

One particular quirk of skill progression, especially in jRPGs, is that mage-type characters tend to have their effectiveness tied to specific skills more than their stats. You might start the game with access to Fire 1, then later, you learn Fire 2, which is identical in function but stronger. This is most easily handled by pairing a constant damage value with a smaller stat damper (see the damage formula section in [[Design]]), such as <i>C + (A/2) * a.magic - B * b.mdf</i>, where A is the stat coefficient for regular attacks. A large <i>C</i> constant will make a spell very powerful initially, but it will wane in usefulness as enemies gain more HP, and the smaller stat coefficient on Magic Attack will prevent stats from making up the difference. In comes Fire 2, with the same formula but a larger constant, and your mage is back in power... until enemies get stronger again.

This method is reasonable when magic functions as a limited resource. Typically, characters gain more magic points or spell charges as they level up, so you become able to use the same spells more often. It wouldn't make sense for a spell you can use 3 times to be just as effective when you can use it 6 times, as that would trivialize battles. You need a way for spells to wane in effectiveness as they become cheaper to the player.

However, this approach is widely disliked by modern gamers, because it leads to a lot of spells that you'll never use after a certain point. Once you get Fire 2, there's no reason to use Fire 1 again -- it's just a useless entry taking up space in your skill menu. Western RPGs based on <i>Dungeons & Dragons</i> avoid this problem by allowing all spells to keep up with the caster's power level -- even basic spells will gain bonuses as you level up, keeping them competitive even at higher levels. However, this can lead to a new problem of making mages overpowered, because they're improving their old abilities <i>while also</i> gaining new abilities at the same time, leading to exponential power growth.

The tiered spell approach is effective, but it's also lazy. I encourage you to come up with more creative solutions. Maybe <i>don't</i> let the player increase their MP, keeping their spells-per-dungeon ratio constant throughout the game? Maybe make dungeons longer or harder, necessitating the use of more spells even though they're just as useful throughout? You could also try making skill upgrades purely qualitative, rather than quantitative -- a new option like a status effect or another element, but nothing strictly better than what the player already has access to.

<h2 id="battlegrid">Battle Grid</h2>
In the default engine, the placement and order of characters in a party doesn't matter. You can stack as many characters into the party as you want, but they'll all exist in a nebulous space where everyone is equally vulnerable to attacks and every enemy is in reach.

This is a nicely simple model, but not all RPGs use it. Some RPGs make space and positioning matter.

You're probably most familiar with this in the form of "tactical RPGs" like <i>Final Fantasy Tactics</i> or <i>Fire Emblem</i>, where battles take place on huge maps, characters can move a limited distance per turn, and attack range may be limited. Something <i>that</i> complex is beyond the scope of the engine at the moment (though you may be interested in <a href="https://sinisterdesign.net/products/telepath-tactics/" target="_blank">Telepath Tactics</a>), but something of more moderate complexity can be enabled with the {{{BATTLE_GRID}}} variable.

<h3 id="battlegrid.1">Setup</h3>
This is gonna get complicated, because it involves <i>\*shudder\*</i> graphic design. We're going to have to first build a graphical representation of the grid for our webpage. Let's look at how that's done in the {{{battle grid.css}}} file:
{{{
.actors.grid {
  display: grid;
  justify-items: center;
  align-items: center;
  row-gap: 1em;
  width: 100%;
  height: auto;
}

.actors.grid.large {
	grid-template: repeat(2,1fr) / repeat(3,1fr);
}

.actor.grid {
  position: relative;
  width: 140px;
  min-height: 96px;
}

.actor.large {
	grid-column: 1 / 4;
	grid-row: 1 / 3;
	width: 100%;
	height: 192px;
	padding: 0;
	display: flex;
	flex-direction: column;
	text-align: center;
	justify-content: center;
	align-items: center;
}
}}}
You may recall from the actor setup notes in [[Documentation|Documentation (Advanced)]] that we added "grid" classes to the actors and their containers when {{{BATTLE_GRID}}} was enabled. Here, you can see how that class changes the display.
{{{
.actor.grid {
  position: relative;
  width: 140px;
  min-height: 96px;
}
}}}
We also need to modify the {{{actor}}} elements. This map is much more rigid than the standard display, so we can't have actor boxes stretching or shrinking based on their content; we need to fix them to a set width. <b>The width of these elements and the width of the {{{#content}}} element are going to determine how many columns your battle grid can span.</b> By default, you can comfortably fit only 3 columns into the 640px-wide {{{#content}}} area. (You may do the math and think that <code>640 / 140 =</code> 4 columns, but that's not accounting for padding and other spacing that's included in these elements.) If you want more columns, you will need to either expand the width of {{{#content}}} or shrink the size of the {{{actor}}} boxes.

The {{{large}}} class is the battle grid's equivalent of the {{{full}}} class in the normal display, a way to make enemy boxes bigger and more impressive-looking. By default, this is set to a defined size: 3 columns and 2 rows, spanning the full width of the container and the height of two actor boxes. Note that this assumes "large" enemies are the only characters on their map, as the class modifies the {{{actors}}} container itself. You may adjust this to suit your needs.

Savvy readers may notice at this point that we haven't set any dimensions (rows and columns) for our grid yet. The reason for that is because we want the grid to be able to shrink and expand to suit the user's needs, rather than fixing it to one set of dimensions. To define the dimensions, we go to {{{user storyinit}}}:
{{{
<<if setup.BATTLE_GRID === true>>
	<<set setup.ROW_SIZE = 3>>
	<<set setup.COLUMN_SIZE = 3>>
	<<set setup.STATUS_SCREENS.menu.push("Formation")>>
<</if>>
}}}
When you enable the battle grid, you also need to define the length of your rows and columns. By default, that's set to 3 each, the maximum width that can fit comfortably in the default display. These variables will be used for several functions relating to the grid, including the construction of the grid itself.

The next step is to create a representation of our grid as a data structure. This will be a two-dimensional array with elements corresponding to each cell in the grid. This is defined as "battle grid setup" in the {{{Battle Grid.tw}}} file.
{{{
<<set $puppetGrid = []>>
<<for _r = 0; _r < setup.COLUMN_SIZE; _r++>>
    <<set _row to []>>
    <<for _c to 0; _c < setup.ROW_SIZE; _c++>>
        /* Create the object used to store the default properties of a map cell. */
        <<set _cell to {
            id: ("cell_r" + _r + "_c" + _c),
            contents: null,
            movement: []
        }>>
        <<run _row.push(_cell)>>
    <</for>>
    <<run $puppetGrid.push(_row)>>
<</for>>
<<for _puppet range puppets()>>
  <<set $puppetGrid[_puppet.row-1][_puppet.col-1].contents = _puppet>>
<</for>>
<<set $enemyGrid = []>>
<<for _r = 0; _r < setup.COLUMN_SIZE; _r++>>
    <<set _row to []>>
    <<for _c to 0; _c < setup.ROW_SIZE; _c++>>
        /* Create the object used to store the default properties of a map cell. */
        <<set _cell to {
            id: ("cell_r" + _r + "_c" + _c),
            contents: null,
            movement: []
        }>>
        <<run _row.push(_cell)>>
    <</for>>
    <<run $enemyGrid.push(_row)>>
<</for>>
<<for _enemy range enemies()>>
  <<set $enemyGrid[_enemy.row-1][_enemy.col-1].contents = _enemy>>
<</for>>
}}}
We must create two grids, one for the puppets and one for the enemies. Each cell is populated with additional metadata, and each character is assigned to the {{{contents}}} property of the cell determined by their {{{row}}} and {{{col}}} values, which we have hopefully set before the battle.

Let's look at how to set up the grid in {{{actorlist}}}.
{{{
<<if setup.BATTLE_GRID === true>>
	<<include "grid actorlist enemies">>
<<else>>
	(...)
}}}
Every section in {{{actorlist}}} includes this branch to split the functionality of the passage into grid and non-grid sections. The grid sections are defined in {{{Battle Grid.tw}}}, and look like this:
{{{
<<for _r, _row range $enemyGrid>>
	<<for _c, _cell range _row>>
		<<if _cell.contents instanceof Actor>>
			<<actorBox _cell.contents>>
		<<else>>
			<div class="actor grid flex-center empty">
				/* no content; empty box */
			</div>
		<</if>>
	<</for>>
<</for>>
}}}
This code iterates over the grid object (rather than the party, as in the normal {{{actorlist}}}) and creates an actor box whenever it detects the cell is populated with an {{{Actor}}} object. Otherwise, we display an empty box with the {{{empty}}} class to denote a blank tile.

Now that all the elements exist, we still need to make sure they appear in the right position. By default, CSS grids will populate themselves in the order elements are created, left to right and top to bottom. That won't necessarily correspond to where the characters are supposed to be, so to make sure of that, we include this code in {{{actorBox}}}:
{{{
<<set _style = "">>
<<if setup.BATTLE_GRID === true>>
  <<set _class += " grid">>
  <<set _style += _actor.gridArea>>
<</if>>
}}}
{{{gridArea}}} is an {{{Actor}}} property that returns the CSS property {{{grid-area}}} with the relevant row and column values taken from the character's {{{row}}} and {{{col}}} properties. This ensures the character will appear exactly where we want them to.

...But we still haven't defined our grid dimensions! That comes at the end of the passage, here:
{{{
<<timed 0s>>
	<<script>>
	$("#enemies .actors.grid").css({
	  "grid-template-columns": `repeat(${setup.ROW_SIZE},1fr)`
	});
	<</script>>
<</timed>>
}}}
This code runs raw JavaScript code. This code finds the {{{actors}}} container using jQuery, then modifies its {{{grid-template-columns}}} attribute to define a number of equally-spaced columns equal to {{{ROW_SIZE}}}. (We have to place it in the seemingly-pointless {{{<<timed 0s>>}}} macro because elements do not exist on the page untill all code has run and the passage has finished rendering. If we tried executing this code outside of a {{{<<timed>>}}}, it would tell use the element doesn't exist. But code within {{{<<timed>>}}} blocks execute after the passage has rendered, so with a delay of 0 we can use them to instantly modify an element on the page just after it's rendered. See <a href="http://www.motoslave.net/sugarcube/2/docs/#macros-dom-warning" target="_blank">the SugarCube documentation</a> for more info.)

In effect, most of the work has been done for you here. You only need to plug in values for {{{ROW_SIZE}}} and {{{COLUMN_SIZE}}}, and extend the width of {{{#content}}} if you want wider battle grids... <i>if</i> you restrict yourself to perfectly rectangular battle grids. If you want an uneven grid with protrusions or holes, that's going to take more work. You will likely need to define both a custom grid and custom placement for your actors (via the {{{grid-rows}}} and {{{grid-columns}}} attributes).

For more information on how to use grids, see <a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank">this guide by CSS-Tricks</a>.

<h3 id="battlegrid.2">Features</h3>
So now that we have our grid, how do we use it for gameplay?

You can potentially use the grid for a lot of things. By default, the only thing it does is allow characters in higher rows to guard lower ones. The code for this can be found in the {{{Hitlist}}} class definition in {{{targeting.js}}}.
{{{
static guardCheck (target) {
	if (setup.BATTLE_GRID === true
		&& !V().action.ranged
		&& (subject().id.charAt(0) !== target.id.charAt(0))) {

		console.assert(target instanceof Actor,`ERROR in guardCheck: target must be Actor`);
		var newTarget = target;

		// Search for character immediately in front of this one (same column, row - 1)
		newTarget = target.ownParty.find(function (a) { return a && a.col === this.col && a.row === this.row - 1 },target);
		if (newTarget instanceof Actor && !newTarget.guardBreak) {
			newTarget = Hitlist.guardCheck(newTarget);
		} else {
			newTarget = target;
		}
		return newTarget;
	} else {
		return target;
	}
}
}}}
This function takes the target object, and checks to see if there's any character directly in front of them (same column position, row position minus one). If there's no such character, the function will return {{{undefined}}}, and we'll know that we can just continue with the original target. If we <i>do</i> find a guarding character, we need to reassign them as the new target (provided they don't have the {{{guardBreak}}} attribute).

<i>But wait!</i> What if that guarding character is, in turn, guarded by <i>another</i> character in the next row up? To account for that, we have to call {{{guardCheck}}} <i>again</i> on the new target. This technique -- calling the same function within itself -- is called <i>recursion</i> in programming, and allows us to perform iterative logic similarly to loops. Just like loops, we have to be careful not to create infinite recursions -- in this case, that is handled by the fact we will eventually run out of rows, at which point we are guaranteed to return a fixed value and end the recursion chain.

{{{guardCheck}}} is run both in the default targeting logic and when determining valid targets in the targeting phase.
{{{
<<if _cell.contents instanceof Actor>>
	<<actorBox _cell.contents>>
<<elseif $B.phase == "move" && def $subject>>
	<div class="actor grid flex-center empty">
		<<capture _r, _c, _cell>>
		<<link "[MOVE]">>
			<<set <<set $subject.position = [_r+1,_c+1]>>
			<<replace "#puppets">><<include "actorlist puppets">><</replace>>
		<</link>>
		<</capture>>
	</div>
}}}
We also want a way to move our characters around on the battle grid. That happens here, in a branch of {{{grid actorlist puppets}}}. If the {{{phase}}} of the battle is "move", empty tiles will generate a link that moves the selected puppet to that tile, and replaced their existing tile with a null. By default, this doesn't take up an action; players can move around all they want during their turn.

There are also additional action functions that interact with the grid, {{{massAttack}}} and {{{pushAttack}}}. The former can target small portions of the grid (rows, columns, or a + shape), and the latter can forcibly move characters around the grid.

This is just one of many features you can use with the battle grid. You may want to have it interact with threat targeting by giving characters in higher rows more starting threat or have them gain more per attack. By default, characters in the back rows can still attack freely, but you could restrict them to ranged attacks, as is the case in <i>Final Fantasy II</i>. Other <i>Final Fantasies</i> take a softer approach, with back-row characters merely gaining a bonus to defense at the expense of melee attack damage. <i>Radiant Historia</i> uses push attacks as a core gameplay mechanic, with the ability to force multiple enemies into the same square and damage all of them with a single attack. Try experimenting!

<h2 id="missMechanics">Misses and Critical Hits</h2>
Once upon a time there was a wargame called <i>Chainmail</i>, which used random dice rolls as a method of combat resolution. This game served as the basis for the role-playing game <i>Dungeons & Dragons</i>, which inherited its dice-based mechanics. Seemingly every computer RPG is based, in some way, on <i>Dungeons & Dragons</i>, and they all unthinkingly copied its mechanics too, including, for some godforsaken reason, the random dice-roll mechanics.

In <i>Dungeons & Dragons</i>, to perform an attack, you must roll a 20-sided die. If the result of the roll compares favorably to the target's Armor Class stat, your attack hits! Otherwise, it misses. As a little bonus, if you roll a 20 on your attack, you can deal a critical hit, which can do a number of things depending on the system but usually involves a multiplier on your final damage result. This is typically counterbalanced by a roll of 1 equating to a "critical miss" or "critical failure" that automatically misses regardless of other modifiers and may do other nasty things to the attacker.

<i>Dungeons & Dragons</i>, in turn, formed the backbone of the first computer RPGs, which were copied by the next generation of computer RPGs and on and on until this mechanic became so entrenched in the genre that no one bothered to question it anymore. So now we get to see "miss" and "critical hit!" messages in our modern RPGs too, all because an old wargame wanted to add a little randomness to its mechanics. Here I'll teach you how to be a mindless <i>D&D</i> copycat too.

Disclaimer: I hate this mechanic with the intensity of a thousand burning suns. I find it infuriating in every RPG I have ever played and I do not believe it adds any depth to gameplay whatsoever, at least in this extreme form. When your player cannot reliably predict the results of their actions -- when you take control away from them -- it violates one of the fundamental tenets of game design, the principle of consistent action-and-response. Players can succeed or fail your challenges not as a consequence of their actions, but by factors completely outside of their control. I consider this a bad thing. But other people, apparently, disagree, so I have grudgingly implemented this feature so that I can faithfully claim my engine can do everything RPG Maker can. However, it is turned off by default and I implore you to keep it that way unless you have a very, very good reason to do otherwise.

For more on this topic and how to use randomness responsibility, see the video "<a href="https://www.youtube.com/watch?v=dwI5b-wRLic" target="_blank">The Two Types of Random in Game Design</a>" by Game Maker's Toolkit.

<h3 id="misses">Accuracy and Misses</h3>
If you look at "Damages and Formulas", you'll see this widget at the top:
{{{
<<widget "accuracyCheck">>
(...)
<<include "accuracy formula">>
<</widget>>
}}}
It's called at the start of {{{<<echoDamage>>}}}, after the protection check but before damage calculation or anything else.

The accuracy formula is offloaded to another passage so you can modify it without having to fuss with the code of the entire "Damage and Formulas" file. By default, I used a formula roughly based on <i>Pokemon</i>'s:
{{{
<<if $action.accuracy === true>>
	<<set _hit = true>>
<<else>>
	<<set _acc = $action.accuracy>>
	<<if subject().stats.hasOwnProperty("Accuracy")>>
		<<set _acc = Math.max(_acc + (subject().get("Accuracy")-100),setup.MIN_ACCURACY)>>
	<</if>>
	<<if _target.stats.hasOwnProperty("Evasion")>>
		<<set _acc = Math.max(_acc - _target.get("Evasion"),setup.MIN_ACCURACY)>>
	<</if>>
	<<set _toHit = random(1,100)>>
	<<if _toHit <= _acc>>
		<<set _hit = true>>
	<<else>>
		<<set _hit = false>>
	<</if>>
<</if>>
}}}
The first thing you should notice here is that accuracy is a property of the action itself. You can set a default value in StoryInit (by default this is {{{true}}}) for all actions if you don't want to define one for each action individually.

If the {{{accuracy}}} property contains the Boolean {{{true}}}, the accuracy check is completely bypassed. We mark {{{_hit}}} as {{{true}}} and that's all. This value is used for "always accurate" attacks that bypass the following check:
{{{
<<set _acc = $action.accuracy>>
<<if subject().stats.hasOwnProperty("Accuracy")>>
	<<set _acc = Math.max(_acc + (subject().get("Accuracy")-100),setup.MIN_ACCURACY)>>
<</if>>
<<if _target.stats.hasOwnProperty("Evasion")>>
	<<set _acc = Math.max(_acc - _target.get("Evasion"),setup.MIN_ACCURACY)>>
<</if>>
}}}
Though these stats do not exist in the default engine, I've included handling for "Accuracy" and "Evasion" modifiers. (Note that the {{{hasOwnProperty()}}} check ensures this will only be done if the correct stats exist, so don't worry about problems if you don't want to use those stats.) I use a simple adjustment formula based on percentile values: The attack gains accuracy equal to the attacker's accuracy stat offset by 100 (so if they had an accuracy stat of 120%, they would gain 20% accuracy; if they had a stat of 80%, they would lose 20% accuracy, etc.) and loses accuracy equal to the target's evasion stat. (In both cases, we do a common-sense check to bound the accuracy value against {{{MIN_ACCURACY}}}, to avoid weird things like negative accuracy values and in case you don't want it to be possible to reduce accuracy to 0% or something.)

Note that these modifers mean <b>an accuracy value of 100 does not guarantee a hit</b>. Accuracy penalties and evasion stats can reduce the attack's accuracy and cause it to still miss. This is why we need a different value to denote attacks that are truly always accurate.
{{{
<<set _toHit = random(1,100)>>
<<if _toHit <= _acc>>
	<<set _hit = true>>
<<else>>
	<<set _hit = false>>
<</if>>
}}}
We then do a simple percentile roll. If we roll under the adjusted accuracy value, the attack hits; otherwise, it misses. We record the result in the {{{_hit}}} variable. (Note that due to the boundary values picked for the {{{random()}}} call, an accuracy of 0 will always miss.)
{{{
<<if _hit === false>>
	<<print setup.MISS_MESSAGE>>
<<elseif _hit === true>>
(proceed as normal)
}}}
It's then up to you what you want to do with a missed hit. By default, this code runs in {{{<<echoDamage>>}}}, printing the miss message and nothing else.

One thing you should note is that, by default, magical attacks (denoted by a {{{useSpecial}}} property of 1) cannot miss. This is consistent with most console RPGs (but not <i>Dungeons & Dragons</i>!). This is probably because making the player waste not only a turn but a limited resource was considered too much of a dick move even for old-school game designers, and they were right.

The reason I hate this mechanic is because I feel the variance in result is too high. A missed attack is a complete nullification of your action; it is possible to make no progress in the battle at all no matter how many actions you take, if you are very unlucky and keep missing. (And don't even get me started on enemies whose "gimmick" is having high evasion.) I can understand, in principle, there being some benefits to preventing the player from getting too complacent, but maybe be a little bit nicer about it? I played one RPG where missed attacks did half damage instead of none, the conceit being that the attack struck a glancing blow instead of missing completely. Try something like that and see how it plays. (You could even play with it further by providing equipment or other modifiers that change the proportion of graze damage. Perhaps you have a weapon that does low base damage but loses less damage on a miss, for a weaker but more reliable attack? Be inventive! Don't just mindlessly copy <i>Dungeons & Dragons</i> like every designer before you!)

<h3 id="crits">Critical Hits</h3>
Missed hits are sometimes "balanced" by their inverse, critical hits. Critical hits typically do greater damage than a normal hit, and may have other properties like inflicting an injury.

Like with accuracy, the formula is wrapped in a widget and offloaded to another passage for modularity purposes. My default critical formula is very similar to the accuracy formula:
{{{
<<set _critChance = $action.critRate>>
<<set _toCrit = random(1,100)>>
<<if subject().stats.hasOwnProperty("Skill")>>
  <<set _critChance += subject().get("Skill")>>
<</if>>
<<if _toCrit <= _critChance>>
  <<print setup.CRIT_MESSAGE+" ">>
  <<set $dmg *= $action.critMultiplier>>
<</if>>
}}}
Like with accuracy, critical rate is an action property but has a default value you can set in StoryInit. (And just like how magic can't miss, by default it can't crit either.) If you've defined a stat called "Skill" for the attacker, its value is added to the action's percentile critical chance, and then we do a percentile roll against the result. (Most RPGs call the stat with this function "Luck", but if you haven't caught on by now, I really hate luck, so I call it "Skill" just out of spite.) If a hit is critical, its damage is multiplied by {{{critMultiplier}}}, another action property that has a default value (1.5 by default).
{{{
<<if !$B.phase && $dmg > 0>>
	<<critCheck>>
<</if>>
}}}
Note that, because critical hits directly modify the damage value, this check is called in {{{<<damageCalc>>}}}, not {{{<<echoDamage>>}}}, which in turn is only called if the attack passes its accuracy check. (Note that passing the "nocalc" argument to {{{<<echoDamage>>}}} will also bypass the call to {{{<<damageCalc>>}}} and thus the critical hit check.) This check is placed at the very end of {{{<<damageCalc>>}}}, after all other factors have been calculated.

I've included some common-sense checks to gate the critical check. We only want criticals to be calculated when the attack is actually performed (in the action phase), not as part of the damage preview in the confirm phase. We track battle phase with the {{{phase}}} property of the battle object, and it is set to {{{null}}} during the action phase, which evaluates to a falsy value; thus, {{{!$B.phase}}} ensures critical checks can only occur during the action phase. I have also decided that if the damage is absorbed (less than 0) due to elemental factors, the attack can't be critical. You can change this if you wish.

You can do a lot more with critical hits than just a damage multiplier. <i>Pokemon</i> lets critical hits bypass stat modifiers; similarly, RPG Maker VX has critical hits ignore defense. Several jRPGs like <i>Final Fantasy</i> have their "Luck" stat increase not just your critical chance, but also your critical multiplier. Our old friend <i>Dungeons & Dragons</i> famously has several critical hit tables that involve rolling again to see what type of gruesome injury you inflict, which can incur additional penalties from stat debuffs to instant death.

If you do use critical hits, I implore you to consider this question: Do enemies get them too? You can run into problems if you do. Players usually have healing skills and enemies usually don't, so RPGs often have a health asymmetry. Enemies tend to have much more health than player characters, because they are not expected to heal, so their health has to last them the whole battle. Player characters, meanwhile, are expected to operate on a cycle of healing after taking hits, so they can usually only survive a comparatively small number of hits from the enemy. If you're too incautious with your critical mechanics, you can make your enemies' damage variance far too large, potentially oneshotting characters who would otherwise be able to survive several hits. This can, like excessive miss rates, edge the game into Roulette territory, making it too frustrating.

<h2 id="bestiaryDocs">Bestiary/Enemy Encyclopedia</h2>
RPGs are games that handle a lot of data. Players will want to know their enemies' statistics just as much as their characters', either to better formulate strategy or just out of curiosity. This is particularly helpful the more complex your battle system is and the more moving parts it has. Some information, like affinities for rare elements or chance-based item drops, may be opaque or non-obvious from just one encounter.

More and more RPGs provide this feature in some capacity: the GameBoy Advance remakes for <i>Final Fantasy</i> I-VI added a menu option for reviewing the statistics of every enemy encountered; third-party RPG Maker scripts provide a similar functionality; western RPGs usually feature a broad encyclopedia of gameplay and setting information that includes enemies; and <i>Pokemon</i>'s Pokedex is one of the most famous examples, where filling out the encyclopedia was actually the goal of the game. In light of this, I decided it was a feature worth adding in version 1.21 of this engine.

We need separate classes for both the bestiary itself and the individual entries. This is similar to the {{{Inventory}}} and {{{Item}}} classes (see the relevant section in [[Documentation|Documentation (Advanced)]]). These classes are {{{Bestiary}}} and {{{BestiaryEntry}}}. Both of them can be found within the {{{database-enemies.js}}} file, below the {{{Enemy}}} class definition.

<h3 id="bestiaryClass">Bestiary Class</h3>
{{{
window.Bestiary = class Bestiary extends Array
}}}
We want the ability to easily sort, manipulate, and iterate over the bestiary, so {{{Bestiary}}} is made a subclass of {{{Array}}}, a default object class that contains many useful functions such as {{{sort}}}.
{{{
for (let [name,enemy] of Object.entries(setup.enemyData)) {
	if (typeof(enemy.bestiaryNo) == "number") {
		this.push(new BestiaryEntry(name,enemy));
	}
}
this.sort(function (a,b) { return a.bestiaryNo - b.bestiaryNo});
}}}
The constructor then automatically reads through the enemy database and adds a new entry for each one. This is done automatically, so you don't need any arguments to create a working {{{Bestiary}}} object, just a working enemy database. Once the bestiary is fully populated, it's sorted by {{{bestiaryNo}}}, short for "bestiary number", a variable defined in the enemy's database entry. This gives you control over what order enemies are displayed in your bestiary; for instance, you probably want enemies the player will encounter early to appear at the start of the bestiary, and you may wish to group similar enemies together, as with <i>Pokemon</i>'s evolution lines.
{{{
if (typeof(enemy.bestiaryNo) == "number")
}}}
Note this conditional. Some database entries, such as alternate form definitions, may not be intended as full entries, or you may just want to keep certain special enemies hidden from the player. You can do this either by giving them a nonnumber value {{{bestiaryNo}}}, or by not giving them one at all. Entries will only be added to the bestiary if the enemy has a valid {{{bestiaryNo}}}.

{{{Bestiary}}} also has a number of method functions, most of them very simple shortenings of {{{Array}}} functions. The {{{fetch}}} function allows us to quickly grab a bestiary entry by name without having to know its index value, and the {{{encountered}}} function returns an array of only the entries the player has encountered. {{{nextEntry}}} and {{{lastEntry}}} simply search over the bestiary and return the next encountered enemy; this is used for menu navigation.

<h3 id="bestiaryEntryClass">BestiaryEntry Class</h3>
The {{{BestiaryEntry}}} class contains all information about the enemy relevant to the bestiary.
{{{
this.name = name;
this.encountered = false;
this.defeated = 0;
this.statsKnown = {
	"hp": false,
	"gp": false,
	"xp": false
};
this.tolerancesKnown = {};
}}}
Above is the main part of {{{BestiaryEntry}}}'s constructor. It has a {{{name}}} property matching the enemy's address in the enemy database, a Boolean flag for whether or not the enemy has been encountered by the player, a counter for how many enemies the player has defeated, and a list of the enemy's statistics. This list allows you to control how much information you want to reveal to the player and when; perhaps they only learn the enemy's statistics when they beat one, or when they use a scanning ability, or when they add it to their Pokedex. It may also enhance gameplay to not reveal an enemy's elemental affinities right off the bat, and instead force players to learn them by testing specific attacks on the enemy.

(Tolerances are listed in a separate object for reasons relating to their eventual front-end display.)
{{{
if (enemy.stats !== undefined) {
	for (let stat in enemy.stats) {
		this.statsKnown[stat] = false;
	}
}
if (setup.ELEMENT_LIST !== undefined) {
	setup.ELEMENT_LIST.forEach(function (elmn) {
		this.statsKnown[elmn] = false;
	},this);
	this.elementData = this.access().elements;
}
if (enemy.tolerances !== undefined) {
	for (let tolerance in enemy.tolerances) {
		this.tolerancesKnown[tolerance] = false;
	}
}
}}}
By default, {{{statsKnown}}} only contains markers for the enemy's hit points, monetary reward, and experience points, stats that every enemy is assumed to have. This section populates it with additional stats that may be more custom to your game: core stats, elemental affinities, and ailment tolerances.
{{{
if (enemy.alts !== undefined) {
	this.altSkin = null;
	this.altsKnown = {};
	enemy.alts.forEach(function (alt) {
		this.altsKnown[alt] = false;
	},this);
}
}}}
Finally, we have a section for alternate forms: Versions of the same enemy that, while not warranting a completely separate entry, may still be significant enough to list. This may be different stages of a boss, such as Rose Quartz's three stages in <i>Cartoon Battle</i>, or the regional variants of Pokemon. If you want to include these, you will need to create an {{{alt}}} property in the enemy's database entry that looks like this:
{{{
"alts": ["Rose 2","Rose 3"]
}}}
That is to say, an array containing string names for each alt form, corresponding to other entries in the database. (This means that alt forms will also need database entries, but should <i>not</i> have {{{bestiaryNo}}}s, or else they will be made completely separate entries in the bestiary.)
{{{
get data () {
	return (setup.enemyData[this.altSkin] || setup.enemyData[this.name]);
}
}}}
You may notice that {{{BestiaryEntry}}}'s getter for the {{{data}}} property is different than for other objects. This is to allow for easy access to alt form data. If the {{{BestiaryEntry}}} is wearing a valid {{{altSkin}}} property, the alt form's data is grabbed instead. Otherwise, we default to the standard entry.
{{{
get baseData () {
	return setup.enemyData[this.name];
}
}}}
However, complicating this issue is that some alt forms exist but do not have valid entries for certain data, because I didn't have the bestiary in mind when I designed them. Oops! This workaround lets you bypass that and take data directly from the base form when necessary.
{{{
access () {
	return new Enemy(this.name);
}
}}}
{{{BestiaryEntry}}} contains this method function, which may seem odd but is actually quite useful. {{{BestiaryEntry}}} contains a lot of data, but it doesn't contain all the functions and processing found in a real, live {{{Enemy}}} object. For complicated cases, we may need to grab the data from an {{{Enemy}}} object instead of the database entry; for example, if we need some processing performed in {{{Enemy}}}'s constructor or one of its getter functions. <b>Note that creating a whole new object is a computation-intensive process, so try not to overuse this function.</b>

{{{bestiaryEntry}}} also contains several getter functions for things like the enemy's database entry and in-game description. To get specific stats, however, we need something more complicated:
{{{
get (stat) {
	if (this.statsKnown[stat] === true) {
		let s = stat.toLowerCase();
		if (s == 'hp' || s == 'gp' || s == 'xp') {
			return (this.data[s] || this.baseData[s] || 0);
		} else if (setup.ELEMENT_LIST.includes(s)) {
			return this.elementData[s];
		} else {
			let statData = (this.data.stats || this.baseData.stats);
			if (typeof(statData) == 'object') {
				return (statData[stat] || this.baseData.stats[stat]);
			} else {
				console.log("ERROR in BestiaryEntry.get(): database entry has no stat object");
				return;
			}
		}
	} else {
		return "???";
	}
}
}}}
We need to pass the name of the stat we want to this function. If the stat isn't known to the player (the corresponding flag in {{{statsKnown}}} is not {{{true}}}), we should just return a generic "unknown" message, by default a simple string of three question marks. Otherwise, we will use an {{{if}}} statement to create branching functionality that allows us to find the correct stat in the enemy's database entry. HP, GP, and XP have single properties with unique names, making them straightforward to access; but because elemental affinities and core stats are stored in sub-containers, we need to cover them under separate branches.
{{{
else if (setup.ELEMENT_LIST.includes(s)) {
	return this.elementData[s];
}}}
Elemental affinities are much more complicated that other stats, and we need the processing of a live {{{Enemy}}} object to get everything we need from them. Fortunately, this was handled in the constructor already, storing the post-processed data in this {{{elementData}}} property.
{{{
let statData = (this.data.stats || this.baseData.stats);
if (typeof(statData) == 'object') {
	return (statData[stat] || this.baseData.stats[stat]);
} else {
	console.log("ERROR in BestiaryEntry.get(): database entry has no stat object");
	return;
}
}}}
With core stats, we have to be careful: Because it's possible for a database entry to have no {{{stats}}} property (if they are an alt form, for instance), we need to grab that first to make sure it's in the format we want -- in this case, a generic object. If it is, all is well, but if not, we need to log an error.

(Note the dual use of {{{data}}} and {{{baseData}}} here. We check {{{data}}} first, but if that turns up an {{{undefined}}}, we can fall back on {{{baseData}}}, which should always have a fully-populated database entry.)

<h2 id="crisis">Crisis/Limit Breaks</h2>
<<nobr>>
<center>
<figure>
	<img @src="setup.ImagePath+'documentation/LBexample.PNG'" />
	<figcaption>
	<span style="font-size:10pt">(Screenshot from <i>Final Fantasy VII</i>, from the Final Fantasy Wiki)</span>
	</figcaption>
</figure>
</center><</nobr>>
The term "Limit Break" was an idea popularized by the video game <i>Final Fantasy VII</i>. In that game, characters filled up a "limit" guage as they took damage, and when it was full, they could unleash a powerful special attack. Later <i>Final Fantasy</i> games would continue to iterate on the concept, most notably the Overdrive mechanic of <i>Final Fantasy X</i>, which also allowed characters to fill up the guage through other methods.

This is a popular mechanic in RPGs, largely because it provides an opportunity to see cool, flashy, cinematic moves that make the player feel awesome and powerful. For that reason, I chose to add support for the feature in version 1.23, calling it "Crisis" as an homage to <i>Last Scenario</i>.

Limit breaks create an interesting paradox: You get stronger the closer you are to losing. This can help modulate the difficulty of your battles by allowing players to bounce back if they're decimated by an enemy attack. You do have to be careful with this, though: if it's too easy to charge up limit breaks, players will be able to trivialize a lot of fights even if they aren't at the intended level of strength or skill. It may even unintentionally incentivize players to be slightly weaker than the intended benchmarks so they can pull off more limit breaks. <i>Final Fantasy VII</i> itself addressed this problem by resetting the limit guage when a character was KO'd, ensuring that characters had to be tough enough to at least survive the enemy's attacks; however, many other games leave limit progress intact on KO.

An important variable to define is what proportion of HP characters need to lose before they can pull off a limit break. Most <i>Final Fantasy</i> games actually require characters to take significantly more than their maximum HP in damage, requiring the use of healing abilities for a successful charge. For example, in <i>Final Fantasy X</i>, a character taking their maximum HP in damage will only charge their limit guage by 30%. This is a good principle if you plan to emphasize teamwork and synergy in your battle system, as it requires characters to work together and support each other in order to use the system to its fullest. This can also be a good way to modulate the frequency of limit breaks in the first place.

(Of course, if you plan to have no or limited healing, this won't be possible. This is why the engine's default crisis modulator is extremely generous, only requiring characters to take 70% of their maximum HP in damage. Since there's no healing, this means characters can only use their crisis ability once; but in a system with healing, the same crisis modulator may allow them to pull off crisis abilities near-constantly.)

However, you need not constrain yourself to only thinking about limit breaks in terms of desperation attacks. You can let the player charge the meter through any behavior you wish, and this is in fact a great way to incentivize players to play the way you want them to. <i>Final Fantasy X</i> notably gave characters multiple methods of charging, with each being unlocked over the course of the game after the character had performed a number of actions related to the method. In this way, players were given more control over how to customize their characters: they could let a strong warrior character charge limit by inflicting damage or killing enemies, or turn dangerous situations into opportunities with modes that charged limit when characters were alone or in critical health.

<i>Radiant Historia</i> provides a more focused example: The characters' equivalent of a limit break guage charges when characters combo long strings of attacks together. This combo mechanic is a core feature of <i>Radiant Historia</i>'s battle system and the game becomes much more fun once you understand it, but most jRPG players may not give it much thought; by tying it to the cool, flashy limit break attacks, it draws the players' attention and encourages them to master it.

You can even introduce an interesting resource tradeoff by making limit break progress useful for other abilities as well. In <i>Alter A.I.L.A. Genesis</i>, characters gain progress towards a powerful, ultimate attack every time they use a basic ability, but these progress points can themselves be used for other special abilities. This adds an interesting new dimension to battles, as you must make tradeoffs between using a moderately powerful ability immediately or waiting to build up to a stronger one.

This ties into one final point: An interesting quirk of the original limit break system is that it cost no Magic Points or any other type of limited resource, unlike other strong abilities like spells. This made limit breaks even more powerful and enticing than they already were. This makes a degree of sense, since they are still limited by the limit guage itself, but it also ran the risk of making them overpowered. Tip the balance too far, and limit breaks can end up reducing tactical depth by turning the optimal strategy into just waiting to use them over and over again. (This was, in fact, a common criticism of <i>Alter A.I.L.A. Genesis</i>.) You need not be limited by this mold; you can make limit breaks cost energy, MP, or some other resource to constrict their use and force the player to think about them more carefully.

Like everything else, if you choose to use limit breaks in your game, use them with thought and care, not just because they seem cool or because other games did it first.

<h3 id="crisis.code">Implementation</h3>
The default engine settings support a straightforward, <i>Final Fantasy</i> style of limit breaks. First, we have to give the characters these actions in the first place:
{{{
class Puppet extends Actor{
	constructor(name){
	(...)
			this.crisis = [];
			if (this.data.crisis instanceof Array) {
				for (let n of this.data.crisis) {
					this.crisis.push(new Action(n));
				}
			} else if (typeof(this.data.crisis) == "string") {
				this.crisis.push(new Action(this.data.crisis));
			}
}}}
In the Puppet constructor, we create an array property called {{{crisis}}} and fill it with Crisis actions, just like we do for regular actions. You can give characters either a single Crisis action or a list by adding it to their database entry. (Crisis actions themselves are created just like any other action, their database entries contain the "crisis" property.)
{{{
[Q] = basic action
<<if subject().lastAction !== null>> | [W] = last action (<<print subject().lastAction>>)<</if>>
<<if subject().crisis instanceof Array && subject().crisis.length > 0>> |
	<<if subject().crisisPoints >= 100>>
		<<set _style = "font-weight:bold">>
	<<else>>
		<<set _style = "color:gray">>
	<</if>>
<span @style=_style> [E] = <<crisisLink>></span>
<</if>>
}}}
Then, on the action list screen, we add this segment after the standard hotkey notifications (for basic and last actions) to allow players to access their characters' Crisis abilities.
{{{
<<if subject().crisis instanceof Array && subject().crisis.length > 0>>
}}}
This clause ensures the Crisis toggle will only appear if the character has Crisis actions in the first place. If their {{{crisis}}} property doesn't exist or is unpopulated, nothing will display here. (This means that if you don't want to have Crisis abilities in your game, you can just not set them and the player will never know -- puppets will still have the {{{crisis}}} property, but it will be empty and thus fail this check.)
{{{
<<if subject().crisisPoints >= 100>>
	<<set _style = "font-weight:bold">>
<<else>>
	<<set _style = "color:gray">>
<</if>>
<span @style=_style> [E] = <<crisisLink>></span>
}}}
We then add a little bit of style to the notification itself. If the player can use a Crisis (their {{{crisisPoints}}} are at 100%), we'll bold the link to draw their attention; if not, we'll gray it out so it's less obtrusive.
{{{
<<widget "crisisLink">>
<<if typeof($args[0]) == "string">>
	<<set _text = $args[0]>>
<<else>>
	<<set _text = "Crisis">>
<</if>>
<span id="crisisLink">
<<link _text>>
	<<replace "#phase">><<include "crisis actions">><</replace>>
<</link>>
</span>
<</widget>>
}}}
The {{{<<crisisLink>>}}} widget itself is straightforward: It's just a link that displays the puppet's crisis actions when clicked. If you want to use a different term than "Crisis", you can also pass alternate text to the widget and that will be displayed instead.
{{{
<<if $args.includes("crisis")>>
	<<set _actions = _char.crisis>>
}}}
The "crisis actions" passage is functionally identical to the standard "actions" passage, the only difference being that it iterates over Crisis actions rather than regular actions. That's accomplished through this little handler in {{{<<actionList>>}}}.

From here, the Crisis action can be handled like any other and reuses much of the same code, though we have to add some additional checks to account for the new resource:
{{{
window.actionStandardCheck = function actionStandardCheck (action) {
	return (...) (action.crisis && subject().crisisPoints < 100);
}

[action effects]
<<if $action.crisis && def subject().crisisPoints>>
	<<set subject().crisisPoints = 0>>
<</if>>
}}}
The selection link is disabled if the character's Crisis points aren't at 100%, and Crisis points are reset to 0 after use.

To give characters Crisis points, we add this passage to the end of {{{<<echoDamage>>}}}:
{{{
<<if Number.isInteger(_target.crisisPoints) && $dmg > 0>>
  <<switch _target.crisisMode>>
    <<default>>
      <<set _target.crisisPoints += Math.round(($dmg/_target.maxhp)*100*_target.crisisFactor)>>
  <</switch>>
<</if>>
}}}
The default formula is very simple, based on <i>Final Fantasy X</i>'s formula for Stoic mode: Crisis points gained are equal to the proportion of max HP taken in damage multipled by a modulator variable. The default Crisis factor is 10/7, meaning characters will fill their Crisis points when they have taken 70% of their max HP in damage, but you can specify unique values for different characters.

You can also see functionality here for alternate Crisis modes a la <i>Final Fantasy X</i>, but no others are implemented at this time.

<h3 id="crisis.stash">Stash</h3>
Rogue's "Stash" Crisis ability is particularly complicated, so I will cover it here.
{{{
"Stash": {
	"crisis": true,
	"phase": "Stash Phase",
	"info": `Use an item for free.`,
	"desc": `Rogue may have kept a few of the party's items tucked away for themselves. But now that the chips are down, they've got to use everything at their disposal!`,
	"preview": null
}
}}}
If you look at Stash's database entry (shown here), you'll find it's very minimal. This is because, unlike other actions, Stash is never meant to be directly used. Its only purpose is to provide the player something to click on, at which point they will be forwarded to a submenu to choose the actual action they will use that turn.

The Stash Phase can be viewed in {{{Battle Phases.tw}}}, but it is essentially identical to the action list menu. The key lies in an additional attribute we add to Rogue during character generation:
{{{
"specialInit": function (actor) {
	(...)
	actor.stash = [
		new ItemAction("Panacea"),
		new ItemAction("Bottled Chi"),
		new ItemAction("Adrenaline"),
		new ItemAction("Stoneskin"),
		new ItemAction("Nootropic"),
		new ItemAction("Stimulant"),
		new ItemAction("Powdered Glass"),
		new ItemAction("Grenade"),
		new ItemAction("Flamethrower"),
		new ItemAction("Gas Bomb"),
		new ItemAction("Flashbang"),
		new ItemAction("Calamity Bomb")
	];
	actor.stash.forEach(function (item) {
		item.free = true;
		item._crisis = true;
	});
}
}}}
The {{{stash}}} array is a list of the actions the player can choose from in the Stash Phase. If the character doesn't have a {{{stash}}} attribute, you'll get an error message and the code will shut down before it starts. Since we're only interested in the action and not the items themselves, we can just use {{{ItemAction}}}s here.

Note that the stash list has no correlation to the player's actual inventory, and in fact I cut out all the minor status cures that would be redundant with the Panacea. This gives you more control over the stash list, perhaps allowing the player to unlock additional items as they level up.
{{{
<<if subject() instanceof Puppet && $action instanceof ItemAction && !$action.free>>
	<<print $inventory.decItem($action.name)>>
<</if>>
}}}
However, this runs into a little problem, here in the action phase. If the action was an {{{ItemAction}}}, we're supposed to remove the corresponding item from the player's inventory -- but the whole point of Stash is that it's not supposed to do that!
{{{
actor.stash.forEach(function (item) {
	item.free = true;
	item._crisis = true;
});
}}}
That is the purpose of this additional code. It runs through the {{{stash}}} array and modifies every action to have the {{{free}}} attribute, which will bypass the item decrement check. We also need to make them behave as Crisis abilities by flagging their {{{_crisis}}} attribute -- otherwise, they wouldn't reset the user's Crisis points!

These are the additional factors you'll need to add in order for Stash to work. The principles you learned here can also be generalized to other types of submenu abilities.
