:: Documentation (Advanced) [text info]
Use the table of contents to navigate. You can come back to the top at any time by pressing the "home" key on your keyboard.

This documentation will assume you are familiar with the explanations detailed in [[Documentation (Basic)]]. This advanced documentation will go into detail on the code of every passage.

In addition to the code in the engine itself, the engine uses <a href="https://twinelab.net/custom-macros-for-sugarcube-2/" target="_blank">Chapel's custom macros</a>. Click the link to learn more.

The opening sections will be quite technical, and deal with external script. If you'd like to skip to how the Twine passages operate, you can head to <a class="noExternal" href="#setup">Setting up the battle</a>.

<h1>Table of Contents</h1>
><a href="#JS">JavaScript vs. Twine</a>
>><a href="#JS.config">Config</a>
>><a href="#JS.databases">Objects, Classes, and Databases</a>
>><a href="#JS.actor">Actor Class</a>
>>><a href="#JS.actor.constructor">Constructor</a>
>>><a href="#JS.actor.getters">Getters and Setters</a>
>>><a href="#JS.actor.effectFunctions">Effect Functions</a>
>>><a href="#JS.actor.equipFunctions">Equipment Functions</a>
>>><a href="#JS.actor.toleranceFunctions">Tolerance Functions</a>
>>><a href="#JS.actor.misc">Miscellaneous Functions</a>
>><a href="#JS.stats">Stat Class</a>
>>><a href="#JS.stats.fill">The FillStat Class</a>
>>><a href="#JS.tolerances">Tolerance Class</a>
>><a href="#JS.puppets">Puppet Class</a>
>><a href="#JS.enemies">Enemy Class</a>
>><a href="#JS.actions">Action Class</a>
>><a href="#JS.items">Inventory and Items</a>
>><a href="#JS.support">Support Functions</a>
>><a href="#JS.serial">Serialization and Save Files</a>
>><a href="#JS.updates">What if we want to update something in a new version?</a>
><a href="#display">Display and aesthetics</a>
>><a href="#statusdisplay">Displaying the status pane</a>
>><a href="#nobr">The nobr tag</a>
>><a href="#pronouns">Personalized text</a>
>><a href="#healthbars">Health Bar Formatting</a>
>><a href="#battlestyle">Special Aesthetics for Battles</a>
>><a href="#savesmodifier">Modifying the Save Display</a>
>><a href="#animationsDoc">Animations</a>
>>><a href="#animations.design">Designing the Animations</a>
>>><a href="#animations.setup">Setup</a>
>>><a href="#animations.execution">Execution</a>
>>><a href="#animations.disabling">Disabling the Continue Button</a>
><a href="#setup">Setting up the battle</a>
><a href="#skeleton">How the battle passages work</a>
>><a href="#auto-end">Auto-endturn</a>
>><a href="#actorlistDoc">Actor List</a>
>>><a href="#actorBoxDoc">Actor Box</a>
>><a href="#commands">Commands</a>
>><a href="#targetingphase">Targeting Phase</a>
>><a href="#confirmphase">Confirm Phase</a>
>><a href="#spellphase">Spell Phase</a>
>><a href="#actionphase">Action Phase</a>
>><a href="#actionqueue">The Action Queue</a>
>><a href="#endOfRound">End of Round</a>
>><a href="#enemyphase">Enemy Phase</a>
>>><a href="#enemyphase.multiActions">Enemies with Multiple Actions</a>
>><a href="#advanceturn">Advancing Turns</a>
>><a href="#victorydefeat">Victory and Defeat</a>
><a href="#actions">Action Mechanics</a>
>><a href="#actions1">Special Cases</a>
>><a href="#actions2">The Functional Link</a>
>><a href="#actions3">Info Display</a>
>><a href="#crossbow">How does Rogue's crossbow work?</a>
>><a href="#items">Items</a>
>><a href="#delayed">Delayed Attacks</a>
><a href="#damage">Calculating and applying damage</a>
>><a href="#damage.1">Calculating damage</a>
>><a href="#damage.2">Applying damage</a>
>>><a href="#dmgreflection">Damage Reflection</a>
>>><a href="#dmg.onhit">onHit</a>
>>><a href="#dmg.shock">Shock cures</a>
>>><a href="#dmg.counters">Setting up counterattacks</a>
><a href="#effects">Status Effects</a>
>><a href="#effects1">Applying effects</a>
>>><a href="#effects1.1">Accounting for protective effects</a>
>>><a href="#effects1.2">Numerical components</a>
>>><a href="#effects1.3">Exclusivity</a>
>><a href="#effects.calc.dot">Damage-over-time effects</a>
>><a href="#effects.loss">Loss-of-control Effects</a>
><a href="#targeting">Targeting and Enemy AI</a>
>><a href="#hitlist-class">Making a Hitlist</a>
>><a href="#targeting.basic">Standard Targeting</a>
>>><a href="#targeting.basic.1">Martyr check</a>
>>><a href="#targeting.basic.3">Mercy</a>
>>><a href="#targeting.basic.4">Smart targeting</a>
>><a href="#targeting.threat">Threat-based/Aggro Targeting</a>
>><a href="#dispel">Dispel Targeting</a>
>><a href="#targeting.ally">Ally Targeting</a>
><a href="#menus">Menu Functionality</a>
>><a href="#menus.status">Status</a>
>><a href="#menus.inventory">Inventory</a>
>><a href="#partypicker">Party Picker</a>
>><a href="#equipmanager">Equipment Manager</a>
>><a href="#itemshop">Item Shop</a>
><a href="#hotkeys">Hotkeys</a>
>><a href="#hotkeys.summary">Summary</a>
><a href="#widgets">Other Widgets</a>
>><a href="#chain">The {{{<<chain>>}}} widget</a>
>><a href="#refreshPuppets">{{{<<refreshPuppets>>}}}</a>
>><a href="#deathcheck">{{{<<deathcheck>>}}}</a>
>><a href="#statusDoc">{{{<<status>>}}}</a>
>><a href="#endofbattle">{{{<<endofbattle>>}}}</a>
>><a href="#backbtn">{{{<<backbtn>>}}}</a>
>><a href="#victorycheck">{{{<<victorycheck>>}}}</a>
>><a href="#stat">{{{<<stat>>}}}</a>
>><a href="#itemdrop">{{{<<itemDrop>>}}}</a>
>><a href="#musicwidgets">Music widgets</a>
>><a href="#find">{{{<<find>>}}}</a>

<h2 id="JS">JavaScript vs. Twine</h2>
To begin, it's important you understand how to operate JavaScript in Twine.

The code you see in Twine passages, such as {{{<<if condition>><<set $variable to value>>}}}, is a modified form of JavaScript designed to be easier to use with stories. However, it has some limitations. For a project as complex as an RPG engine, I chose to include pure JavaScript as well.

Fortunately, Twine is compatible with external JavaScript files. Normally, this is accessed through a special passage that can be accessed by clicking the story's title at the bottom of the screen; however, because Twine only allows one JavaScript passage, for ease of use, I separated it into multiple independent JavaScript files which can be found in {{{src/javascript}}}. For this engine, the JavaScript is mostly used for storing information for data structures used in the game, such as characters, items, and actions. You can edit these files by opening them in a text editor such as Notepad++, and add them to the story by compiling them with Tweego. (Editing through Twine is unfortunately difficult, due to a lack of a search feature.)

JavaScript is very similar to SugarCube Twine code, but has a separate store of variables from the ones defined in Twine. To access a story variable in JavaScript, you must put {{{variables().}}} in place of where you would put the {{{$}}} symbol in Twine. To access a temporary variable, you must put {{{temporary().}}} in place of the {{{_}}} symbol.

<h3 id="JS.config">Config</h3>
The first JavaScript file is "0_config". The 0 is added to ensure it comes first in the directory, as files are compiled in alphabetical order.

This file stores configuration settings for Twine, such as how saves are formatted and what path to use for media files. Additionally, the {{{variables()}}} function used to access story variables is assigned to the shorter name {{{V()}}}, for convenience. Note that this is case sensitive.

You can add additional configuration settings as needed for your story. See the SugarCube documentation for details.

<h3 id="JS.databases">Classes and Databases, advanced</h3>
In [[Documentation (Basic)]], you learned how to create your own entries for the engine's databases. Here, you will learn how those entries are read and constructed into live objects.

You also learned that objects are collections of sub-variables called <b>properties</b> that you can access with the dot operator. Typically, there are variables stored inside each property; however, that is not strictly necessary.

RPGs use a lot of terms and structures that have associated data, such as characters, abilities, and items. In many cases, the data associated with these structures doesn't change. For instance, Fighter's "Sword" ability always has a cost of 2, a weight of 1, always does damage for its action, and always has the same info and description data. None of that will change over the course of the game.

We therefore don't need to encode all of that data into a "Sword" object. In fact, it would be very good if we didn't have to, because Twine has to copy every single object and variable every time it makes a passage transition! With lots of bulky objects, that can really slow down performance. Instead, since the data doesn't change, we can define it in a separate database object, and look it up through functions tied to object classes.

Here is an example from the <code>Action</code> class:
{{{
get actionData () {
	return (setup.actionData[this.name] || setup.actionData[this.displayname] || {});
}
}}}
This is known as a <b>getter function</b>. When you define a function through the keyword <code>get</code>, that function can be called just like an attribute of the object -- no function call required! This means it can't take any arguments, but that's okay. We only need simple functions for this.

With this function, if we define an object in <code>setup.actionData</code> with the action's name as a property, this will return whatever data is associated with that action. (Note the parentheses and <code>||</code> operator; if you are not familiar with how that feature works, read about it <a href="https://stackoverflow.com/questions/2802055/what-does-the-construct-x-x-y-mean" target="_blank" rel="nofollow">here</a>. tl;dr If the result of the code is falsy, it will skip it and attempt to return the next entry. This is useful for defining default values in the case that something is undefined.)

We can then define a getter for every property we need by extracting it from <code>actionData</code>:
{{{
get cost () {
	var val = this._cost;
	if (val === undefined) {
		val = this.actionData.cost;
	}
	if (val === undefined) {
		val = 0;
	}
	return (val instanceof Function) ? val(this) : val;
}

(etc.)
}}}
Note the way this is constructed. There may be times where we <i>do</i> want to modify a particular Action instance with a unique property that's different from its property in the database, such as with the variable effects of Mage's spells. For this, we use a special property with the same name, but prepended with an underscore <code>_</code> to denote it as an override property. We may also want to calculate the property through another function rather than hold it as a single value, so we have to include a check to call the function if there is one.

(Why does this look so much more complicated than the one-line return statement in the last getter? Because variable return works on logical operation, which means it skips an entry if it evaluates to <code>false</code> -- <i>not just</i> if it's <code>undefined</code>! <code>cost</code> can be 0, which is a falsy value. Because of this, we have to write out a full <code>if</code> tree that explicitly only excludes <code>undefined</code> values. You'll want to do this for any property that could have a falsy evaluation, which are listed <a href="https://developer.mozilla.org/en-US/docs/Glossary/falsy" target="_blank" rel="nofollow">here</a>. It's a pain, but doing it here will save you more trouble in the long run!)

This method of offloading constant data to a database and accessing it through lookup is known as <b>Flyweight</b>. It is very useful for streamlining our data: Now, our objects only have to store a <code>name</code> property and any dynamic properties that might change over the course of the game. As an added bonus, this makes updating the game between versions easier as well: The <code>setup</code> variable exists independent of save states, so any changes made to the database will automatically be reflected in existing saves.

Now that you know the general principles, let's get into the individual classes.

<h3 id="JS.actor">Actor Class</h3>
The <b>Actor</b> class defines a character who, as the name implies, acts in battle. This means it should define all the attributes we want battling characters to have.

<h4 id="JS.actor.constructor">Constructor</h4>
All classes require a <b>constructor</b> function that standardizes how they are initialized. It takes arguments just like any other function that are used in the construction of the object. Since we use a database structure, for {{{Actors}}}, we only need the name.
{{{
if (this instanceof Puppet) {
	this.id = "p";
} else if (this instanceof Enemy) {
	this.id = "e";
} else {
	this.id = "_";
}
this.id += (new Date().getTime() + Math.random() * 0x10000000000).toString(16);
}}}
The first thing we do in the constructor is create a unique ID value for the Actor. This is necessary for a few other features that need to be able to identify a specific Actor out of an array. It's also necessary for the ID to distinguish between Puppets (player characters) and Enemies, so we use an if tree to append a unique symbol to the start of the ID depending on which one this object is. (Puppet and Enemy are also object classes; they will be explained later.)
{{{
this.name = name;
}}}
We then start assigning values to the object's attributes, starting by assigning the <code>name</code> argument to a <code>name</code> property.
{{{
if (this.data)
}}}
Then we perform this check before proceeding. We will learn how this works when we examine Actor's functions. For now, just remember this.
{{{
this._HPregen = {
	"flat": new Stat(0),
	"percent": new Stat(0)
}
this.elements = new Map();
if (setup.ELEMENT_LIST !== undefined){
	setup.ELEMENT_LIST.forEach(function(x) {
		this.elements.set(x,{"percent": new Stat(1), "flat": new Stat(0)});
	}, this);
}
this.tolerances = new Map();
if (setup.effectData !== undefined){
	Object.keys(setup.effectData).forEach(function(x) {
		this.tolerances.set(x,new Tolerance(0));
	}, this);
}
}}}
Then three properties are initialized to default valies: HP regeneration (which contains both flat and percentage rates), elemental affinities, and ailment tolerances. {{{ELEMENT_LIST}}} is a story variable you can define in StoryInit to list all the elements you want in your game. This code checks to make sure it exists, and if it does, runs across it to create elemental affinity values for each. (By default, they are all neutral: 1 for the proportional multiplier and 0 for flat reduction.) This will prevent the game from throwing an error when a character is attacked with an elemental ability; if the game tries to read a value and there's nothing there, it may create problems. Similarly, {{{tolerances}}} generates ailment resistances by running over {{{effectData}}}, the database of all status effects in your game (see <a class="noExternal" href="#effects">Status Effects</a>), and creating resistances based on the name values it extracts.

The {{{elements}}} and {{{tolerances}}} attributes are defined as a Map object rather than an array. Maps are very similar to arrays, but their index values can be anything, not just numbers. To extract a value from a Map, you use {{{<var>.get(<key>)}}}, similarly to how you use {{{<var>[index]}}} to extract values from arrays. This makes it much easier to call an affinity in response to an elemental attack, as you can just input the name and the program will pull up the corresponding value, instead of having to remember the order of the array.
{{{
this._maxhp = new Stat(this.data.hp);
this._hp = this.data.hp;
this.stats = {};
for (let [pn,v] of Object.entries(this.data.stats)) {
	this.stats[pn] = new Stat(v);
}
if (this.data.elements) { this.setElements(Object.entries(this.data.elements),"percent"); }
if (this.data.tolerances) { this.setTol(Object.entries(this.data.tolerances)); }
if (this.data.retaliations) { this._retaliations = new FillStat(this.data.retaliations); } else { this._retaliations = new FillStat(0); }
}}}
Next we start actually extracting data from the database. Main stats such as Attack and Defense are stored in the <code>stats</code> attribute, which is populated by looping over the entries provided by the <code>stats</code> property in the character's database entry. (This means that the initialization will work for any number of stats; you don't need to change the code here if you want to add or remove stats.) If the character has defined <code>elements</code>, <code>tolerances</code>, or <code>retaliations</code> in their database entry, those are extracted; otherwise, they remain at their default values. (Currently, only percent-based elemental affinities are initialized here. You'll have to implement your own code for flat rates.)
{{{
this.isDone = false;
this.dead = false;
this.effects = [];
this._deathMessage = `${this.name} is defeated!`;
}}}
Next we initialize some important flags. <code>isDone</code> will be used to determine if a character has finished their turn, and <code>effects</code> holds status effects. After this, we set a bunch of flags that mark if a character has a certain status effect (see <a class="noExternal" href="#effects">Status Effects</a>).
{{{
this.equipment = new Map([
	["Weapon",null],
	["Armor",null],
	["Accessory",[null,null] ]
]);
}}}
Finally, we define equipment slots. Thesse are discussed more in <a class="noExternal" href="#JS.items">the Item Database</a>.
{{{
else {
	console.log("ERROR: Actor "+name+" is not in database");
	this.name = "INVALID ACTOR";
	this._hp = 1;
	this._maxhp = new Stat(1);
}
}}}
We finish with a default error handler in the case that our earlier <code>if (this.data)</code> check failed. This will at least fill the important fields so we don't have a completely undefined object breaking things, and log an error to the database that tells us what happened.

<h4 id="JS.actor.getters">Getters and Setters</h4>
We are then finished with the constructor, but we can continue to add other functions. These functions, called <b>object methods</b>, can be used by any instance of the Actor class.
{{{
get data () {
	var id = (this.idname || this.name);
	if (this instanceof Puppet) {
		return (setup.puppetData[id] || false);
	}
	else if (this instanceof Enemy) {
		return (setup.enemyData[id] || false);
	}
	else {
		return undefined;
	}
}
}}}
Like all database-associated objects, we need to start with a function that accesses the database. This one is a little more complicated than others, because we don't intend to use pure Actor objects in our game; every Actor is going to be one of two subclasses, Puppets or Enemies. The data for these classes are defined in separate databases, so we need to check the type of our object to determine which database to access. We also need to return <code>false</code> for our default value instead of an empty object so that our <code>if (this.data)</code> check will fail in the event there's no matching database entry.

(We also use a multiple-choice assignment to pick from two possible identifiers, for <a class="noExternal" href="#JS.enemies">reasons</a>.)

We next define getters and setters for several properties. Accessing Map values is a little unwieldy, especially when those values are themselves objects, so we define functions with shorter names that do the same thing. We have functions here for getting and setting all modifiable stats, and obtaining equipment and circumstance bonuses.

Note the <code>hp</code> setter:
{{{
set hp (amt) {
	this._hp = Math.clamp(amt,0,this.maxhp);
}
}}}
This prevents a character's HP from going below 0 or above their maximum HP.
{{{
get (key) {
	// calculates effective stats
	if (this.stats[key]) {
		let v = this.stats[key];
		let n = v.current;
		if (n < setup.MIN_STAT && !(key == "Defense" && this.forsaken)){
			n = setup.MIN_STAT; // 0 in subtractive, 1 otherwise
		}
		return Math.round(n);
	} else {
		console.log("ERROR in stat getter, target does not have requested stat");
		return 0;
	}
}
}}}
Similarly, this function (just called <code>get</code>) not only returns a stat, but ensures it stays within acceptable bounds. In a divisive defense system, letting a defense stat hit 0 can result in a division by zero error, so this is very important! (This isn't an issue in the default subtractive system, so I included a little handler here that lets Defense go negative if the character has the Forsaken status. This is how Forsaken is uniquely able to reduce Defense below 0.)
{{{
getElement (needle,type) {
	if (type === undefined) {
		return this.elements.get(needle);
	} else {
		return this.elements.get(needle)[type].current
	}
}

setElements (array,type) {
	// Easy way to set base elemental affinities. Takes an array of arrays that each contain two elements, the name of the effect and the base value. Pass the second argument to denote if you are setting flat or percent rates.
	if (type === undefined || typeof(type) !== 'string') {
		console.log("ERROR in setElements: no type defined");
	} else {
		array.forEach(function(data) {
			if (this.elements.has(data[0])) {
				this.elements.get(data[0])[type].base = data[1];
			}
		}, this);
	}
}

(...)

getTol (key) {
	// This is for evaluating tolerance in-battle, and therefore only returns the current value. DON'T use it to access the whole tolerance object, because that's not what it returns.
	if (!this.tolerances.has(key)){
		return undefined;
	} else {
		return this.tolerances.get(key).currentVal;
	}
}

setTol (array) {
	// Easy way to set base tolerances. Takes an array of arrays that each contain two elements, the name of the effect and the base value.
	array.forEach(function(data) {
		if (this.tolerances.has(data[0])) {
			this.tolerances.get(data[0]).base = data[1];
		}
	}, this);
}
}}}
We also have some special getters and setters for handling elemental affinities and ailment tolerances. Because these are complicated structures stored in large maps, it's difficult to access and modify them directly. {{{getElement}}} lets you specify if you want the flat soak or the proportional resistance associated with that element and returns the {{{current}}} value (see <a class="noExternal" href="#JS.stats>the Stat class</a>) of the associated property, making it very easy to plug it into in-game calculations; {{{getTol}}} does the same for tolerances, but is less complicated since tolerances don't have sub-properties for flat and proportional. (Note that these are not normal "getter" functions, as they do not actually access the maps' raw values. You will need to use {{{.get(key)}}} for that.) {{{setElements}}} lets you quickly set base values for elemental affinities, and {{{setTol}}} does the same for tolerances.

<h4 id="JS.actor.effectFunctions">Effect Functions</h4>
{{{
addEffect (effect,time,power) {
	if (typeof(effect) == 'string'){
		effect = new Effect(effect,time,power);
	}
	this.effects.push(effect);
	effect.onApply(this);
	return effect.addText(this.name);
}

removeEffect (effect,mods) {
	mods = (mods || {});
	if (!this.stasis || mods.pierce === true){
		var E;
		if (typeof(effect) == 'string') {
			E = this.effects.find(function(e) { return e && e.name === effect; });
		}
		else {
			E = effect;
		}
		if (!V().inbattle || ((!E.ULTIMATESTICKY || mods.unsticky == "ultimate") && (!E.sticky || mods.unsticky))) {
			E.onRemove(this);
			this.effects.delete(E);
			return E.removeText(this.name);
		}
		else {
			return `${E.name} status can't be removed!<br/>`;
		}
	} else {
		return `${this.name}'s Stasis held the effect in place!<br/>`;
	}
}
}}}
The next set of functions governs how status effects interact with the character. They effectively bundle three functionalities together for us: adding or removing the Effect object in the character's {{{effects}}} array, applying the effect's actual functionality, and sending a message to the player.

Note that these functions have branching functionality depending on the arguments they receive:
{{{
if (typeof(effect) == 'string'){
	effect = new Effect(effect,time,power);
}
}}}
{{{addEffect}}} is designed to take a single argument -- an Effect object -- by default. This is because it has to call {{{onApply}}} and {{{addText}}}, which are functions of Effect objects. The standard structure of effect management is set up to be compatible with format. However, what if you want to make a new effect and add it at the same time? This sometimes happens in special circumstances, such as Darwin's power up scene in <i>Cartoon Battle</i>. You could say {{{addEffect(new Effect(name,time,power))}}}, but this is a little awkward to write. It's easier if we're just able to pass the raw variables directly, as we would when constructing a new Effect. That's what this {{{if}}} statement does: If the first argument is a string, the function assumes the user is trying to construct a new Effect object, and does so before proceeding.
{{{
if (typeof(effect) == 'string') {
	E = this.effects.find(function(e) { return e && e.name === effect; });
}
else {
	E = effect;
}
}}}
We see something similar in {{{removeEffect}}}. By default, it is designed to take a single object -- an Effect object present in the Actor's list of {{{effects}}} -- so it can remove it through the {{{delete}}} function. This assumption is valid for the default engine structure, where effect removal actions iterate over the {{{effects}}} array and remove elements non-specifically. But what if we <i>do</i> want that specificity? What if we only want to remove a specific effect? We could iterate over the {{{effects}}} array and check against the name of the effect we want to remove every time, but that's tedious. Instead, we can just pass a string, and the work of searching is offloaded to this function. (Note, however, that due to the way {{{find}}} works, this will only remove the <b>first</b> effect it finds, and leave the others alone. If you want to remove all instances of a stackable effect, you will indeed need to loop through the whole array to collect them.)

If you call these functions with a {{{<<print>>}}} statement, the {{{return}}} statement will be printed to the screen. You don't need to call it again; the code of a function is executed regardless of the context in which it is called, so it'll still run in addition to printing the text. If you want to discard the output, all you need to do is call the function with a {{{<<run>>}}} statement instead; it will still perform its functionality, but you won't print the {{{return}}} statement.
{{{
if (!V().inbattle || ((!E.ULTIMATESTICKY || mods.unsticky == "ultimate") && (!E.sticky || mods.unsticky)))
}}}
Additionally, <code>removeEffect</code> has this clause before it removes an effect. "Sticky" effects aren't supposed to be removable by normal means. We could manually implement this functionality into every cure or dispel ability, but that's tedious. Since this is universal behavior, we'll implement it here. If you want a special ability to be able to remove sticky effects, such as Witch's "Renewal" ability, you can pass an {{{unsticky}}} flag here.

Certain effects have an "ULTIMATESTICKY" property as well that prevents them from being removed even by normal unsticky abilities. You can still remove these, but you will need to assign the string "ultimate" to the {{{unsticky}}} variable.

(We also have to be careful -- we still want to be able to remove sticky effects through system cleanup, such as end-of-battle processing! I account for this by implementing a bypass if the game isn't currently in a battle, but if you want sticky effects to persist after battle you will have to do something different.)

<h4 id="JS.actor.equipFunctions">Equipment Functions</h4>
{{{
unequip (slot,index,mods) {
	mods = (mods || {});
	if (this.equipment.has(slot)) {
		var item = null;
		if (this.equipment.get(slot) instanceof Array) {
			if (typeof(index) == 'number') {
				item = this.equipment.get(slot)[index];
			} else { console.log("ERROR in unequip: Invalid item index."); return; }
		} else {
			item = this.equipment.get(slot);
		}
		if (item !== null){
			if (item.default === undefined && mods.destroy !== true) {
				inv().addItem(item.name);
			}
			if (item.onRemove !== undefined) {
				item.onRemove(this);
			}
			(this.equipment.get(slot) instanceof Array) ? this.equipment.get(slot)[index] = null : this.equipment.set(slot,null);
			//this.equipment.set(slot,new Item("Default "+slot));
		}
	}
	else { console.log("Attempted to unequip nonexistent slot."); return; }
}
}}}
There are similar functions for handling equipment, though in this case we define the removal function first. {{{unequip}}} is straightforward in most cases: it is passed the slot to unequip, and the item in that slot is removed. We require a common-sense check to ensure the given slot exists and isn't already empty. We also want to store the unequipped item and place it back in the player's inventory, as the {{{set}}} function will simply overwrite what was originally in the slot. (If we <i>do</i> want the player to permanently lose the item, we can set the {{{destroy}}} flag to {{{true}}}.)

Things become slightly more complex if we are looking at an equipment slot with multiple subslots, such as "Accessory" in the default engine. If we're unequipping from such a slot, the function must be passed an {{{index}}} value so it knows which subslot to unequip. It will then check at the beginning if the slot is an array; if it is, it will assign the item at the index value to {{{item}}}, instead of the slot itself. The function checks once more at the end so that it can correctly target the slot to set to {{{null}}}.

There is an optional statement here for systems that cannot function with a {{{null}}} equipment slot; for instance, most versions of <i>Dungeons & Dragons</i> must read the statistics of the equipped weapon for attacks. In this case, instead of setting the slot to {{{null}}}, you would want to replace it with another object. These default objects can be defined in the item database like any other.

There is also an {{{unequipAll}}} function, which simply runs through the Actor's {{{equipment}}} and calls this on each item.
{{{
equip (item) {
	if (this.equipment.has(item.equippable.slot)) {
		var slot = this.equipment.get(item.equippable.slot);
		var existing = null;
		var subslot = undefined;
		if (slot instanceof Array) {
			for (let i = 0; i < slot.length; i++) {
				if (slot[i] === null) {
					subslot = i;
					break;
				}
			}
			if (subslot === undefined) {
				subslot = slot.length-1;
				existing = slot[subslot];
			}
		}
		else {
			existing = slot;
		}
		if (existing !== null){
			this.unequip(item.equippable.slot,subslot);
		}
		(slot instanceof Array) ? slot[subslot] = item : this.equipment.set(item.equippable.slot,item);
		if (item.onEquip !== undefined){
			item.onEquip(this);
		}
		if (inv() !== undefined && inv().has(item.name)){
			inv().decItem(item.name);
		}
	} else { console.log("ERROR: Equipment type not recognized"); return; }
}
}}}
The {{{equip}}} function is similar; however, to equip something we have to unequip what was already there! Fortunately, we've defined {{{unequip}}} already, so we can simply call it (after making common-sense checks that the slot exists and isn't empty). Then we assign the item to the slot and run any {{{onEquip}}} functionality, if it exists. We will also want to remove the item from the player's inventory; the {{{set}}} statement creates a new copy, so if we didn't remove the original we'd be duplicating the item!

Subslot compatibility is more complicated for this function. If the slot is an array, we need to search through it with a {{{for}}} loop to find the first available subslot (the first slot with contents {{{null}}}). As soon as it finds an empty slot, we {{{break}}} out of the loop to save processing power. This ensures that equipping additional items to this slot will fill the subslots in ascending order.

What if there are no empty subslots? In this case, {{{subslot}}} remains {{{undefined}}} and the {{{if}}} statement triggers, targeting the last subslot to swap with the new item.

<h4 id="JS.actor.toleranceFunctions">Tolerance Functions</h4>
{{{
decTol (k) {
	this.tolerances.get(k).currentVal--;
}

resetTol (key) {
	this.tolerances.get(key).refill();
}
}}}
We also have functions that simply shorten common tasks for handling tolerances. {{{decTol}}} decrements the current tolerance value (normally a mouthful to access, as you can see here), and {{{resetTol}}} resets the current tolerance value to its maximum.

(See <a class="noExternal" href="#effects1">Applying Effects</a> for more explanation on tolerances.)

<h4 id="JS.actor.misc">Miscellaneous Functions</h4>
{{{
regenHP () {
	this.setHP(this.maxhp * this.HPregenPercent);
	this.setHP(this.HPregenFlat);
}
}}}
{{{regenHP}}} shortens two lines of code into one. Because HP regeneration can have both flat and propotional attributes, we have to apply both when running HP regeneration.
{{{
get row () {
	if (setup.BATTLE_GRID === true) {
		var party;
		if (this instanceof Enemy) {
			party = V().enemies;
		} else if (this instanceof Puppet) {
			party = V().puppets;
		}
		for (var i = 1; i <	setup.COLUMN_SIZE; i++) {
			if (party.indexOf(this) < i * setup.ROW_SIZE) {
				return i;
			}
		}
		console.log("ERROR in row getter: could not find row");
		return 0;
	} else {
		return;
	}
}

get col () {
	if (setup.BATTLE_GRID === true) {
		var party;
		if (this instanceof Enemy) {
			party = V().enemies;
		} else if (this instanceof Puppet) {
			party = V().puppets;
		}
		for (var i = 1; i <	setup.ROW_SIZE; i++) {
			if (party.indexOf(this) % setup.COLUMN_SIZE == (i-1)) {
				return i;
			}
		}
		console.log("ERROR in column getter: could not find column");
		return 0;
	} else {
		return;
	}
}
}}}
These getters tell us the row and column addresses of a character if they are in a battle grid. See [[the Battle Grid|Additional Features]] for more information.

<h3 id="JS.stats">Stat Class</h3>
Stats also require their own class. If you intend for your stats to be totally static and never undergo temporary changes, defining them as a simple variable is fine; but what if you want to give players a ring that provides +1 Strength they can put on or take off at will, or a "weaken" status effect that decreases Strength for a given duration?

That is the main function of this class, defined in {{{stat class.js}}}.
{{{
constructor (base) {
    this._base = base;
    this._mods = {};
    this._current = undefined;
}
}}}
The constructor isn't too special; we just initialize some properties.
{{{
addMod (id, mod, equipment) {
	id = String(id);
	var mods = this._mods[id] = this._mods[id] || [];
	if(Number.isFinite(mod)) {
		mod = { add: mod };
		if (equipment === true) {
			mod.equipment = true;
		}
	}
	if(typeof mod === "object") {
		var idx = 0;
		mods.forEach(function(mod) { idx = Math.max(idx, mod.idx); });
		mod.idx = (++ idx);
		mods.push(mod);
		this.clearCache();
		return mod.idx;
	}
}
}}}
The {{{addMod}}} function is the main purpose of this class. The way it works is this: Every {{{Stat}}} has a {{{_mods}}} property that initializes as an empty object, <code>{}</code>. This empty object acts as a container for every modifier that acts on the stat. Every time you want to add something that modifies the stat, such as a piece of equipment, you pass a name ({{{id}}}), and {{{_mods}}} will gain a property with that name that contains the modifier data.

However, there's an additional wrinkle: What if you want multiple mods of the same type to stack, such as applying multiple copies of the same status effect, or wearing two Rings of +1 Strength at the same time? And object can't have multiple properties with the same name; attempting the second assignment will simply overwrite the existing property. To account for this, each mod's name points to an <i>array</i> of modifier objects, rather than just one modifier object. We initialize this through the following statement:
{{{
var mods = this._mods[id] = this._mods[id] || [];
}}}
In English, this says, "If {{{this._mods}}} already contains a property with the given {{{id}}}, copy it; if it does not, create a property with the given {{{id}}} and make it an empty array. Then, define a new variable {{{mods}}} and assign it to {{{this._mods}}}." Essentially, this statement is evaluated from right to left instead of left to right.

We then check if the passed {{{mod}}} is a finite number. If it is, we convert it into object form, attaching the passed value to an {{{add}}} attribute. We also check if the {{{equipment}}} argument has a value of {{{true}}}; if so, we mark the mod as an equipment-based modifier by adding an {{{equipment}}} attribute.

(We can bypass this code if we pass an object to the {{{mod}}} argument; this is useful if you want to create other, special properties for your mod. However, this functionality works for most purposes.)

After this processing, the finalized mod is added to the {{{mods}}} array. For accurate recall, every mod in the array needs a unique identifier, which we add through the {{{idx}}} variable and the following function:
{{{
mods.forEach(function(mod) { idx = Math.max(idx, mod.idx); });
mod.idx = (++ idx);
}}}
In English, this says: "For every mod in the mods array, compare the existing {{{idx}}} value to the mod's {{{idx}}} value, and set {{{idx}}} to whichever value is higher. Then, increment {{{idx}}} by 1 and assign it to the mod object we want to add to {{{mods}}}." This allows us to ensure that every mod has a unique {{{idx}}} value, and that they increment in logical order.

Because adding a mod obviously causes a change in the stat's modifiers, we next run {{{clearCache()}}}, which recalculates the stat's current value.

We end by returning the value of {{{idx}}}. This is useful for storing the specific mod's index to another variable so we can recall it for accurate removal later.

As an example of how this is used, here is the data for a status effect that does exactly what it sounds like, ATK Boost:
{{{
'ATK Boost': {
	"buff": true,
	"stackable": true,
	"statmod": true,
	"onApply": function (puppet) {
		this.id = puppet.stats.addMod("Attack","ATK Boost",this.power);
	},
	"onRemove": function (puppet) {
		puppet.stats.removeMod("Attack","ATK Boost",this.id);
	},
	"info": function (effect) {
		return `Attack boosted by ${this.power}.`;
	},
	"addText": function (target) {
		return `${target} is surging with strength!`;
	},
	"removeText": setup.effectFunctions.remBuff
}
}}}
When an ATK Boost is applied to a character, they gain a mod with the name "ATK Boost" that points to the array {{{[ {add: <power>, idx: 1} ]}}}, and the ATK Boost object gets the ID of the mod, {{{1}}}, assigned to its {{{id}}} property. This is a stackable effect, so if the character got a second ATK Boost, it would be added to the "ATK Boost" array, which would now look like this: {{{[ {add: <power>, idx: 1}, {add: <power>, idx: 2} ]}}}
{{{
removeMod (id, index) {
	id = String(id);
	if (Number.isFinite(index)) {
		this._mods[id].deleteWith(function(mod) { return (mod.idx === index); })
	} else {
		delete this._mods[id];
	}
	this.clearCache();
}
}}}
To remove a mod, we need only the mod's ID and, optionally, its index within the ID. If no index is passed, this function simply deletes all mods under the given ID, which is fine for non-stackable effects. If an index is passed, we instead delete only the mod with that index value, using SugarCube's {{{deleteWith}}} function.
{{{
get current () {
	if (this._current === undefined) {
		/* gather multipliers */
		var mult = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		/* gather sums */
		var add = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		this._current = this.base * (mult + 1) + add;
	}
		return this._current;
}
}}}
Here is where it all comes together. When you call for a stat's {{{current}}} property, you don't get {{{_current}}}; the stat is calculated based on the base value and all modifiers.

This definition has functionality for both multiplier and incrementor modifiers, and has a sub-section for each. They're both fundamentally similar, however.

Note that the following happens all at once. Don't let the line breaks fool you; if there's no semicolon, the code doesn't stop.
{{{
Object.values(this._mods)
}}}
{{{Object.values()}}} extracts the values of an object's properties and converts them into an array. This is useful because arrays have additional functions that make finding and extracting data easier. We use this to get a list of all the mods in {{{_mods}}} in array form, then:
{{{
.reduce(function(bigSum, entry) { return bigSum + entry
}}}
The {{{Array.reduce}}} function defines an accumulator value, and then uses it in a function it applies to every element in the array. This is most commonly used for quickly summing all the values in an array of numbers, and that's exactly what we want to do here, after a fashion. However, remember that every mod in {{{_mods}}} is an array of objects, not values, so we need to go deeper. We need to perform another function on each {{{entry}}}:
{{{
.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
}}}
The {{{Array.map}}} function returns an array that is the result of performing a function on every element in the array. In this case, we use it to extract a specific property from our modifier objects: if the objects have a finite {{{add}}} value (or {{{mult}}} value, if we're tracking multipliers), it's returned and placed into a new array.

So we now have an array of the numeric data of our modifiers. We can compress that into a single value with another...
{{{
.reduce(function(sum, add) { return sum + add; }, 0);
}}}
This one is very straightforward: we simply run through every value in the array and add them together.

Going back to our initial {{{reduce}}}, this sum is the value that will finally be returned after all the processing we've done on {{{entry}}}. It's then added to {{{bigSum}}}, and the process starts again for the next type of modifier. Once this is done, we'll have all our modifiers compiled into one final value.
{{{
this._current = this.base * (mult + 1) + add;
}}}
Then, at last, we can calculate what the current stat value should be. It's this value that's returned.

Notice this {{{if}}} statement at the start:
{{{
if (this._current === undefined)
}}}
All of this calculation only occurs if {{{_current}}} is {{{undefined}}}. This is very efficient, because it means the stat is only calculated when it needs to be. We only have to set {{{_current}}} to {{{undefined}}} when it needs to be recalculated, and can otherwise continue using the same value.
{{{
Map.prototype.addMod = function (key, id, mod, equipment, type) {
	if (type !== undefined && typeof(type) == 'string') {
		return this.get(key)[type].addMod(id,mod,equipment);
	} else {
		return this.get(key).addMod(id,mod,equipment);
	}
}

Map.prototype.removeMod = function (key, id, index, type) {
	if (type !== undefined && typeof(type) == 'string') {
		this.get(key)[type].removeMod(id, index);
	} else {
		this.get(key).removeMod(id, index);
	}
}
}}}
Finally, I created these two functions to make some things a little easier. Many {{{Stat}}}s, such as elemental affinities and tolerances, are stored in {{{Map}}} objects, and would therefore necessitate a lengthy {{{get}}} call to access for mod addition or removal. With these, you only have to pass the name of the entry you want to target, and the function will find it for you. (A wrinkle exists for stats with multiple properties, such as elemental affinities having both soak and resistance, so you can also pass the {{{type}}} you want to target, if necessary.)
{{{
setup.statInfo = {
	"Attack": "Increases damage of regular attacks.",
	"Defense": "Reduces damage taken.",
	"Special": "Improves effectiveness of status effects, mitigates received status ailments, and increases damage of item attacks."
}
}}}
Information on what each stat does is also defined in this file. This information is called as a tooltip in <a class="noExternal" href="#menus.status">the party menu</a>. I recommend defining these for any stats whose purpose is not immediately obvious, since the player needs to understand their basic toolset.

<h4 id="JS.stats.fill">The FillStat Class</h4>
Some stats can be "filled" and "depleted", with both a current and maximum value. This functionality is handled by the FillStat class, which is a subclass of the Stat class.
{{{
constructor (base) {
	super(base);
	this.currentVal = base;
}
}}}
The constructor is much the same, but it adds a new property, {{{currentVal}}}. Don't confuse this with the {{{current}}} value! Due to inheritance, we have to keep the name of the calculated stat value {{{current}}}, but this refers to the <i>maximum</i> stat value, not the current "points" in the pool.
{{{
clearCache () {
	this._current = undefined;
	this.refill();
}

refill () {
	this.currentVal = this.current;
}
}}}
The mechanics of {{{currentVal}}} necessitate a slight change to the way {{{_current}}} is updated. When {{{_current}}} (the maximum stat value) is changed, we need to update {{{currentVal}}} to match it. This is accomplished through the {{{refill}}} function, and by running it in {{{clearCache}}}. <b>Note that this assumes you will not be modifying max values in the middle of battle, or that if you are, you want them to be refreshed alongside the change. If you want something different, you'll need to code different functionality.</b>

<h4 id="JS.tolerances">Tolerance Class</h4>
Tolerances (status ailment resistances) have additional properties that necessitate their own specialized form of {{{FillStat}}}.
{{{
get current () {
	if (this._current === undefined) {
		// check for immunity
		let immunity = false;
		if (this.base >= 0) {
			Object.values(this._mods)	// returns array of arrays
				.forEach(function(modArray) {
					modArray.forEach(function(mod) { if (mod.immune === true) {immunity = true;} });
				});
		} else {
			immunity = true;
		}
		if (immunity === true) {
			this._current = -1;
		} else {
			// gather tolerance
			var tol = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			this._current = this.base + tol;
		}
	}
		return this._current;
}
}}}
The only change comes in the getter for {{{current}}}. In addition to partial resistance, it is possible for a tolerance to grant complete immunity to an ailment, and this has to be handled differently than in the normal {{{current}}} calculation.
{{{
if (this.base >= 0)
}}}
Obviously, if mods provide an immunity, calculating the resistance value is moot. This means we should check for immunity first. Immunity is conveyed through a negative tolerance value, so we can check if the base tolerance already provides it with this {{{if}}} statement. If the {{{base}}} is less than 0, we know the character is already immune, so we can skip the rest of this function; but if it's not, we need to check for immunity from mods.
{{{
Object.values(this._mods)
	.forEach(function(modArray) {
		modArray.forEach(function(mod) { if (mod.immune === true) {immunity = true;} });
	});
}}}
The immunity check works differently from the other calculations. Instead of a total value, we only care about a binary state: is there an immunity or not? We therefore only need a regular {{{forEach}}} function to run through and test all the mods. If we find a mod with an {{{immune}}} property of {{{true}}}, we set the previously-defined {{{immunity}}} variable to {{{true}}} to record that we found an immunity.

If we found an immunity, we can set {{{_current}}} to -1 (a negative value, so it will be read as an immunity) and end the calculation. If we didn't, we gather tolerance values using the normal {{{Stat}}} code.

<h3 id="JS.puppets">Puppet Class</h3>
This file defines the statistics of the player characters. They're called "puppets" as a holdover from <i>Cartoon Battle</i>, but you can change the name if you like.
{{{
class Puppet extends Actor
}}}
To begin with, we say that the {{{Puppet}}} class <i>extends</i> {{{Actor}}}. This makes {{{Puppet}}} a <i>subclass</i> of the {{{Actor}}} class. It will inherit all of {{{Actor}}}'s object methods, and will count as an instance of {{{Actor}}} for data check purposes. We can still use {{{.get}}} with it, for instance. This is handy because it allows us to define unique attributes of puppets we don't want for enemies, while still maintaining access to all the useful attributes and methods defined in {{{Actor}}}.

Subclasses are constructed a little differently: they still have a {{{constructor}}} function, but it must use the parent class's constructor before it can make its own unique modifications. This is done through the keyword {{{super}}}. This can be thought of as us constructing an instance of the parent class and then modifying it with unique subclass features.
{{{
this.lastAction = null;
this.maxen = 10;
this.en = 5;
this.inspired = false;
this.defeats = 0;
this.kills = 0;
}}}
By default, that's these features: Energy values, the <code>inspired</code> flag, <code>kills</code> and <code>defeats</code> counters, and the <code>lastAction</code> property, which is initialized to a blank <code>null</code>. You can change this section if, for instance, you want unique Energy stats for every character.
{{{
for (let n of this.data.actions) {
	this.actions.push(new Action(n));
}
this.defaultAction = new Action(this.data.defaultAction);
if (this.data.specialInit) { this.data.specialInit(this); }
}}}
For specific data unique to the character, we make calls to the database. Recall that most statistics, such as HP and core stats, are already handled by the <code>Actor</code> constructor. By defult, the subclass' constructor adds the character's actions and default action, with any miscellaneous modifications run through the <code>specialInit</code> function (assuming it exists).

You can also define unique method functions here if you need them. By default, there's a getter and setter for the {{{en}}} property that, like the HP setter, is designed to keep it within bounds, and some functions for calculating XP requirements.

<h3 id="JS.enemies">Enemy Class</h3>
Enemies are constructed similarly to puppets, with of course the major change that their {{{actions}}} property functions completely differently, as explained in [[Documentation (Basic)]]. However, their constructor has a few unique statements:
{{{
if (this.data.cooldown) { this.cd = new Map(Object.entries(this.data.cooldown)); }
}}}
You may recall that some enemies had a {{{cooldown}}} attribute in their entry. This statement extracts those values and assigns them to a Map, just as with elements and tolerances. This {{{cd}}} Map (short for "cooldown") can then be checked with the {{{CDcheck}}} function.
{{{
this._noAttacks = Number.isInteger(this.data.noAttacks) && this.data.noAttacks > 0
	? new FillStat(this.data.noAttacks)
	: new FillStat(1);
}}}
Enemies also have a special handler for their {{{noAttacks}}} attribute. If the {{{noAttacks}}} property of their database entry is a positive integer, the constructor creates a {{{FillStat}}} equal to that number; otherwise, their {{{noAttacks}}} defaults to 1.
{{{
get noAttacks () {
	return this._noAttacks.currentVal;
}

set noAttacks (amt) {
	this._noAttacks.currentVal = amt;
}
}}}
This property assignment requires an underscore because the getters and setters for the enemy's {{{noAttacks}}} property point to the {{{FillStat}}}'s {{{currentVal}}} property, rather than the {{{FillStat}}} itself.
{{{
if (setup.THREAT_TARGETING === true) {
	this.threat = new Map();
	puppets().forEach(function(puppet) {
		this.threat.set(puppet.name,puppet.initialThreat());
	}, this);
}
}}}
If your game uses threat targeting, enemies also generate a threat table with a value keyed to every puppet.
{{{
changeInto (name) {
	if (setup.enemyData[name].hp) {
		this.setMaxHP(setup.enemyData[name].hp);
	}
	if (setup.enemyData[name].stats) {
		for (let [pn,v] of Object.entries(setup.enemyData[name].stats)) {
			this.setBase(pn,v);
		}
	}
	if (setup.enemyData[name].actions) {
		this._actions = setup.enemyData[name].actions;
	}

	if (setup.enemyData[name].special) {
		setup.enemyData[name].special(this);
	}
}
}}}
Finally, there is the {{{changeInto}}} function. This is a quick way of modifying enemies, such as if they transform into another form with different stats or actions. You could define these alternate forms as entirely separate enemies and generate the new form with a constructor call, but that would overwrite all the enemy's current attributes, such as their active effects. {{{changeInto}}} allows the enemy to retain all attributes you do not change. The entries specified by the {{{name}}} argument are also entries in the database, as you can see in the entry for Big Dipper:
{{{
"Big Dipper": {
	"special": function (actor) {
		actor.idname = "Dipper";
		actor.name = "Big Dipper";
	},
	"actions": function () {
	(...)
	}
}
}}}
Note the {{{idname}}} property here. You may recall from <a class="noExternal" href="#JS.actor">the Actor class</a> that this is used when fetching data from the database. The issue here is that but Big Dipper isn't a complete entry, as it's only intended to modify the base Dipper and I otherwise want to keep using the data from that entry -- but I do want the new name "Big Dipper" to display in battle, even though that will make the object point to this entry in the database. The solution is to make a new variable whose <i>only</i> function is to serve as a pointer for the database entry. Now, the enemy the player sees can have the official name of "Big Dipper", while still pointing to "Dipper" if it needs something that's not listed in "Big Dipper".

We also define several other method functions for enemies.
* {{{decCD}}} is a quick way of decrementing cooldowns at the start of every turn.
* {{{CDcheck}}} is a quick way of determining if a cooldown action is available. It returns {{{true}}} if the cooldown is less than 0 and {{{false}}} otherwise.
* {{{surrenderCheck}}} checks if an action violates an enemy's surrender by checking against the action's {{{truce}}} property. Note that, by default, this includes actions that don't affect the enemy at all; they are smart enough to understand that the only reason you'd be casting a buff is if you plan to attack them. You can change this logic if you want.
{{{
get priority () {
	if (this._priority === undefined) {
		return V().enemies.indexOf(this);
	} else {
		return this._priority;
	}
}
}}}
As a final note, here is the getter for the {{{priority}}} attribute. This determines what order enemies act in during the enemy turn. To set a unique priority value, you will need to assign a value to {{{_priority}}}; otherwise, the enemies default to acting in index order.

<h3 id="JS.actions">Action Class</h3>
This class defines actions that characters use in battle. It should be quite straightforward, as unlike battling characters, action properties are almost always invariant and require little processing in the constructor or object itself. For more on how action properties are used, see <a class="noExternal" href="#actionphase">the Action Phase</a>.

There is also a subclass, {{{ItemAction}}}, that is used for consumable items. It functions in much the same way, but has a few different default values.

You may also want to look at the file {{{2_action functions.js}}}. This file contains several functions used to define common action code, such as adding an effect or dealing damage. This makes it easier to define actions. You can see it used in this example in the "act" property of the "Sword" entry: it was assigned the {{{justdmg}}} function, which, as the name implies, just does damage and nothing else. Corresponding preview code is stored under the {{{Prev}}} object as well. These are designed to be modular, and can be passed an {{{extension}}} argument to add additional functionality.

<h3 id="JS.items">Inventory and Items</h3>
{{{
window.inv = function inv () {return V().inv;}
}}}
When working with items, the very first thing we want to do is define our inventory. We need an inventory to put items in, right? A lot of code references the inventory, so we need a standardized way to refer to it. That's this: the {{{inv()}}} function returns whatever your actual inventory variable is. By default, it's a story variable, but you could rename it or tie it to specific characters.
{{{
class Inventory extends Map {
	constructor(ItemArray){
		var m = [];
		ItemArray.forEach(function(item){
			m.push([item.name,item]);
		});
		super(m);
	}

	addItem (name,amt) {
		if (amt === undefined){
			amt = 1;
		}
		if (this.has(name)){
			if (this.get(name).stock + amt > setup.ITEM_MAX) {
				let s = 1;
				while (((this.get(name).stock + 1) < setup.ITEM_MAX) && s < amt) {
					this.get(name).stock += 1;
					s++;
				}
				return false;
			} else {
				this.get(name).stock += amt;
				return true;
			}
		} else {
			this.set(name,new Item(name,amt));
			return true;
		}
	}

	decItem (name,amt) {
		if (this.has(name)){
			if (amt === undefined){
				amt = 1;
			}
			var v = this.get(name);
			v.stock -= amt;
			if (v.stock <= 0){
				this.delete(name);
			}
			return;
		} else {
			return "ERROR in decItem: item name not found in inventory\n";
		}
	}
}
}}}
Then, we should probably define what functionality we want our "inventory" to have. The {{{Inventory}}} class extends the {{{Map}}} object, meaning it functions the same way: if you need to reference an item, you can just call up its name. However, we've also added some method functions, and modified the constructor.
{{{
constructor(ItemArray){
	var m = [];
	ItemArray.forEach(function(item){
		m.push([item.name,item]);
	});
	super(m);
}
}}}
Instead of how you would normally construct a {{{Map}}} (an array of key/value pairs), you can construct an {{{Inventory}}} with just an array of items. The constructor will automatically extract the {{{name}}} attribute from the item and turn it into the key for that entry.
{{{
addItem (name,amt) {
	if (amt === undefined){
		amt = 1;
	}
	if (this.has(name)){
		if (this.get(name).stock + amt > setup.ITEM_MAX) {
			let s = 1;
			while (((this.get(name).stock + 1) < setup.ITEM_MAX) && s < amt) {
				this.get(name).stock += 1;
				s++;
			}
			return false;
		} else {
			this.get(name).stock += amt;
			return true;
		}
	} else {
		this.set(name,new Item(name,amt));
		return true;
	}
}
}}}
We also require special functionality for adding an item to the inventory. We run into the issue that if an item already exists in the {{{Inventory}}}, we only want to add to its {{{stock}}} value rather than creating a whole separate key. That's what this function checks for: if the {{{Inventory}}} already has the given item, it just increases the {{{stock}}} of that item, and if it doesn't, it makes a new entry with a {{{set}}} command.

We also include a check against {{{ITEM_MAX}}}. If adding the item to the inventory would exceed the item cap, we'll run a loop up to the value of {{{amt}}} and increment the item's stock by 1 each time until we reach the cap. This will allow the player to take as much as they can carry if they get a huge windfall of items, instead of getting nothing. The function will also return {{{false}}}, allowing your code to know that the player couldn't store all of the treasure. <b>Note that there's no corresponding code to automatically decrement the "stock" of a partially obtained treasure. For now, you will have to keep track of that manually.</b>

(This assumes you want your inventory to function in this way, with items being "stackable". Some games don't allow this, and make every item appear as its own instance in the inventory. If you want this kind of behavior, you could base {{{Inventory}}} on an {{{Array}}} instead, but be warned that it will be very hard to refer to an item after it's been added.)

There is a corresponding function, {{{decItem}}}, that operates similarly: it decreases {{{stock}}}, and deletes the item from the {{{Inventory}}} if there's none left. You can change this if you do want items to still appear even at 0 stock.

(If you ever want to completely clear an item, you can use {{{Map}}}'s {{{.delete}}} function directly.)

Items themselves are constructed exactly like <a class="noExternal" href="#JS.actions>actions</a>: the class definition itself only defines getter functions to fetch data from a database, and the actual details of the items are defined in the {{{itemData}}} object.

<h3 id="JS.support">Support Functions</h3>
There are several other useful functions storied in {{{1_support-functions.js}}} designed to make some common tasks easier.
{{{
window.target = function target () {return State.variables.B === undefined ? null : State.variables.B.target;};
window.subject = function subject () {return State.variables.B === undefined ? null : State.variables.B.subject;};
window.action = function action () {return State.variables.action;};
}}}
A big draw are these functions, which allow us to more conveniently access the active target, subject, and action in battle. You'll be seeing these a lot. (However, be aware that <b>you cannot use a function to call a variable for assignment.</b> For example, you cannot say {{{target() = Object}}}. You must say {{{V().B.target = Object}}}.)
{{{
Map.prototype.inc = function (key,amt) {
	this.set(key,this.get(key)+amt);
	return;
}
}}}
This is a simple function added to the {{{Map}}} prototype, which means that all {{{Map}}}s we use will have access to it. This is a relative setter that <i>adds</i> the passed value to to the value in the {{{Map}}}, as opposed to an absolute setter like the default {{{Map.set}}} function.
{{{
window.deadCount = function deadCount () {
	let count = 0;
	puppets().forEach(function(puppet) {
		if (puppet.dead) {
			count++;
		}
	});
	return count;
}
}}}
We have a function for quickly representing the number of defeated characters. This is useful when calculating <a class="noExternal" href="#victorycheck">victory and defeat conditions</a>.
{{{
window.puppets = function puppets () {
	return V().puppets.filter(function(p) { return p !== null });
}

window.enemies = function enemies () {
	return V().enemies.filter(function(p) { return p !== null });
}
}}}
These functions return party arrays with all {{{null}}} entries removed. This is helpful if you want to use the battle grid.
{{{
setup.textWidth = function(text, bold, size) {
    /* create the <span> to measure the text width */
	if (bold === undefined) {
		bold = "normal";
	}
	else if (bold === true) {
		bold = "bold";
	}
	if (size === undefined || typeof(size) != 'number') {
		size = "12pt";
	} else {
		size = Number.toString(size) + "px";
	}
    var tElement = jQuery(`<span style="font-weight: ${bold}">` + String(text) + "</span>");
    /* add it (hidden) to the end of the document's body so that
       the browser updates its width and we can save it */
    tElement.hide().appendTo(document.body);
    var width = tElement.width();
    /* clean up */
    tElement.remove();
    return width;
};

setup.scaledTextDiv = function(text, width, bold, size, print) {
    var tWidth = setup.textWidth(text, bold, size);
	if (print !== undefined) {
		text = print;
	}
    if (temporary().enemy !== undefined && temporary().enemy.large) {
		return `<div>${text}</div>`;
	} else if(tWidth < width) {
        return `<div style="width: ${width}px; overflow: hidden;"><span style="display: inline-block; white-space: nowrap;">${text}</span></div>`;
    } else {
        return `<div style="width: ${width}px; overflow: hidden;"><span style="display: inline-block; white-space: nowrap; transform: translate(-50%, 0) scaleX(${width / tWidth}) translate(50%, 0);">${text}</span></div>`;
    }
};
}}}
These functions allow you to scale text to fit it within a certain width; the text will be compressed instead of overflowing or breaking its container. This is useful if you have variable elements displaying inside a container that must have a fixed width, such as the actor boxes. Though the code here is complicated, the function is simple to use: Simply pass the text you want to scale, the maximum width you wish to allow, whether or not the text is bold, its font size (in pt), and what you want the text to finally display if that's different than the original. (This is useful for, say, making links or other macros containing text we want scaled -- you can pass the text as the {{{text}}} argument and the macro as the {{{print}}} argument, and it will work.)
{{{
(function(window){
  // A full compatability script from MDN:
  var supportPageOffset = window.pageXOffset !== undefined;
  var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");

  // Set up some variables
  var statusbar;
  var noHorizontal;
  var noVertical;
  // Add an event to the window.onscroll event
  window.addEventListener("scroll", function(e) {

	statusbar = document.getElementById("status");
	noHorizontal = document.getElementById("noHorizontal");
	noVertical = document.getElementById("noVertical");

	// A full compatability script from MDN for gathering the x and y values of scroll:
	var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
	var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

	if (noHorizontal) {
		noHorizontal.style.left = -x + 1250 + "px";
	}
	if (statusbar) {
		statusbar.style.left = -x + 1020 + "px";
	}
	if (noVertical) {
		noVertical.style.top = -y + 50 + "px";
	}
  });
})(window);
}}}
This function is designed to allow the status pane to scroll with the user's viewport. Currently, the offset numbers used in this function do not automatically scale to the width of the status or battle panes, and must be tweaked manually. Don't change them or the attributes of the {{{#status}}} element unless you know what you're doing.

{{{getActor}}} is discussed with <a class="noExternal" href="#chain">the {{{<<chain>>}}} widget</a>.

{{{reverseChildren}}} and {{{guardCheck}}} are discussed with [[the Battle Grid|Additional Features]].

<h3 id="JS.serial">Serialization and Save Files</h3>
If you look at the end JS files, you may notice that every class has a variation on these two functions at the end:
{{{
<Object>.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new <Object>(this);
};

<Object>.prototype.toJSON = function () {
	// Return a code string that will create a new instance
	// containing our current data.
	const data = {};
    Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
    return JSON.reviveWrapper('new <Object>($ReviveData$)', data);
};
}}}
You may also notice that several classes have an odd addition to their constructors:
{{{
if (typeof(<1st argument>) == 'object'){
	Object.keys(<1st argument>).forEach(prop => this[prop] = clone(<1st argument>[prop]));
}
}}}
These features are necessary to make custom classes work with Twine's save/load feature. Essentially, every time a save is loaded, the game must generate a completely new instance of every object via its constructor. The {{{toJSON()}}} function, which in turn depends on the {{{clone()}}} function, tells the program how to do this.

It would be a huge hassle to need to pass every single one of an object's properties to its constructor, so we can simplify things by instead passing it an object and assigning its properties to the new object. If this passed object is a clone of the old one, the new object will be reconstructed perfectly. However, we still want a "normal" constructor for constructing completely new objects. To accomplish both functionalities, we add {{{if (typeof(<1st argument>) == 'object')}}} to the start of the constructor, to branch its functionality. This tells the program that if we pass an object to the constructor instead of a normal variable, it should copy over that object's properties instead of going through the normal construction.

This is accomplished through {{{Object.keys(<1st argument>).forEach(prop => this[prop] = clone(<1st argument>[prop]))}}}. In English, this says, "Assemble a list of every property name in the object passed as the 1st argument; then, for every one of those properties, clone the property in the passed argument and assign it to a property of the same name in this new object we're creating." Or, alternatively, "Make this object a clone of the 1st argument." The only trick is that we need to do the exact same thing in the {{{toJSON()}}} function to create an object to pass to the revival method, because just passing the existing object ({{{this}}}) to {{{reviveWrapper()}}} will create an error.

(If our custom object doesn't reference any custom objects itself, we can use the shorter {{{Object.assign(this,<1st argument>)}}}. However, this method ensures all properties are cloned correctly too, so it is best to use it just to be safe.)

<b>Warning:</b> Arrays return 'object' when passed to {{{typeof()}}}. If you want your normal constructor to read an array, you will need to use {{{instanceof Array}}} instead.

<h3 id="JS.updates">What if we want to update something in a new version?</h3>
Let's say one of your beta testers discovers an action or item is incredibly gamebreaking. Not a problem, you say, you'll just tweak some values in the database and all new games will use those values instead. But wait! People who are already playing the game and have the old version saved will still have the old values! How can you ensure they get updated too?

The structure of the database actually means this won't be a problem. We tie action, effect, and item data to the {{{setup}}} variable, which exists independently of save game states. It is specifically designed for exactly this scenario -- any changes to {{{setup}}} will be reflected in existing saves, no additional modification necessary. You should use {{{setup}}} for any variables you intend to remain constant throughout a playthrough.

But what if you need to change something that isn't part of {{{setup}}}? Let's say you realize you made a typo in a variable adjustment when writing the consequences for a certain choice the player can make during the course of the game. Well, don't worry, you can fix that too.
{{{
Config.saves.onLoad = function (save) {
	switch (save.version){
			// You would make a case for older version numbers, and adjust variables as necessary. If you've made variable changes since that would cause conflicts with the save, you can update them here.
		case 0:
			/*
			save.version++;
			save.state.history.forEach(function (moment) {
				//Access story variables through moment.variables
			});
			*/
		default:
			// all is (hopefully) well, do nothing
	}
};
}}}
In the {{{0_config.js}}} file, you will see this. {{{onLoad}}} is a function built into SugarCube that is called before loading any save, and is particularly useful for updating saves to current versions. The save game version (which you can set with {{{Config.saves.version}}}) is placed into a {{{switch}}} statement here, allowing you to run unique code depending on the version. You'll want to increment the save version in each case so you don't keep running the same code every time you load a save in your current version. (Note that this is distinct from the official version number you would display in the game itself; you only need to update the save version when you need to make another case for {{{onLoad}}}.)

There is one trick involved here. See, you can't access the variables in a save through the normal {{{variables()}}} and {{{temporary()}}} functions, because those only refer to the <i>existing</i> story state. To modify a save, you have to call the variables in each {{{moment}}} of its {{{history}}} attribute. This code has already written out how to do that for you: Run a {{{forEach}}} loop over the save's {{{history}}}, and then modify the {{{variables}}} of each {{{moment}}} in the {{{history}}}. It may sound complicated, but other than that wrapper, you can access and modify variables the same way you would otherwise.

I recommend copying this code to a new case every time you make an update function so you don't forget it.

<h2 id="display">Display and aesthetics</h2>
[img[setup.ImagePath + "documentation/002.PNG"]]

Visual display -- the color and placement of the text, the borders around blocks, and the positioning of elements -- is determined by the <b>story stylesheet</b>, which can be accessed by clicking on the story title in the editor. This stylesheet uses a different coding language than Twine's script: CSS, or <b>Cascading Style Sheets</b>.

By default, the content width is optimized for three-character parties, so you may want to extend it if you are looking for larger party sizes. With more advanced CSS elements, such as a grid, you could even incorporate features like a battle map where characters can move in two-dimensional space.

If you didn't understand any of that, don't worry! You don't need to know CSS to use the engine, just if you want to make it look different.

<h3 id="statusdisplay">Displaying the status pane</h3>
{{{
<span id="status">
<<include status>>
</span>

<span id="content">
<span id="actorlist">
<<include "actorlist">>
</span>
<div id="phase">

</div>
</span>
}}}
This is the body code for the "Battle!" passage. We'll get more into the rest later, but for now, just notice that the status pane is in a separate {{{<span>}}} from everything else. This is necessary to get it to display in its proper spot, directly to the right of the battle content. The stylesheet code responsible for the correct display can be seen here:
{{{
.passage.battle {
  width: 1030px;
}

#content {
	float: left;
	width: 640px;
	border: dotted 1px;
	padding: 1em;
}

#status {
	float: right;
	width: 300px;
	min-height: 300px;
	padding: 1em;
	border-left: 1px solid;
	font-weight: bold;
}
}}}
The key component here is that <b>the passage itself</b> is set to be wider than the {{{#content}}} and {{{#status}}} widths together. If you don't do this, the two sections will crash into each other and display on separate lines, like so:

[img[setup.ImagePath + "documentation/003.PNG"]]

Note, however, that this width is only fixed in passages tagged "battle". In all other passages, the passage width will scale to fit the resolution of the screen. This makes things easier for smaller monitors, but you'll need to make sure to tag any passage where you want to the status pane to display.

You can tweak the widths in the stylesheet depending on your preferences.

<h3 id="nobr">The nobr tag</h3>
[img[setup.ImagePath + "documentation/004.PNG"]]

You may notice a gray {{{nobr}}} tag at the top of several passages. <b>These are really important for preventing unwanted whitespace.</b> Twine parses all line breaks by default, even when you only use them to organize code. To make your code readable without creating tons of empty lines in the process, you'll need to use {{{nobr}}}. The downside to this is that when you <i>do</i> want a line break, you will need to add it manually with the {{{<br/>}}} tag.

<h3 id="pronouns">Personalized text</h3>
[img[setup.ImagePath + "documentation/005.PNG"]]

So English has these annoying things called "gendered pronouns". As you can see in the above example from an earlier version of the engine, they make natural-sounding system text a little tricky.

I tried to sidestep this issue by avoiding pronouns entirely in system messages, but eventually gave up and defaulted to the gender-neutral "they". This is great for <i>Cartoon Battle</i>'s genderless puppets, but sounds awkward when applied to other characters; not to mention you may want to have characters go up against animals or monsters, for whom "it" pronouns may be more appropriate.
{{{
getPronouns (type) {
	if (typeof(type) == 'string') {
		var pr;
		switch(this.gender.toLowerCase()) {
			case 'f':
			case 'female':
				pr = {obj: "her", subj: "she", pos: "her"};
				break;
			case 'm':
			case 'male':
				pr = {obj: "him", subj: "he", pos: "his"};
				break;
			case 'n':
			case 'neuter':
			case 'neutral':
			case 'agender':
				pr = {obj: "them", subj: "they", pos: "their"};
				break;
			default:
				pr = {obj: "it", subj: "it", pos: "its"};
		}
		var result = pr[type];
		if (result === undefined) { console.log("ERROR in getPronouns: invalid pronoun type"); }
		return result;
	}
	else {
		console.log("ERROR in getPronouns: no pronoun type passed");
		return undefined;
	}
}

get them () {
	return this.getPronouns("obj");
}

get they () {
	return this.getPronouns("subj");
}

get their () {
	return this.getPronouns("pos");
}

get theyare () {
	switch (this.they) {
		case "they":
			return "they are";
		default:
			return (this.they + " is");
	}
}
}}}
To solve this, I made gender an accessible attribute of characters, and getter functions for determining each type of pronoun.

Twine will automatically print naked variables, so to use them you can just place them in text like this: {{{_subject.name swings _subject.their sword!}}} That will evaluate to "Ros swings their sword!" if {{{_subject}}}'s pronouns are set to neutral, or "Monster swings its sword!" if {{{_subject}}}'s pronouns are default, and so on.

<h3 id="healthbars">Health Bar Formatting</h3>
Battling characters have health bars, provided by <a href="https://twinelab.net/custom-macros-for-sugarcube-2/#/meter-macros" target="_blank">Chapel's meter macro set.</a> You can define the color of the enemy and player bars in StoryInit; by default, they are set to red and green, respectively. If you want to edit the meter's appearance further, you can find the macro in {{{bundle.js}}}, the source code for all of Chapel's custom macros. Find this section:
{{{
var $wrapper = $(document.createElement('div'))
    .addClass('chapel-meter')
    .attr({
        'data-val' : value,
        'data-label' : this.settings.label
    })
    .css({
        'position' : 'relative',
        'background-color' : this.settings.back,
        'height' : this.settings.height,
        'width' : this.settings.width,
        'overflow' : 'hidden',
		'border-radius' : '3px'
    });
}}}
You can edit the {{{.css}}} attribute here to add any CSS formatting you wish to the meter. Just understand that the attribute names and values must both be strings (so, in quotes). Here, you can see that I have added a {{{border-radius}}} attribute to the default formatting, which is what gives the meters their rounded look. If you prefer them more angular, you can remove that attribute.

<h3 id="battlestyle">Special Aesthetics for Battles</h3>
There may be instances where you want certain battles to look different. Maybe the player is fighting a scary enemy in a dark room, and you find that the engine's default bright white background undercuts the atmosphere.

There is functionality for this in the "Preparation" passage, called before all battles:
{{{
<<callEncounter $scenario>>
<<if typeof($B.style) == 'string'>>
	<<addclass "html" $B.style>>
<</if>>
}}}
If you set the {{{style}}} property in the encounter call or anywhere else, the code will add that class to the story document. You can add whatever formatting you want to this class or others in the stylesheet files. In the default engine, the "dark" class has the following format:
{{{
html.dark body
{
  background-color:#111;
  color:#fff;
}
}}}
This is the default SugarCube style: white text on a dark gray background.

<b>NOTE:</b> Modifying the document in this way affects the entire story, not just the current passage. This is <b>good</b> for our purposes, because the battle engine actually consists of multiple passages. This way, we don't need to worry about the custom formatting disappearing on passage jumps. <b>However,</b> you will need to undo this change if you don't want the story to keep looking like the custom format for the rest of the game. This is handled through the {{{<<endofbattle>>}}} widget:
{{{
<<if $B.style>>
	<<addclass "body" $B.style>>
	<<removeclass "html" $B.style>>
<</if>>
}}}
(Why add the class to the {{{body}}} element first? Because otherwise, there will be a "flicker" of default formatting in the victory passage before the player is forwarded to the next passage. Unlike {{{html}}}, the {{{body}}} element is refreshed between passages, so this still removes the styling while ensuring a smoother transition.)

<h3 id="savesmodifier">Modifying the Save Display</h3>
[img[setup.ImagePath + "documentation/default_save.PNG"]]
By default, SugarCube uses a passage excerpt to describe a save in the save menu. This is useful for most text adventure games, where there is little else to worry about other than the player's position in the story.
<<nobr>>
<center>
<figure>
	<img @src="setup.ImagePath+'documentation/sojourner_save.PNG'" />
	<figcaption>
	<span style="font-size:10pt">(Screenshot from <i>Sojourner</i>, taken by myself)</span>
	</figcaption>
</figure>
</center><</nobr>>In an RPG, there are potentially many more variables that are relevant to the player, beyond just the current location or chapter in the story. This screenshot (from an RPG Maker VX Ace game) is an extreme example, with a very large save screen that contains a lot of information. Some of this information you may consider extraneous, but the party level, composition, and finances are likely relevant when remembering which save to choose.
[img[setup.ImagePath + "documentation/custom_save.PNG"]]
I think you will agree that this save file is a lot more informative than the default, even if it isn't as huge as RPG Maker's! By default, Another RPG Engine's custom save display shows the major area (set through the {{{currentArea}}} story variable), the party's GP, and the current party composition and the levels of each.

How is this constructed, and what must you do if you wish to add, subtract, or modify information for your own game? Well, it turns out that's a bit tricky. The description of a save file object can't be modified through SugarCube directly. We have to devise a workaround using JavaScript.
{{{
(function() {
	// Add metadata to saves.
	Config.saves.onSave = function (save) {
		var active = save.state.history[save.state.index];
		save.metadata = {
			area	: active.variables.currentArea,
			party	: active.variables.puppets.filter(function (p) { return p !== null; }),
			money	: active.variables.currency
		};
	};

	// Create save description from metadata.
	function createSaveDescription(metadata) {
		var desc = `<div class="save-desc monospace"><div class="save-left">`;

		if (metadata.area !== undefined) { desc += `<span class="save-area">${metadata.area}</span>`; }
		if (metadata.money !== undefined) { desc += `<span class="save-money">${setup.CURRENCY_NAME}: ${metadata.money}</span>`; }
		desc += `</div>`;
		if (metadata.party !== undefined) {
			desc += `<span class="save-party" style="min-width:${setup.PORTRAIT_SIZE*setup.PARTY_SIZE}px;">`;
			metadata.party.forEach(function(puppet) {
				desc += `<div style="display:inline-flex; flex-direction:column;"><span class="save-puppet" style="width:${setup.PORTRAIT_SIZE}px; height:${setup.PORTRAIT_SIZE}px;">`;
				if (setup.SHOW_PORTRAITS === true && puppet.portrait !== undefined) {
					desc += `<img src="${puppet.portrait}" />`;
				} else {
					desc += `${puppet.portrait}`;
				}
				desc += `</span>LV ${puppet.level}</div>`;
			});
			desc += '</span>';
		}

		return desc+`</div>`;
	}

	// Modify native Save dialog descriptions upon opening the dialog.
	if (true) {
		$(document).on(':dialogopening', function () {
			if ($('#ui-dialog-body').hasClass('saves')) {
				$('#ui-dialog-body.saves tr').each(function (_, el) {
					var $tr = $(el);
					var $load = $tr.find('button.load:not([disabled])');

					if ($load.length === 0) {
						return;
					}

					var slot = $load.attr('id').split('-')[2];
					var save = slot === 'auto'
						? Save.autosave.get()
						: Save.slots.get(Number(slot));

					if (save !== null && typeof(save.metadata) == 'object') {
						$tr.find('td>div:first-child')
							.empty()
							.append(createSaveDescription(save.metadata));
					}
				});
				// Refresh the custom display when deleting saves
				$('#ui-dialog-body.saves button.delete').on('click', function () {
					$(document).trigger(':dialogopening');
				});
			}
		});
	}
})();
}}}
That is the purpose of this function, found in {{{saves-modifier.js}}} and authored by TheMadExile. There are three components here, but we will only cover the first two. (The third function, in a nutshell, alters the content of the HTML element holding the save description when the save menu is opened. You shouldn't need to touch it unless you really know what you're doing.)
{{{
Config.saves.onSave = function (save) {
	var active = save.state.history[save.state.index];
	save.metadata = {
		area	: active.variables.currentArea,
		party	: active.variables.puppets.filter(function (p) { return p !== null; }),
		money	: active.variables.currency
	};
};
}}}
The first thing we need to do is record the data we want to use in our display. Fortunately, SugarCube saves have a property just for this kind of thing, called {{{metadata}}}. This function extracts the variables from the currently active moment of the story (so, the most current passage) and allows us to store them however we wish as properties of {{{metadata}}} when a save is made. By default, we store information for the area, the active party, and the player's money.
{{{
function createSaveDescription(metadata) {
	var desc = `<div class="save-desc monospace"><div class="save-left">`;

	if (metadata.area !== undefined) { desc += `<span class="save-area">${metadata.area}</span>`; }
	if (metadata.money !== undefined) { desc += `<span class="save-money">${setup.CURRENCY_NAME}: ${metadata.money}</span>`; }
	desc += `</div>`;
	if (metadata.party !== undefined) {
		desc += `<span class="save-party" style="min-width:${setup.PORTRAIT_SIZE*setup.PARTY_SIZE}px;">`;
		metadata.party.forEach(function(puppet) {
			desc += `<div style="display:inline-flex; flex-direction:column;"><span class="save-puppet" style="width:${setup.PORTRAIT_SIZE}px; height:${setup.PORTRAIT_SIZE}px;">`;
			if (setup.SHOW_PORTRAITS === true && puppet.portrait !== undefined) {
				desc += `<img src="${puppet.portrait}" />`;
			} else {
				desc += `${puppet.portrait}`;
			}
			desc += `</span>LV ${puppet.level}</div>`;
		});
		desc += '</span>';
	}

	return desc+`</div>`;
}
}}}
{{{createSaveDescription}}} is where we construct the custom description itself, based on the metadata from the save. You <i>could</i> just plunk all the data in raw, but that wouldn't look very nice. We use HTML elements to construct the description piece by piece, and then return the full HTML code when we're done.

You can see the CSS used to make the save display presentable in {{{saves desc.css}}}. Some of it's pretty complicated, so don't mess with it unless you know what you're doing! In particular, the default party display looks ugly because the default characters don't have portraits or other associated art <del>because I can't draw</del>. You should probably use portraits or other representative images for your party members; this is better than using their names, because with images, you can ensure a consistent size that won't break the display. (By default, the space provided for each character is 50 pixels square; you can change this through the {{{PORTRAIT_SIZE}}} variable in StoryInit.) You may also want to set the caps on currency and level with care, as there is currently no handler for overflow if the numbers get too large and exceed their expected dimensions.

<h3 id="animationsDoc">Animations</h3>
[img[setup.ImagePath + "documentation/AnimExample.gif"]]
Animations give a sense of life to the otherwise still world of a text-based video game. They're a great way to make your game more exciting and engaging. In this section, you'll learn how they're implemented in this engine, and how you can customize your own animations.

<h4 id="animations.design">Designing the Animations</h4>
The animations are coded through CSS. In addition to letting you customize the properties of HTML elements, CSS can also change properties dynamically with animations. The animations used in the default engine are modified from animations provided by <a href="https://animate.style/" target="_blank">animate.css</a>, a free set of excellent CSS animations. The complete set of animations is included in the {{{stylesheets}}} folder, with the modified animations in {{{custom animations.css}}}. (Redefining the same animation name with different properties will overwrite it, provided the version you want in the final product comes last in compilation order.) In particular, I used modified forms of the "headShake", "slideOutUp", and "slideOutDown" animations.

For more information on how to design your own animations, see <a href="https://www.w3schools.com/css/css3_animations.asp" target="_blank">this guide by w3schools</a>.

<h4 id="animations.setup">Setup</h4>
To begin with, you're going to need to see how the animations are set up. This is done in the {{{action effects}}} passage.
{{{
<<set _queue = new Set()>>
}}}
To begin with, we define this variable before we run any action code. It is a temporary variable, so we don't have to worry about it accidentally bleeding information over to the next passage. We define it as a {{{Set}}} object; this is an iterable container object like an array, but with the distinction that <b>all its elements must be unique</b> -- it cannot contain duplicates. If you try to add a duplicate element, nothing will happen. This is exactly what we want for the {{{_queue}}} object, because we will be using it to store every character we want to animate. A {{{Set}}} allows us to run general code for adding a character to the {{{_queue}}} for everything that would trigger an animation, without duplicating them if e.g. they were hit multiple times by the same attack.
{{{
<<if $ANIMATIONS === true && _queue.size > 0>>
<div class="actors animationContainer">
<<set _animationActive = true>>

<<for _i, _p range _queue>>
  <div style="position:relative">
    <div @id="'box'+_i" style="display:inline-block">
		<<capture _p>>
		<<liveblock>>
    	<<actorBox _p "" "simplified">>
		<</liveblock>>
		<</capture>>
    </div>
		<<for _x, _m range _p.battleMsg>>
	    <div @id="'dmg'+_i+'-'+_x" class="dmgPopup">
				<<print _m.content>>
	    </div>
		<</for>>
  </div>
<</for>>

</div>
<</if>>
}}}
Then comes the animation block. Note that this code is run <i>after</i> the action code is run, even though in the final passage it's displayed first; this is due to the {{{order}}} property, which allows flexbox elements to be displayed in a different order than in the code. In this case, we need to run the action code first to collect data that we need for the animations.
{{{
<<if $ANIMATIONS === true && _queue.size > 0>>
}}}
First, we only run this if the user has allowed it through the {{{ANIMATIONS}}} variable (defined in {{{StoryInit}}}), and if there are characters in the {{{_queue}}}. Some actions don't target anyone, in which case there's no need for an animation.
{{{
<div class="actors animationContainer">
<<set _animationActive = true>>
}}}
We want the animation lineup to look similar to the character lineup in the normal battle display, so we use the same container class, but with an additional {{{animationContainer}}} class that will allow us to specify custom details in the stylesheet. We also set an {{{_animationActive}}} flag, which we will use later.
{{{
<<for _i, _p range _queue>>
  <div style="position:relative">
    <div @id="'box'+_i" style="display:inline-block">
		<<capture _p>>
		<<liveblock>>
    	<<actorBox _p "" "simplified">>
		<</liveblock>>
		<</capture>>
    </div>
		<<for _x, _m range _p.battleMsg>>
	    <div @id="'dmg'+_i+'-'+_x" class="dmgPopup">
				<<print _m.content>>
	    </div>
		<</for>>
  </div>
<</for>>
}}}
The contents are generated similarly to <a class="noExternal" href="#actorlistDoc">the actor list</a>, generating an {{{<<actorBox>>}}} for every character in the {{{_queue}}}. We also run a second loop over the character's {{{battleMsg}}} attribute, which is an array containing information for every message we want to pop up during the animation, and generate another element for each message. (These elements are invisible by default, as a property of the {{{dmgPopup}}} class. We will make them visible only when the animation begins.) Note that we need to tag each one of these elements with a unique ID, as we will need to be able to reference them later to trigger the animation.
{{{
<<liveblock>>
	<<actorBox _p "" "simplified">>
<</liveblock>>
}}}
We also wrap each {{{<<actorBox>>}}} in a {{{<<liveblock>>}}} macro so it can be updated dynamically during the animation.
{{{
<<set target().battleMsg.push({shake: true, type: "damage", content:$dmg})>>
}}}
Messages themselves are set up when the action executes; for example, here is a line of code from the {{{<<echoDamage>>}}} widget. (This is why we need the action code to execute first.) Each message contains three important attributes that determine how it will appear: the type (damage, healing, effect, etc.), the content (the text that will display in the popup), and whether or not it makes the actor box shake. By default, negative effects (taking damage, gaining ailments, losing buffs) all make the box shake, to simulate being hit by an attack. Positive effects (healing, gaining buffs, losing ailments) just display the popup with no shake.

<h4 id="animations.execution">Execution</h4>
The control code for animations is called in a special passage, {{{PassageDone}}}. {{{PassageDone}}} executes only after the passage has finished rendering, which is important for ensuring there are no glitches in animation delays due to passage load times. The animation controller itself is stored in the file "battle animations".
{{{
<<set _animationsToComplete = 0>>
<<set _animationsComplete = 0>>
}}}
The first thing we do is define the {{{_animationsToComplete}}} and {{{_animationsComplete}}} variables. This allows us to track when all animations are complete, which we will need to know later.
{{{
<<timed setup.ANIM_WINDUP+"ms">>
}}}
The main animation code is wrapped in this {{{<<timed>>}}} block. This gives the player a moment to absorb the information of the new action before the animation begins, and also to offset the time taken to load the passage. {{{ANIM_WINDUP}}} is set to 750 milliseconds by default, but you can change it in {{{StoryInit}}}.
{{{
<<for _i, _p range _queue>>
	<<set _idA = "#box"+_i>>
	<<capture _idA, _p>>
    <<for _x, _m range _p.battleMsg>>
			<<set _idB = "#dmg"+_i+'-'+_x>>
			<<capture _x, _idB, _m>>
			<<if _m.shake>> /* if true, box shakes */
				<<set _time = (_x*(setup.ANIM_DURATION+400))+"ms">>
				<<timed _time>>
					<<run animateCSS(_idA,"headShake",setup.ANIM_DURATION+"ms")>>
					<<include "popup animation">>
				<</timed>>
			<<else>>
				<<set _time = (_x*500)+"ms">>
				<<timed _time>>
					<<include "popup animation">>
				<</timed>>
			<</if>>
			<</capture>>
    <</for>>
	<</capture>>
	<<set _animationsToComplete += _p.battleMsg.length>>
	<<set _p.battleMsg = []>>
<</for>>
}}}
The animations are activated through two nested loops: Once over every character in the {{{_queue}}} variable, and then over every message in those characters' {{{battleMsg}}} attributes. At the end of every loop, we add the number of messages the character carried to a running total in {{{_animationsToComplete}}}, and reset the {{{battleMsg}}} attribute to an empty array so no messages are erroneously carried over into the next turn.

Now, to get the timing right on the animations, we have to think carefully. This entire block of code, like everything else, will be executed as soon as the passage loads at the speed of the computer's processor (very fast). If we simply trigger the animation within each loop, they will all execute at once, making all the messages overlap each other in a sloppy mess.
{{{
<<set _time = (_x*500)+"ms">>
<<timed _time>>
}}}
To stagger the messages, we need to use {{{<<timed>>}}} macros, but here is the key: the code for the <i>creation</i> of the {{{<<timed>>}}} macros executes at the same time as everything else; that is, near-instantaneously. If we use the same delay for every {{{<<timed>>}}} macro, they'll all go off at the same time, defeating the purpose of staggering them. To space them out properly, we need to increment the delay with every loop by multiplying the index variable (the current iteration number) by some constant. This will near-simultaneously create a {{{<<timed>>}}} macro with a delay of 500ms, then another of 1000ms, and so on, creating {{{<<timed>>}}} macros that trigger 500ms apart.

Note that for messages that make the actor shake, we use a longer delay time. This is because we have to make sure the shake animation completes before we trigger it again. If an animation is reactivated before it completes, it may behave strangely or simply not trigger again.
{{{
<<set _animation = "slideOutUp">>
<<switch _m.type>>
	<<case "damage">>
		<<set _p.hp -= _m.content>>
	<<case "healing">>
		<<run $(_idB).addClass("green")>>
		<<set _p.hp += _m.content>>
	<<case "block">>
		<<run $(_idB).addClass("small")>>
	<<case "addEffect">>
		<<run $(_idB).addClass("small")>>
		<<run $(_idB).addClass("stat-raised")>>
	<<case "removeEffect">>
		<<run $(_idB).addClass("small")>>
		<<run $(_idB).addClass("maroon")>>
		<<set _animation = "slideOutDown">>
<</switch>>
<<update>>
<<if typeof(_m.mod) == "string">>
	<<run $(_idB).addClass(_m.mod)>>
<</if>>
<<set _animationsComplete++>>
<<run animateCSS(_idB,_animation,setup.DMG_DURATION+"ms")>>
}}}
Here is the code for the popup animation specifically. The code reads the {{{type}}} attribute of the message to determine its behavior, adds any classes specified in the message's {{{mod}}} attribute (if it has one), and increments {{{_animationsComplete}}}. By default, healing numbers are colored green, added effects are colored blue, and removed effects are colored maroon. (Elemental weaknesses and resistances are also marked with special colors, which you can see in {{{<<echoDamage>>}}}.)

<b>Note that HP adjustments for damage and healing are only done here and not in the action code itself.</b> This is to create the appearance of the actor box dynamically updating to reflect the results of each hit. However, because this code takes place inside a {{{<<timed>>}}} block, <b>it will not execute if the player leaves the passage before the animation triggers</b>.

<h4 id="animations.disabling">Disabling the Continue Button</h4>
To ensure the above glitch doesn't happen, we need to prevent the player from moving to the next passage until all the animations complete.
{{{
<<if $("#continue") !== undefined>>
	<<script>>
	$("#continue .macro-button").each((index, element) => {
			element.disabled = true;
		});
	<</script>>
<</if>>
}}}
That's done through this code, run at the start of the animation activator. This script uses jQuery to select the continue button (which we have tagged with the {{{#continue}}} ID) and disables it, preventing it from being clicked by the player.

However, we can't just end it there; otherwise, the player will never be able to click the continue button, and they'll be stuck!
{{{
function handleAnimationEnd() {
	node.classList.remove(`${prefix}animated`, animationName);
	if ($('#continue') !== undefined && temporary().animationsComplete >= temporary().animationsToComplete) {
			$("#continue .macro-button").each((index, element) => {
				element.disabled = false;
			});
	}
	resolve('Animation ended');
}
}}}
We re-activate the continue button with this function, defined within the {{{animateCSS}}} function and called at the end of every animation. If {{{_animationsComplete}}} matches the number of {{{_animationsToComplete}}}, we run the same code in reverse, re-enabling the continue button.

For actions that don't generate any animations, the animation activator won't be called, so the continue button won't be disabled in the first place.

<h2 id="setup">Setting up the battle</h2>
{{{
<<set $B = {target: null, subject: null, actor: null, turn: "player", turnCounter: 0, enemyTurns: 0, phase: "command", embargo: 0, event: false, surrender: false, kills: [], specialdeath: [], XPreward: 0, moneyReward: 0, destination: previous()}>>
<<callEncounter $scenario>>
<<refreshPuppets>>
<<if typeof($B.style) == 'string'>>
	<<addclass "html" $B.style>>
<</if>>
<<set $B.playerBars = []>>
<<for _i, _p range $puppets>>
	<<set _id = 'p'+_i>>
	<<run $B.playerBars.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.PLAYER_BAR_COLOR>>
		<<animation false>>
		<<sizing 100%>>
	<</newmeter>>
<</for>>
<<set $B.enemyBars = []>>
<<for _i, _e range $enemies>>
	<<set _id = 'e'+_i>>
	<<run $B.enemyBars.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.ENEMY_BAR_COLOR>>
		<<animation false>>
		<<sizing 100%>>
	<</newmeter>>
<</for>>
<<include "custom battle preparation">>
<<set $inbattle to true>>
<<set $stScreen = 1>>
<<if $B.ambush>>
	<<set $B.turn = "enemy">>
	<<goto "enemy phase">>
<<else>>
	<<goto "Battle!">>
<</if>>
}}}
The "Preparation" passage, shown here, is responsible for cleaning up variables and getting everything ready for the battle. You will want to have something like this to make sure every battle starts the way you want it to, without any loose flags or variables messing things up. The most important thing here is the initialization of the {{{$B}}} variable, which stands for "battle controller". {{{$B}}} will be used to handle every flag and variable we need to keep track of during battle. Tying these variables to a single object makes keeping track of them easy -- if we want to clear and reset our variables (such as when starting a new battle), we can just create a brand new {{{$B}}}, instead of having to keep track of whether or not we've reset every single variable that can come up during battle.

You should pay attention to the {{{<<callEncounter>>}}} line, immediately after the initialization of {{{$B}}}. This references a widget defined in the "Database: Encounters" passage.
{{{
<<widget "callEncounter">>

<<switch $args[0]>>

<<case "tutorial">>
/* Dummy enemies for the tutorial. */
<<set $enemies to [new Enemy(), new Enemy(), new Enemy()]>>
<<run $enemies[0].effects.push(new Effect("Stunned",1,0))>>
<<run $enemies[1].effects.push(new Effect("Pain",3,10))>>
<<run $enemies[2].effects.push(new Effect("SPC Boost",3,10))>>
}}}
In "Database: Encounters" we can see how the {{{<<callEncounter>>}}} widget is used to create the enemy parties. They are created as arrays of either "Puppet" or "Enemy" objects, which is useful because it will allow us to easily iterate over them later. I recommend creating your own "Database: Encounters" passage as a separate twee file and using it to overwrite the default passage.

<b>NOTE: Though you may be tempted, DO NOT use the {{{fill()}}} function to fill enemy arrays.</b> {{{fill()}}} fills an array with exact copies of fill element, which means all the enemies will have the same ID. This makes it impossible to accurately recall the target and subject; see <a class="noExternal" href="#chain">the {{{<<chain>>}}} widget</a> for details.
{{{
<<refreshPuppets>>
}}}
Next, we reset puppets to their resting states with {{{<<refreshPuppets>>}}}. For more details, go <a class="noExternal" href="#refreshPuppets">here</a>.
{{{
<<set $B.playerBars = []>>
<<for _i, _p range $puppets>>
	<<set _id = 'p'+_i>>
	<<run $B.playerBars.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.PLAYER_BAR_COLOR>>
		<<animation false>>
		<<sizing 100%>>
	<</newmeter>>
<</for>>
<<set $B.enemyBars = []>>
<<for _i, _e range $enemies>>
	<<set _id = 'e'+_i>>
	<<run $B.enemyBars.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.ENEMY_BAR_COLOR>>
		<<animation false>>
		<<sizing 100%>>
	<</newmeter>>
<</for>>
}}}
Next, we define the characters' health bars. Due to the unusual ways meters function and are stored in the game data, these have to be made on battle initialization, as each one requires a unique name. Because parties can be any size, we can't know how many meters to create in advance. Instead, we have to key them to the number of players and enemies in the current battle.

By default, I've set the health bars to have no color transition, no animation, and to span the full width of their container. You can edit any of these features if you like. The color variables are set in StoryInit, though this also allows for you to give characters unique colors; just define a {{{color}}} attribute or some such and pass it to the {{{<<colors>>}}} macro.

<b>Note that meters are not stateful.</b> This means that they do not persist across save game loads or browser refreshes. You may have noticed that if you refresh the page during the battle, the display will become a mess of error messages telling you the health meters don't exist; this is why. Unless you plan to remake the meters at the start of every passage, you should not allow saving during battles.

After this, custom preparation code is called. In the default engine, this is just the {{{<<restock>>}}} widget, which replenishes items.

<h2 id="skeleton">How the battle passages work</h2>
The battle screen that the player sees isn't just a single passage. It's many smaller passages (including the "Preparation" passage you just read about) all linked together and called at various points. You can see all of them in the "Battle Phases" file in the "passages" folder. You can open that file to follow along.

The file begins by defining a lot of the widgets used in battle. We'll return to these; you can skip over them for now.

The "Battle!" passage is the passage that ties everything together, but it doesn't contain much code, other than {{{<<include>>}}}ing the relevant passages in the right spots. Note how it is structured, however:
{{{
<span id="status">
<<include status>>
</span>

<span id="content">
<span id="actorlist">
<<include "actorlist">>
</span>
<div id="phase">

</div>
</span>
}}}
The two major components of the battle display, the character display and the phase of battle, are wrapped in HTML elements that give them unique IDs. This is necessary if we want to change them using macros.

<h3 id="auto-end">Auto-endturn</h3>
{{{
<<set _doneCount = 0>>
<<for _puppet range puppets()>>
	<<if (_puppet.isDone || _puppet.dead || _puppet.noact)>>
		<<set _doneCount++>>
	<</if>>
<</for>>
<<if !($B.victory || $B.defeat || _specialmsg)>>
	<<if $AUTO_ENDTURN === true && _doneCount == puppets().length>>
		<<endturn>>
	<<elseif setup.TURN_EXCHANGE === true && $B.enemyTurns > 0>>
		<<set $B.phase = null>>
		<<goto "enemy phase">>
	<</if>>
<</if>>
}}}
In addition to the main content, there is also this handler for the automatic turn ending feature, which can be enabled in the Settings menu. If it's enabled, we automatically end the player's turn after all characters have acted. To accomplish this, we intialize a {{{_doneCount}}} variable to 0, then run a loop over {{{$puppets}}}, incrementing {{{_doneCount}}} whenever we find a puppet who has acted or cannot act (due to being defeated or under a hold effect). If {{{_doneCount}}} then equals the length of {{{$puppets}}}, all characters have acted and we end the turn.
{{{
<<if $AUTO_ENDTURN === true && _doneCount == puppets().length>>
}}}
The feature is controlled by this conditional. {{{$AUTO_ENDTURN}}} is controlled by the Settings menu.
{{{
<<if !($B.victory || $B.defeat || _specialmsg)>>
}}}
Note that we also perform this check before we consider the auto-forwarder at all. Why? Well, Twine has a strange quirk: If it is forced to execute multiple {{{<<goto>>}}} operations on the same page, they will all execute simultaneously, ending with the player being forwarded to the last passage specified by a {{{<<goto>>}}}. Since the victory and defeat handlers also forward the player to another passage (see <a class="noExternal" href="#victorycheck">{{{<<victorycheck>>}}}</a>), we need to prevent that from happening. Otherwise, players will be forwarded to the victory passage and then immediately back to the battle screen, causing all sorts of problems! You can also set a {{{_specialmsg}}} flag in case you need to use any other passage forwarding, such as to a special scene using {{{<<specialcheck>>}}}.
{{{
<<elseif setup.TURN_EXCHANGE === true && $B.enemyTurns > 0>>
	<<set $B.phase = null>>
	<<goto "enemy phase">>
<</if>>
}}}
A related feature is "turn exchange", which is set in {{{StoryInit}}}. This will force a shift to the enemy phase if there are any {{{enemyTurns}}} stored -- in practice, after every player action.

<h3 id="actorlistDoc">Actor List</h3>
{{{
<<set _enemiesClass = "actors enemies">>
<<set _puppetsClass = "actors">>
<<include "battle display mods actorlist">>

<<if setup.BATTLE_GRID === true>>
	<<set _enemiesClass += " grid"; _puppetsClass += " grid">>
<</if>>

<<if $B.reverse_display>>
<<set _enemiesClass += " reverse">>
<</if>>

<div @class="_enemiesClass" id="enemies">
<<include "actorlist enemies">>
</div>

<div id="battlelines">
<<include "special battle lines">>
</div>

<div id="puppets">
<<include "actorlist puppets">>
</div>
}}}
The <b>actorlist</b> passage displays the battling characters.

In the default formatting, each of the character "blocks" you see in-game are held in a CSS structure called a "flexbox". This is a useful structure for placing elements in 1-dimensional space, as it gives us a lot of control over where its elements are placed and how they're formatted. To do this, there has to be a <i>container</i> element that controls the flexbox formatting, and <i>item</i> elements that go inside the container.

The way this works in the default stylesheet is that the <i>actors</i> class is the container, and the <i>actor</i> class represents items. So before we do anything we need to make a {{{<div>}}} element with the class "actors" to create the container, and then we can add elements classed "actor" inside.
{{{
<div @class="_enemiesClass" id="enemies">
}}}
You can situationally modify the formatting of the flexbox using Twine's {{{@}}} operator. When placed before an HTML attribute, it will cause the attribute data to be read as TwineScript, allowing you to pass Twine variables as attributes. Here, we use it to input the class of the container element. If you want a certain battle scenario to display the characters in reverse order (such as in the Crystal Gems encounter in <i>Cartoon Battle</i>), you can define {{{_enemiesClass}}} as "actors reverse" to add the additional "reverse" class to the container. In all other cases, {{{_enemiesClass}}} is just defined as "actors", and the default formatting is used. <i>Note that you <b>must</b> always define something in {{{_enemiesClass}}} if you use this method, as there is no way to evaluate the attribute as partially literal and partially TwineScript.</i>

<h4 id="actorBoxDoc">Actor Box</h4>
Once the container is established, we can start adding items. This is done through a standardized widget, {{{<<actorBox>>}}}.
{{{
<<widget "actorBox">>
<<set _actor = $args[0]>>

<<if _actor instanceof Puppet>>
  <<set _idx = $puppets.findIndex(function (a) { return _actor.id == a.id; })>>
  <<set _nameID = "pname"+_idx>>
  <<set _boxID = "p"+_idx>>
  <<set _healthBar = $B.playerBars[_idx]>>
<<elseif _actor instanceof Enemy>>
  <<set _idx = $enemies.findIndex(function (a) { return _actor.id == a.id })>>
  <<set _nameID = "ename"+_idx>>
  <<set _boxID = "e"+_idx>>
  <<set _healthBar = $B.enemyBars[_idx]>>
<</if>>

<<set _class = "actor ">>
<<if $args.length > 1 && typeof($args[1]) == "string">>
  <<set _class += $args[1]>>
<</if>>
}}}
The widget starts by declaring some variables: the actor itself (passed as the 0th argument to the widget), additional classes to be added to the box (the 1st argument to the widget, optional), and the actor's index in its party array, which is used to create unique anchors for hotkeys and to identify the correct health bar.
{{{
<<if _actor.caps>>
  <<set _nameStyle = "text-transform:uppercase">>
<<else>>
  <<set _nameStyle = "">>
<</if>>
}}}
We also define this style code if the actor's "caps" property is true, which will make their name display as uppercase. Otherwise, {{{_nameStyle}}} is blank. You can add other name modifiers here if you wish.

Then we can begin constructing the box itself. We want each block to contain the character's name, HP, HP meter, and status button. In the puppet blocks, we also want to print EN after HP. Let's go over how to do these things.

The first element we want to display is the name. This is also the most complicated element, because it also functions as a link that can perform multiple functions depending on the context of the battle.
{{{
/* Element 1: name */
<span class="actorname" @id=_nameID @style=_nameStyle>
<<if _actor.dead>>
	/* Dead characters display their name and the  (dagger) symbol in place of the status button */
	<<set _class = "statusbutton">>
	<<if _actor.large>>
		<<set _class += " absolute">>
	<</if>>
	<span class="dead">
		_actor.fullname
		<span @class=_class>&dagger;</span>
	</span>
}}}
The simplest special case is if the actor is dead. In this case, all we want is for the actor's name to be grayed out and for a &dagger; (dagger) symbol to be displayed in the corner of their box. (If you can't see the symbol, your Unicode support is out of date; try updating your browser.) We want the dagger symbol to replace the status button (discussed later), so we will use the same positioning class to display it. We will also wrap the name in a "dead" class, which we can use to provide the gray color.
{{{
<<elseif _actor instanceof Puppet && $B.phase == "selection" && ndef _s && (!_actor.noact || _actor.down) && !_actor.isDone>>
  /* For Puppets in the selection phase, their name becomes a link that sets them as the subject and allows the player to select their commands. */
  <<capture _idx, _actor>>
  <<link "_actor.name">>
    <<set $B.subject = _actor>>
    <<set _s = _idx>>
    <<set $B.phase = "command">>
    <<if setup.BATTLE_GRID === true>>
      <<removeclass "#puppets" "grid">>
    <</if>>
    <<addclass "#enemies" "invisible">>
    <<replace "#puppets">><<include "actorlist puppets">><</replace>>
    <<replace "#phase">><<include "commands">><</replace>>
  <</link>>
  <</capture>>
}}}
The next case concerns how the name should appear during the selection phase (when the player is selecting which puppet to act). What this says in English is, "If this actor is a Puppet, and the player's turn is in the selection phase, and a character has not already been selected ({{{_s}}} stands for "selection"), and this character is not under a hold effect, and this character has not already acted, turn this character's name into a link that sets this character as the subject, assign their index in the {{{$puppets}}} array to the {{{_s}}} variable, refresh the puppet actor list, and make commands appear in the {{{#phase}}} area."

To see what will happen when this link is clicked, we must take a quick trip to the "actorlist puppets" passage:
{{{
<div @class="_puppetsClass">
(...)
<<if def _s>>
	<div style="position:absolute; top:0; right:0"><<backbtn>></div>
	<<actorBox $B.subject>>
}}}
That's it! The puppet container will refresh to display only the character the player has just selected, allowing them to focus on them while they consider what commands to pick. Despite the complex setup code, the result is simple.

The next case determines how characters can be selected during the <a class="noExternal" href="#targetingphase">Targeting Phase</a>, and is discussed in that section.
{{{
<<else>>
  /* In all other phases, just display the name as normal. */
  _actor.fullname
<</if>>
}}}
Otherwise, the actor's name is displayed as plain text, no fluff.
{{{
/* Element 2: status button */
<<if !_actor.dead>>
  /* only display status button if character is not dead */
  <<set _class = "statusbutton">>
  <<if _actor.large>>
    <<set _class += " absolute">>
  <</if>>
  <<capture _actor>><span @class=_class><<status _actor>></span><</capture>>
<</if>>
}}}
Then we display the status button, which is much simpler, as the code for the button itself is offloaded to the {{{<<status>>}}} widget. All this code has to do is make sure the button appears correctly; by default, only if the character is not dead. (We also have to add the additional "absolute" class if the actor box is large, as the large box requires the status button be positioned differently.)
{{{
/* Element 3: HP */
<<if !_actor.dead>>
  <<capture _healthBar>>
  <div>
  HP: <<if _actor.maskhp>>???
  <<else>><<print _actor.hp>><<if _actor.showMaxHP>> / _actor.maxhp<</if>>
  <</if>>
  </div>
	(...)
  <</capture>>
<</if>>
}}}
Next, we display HP (but only if the character isn't dead). There are several modifiers to this display you can set as properties of the actor object. By default, only the current HP is shown, but you can also display the maximum HP by setting the {{{showMaxHP}}} attribute. The {{{maskhp}}} attribute will instead forego this whole process and just display the HP as "???", for when you don't want the player to know the character's HP.
{{{
<<if (!_actor.maskhp && setup.SHOW_HEALTHBARS)>>
  <<if setup.BATTLE_GRID === true && _actor.large>>
    <div class="largehealth">
      <<showmeter _healthBar `_actor.hp / _actor.maxhp`>>
    </div>
  <<else>>
    <<showmeter _healthBar `_actor.hp / _actor.maxhp`>>
  <</if>>
<</if>>
}}}
Next, we display the health bars, provided {{{setup.SHOW_HEALTHBARS}}} is set to true. The bar will stretch the entire length of the character block. For boss characters, whose block extends across the entire screen, this makes the bar very long!
{{{
/* Element 4: EN (Puppets only) */
<<if !_actor.dead && _actor instanceof Puppet && !$args.includes("simplified")>>
  <div>
  EN: _actor.en / _actor.maxen
  </div>
<</if>>
}}}
On the next line, EN is displayed, but only for Puppets, and only if they're not dead. (This section is also omitted in "simplified" form, such as in damage animations.) By default, this display is very simple, but you can modify it as you need.
{{{
/* Element 5: Crisis points */
<<if !_actor.dead && def _s && _actor.crisis instanceof Array && _actor.crisis.length > 0 && !$args.includes("simplified")>>
  /* Only display this if the character isn't currently selected (and if they have a valid Crisis in the first place) */
  <<set _style = "font-size: 10pt; ">>
  <<if _actor.crisisPoints >= 100>>
    <<set _style += "color:red">>
  <<else>>
    <<set _style += "font-weight:normal">>
  <</if>>
  <div @style=_style>
    Crisis: <<print _actor.crisisPoints>>%
  </div>
<</if>>
}}}
Crisis points are displayed next, but only if the character has a valid {{{crisis}}} attribute (and isn't dead). If you don't want to use Crises in your game, just don't give the characters any, and this whole section will be ignored.

By default, Crisis points are displayed in at a smaller size than normal (because the actor box is getting pretty big by this point), and is highlighted an eye-catching red if it's at maximum.
{{{
/* Element 6: Status messages */
<<if !_actor.dead>>
  <div class="noact">
  <<if $args.includes("simplified")>>
    <br/>
  <<elseif _actor.isDone>>
    Done!
  <<elseif _actor.stunned>>
    Stunned!
  <<elseif _actor.down>>
    Prone!
  <<else>>
    <br/>
  <</if>>
  </div>
<</if>>
}}}
The final element is a little notifier for when the character's turn is done, or if they're under a hold effect. In the simplified display, these messages are ignored and replaced with an empty line. Including an extra line break in the default case is not strictly necessary, but it keeps the character box dimensions consistent; if you don't include it, the box will become taller or shorter depending on if a message is displayed or not.

<h3 id="commands">Commands</h3>
[img[setup.ImagePath + "documentation/012.PNG"]]
[img[setup.ImagePath + "documentation/012a.PNG"]]

We need the player to be able to select actions and give commands to their characters to play the game. But by default, we see no commands, just the character boxes. When a character is selected, all the other characters disappear, and a command pane appears below their character box.

To show how this is done, we have to move up a step, and look at {{{actorlist puppets}}}, the container for <i>all</i> the actor boxes for the player characters.
{{{
<div @class="_puppetsClass">
(...)
<<if def _s>>
	<div style="position:absolute; top:0; right:0"><<backbtn>></div>
	<<actorBox $B.subject>>
<<else>>
	(...)
	<<for _i, _puppet range $puppets>>
		<<set _puppetClass = "">>
		(...)
		<<if _puppet === null>>
			(...)
		<<else>>
			<<actorBox _puppet _puppetClass>>
		<</if>>
	<<for>>
}}}
Recall from <a class="noExternal" href="#actorBoxDoc">the Actor Box</a> that when a Puppet's name is clicked in the selection phase, the {{{_s}}} variable is set and the puppet container is refreshed. That triggers the first {{{if}}} clause here, and displays <i>only</i> the box for the active subject (the puppet selected). (Because it is still within the flexbox container, the character box is automatically centered on the screen, which is handy.) Otherwise, we iterate over the {{{$puppets}}} array and make an {{{actorBox}}} for everyone.
{{{
<div style="position:absolute; top:0; right:0"><<backbtn>></div>
}}}
Note that this code in the selection branch is an important addition. We need to give the player the ability to go back in case they decide they want a different character to act. The {{{div}}} here is just to make sure it is placed in an aesthetically pleasing position; we can't place it inside the normal element flow, since it will go inside the flexbox and interfere with the placement of the character box. {{{position:absolute}}} allows us to control where it appears without affecting any other elements; in this case, we place it in the upper-right corner of the flexbox container. This displays it prominently near the character box, which is a good location.

However, this still doesn't show us how we get the commands to display. To answer that, recall this element from the master "Battle!" passage:
{{{
<div id="phase">

</div>
}}}
You may recall that clicking the selection link replaced this element with a passage called "commands", so let's look there:
{{{
<div class="commandcontainer">
<div class="commands">
	<span id="actbtn"><<act $puppets[_s]>></span><br />
	<span id="restbtn"><<rest $puppets[_s]>></span><br />
	<span id="itembtn"><<items $puppets[_s]>></span><br />
	<<if $B.surrender is true>>
		<<spare $puppets[_s]>><br/>
	<</if>>
</div>
</div>
}}}
Here, finally, are our commands. They display only if this passage has been slotted into the {{{#phase}}} element through the selection link, and they appear in a flexbox of identical dimensions that ensures they will display just under the character box. This is how we are able to display the commands only when a character has been selected.

As for the commands themselves, the mechanics required for these are a bit more complicated than a normal Twine link, so they refer to custom widgets found at the top of the "Battle Phases" file:
{{{
<<widget "act">>
<<if _puppet.down is true>>
	<<if $args[0].en >= setup.struggleCost>>
		<<link "Struggle">>
			<<set $B.subject = $args[0]; $action = new Action("struggle"); $B.target = null>>
			<<replace "#phase">><<include "confirm phase">><</replace>>
		<</link>>
	<<else>>
		<b>Exhausted!</b>
	<</if>>
<<else>>
	<<link "Act">>
		<<set $B.subject = $args[0]>>
		<<replace "#phase">><<include "actions">><</replace>>
	<</link>>
<</if>>
<span class="hotkey monospace right">[Q]</span>
<</widget>>
}}}
The first branch of the if clause here may look complicated, but it's only for a special case that turns the "Act" button into a selection for a single action. The part that the player will see for most of the battle is the default {{{<<else>>}}} case, which links to the "actions" passage while assigning the current character to the {{{$B.subject}}} variable.
{{{
<<set $B.phase = "actions">>
<span class="hotkey monospace">[Q] = basic action | [W] = last action</span><br/><br/>

<<actionlist $B.subject>>
}}}
Instead of making a separate passage for every character (which would quickly get cumbersome), everything is outsourced to another widget in order to reduce clutter. This can be found the widgets section of the "Battle Phases" file, and is discussed in <a class="noExternal" href="#actions">Action Mechanics</a>.

The "Item" command works similarly.

Once you have selected an action, you are moved to the targeting phase to choose a target.

<h3 id="targetingphase">Targeting Phase</h3>
{{{
<<set $B.phase = "targeting">>
<<replace "#actorlist">><<include "actorlist">><</replace>>
<<if $B.targeting == "enemy">>
	<<addclass "#puppets" "invisible">>
<<elseif $B.targeting == "ally">>
	<<addclass "#enemies" "invisible">>
<</if>>
<<backbtn>>

Select a target. <span class="hotkey monospace">[hotkeys: 1-0] <<if $B.reverse_display>>[enemies are displayed in reverse order]<</if>></span><br/>
<br/>
<<if $B.targeting == "all">>
<<set _targetingEnemy = true>>
<span class="hotkey monospace" id="target_help">
[Hotkeys targeting <<if _targetingEnemy === true>>enemies<<else>>allies<</if>>. Press Shift to switch targets.]
</span>
<</if>>
}}}
The <b>targeting phase</b> passage is not much to look at in and of itself. It is basically a filler passage that gives the player a stage to select their target. For clarity, the opposite party is made invisible if the action can only target one party or another.

However, to see how it behaves under normal circumstances, let us return to {{{<<actorBox>>}}}:
{{{
<<elseif $B.phase == "targeting">>
	<span class="targetnumber"><<print _idx+1>></span>
	<<if ($B.targeting == "all" || (_actor instanceof Enemy && $B.targeting == "enemy") || (_actor instanceof Puppet && $B.targeting == "ally"))>>
		<<if (_actor instanceof Puppet && !($B.subject.name == _actor.name && $B.noself === true)) ||
			(_actor instanceof Enemy &&
			((_actor.martyr || (!_martyr && !_actor.untargetable)) && ($action.ranged || guardCheck(_idx))))>>
			<<capture _actor>>
			<<link "_actor.fullname">>
				<<set $B.target = _actor; $B.targeting = null>>
				<<replace "#phase">><<include "confirm phase">><</replace>>
			<</link>>
			<</capture>>
		<<else>>
			/* If invalid target, just display the name as normal. */
			_actor.fullname
		<</if>>
	<<else>>
		/* If not being targeted, just display the name as normal. */
		_actor.fullname
	<</if>>
}}}
This is the name-display clause we skipped over previously. During the targeting phase, this clause turns the character's name into a link that, when clicked, directs the player to the confirm phase and sets the character as the target of the ability.

(There are also several riders for special circumstances: if an enemy is flagged untargetable they are, well, untargetable, and the same applies if they are protected by someone or their team has a martyr. On the player side, there is a rider that disables the user as a valid target if {{{$B.noself}}} is {{{true}}}. This will be explained in the action section.)

<h3 id="confirmphase">Confirm Phase</h3>
{{{
<<replace "#actorlist">><</replace>>
<<if $SHOW_CONFIRM>>
<<set $B.phase = "confirm">>
<<backbtn>>

$B.subject.name will

<<if $action.name is "rest">>
	<b>rest</b> this turn.
<<elseif $action.name is "struggle">>
	spend setup.struggleCost Energy to get back on <<print subject().their>> feet.
<<elseif $action.item is true>>
	use <<switch $action.name.first().toLowerCase()>><<case 'a' 'e' 'i' 'o' 'u'>>an<<default>>a<</switch>> $action.name.
<<elseif $action.name is "spare">>
	accept the enemy's surrender.
<<else>>
	use <b>$action.name</b><<if $B.target isnot null>> on <b>$B.target.name</b><</if>>.
<</if>>
 [[Confirm?|action phase]]<br />
<span class="preview">
<<if $action.preview instanceof Function>>
	<<print $action.preview()>>
<<else>>
	<<print $action.preview>>
<</if>>
</span>
<<else>>
<<goto "action phase">>
<</if>>
}}}
The confirm phase is very simple. It is designed as a courtesy to players to prevent them from accidentally confirming the wrong action by misclicking, and to allow them to review how the action will play out. It can be turned off in the Settings menu if players don't want to make the extra click, however.

The complicated-looking if clause here is just fluff to provide different messages depending on the class of action chosen. The a/an rule in English presents an issue when describing the use of items starting with vowels. I whipped up a quick {{{<<switch>>}}} statement to address this directly, but you may be able to come up with something more robust. (Or you could just accept defeat and display it as "a(n)". If you ever wondered why game developers do that, now you know!)

The {{{preview}}} attribute is another courtesy to the player. It describes the expected effect of the action, such as pre-calculating damage. It's unique for every action, and can be examined in the action database JavaScript.

<h3 id="spellphase">Spell Phase</h3>
In the default engine, Mage can expend additional energy points to make their spells stronger. This functionality is handled in the <b>spell phase</b> and <b>spell check</b> passages.
{{{
<<backbtn>>

<<if isNaN($action.cost)>>
You need to input a number.<br/>
<<elseif $action.cost < $B.mincost>>
Spell requires at least $B.mincost Energy.<br/>
<<elseif $B.subject.en < $action.cost>>
Not enough Energy!<br/>
<</if>>

How much Energy do you want to put into $action.name? (Minimum $B.mincost)<br />
<<numberboxplus "$action.cost" $B.mincost autofocus>>
<<include "spell check">>
<</numberboxplus>><br/>
(Press Enter to confirm.)<br/>
}}}
The <b>spell phase</b> passage is shown above. A {{{<<numberboxplus>>}}} macro is used to receive player input, because it allows the player to continue just by pressing the Enter key rather than having to fuss with another confirm link. The {{{<<numberboxplus>>}}} modifies the {{{$action.cost}}} variable, is initialized to a default value of {{{$B.mincost}}} (the minimum cost for the spell), calls the "spell check" passage when Enter is pressed, and autofocuses when the page is loaded.

(Thanks to SugarCube developer TheMadExile for providing the {{{<<numberboxplus>>}}} macro, which was necessary for preserving the engine's structure.)
{{{
<<run $action.cost *= 1>>
<<if ($action.cost < $B.mincost) or ($B.subject.en < $action.cost) or isNaN($action.cost)>>
<<replace "#phase">><<include "spell phase">><</replace>>
<<else>>

<<run $action.spellMod()>>

<<if $action.phase != "confirm phase">>
	<<set $B.targeting = $action.target>>
	<<replace "#phase">><<include "targeting phase">><</replace>>
<<else>>
	<<replace "#phase">><<include _action.phase>><</replace>>
<</if>>

<</if>>
}}}
The <b>spell check</b> passage, shown above, is not something the player should ever see. It is only for running calculations and directing the player to the correct passage.
{{{
<<run $action.cost *= 1>>
}}}
This initial {{{<<run>>}}} macro is needed to convert the {{{$action.cost}}} variable to a number, as it is passed as a string (text) when obtained through a text field.

From there, the if clause checks if the {{{$action.cost}}} value is within acceptable bounds. If the player inputted less energy than the minimum, more energy than Mage currently possesses, or something that wasn't a number, the player is pushed back to the spell phase and prompted to try again.

If the input was correct, the spell's {{{spellMod()}}} function is called to calculate adjustments for supercharging the spell. Each spell has a unique {{{spellMod()}}} that is defined in the action database. Once this is done, the player is directed to the next phase, and the action proceeds as normal.

<h3 id="actionphase">Action Phase</h3>
This is where actions take place. The "action phase" passage itself only executes standard behavior, such as variable cleanup. This will be discussed later. The details of specific actions take place in the "action effects" passage, which is {{{<<include>>}}}d in "action phase".

The actorlist passage is not included here, simply because it is difficult to update stats in real time.

Let's look at "action effects":
{{{
<<if $action.silent === true>>
	<<if $action.act instanceof Function>>
		<<print $action.act()>>
	<<else>>
		<<print $action.act>>
	<</if>>
		<<goto "Battle!">>
}}}
The first section handles actions that don't do anything significant enough to require a message. {{{silent}}} actions immediately forward the player back to the main battle screen after performing their function.

The "else" case here handles everything else -- that is to say, actions that <i>do</i> display a message and create text during the action phase.

How you code this section will depend on exactly how you want your actions to look. By default, this passage neatly partitions the display into use text, flavor text, and the mechanical effect of the action. Every section is given a unique ID that can be modified in the story stylesheet.
{{{
<div id="actFlavor">

<<if !($action.useText === null || ($action.useText instanceof Function && $action.useText() === null))>>
<div id="useText">
<<if $action.useText instanceof Function>>
	<<print $action.useText()>>
<<else>>
	<<print $action.useText>>
<</if>>
</div>
<</if>>

<<include "battle interruptions">>

<<if $action.actText !== null>>
<div id="actText">
<<if $action.actText instanceof Function>>
	<<print $action.actText()>>
<<else>>
	<<print $action.actText>>
<</if>>
</div>
<</if>>

</div>
}}}
First, we're going to open the "#actFlavor" {{{div}}}. This is the black-bordered text box that contains the descriptive text of the action. There are two portions to this {{{div}}}, the use text and the action text, and both get their own {{{div}}}s that you can format independently. The contents are defined as attributes of the action, and can be either normal strings, or functions (if, for instance, you want text to vary depending on certain variables). If you wish to bypass either element, you can set the corresponding attribute to {{{null}}} and the {{{div}}} will not generate.

There is also a call to {{{<<include>>}}} the "battle interruptions" passage, which can add special circumstances and additional scenes, such as one enemy protecting another from your attack.
{{{
<<if $action.act !== null>>
<div id="actEffect">

<<if def _targetingMsg>>
<<print _targetingMsg>>
<<unset _targetingMsg>>
<</if>>

<<if $action.act instanceof Function>>
<<print $action.act()>>
<<else>>
<<print $action.act>>
<</if>>

</div>
<</if>>
}}}
Then, there is a similar section for mechanical effects. Like use and act text, this is defined as an attribute of the action, usually a string of SugarCube code (which will execute as normal when {{{<<print>>}}}ed), and the element will not appear at all if the attribute is set to {{{null}}}. There is also a handler for the {{{_targetingMsg}}} variable, which handles a complicated problem discussed in <a class="noExternal" href="#targeting.basic">Standard Targeting</a>.
{{{
<<if def _OG>>
	<<set $B.subject = _OG.subject; $B.target = _OG.target; $action = _OG.action>>
	<<unset _OG>>
<</if>>
}}}
We also have to run this code at the very end. For special actions like counterattacks, we may want to temporarily change the subjet, target, and action, but we need to put them back afterwards so any further actions don't use the wrong variables.

This format creates a very nice, standardized, and customizable appearance for actions, but it does require actions to adhere to its rigid structure. All non-invisible actions <i>must</i> have a {{{useText}}}, {{{actText}}}, and {{{act}}} attribute, even if it's only {{{null}}}. Otherwise, you're going to be drowning in error messages when this passage displays.

We then bring this all together in the action phase:
{{{
<<set $B.phase = null>>
<span id="content">

/* Some abilities (such as AoE attacks) don't always end with the same target as the one they started with. This saves the initial target if you want to use it for something, e.g. a reaction scene. */
<<set _initialTarget = $B.target>>

/* Saves the number of kills from before the action. By comparing this to the kills array afterwards, you can identify whether or not a kill happened during the action. */
<<set _initialKills = $B.kills.length>>

/* Tracks characters who have counterattacked this action. Required to enable counters. */
<<set _counters = []>>

<<if $action.name == "spare">>
	<<run $enemy_to_spare.surrender()>>
<</if>>

/* Add any bonus threat from the action. */
<<if setup.THREAT_TARGETING === true && target() instanceof Enemy && subject() instanceof Puppet>>
	<<run target().threat.inc(subject().name,$action.threat)>>
<</if>>

<<include "action effects">>

/* Variable cleanup. Due to the way goto works, this will work even for invisible actions. */

/* Remember this action for the last action shortcut: */
<<if !$action.nosave && !($action.name == "struggle" || $action.name == "spare")>>
	<<include "lastaction mods">>
<</if>>

/* If action has limited uses, decrement that */
<<if def $action.uses>>
	<<run subject().actions.find(function(a) { return a && a.name == $action.name }).uses -= 1>>
<</if>>

/* If action has a cooldown, reset it */
<<if def $action.cd>>
	<<run subject().actions.find(function(a) { return a && a.name == $action.name }).resetCD()>>
<</if>>

/* If target was an enemy (i.e. an attacking skill was used), subject is marked as attacker. (This is for enemies that target the last puppet to attack them.) */
<<if $B.target instanceof Enemy>>
	<<set $B.attacker = $puppets.indexOf($B.subject)>>
<</if>>

/* isDone logic; checks for confounding factors */
<<if $action.instant>>
	/* do nothing */
<<elseif $B.subject.inspired>>
	<<set $B.subject.inspired = false>>
<<else>>
	<<set $B.subject.isDone = true>>
	<<set $B.enemyTurns++>>
<</if>>

<<if $action.oncePerTurn>>
	<<set $action.used = true>>
<</if>>

/* Subtract action cost */
<<if $action instanceof ItemAction>>
	<<set $B.item_used = true>>
	<<if $B.subject.crafty>>
		<<set $action._cost = Math.round(setup.ITEM_COST/2)>>
	<<else>>
		<<set $action._cost = setup.ITEM_COST>>
	<</if>>
<</if>>
<<set $B.subject.en -= $action.cost>>

<<if $B.surrender && def $action.name>>
	<<print $enemy_to_spare.surrenderCheck()>>
<</if>>

<br/>
<center><<button "Continue..." "Battle!">><</button>></center>

</span>
}}}
Now you can see how it all comes together in the action phase. The bits of code at the end are for tidying up. The action is saved to {{{lastAction}}}, the subject is flagged as done for the turn, and various other necessary flags are set. This code is simple in its basic structure, but a few special cases require some {{{<<if>>}}} statements, such as instant skills or the additional turn from Mage's "Inspiration" ability.
{{{
<<if $B.surrender && def $action.name>>
	<<run $enemy_to_spare.surrenderCheck()>>
<</if>>
}}}
There is also functionality here for calling the {{{surrenderCheck}}} function, described in the <a class="noExternal" href="#JS.enemies">Enemy Database</a>. If the player uses an action that doesn't pass the check, the surrendering enemy will be aggro'd and cease their surrender.

<h3 id="actionqueue">Action Queue</h3>
There is additional functionality for handling special actions, such as counterattacks and Archer's Mark attacks. It is included in the {{{Widgets (Special Attacks).tw}}} file, which also handles the logic for triggering these special actions.
{{{
<center id="continue">
(...)
	<<button "Continue...">>
		<<if $B.actionQueue.length > 0>>
			<<replace "#content" "t8n">>
				<<include "Action Queue">>
				<<timed 0s>><<include "animation activator">><</timed>>
			<</replace>>
		(...)
</center>
}}}
If you look at the "Battle Continue Button" passage, you will see this handler within the button code. This says that if the {{{actionQueue}}}, and array property of the battle controller defined at the start of the battle, has a {{{length}}} greater than 0 (i.e. it has entries), we run this code instead of forwarding the player to the next passage as normal. We {{{<<replace>>}}} the existing passage instead of moving to a new one to preserve the identity of the current passage, as the passage name is used when determining the player's next destination when the queue is finished.

The "Action Queue" passage itself looks like this:
{{{
<<if $B.actionQueue.length > 0>>
	<<set _data = $B.actionQueue.shift()>>
	<<set _OG = {target: $B.target, subject: $B.subject, action: $action}>>
	<<set $B.subject = getActorById(_data[0]); $action = _data[1]>>
	<<if !(subject().dead || subject().noact)>>
		<<if $action.counter>>
			<<set $B.target = _OG.subject>>
			<<set _counterActive = true>>
		<</if>>
		<<include "action effects">><br/>
		<<set _counterActive = false>>
	<<else>>
		<<timed 0s>><<trigger 'click' "#continue button">><</timed>>
	<</if>>
<</if>>
<<include "Battle Continue Button">>
}}}
We start by {{{shift}}}ing the first entry out of the {{{actionQueue}}} and storing it in {{{_data}}}. ({{{shift}}} is an array function that extracts the first entry from an array; this both removes it from the original array, and allows us to store the entry in another variable. Because this shortens the array, we will eventually empty the {{{actionQueue}}} this way.) Then, we need to store the original target, subject, and action in a holder variable, so that we can put them back when we're done.
{{{
<<set $B.subject = getActorById(_data[0]); $action = _data[1]>>
}}}
We then need to set the new subject and action. We do this by reading the entry we got from the {{{actionQueue}}}. Entries added to the {{{actionQueue}}} are assumed to be, themselves, arrays consisting of two elements: the ID of the character to perform the action, and then the action itself.

The target is determined by the action itself. For counterattacks, there is standard code that sets the target to the original subject.
{{{
<<include "action effects">>
}}}
Note that we need to include "action effects" to run the action -- but that passage, itself, populates the {{{actionQueue}}}! If two characters with counterattacks started attacking each other, they'd keep attacking in an endless loop. To prevent that, we set the {{{_counterActive}}} flag, which prevents further counterattacks from triggering. This prevents characters from countering counters and creating an endless loop. (We need to set similar flags for every class of special action to prevent similar loops.)
{{{
<<if !(subject().dead || subject().noact)>>
	(...)
<<else>>
	<<timed 0s>><<trigger 'click' "#continue button">><</timed>>
}}}
Finally, we have an escape handler. If for some reason the character died or was stunned in-between triggering their counter and now, we skip straight to the next passage by simulating a click on the continue button. (Note that we have to wrap this code in a {{{<<timed>>}}} block because it references an element on the page, which won't exist until the whole page has finished rendering.)

<h3 id="endOfRound">End of Round</h3>
{{{
<span id="status">
<<include status>>
</span>

<span id="content">

<<if $B.turn eq "player">>
/* If the turn reads "player", it's because the enemy round just finished. Run end of turn for enemies. */
	/* If it's a new player turn, it's a "true" new round, so need to update and reset controller variables. */
	<<set $B.turnCounter++; $B.embargo--; $B.enemyTurns = 0; $B.actions_this_turn = {}>>
	<<endOfRound $enemies>>
	<<newTurn $puppets>>
	<<if _message>>
		<<button "Continue..." "Battle!">><</button>>
	<<else>>
		<<goto "Battle!">>
	<</if>>

<<elseif $B.turn eq "enemy">>
/* If the turn reads "enemy", the player turn just finished. Run end of turn for player. */
	<<endOfRound $puppets>>
	<<if _message>>
		<br/><<button "Continue..." "enemy phase">><</button>>
	<<else>>
		<<goto "enemy phase">>
	<</if>>
<</if>>
</span>
}}}
As you can see, the functionality of the <b>end of round</b> passage is mostly outsourced to a widget, which can be found at the top of the "Battle Phases" file.
{{{
<<widget "endOfRound">>
<<for _actor range $args[0].filter(function (a) { return a !== null; })>>
	<<set _actor.isDone = false>>
	<<if _actor instanceof Enemy && def _actor._respawn && _actor.dead>>
		<<set _actor.respawn-->>
		<<if _actor.respawn <= 0>>
			<<set _actor.dead = false; _actor.hp = _actor.maxhp; _actor.resetRespawn()>>
			<<set _message = true>>
				<div id="actFlavor">
					<<print _actor.respawnMessage>>
				</div>
				<br/>
		<</if>>
	<</if>>
	<<for _effect range _actor.effects>>
		/* DoT check */
		<<if _effect.dot is true>>
				<<set _message to true>>
				<<set $dmg = _effect.damage(_actor)>>
				<div id="actFlavor">
					<<print _effect.msg(_actor)>>
				</div>
				<div id="actEffect">
					<<echoDamage _actor "indirect" "nocalc">>
				</div>
				<br/>
		<</if>>
	<</for>>

	/* decrementor */
	<<decayMessage _actor.effects false>>
<</for>>
<</widget>>
}}}
The main purpose of the end-of-round widget is to handle status effects. Status effect durations are decremented and damage-over-time effects inflict their damage. This is accomplished through two for loops: one across the party (which party is specified in the argument given to the widget), and one across the effects of the current character. If a damage-over-time effect is found, its damage is calculated its damage message is printed.

For effect decrement, we use another widget, {{{<<decayMessage>>}}}. (This code is compartmentalized because it is reused in the top-of-round code; see {{{newTurn}}}, below.)
{{{
<<widget "decayMessage">>

<<set _topDec = Boolean($args[1])>>
<<set _decayMsg = "">>
<<for _effect range $args[0].filter(function (eff) { return eff.topDec == temporary().topDec })>>
  <<set _m = _effect.decay(_actor)>>
  <<if _m.length > 1>>
    <<set _decayMsg += _m>>
  <</if>>
<</for>>
<<if _decayMsg.length > 0>>
  <div id="actEffect">
    <<print _decayMsg>>
  </div>
  <br/>
<</if>>
<</widget>>
}}}
We call the {{{decay}}} method function on each of the character's effects, which decrements the effect's duration by 1 and removes it if it hits 0. If the effect is removed, {{{decay}}} will return the removal message, which we will store in temporary variable {{{_m}}} and add to an aggregate text string, {{{_decayMsg}}}. When all effects are finished, we print the aggregate {{{_decayMsg}}}, providing it contains anything.
{{{
<<if _m.length > 1>>
  <<set _decayMsg += _m>>
<</if>>
}}}
Note this check here. Some effects produce an empty decay message, which is not meant to be displayed to the player. We don't want to add these strings to {{{_decayMsg}}}, so we need to check that {{{_m}}} is longer than 1 character. The reason the check is <i>strictly greater than</i> 1 as opposed to <i>greater than or equal to</i> 1 is because the {{{decay}}} function automatically adds a newline character, {{{\n}}}, to any decay message it receives, even if it's empty.
{{{
<<if _message>>
	<<button "Continue..." "Battle!">><</button>>
<<else>>
	<<goto "Battle!">>
<</if>>
}}}
Finally, we use the {{{_message}}} flag is used to ensure the player only lingers on the "end of round" passage if necessary. If no messages were generated, {{{_message}}} will remain false, and the player will be pushed to the next passage automatically. This is done to create a smoother player experience. (The {{{decay}}} function will automatically flip {{{_message}}} to {{{true}}} if it receives a non-empty decay message.)

There is a corresponding widget called at the top of a round: {{{<<newTurn>>}}}.
{{{
<<widget "newTurn">>
<<for _actor range $args[0].filter(function (a) { return a !== null; })>>
	<<set _actor.isDone to false>>
	<<if !_actor.dead>>
		<<run _actor.regenHP()>>
		<<run _actor._retaliations.refill()>>
  <</if>>
	<<if _actor instanceof Puppet>>
    /* Puppet-exclusive tasks:
			decrement respawn (enemy respawn only decremented at end of round)
			refresh used actions */
    <<if _actor.dead && def _actor._respawn>>
  		<<set _actor.respawn-->>
  		<<if _actor.respawn <= 0>>
  			<<set _actor.dead = false; _actor.hp = Math.round(_actor.maxhp * setup.RESPAWN_HP); _actor.resetRespawn()>>
  			<<set _message to true>>
  			<div id="actFlavor">
  				<<print _actor.respawnMessage>>
  			</div>
  			<br/>
  		<</if>>
    <</if>>
    <<for _action range _actor.actions.filter(function (act) { return act.used === true })>>
      <<run _action.used = false>>
    <</for>>
	<</if>>
  <<decayMessage _actor.effects true>>
<</for>>
<<include "custom newTurn">>
<</widget>>
}}}
This refreshes everyone's {{{isDone}}} flag, regenerates HP and retaliatiations, advances respawn counters, and decrements top-of-round status effects. Actions that can only be used once per turn, such as Mage's "Sacrifice" ability, are also reset so they can be used again. (In the default engine, EN regeneration is handled in "custom newTurn", so you can easily remove it if you don't want to use EN.)

<h3 id="enemyphase">Enemy Phase</h3>
The enemy turn. This passage is complicated, because it must essentially incorporate all the events of the previous passages at once.
{{{
<<if (deadCount() == puppets().length)>>
/* If all puppets are dead, it's game over -- no point in finishing this passage, just let victorycheck do its thing. */
}}}
The very first thing we have to do is actually to check if there's any point in running the enemy turn at all! It is possible for the enemies to defeat the player in the middle of their turn; it would be pointless for them to keep acting after that, as the player has already lost. In this case, we run no code in this passage, and just let the defeat handler resolve the battle.
{{{
<<if $B.ambush>>
	<<set $B.ambush = false; $B.turn = "enemy">>
	<center style="font-weight:bold">AMBUSHED!</center><br/>
<</if>>
}}}
If we <i>are</i> executing the enemy turn, first we have a handler for ambushes. Normally, battles start on the player's turn, but if the {{{ambush}}} property is flagged, the battle starts here. We display a message informing the player of this fact, and unset {{{ambush}}}.
{{{
<<set _enemy = enemies().sort(function(a,b) { return a.priority - b.priority; })
	.find(function (e) { return e && !e.isDone && !e.dead })>>
}}}
We then need to find the active enemy. We can't just iterate over the whole enemy party with a loop, because we don't want every enemy's turn to display at once. Instead, we have to pick a single enemy by searching the array. First, we sort the enemy party in ascending {{{priority}}} value; then, we run a {{{find}}} function searching for an enemy that is defined, not done, and not dead. Because {{{find}}} stops at the first element that satisfies its conditions, and because we have already sorted the array, this will ensure enemies act in the proper priority order.
{{{
<<if _enemy instanceof Enemy>>
(...)
<<else>>
	<<set $B.turn = "player">>
	<<goto "end of round">>
<</if>>
}}}
However, we can only go ahead if that operation <i>did</i> find a valid enemy! If all the enemies have acted, {{{find}}} will fail and return {{{undefined}}}. In this case, we should end the enemy turn and forward the player to the next round.
{{{
<<set $B.subject = _enemy>>
<<set $B.target = null>>
<<if _enemy.isFirstAction>>
	<<newTurn `[_enemy]`>>
<</if>>
<<set _enemy.isDone = true>>
}}}
But if all is well, we will run {{{<<newTurn>>}}} for the enemy, which provides the same functions as it did for the player characters. (Note that {{{<<newTurn>>}}} only works with arrays, so we need to place the enemy object within an array when passing it to the widget.) However, we need to manually set {{{isDone}}} to {{{true}}}, because if you recall, {{{<<newTurn>>}}} sets {{{isDone}}} to {{{false}}}. The enemy also becomes the active subject.
{{{
<<if !_enemy.fakedeath>>
(...)
<<else>>
	<<goto "enemy phase">>
}}}
Then we have to check this clause before proceeding. The {{{fakedeath}}} property essentially skips the enemy's turn as if they were dead, but still allows the above new-round effects to occur.
{{{
<<if _enemy.noact>>
	<<set _effect = _enemy.effects.sort(function(a,b) { return a.priority - b.priority; })
		.find(function (e) { return e && e.holdAction instanceof Function })>>
	/* Sorts effects by priority and returns the first hold effect (one with a holdAction) */
	<<run console.assert(_effect !== undefined,`ERROR in enemy phase: ${_enemy.name} has noact but no hold effect`)>>
	<<set $action = _effect.holdAction()>>
	<<include "action effects">><br/>
	<<include "custom end of action effects">>
}}}
The enemy is then checked against hold effects. If they have one (or more), their effects are sorted by {{{priority}}}, then the first effect with a working {{{holdAction}}} property is found. {{{holdAction()}}} is then run, which fills {{{$action}}} with a "dummy" action that just contains {{{actText}}} informing the player that the enemy is under said effect. (The {{{priority}}} sort allows you to have a heirarchy of hold effects; for example, by default, enemies cannot right themselves from Knocked Down if they are also Stunned.)
{{{
<<else>>
	<<if _enemy.isFirstAction>>
		<<run _enemy.decCD()>>
	<</if>>
	<<set _counters = []>>
	<<set $action = null>>
	<<run _enemy.actions()>>
	<<run $B.actionsThisTurn[_enemy.id].push($action.name)>>
	<<if !_targetfail>>
		<<include "action effects">><br/>
	<</if>>
	(...)
		<<run $B.enemyTurns -= 1>>
<</if>>
}}}
Only in the default {{{<<else>>}}} clause, if the enemy passes all these checks, does enemy action occur. The {{{actionsThisTurn}}} object can be used to track which actions the enemy has already used on their turn, if you want them to modify their behavior based on previous actions. (Note that we must populate it with the enemy's <i>ID</i>, not the enemy's name, because while names can be duplicated, IDs are unique.)

The details of the {{{actions}}} function can be found in the {{{database-enemies}}} JavaScript file, which is discussed <a class="noExternal" href="#JS.enemies">here</a>. Setting {{{$action}}} to {{{null}}} is necessary to ensure the function works correctly; otherwise the enemy will think they've already selected an action.
{{{
<<if !_targetfail>>
}}}
This check is necessary in case the enemy's attack fails to find a target. (See <a class="noExternal" href="#targeting.basic">Targeting</a>.) If this happens and the action is allowed to play out, glitches can occur.
{{{
<center id="continue">
<<button "Continue...">>
	<<if $B.enemyTurns > 0 || $B.turn == "enemy">>
		<<goto "enemy phase">>
	<<else>>
		<<goto "Battle!">>
	<</if>>
<</button>>
</center>
}}}
Finally, at the very end of the passage, we generate a button to allow the player to continue. It has branching behavior depending on the {{{enemyTurns}}} counter: If there are enemy turns remaining (or if it's the enemy's turn, in which case they all act at once), we refresh this passage, which allows the next enemy to be selected and act. (Remember that if all the enemies have acted, we will forward the player to the end of round passage instead through an earlier handler.) Otherwise, the player is taken back to the main "Battle!" screen and returned to their turn.

<h4 id="enemyphase.multiActions">Enemies with Multiple Actions</h4>
Some enemies can act multiple times per turn, as determined by their {{{noAttacks}}} (short for "number of attacks") attribute. For this, we need some special handlers.
{{{
get isFirstAction () {
	return (V().B.actionsThisTurn[this.id] instanceof Array && V().B.actionsThisTurn[this.id].length == 0);
}
}}}
You might recall seeing this property used in some of the previous checks. It returns {{{true}}} if the enemy's {{{noAttacks}}} is at maximum; that is, if they haven't taken any actions yet. This is useful, because we want to keep running the same action code for the enemy until they're out of actions, but there's some code, like {{{<<newTurn>>}}}, we only want to run once.
{{{
<<if $action.fullround === true>>
	<<run _enemy.noAttacks = 0>>
<<elseif !$action.instant>>
	<<run _enemy.noAttacks-->>
<</if>>
<<if _enemy.noAttacks > 0>>
	<<set _enemy.isDone = false>>
<<else>>
	<<run $B.enemyTurns -= 1>>
<</if>>
}}}
After the enemy's action is executed, we run some checks against their {{{noAttacks}}}. Firstly, if the action had the {{{fullround}}} attribute, it is considered to end the enemy's turn no matter how many actions they had remaining, so we set {{{noAttacks}}} to 0. Otherwise we'll reduce {{{noAttacks}}} by 1, unless the action was instant. Then, we'll only remove the enemy's turn from the {{{enemyTurns}}} pool <i>if they have no actions remaining</i> -- if {{{noAttacks}}} is greater than 0, {{{isDone}}} is set to {{{false}}}, allowing the enemy to be selected again. In this way, we allow the enemy to keep acting until it's out of actions. ({{{noAttacks}}} is refreshed at the end of the round, starting the cycle anew.)

<h3 id="advanceturn">Advancing Turns</h3>
There is a feature added in version 1.12 that modifies the behavior of the "End Turn" button.
{{{
<<set $B.subject.isDone = true>>
<<set $B.enemyTurns++>>
(...)
<<run _enemy.decCD(); $B.enemyTurns-->>
(...)
<<for _e, _enemy range $enemies.sort(function(a,b) { return a.priority - b.priority; })>>
	<<if !($B.enemyTurns > 0 || $B.turn == "enemy")>>
		<<break>>
}}}
Notice this {{{enemyTurns}}} variable. We skipped over it in prior discussions, but let's bring it all together now. You can see through this code (from the action and enemy phases) that {{{enemyTurns}}} is incremented when a player character finishes their turn, and decremented when an enemy performs their turn. If {{{enemyTurns}}} drops to 0 while the turn is still the player's, the {{{break}}} statement within {{{if !($B.enemyTurns > 0 || $B.turn == "enemy")}}} will be executed, and the enemy actions loop will stop prematurely.

This allows the player to space out the enemy turns, instead of having to take all of their attacks at once. This isn't too big of a deal in <i>Cartoon Battle</i>, but players might appreciate it in a system where they have lower HP totals than the enemies and might get taken out if a single character is swarmed by all enemies.

However, we still need to account for the possibility that the enemy and player parties are unequal. If the enemy has 4 characters and you have only 3, what happens when you use all of your turns and have only given the enemy 3? This is the purpose the {{{if $B.turn == "enemy"}}} clause. If the player's turn has completely ended and the round has shifted to the enemies, they bypass the {{{enemyTurns}}} check and all remaining enemies can act freely.
{{{
<<if $B.enemyTurns == 0 || _doneCount == puppets().length>>
	<<button "END TURN">>
		<<endturn>>
	<</button>>
<<else>>
	<<button "ADVANCE TURN">>
		<<set $B.phase = null>>
		<<goto "enemy phase">>
	<</button>>
<</if>>

(...)

<<widget "endturn">>
<<set $B.turn = "enemy"; $B.phase = null>>
<<goto "end of round">>
<</widget>>

(...)

<<button "Continue...">>
	<<if $B.turn == "enemy">>
		<<set $B.turn = "player">>
		<<goto "end of round">>
	<<else>>
		<<goto "Battle!">>
	<</if>>
<</button>>
}}}
But that raises another question: How do we determine when the player's turn has "ended"? That's handled through the first block of code here, which generates the "End Turn" button for the player. If there are no enemy turns left or if all puppets have acted, the button says "END TURN", sets the {{{turn}}} property to "enemy", and forwards the player to the "end of round" passage. Otherwise, the button says "ADVANCE TURN", and only forwards us to the enemy passage without modifying the {{{turn}}} property. From the previous code, you can see this means only a number of enemies equal to the {{{enemyTurns}}} variable will act. The enemy phase's "Continue" button has its own form of this: If the turn belongs to the enemy, we switch the {{{turn}}} property back around and go to "end of round" to finish the round; otherwise, we go back to the player's side of things.
{{{
<<if _start == $B.enemyTurns>>
	<<set $B.turn = "player">>
	<<goto "end of round">>
<</if>>
}}}
There's also this little check, which is just for convenience. If {{{enemyTurns}}} doesn't change -- so, no enemies act -- this passage will be blank except for the "Continue" button, which looks weird. There's no need for the player to linger on the passage in this case, so we just automatically forward them to the end of the round.

<h3 id="victorydefeat">Victory and Defeat</h3>
So, what happens when the battle ends? There is a standard {{{Victory}}} passage that the player is forwarded to if they win (see <a class="noExternal" href="#victorycheck">{{{<<victorycheck>>}}}</a>). Let's look at it:
{{{
<<set _XPBars = []; _animationTime = "1s">>
}}}
The first thing is to initialize the array of our experience bars and their animation time (defaulting to 1 second).
{{{
<div class="actors">
<<for _i, _puppet range $puppets>>
	<<set _id = 'p'+_i>>
	<<run _XPBars.push(_id)>>
	<<set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)>>
	<<newmeter _id _value>>
		<<colors cyan cyan black>>
		<<animation _animationTime linear>>
		<<sizing 100%>>
	<</newmeter>>
}}}
We iterate over our {{{$puppets}}} and generate XP bars similarly to how we generated health bars in <a class="noExternal" href="#actorlist">actorlist</a>. The starting value of the bars is a little complicated to calculate: We are looking not at the ratio of total XP to the XP of the next level (which both account for <i>all</i> the XP a puppet has acquired since level 1), but how much <i>more</i> XP the puppet has to get to reach the next level. To get that, we need to calibrate for the current level. To track the puppet's current progress, we subtract the puppet's current XP from the {{{XPtoNext}}} of the <i>previous</i> level, and mark the "goal" as the {{{XPtoNext}}} of their current level minus their previous. We also have to clamp this ratio between 0 and 1 to prevent possible overflow.

That was probably confusing to follow, so here's a concrete example: Say the puppet has just reached level 3, and has 3000 XP in total. According to their {{{XPtoNext}}} function, they will reach level 4 when they have 5000 XP <i>in total</i>. However, in relative terms, they only need 2000 more XP to reach the next level. If we just set the meter's progress to {{{XP / XPtoNext()}}}, that will give us {{{3000 / 5000}}}, starting the meter at 60% filled! But if we subtract the XP requirement for the previous level (3000) from both the current and target XP values, we get {{{0 / 2000}}} -- completely unfilled, as it should be when starting at the next level. If the puppet gains 1000 XP, the meter's progress will be {{{1000 / 2000}}} -- halfway filled.
{{{
<<animation _animationTime linear>>
}}}
Unlike the health bars, these meters <i>are</i> animated, with a time set by {{{_animationTime}}}. You can change this if you like.
{{{
<div class="actor victory">
<center style="text-transform:uppercase; font-weight:bold">_puppet.name</center>
LEVEL <span @id="'lv'+_i">_puppet.level</span>
<<showmeter _XPBars[_i] _value>>
<center @id="'lvlupmsg'+_i">&nbsp;</center>
</div>
}}}
With our calculations done, we can display the actual meter. The puppet is displayed in a standard {{{actor}}} box, with a few modifications from the {{{victory}}} class. (The most important one is a {{{margin-bottom: 1em}}} attribute, which spaces out the boxes more nicely if they run onto a second line.) The puppet's current level is displayed within a {{{<span>}}} marked with an {{{id}}} keyed to the puppet's index, then the XP bar, and then a placeholder for a level up message, again marked with an {{{id}}} keyed to the puppet's index so we can reference it later.
{{{
<<set _multiplier = 1>>
<<set _puppet.xp += Math.round($B.XPreward * _multiplier)>>
<<set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)>>
<<updatemeter _XPBars[_i] _value>>
}}}
Having initialized the XP bar, now we can update it. Each puppet's XP is incremented by the {{{XPreward}}} accumulated throughout the battle (see <a class="noExternal" href="#deathcheck">{{{<<deathcheck>>}}}</a>), the new value of the meter is calculated the same way as before, and the meter is updated with the new value. (This will run the update animation. If you have no animation specified, the XP meters will immediately start at their updated values from the player's perspective. Note that there's no delay on this, so the meters will start filling immediately; if you want to space it out, you'll have to place this code in a separate {{{<<timed>>}}} block.)

We also include a variable, {{{_multipler}}}, that you can use to account for any special modifiers on XP. Perhaps you have a piece of equipment that lets you gain XP faster, or a status effect that renders you unable to gain XP.
{{{
<<set $currency += $B.moneyReward>>
<center style="margin-top:1em;"><div style="display:inline-block; width:50%; font-size:20pt; text-align:left"><<print setup.CURRENCY_NAME>> <span style="float:right">$B.moneyReward</span></div></center>
}}}
After that's done for all puppets, we increment the player's currency variable by the battle's {{{moneyReward}}}, and display a message informing the player of this fact. (If you have more complicated rules for handling currency, such as every character having their own purse, you'll need to do something different.)
{{{
<<set _itemDrops = []>>
<<for _enemy range $B.kills>>
	<<for _item, _chance range _enemy.itemDrops>>
	/* Assumes itemDrops is an object with property names of items corresponding to a number between 1 and 100 equal to the % chance of the item being dropped. */
		<<if typeof(_item) == 'string' && typeof(_chance) == 'number'>>
			<<set _r = random(1,100)>>
			<<if _r <= _chance>>
				<<run inv().addItem(_item); _itemDrops.push(_item)>>
			<</if>>
		<</if>>
	<</for>>
<</for>>
<<if _itemDrops.length > 0>>
	<center style="margin-top:1em;">
	<div style="font-size:20pt; font-weight:bold">DROPS:</div>
	<span class="itembox" style="width:30%">
	<<for _item range _itemDrops>>
		<b><<print _item>></b><br/>
	<</for>>
	</span>
	</center>
<</if>>
}}}
Then comes item drops. We'll loop over the {{{kills}}} array and extract the {{{itemDrops}}} table from each enemy. If the table has been constructed correctly (a list of item names as properties pointing to percentile values), we roll a d100 to see if the item was dropped by the enemy. If so, we add it to the player's inventory and to the {{{_itemDrops}}} array, which we iterate over next to display the information to the player.

Note that this code allows the same enemy to drop multiple items, as the loop over {{{itemDrops}}} is not stopped if a drop is found. You will need to change this code if you want different behavior.

Note also that this prints every item individually, even if they're duplicates. This could get cumbersome if you plan to have large party sizes and/or for enemies to drop many items, and it may be worthwhile to figure out a way to lump duplicate items together onto one line for this circumstance.
{{{
<<timed _animationTime>>
	<<for _i, _puppet range $puppets>>
		<<if _puppet.xp >= _puppet.XPtoNext()>>
			<<set _id = "#lv"+_i>>
			<<replace _id>><span style="font-weight:bold"><<print (_puppet.level+1)>></span><</replace>>
			<<set _id = "#lvlupmsg"+_i>>
			<<replace _id>><span style="font-weight:bold; color:cyan">LEVEL UP!</span><</replace>>
		<</if>>
	<</for>>
	<<levelcheck>>
	<<timed 3s>>
		<<goto "Level Check">>
	<</timed>>
<</timed>>
}}}
We then execute this {{{<<timed>>}}} block. It waits for the XP bars' animations to finish, then if the puppet leveled up, it replaces the {{{<span>}}}s we marked earlier with a "LEVEL UP!" message and an update to reflect the puppet's new level.

After another {{{<<timed>>}}} block, to give the player a chance to read and process these messages, the player is forwarded to the "Level Check" passage:
{{{
<<if $LevelUps.length > 0>>
	<<set _p = $LevelUps.shift()>>
	<center><<LevelUp _p>></center>
<<else>>
	<<endofbattle>>
	<<goto $B.destination>>
<</if>>
}}}
If any puppets were added to the {{{$LevelUps}}} queue, they're {{{shift}}}ed out of the list and leveled up. The "Level Up" passage will keep directing the player back here until all level ups are complete, at which point the battle will end and the player will be forwarded to the passage specified by {{{$B.destination}}}. (By default, this is the passage immediately before the battle started, but unique destinations can be specified in the encounter definitions.)

Note that all of this assumes you are using a standard RPG model with XP, levels, and currency rewards after every battle. If you aren't, you may need to change this passage.

<h2 id="actions">Action Mechanics</h2>
{{{
<<widget "actionlist">>
/* Widget for display of player actions. */
/* Individual action widgets take cost, damage multiplier, and other relevant variables as arguments so they can be displayed in the description. Values are given in "Database: Actions". */

<<run console.assert($args.length > 0 && ($args[0] instanceof Puppet),"ERROR in actionlist: no Puppet")>>
<<set _char = $args[0]>>
(...)
<<set _actions = _char.actions>>
<<for _action range _actions>>
<<if $inbattle && !_action.passive>>
	(...)
	<div @class="_actionClass">
	<<capture _action>>
	<<mouseover>>
	<span class="actionName">
	<<if actionStandardCheck(_action)>>
	_action.name<<if (def _action.cd && _action.cd !== 0)>>&nbsp;<span class="cooldowndisplay">[CD <<print _action.cd>>]</span><</if>>
	<<elseif actionLockCheck(_action)>>
	<del>_action.name</del> <span class="dizzy">Dizzy!</span>
	<<elseif actionHPCheck(_action)>>
	<del>_action.name</del> <span class="dizzy">Not enough HP!</span>
	<<elseif actionElementCheck(_action)>>
	<del>_action.name</del> <span class="dizzy">No element.</span>
	<<else>>
		<<link "_action.name">>
			<<actionLink>>
		<</link>>
	<</if>>
	</span>
	<<onmouseover>>
		<<if $COMPRESSED_ACTIONS === true>>
			<<replace '#actionInfo'>>
				<<actionInfo _action _char "full">>
			<</replace>>
		<</if>>
	<<onmouseout>>
		<<if $COMPRESSED_ACTIONS === true>>
			<<replace '#actionInfo'>>
				<<include "action box default">>
			<</replace>>
		<</if>>
	<</mouseover>>
	<</capture>>
	<<if $COMPRESSED_ACTIONS === true && $inbattle>>
		<<actionInfo _action _char "no name">>
	<<else>>
		<<actionInfo _action _char "no name" "full">>
	<</if>>
	</div>

<<elseif !$inbattle>>
	<div class="actionDisplay uncompressed">
		<<actionInfo _action _char "full">>
	</div>
<</if>>
<</for>>
<</widget>>
}}}
The construction of actions is previously discussed in <a class="noExternal" href="#JS.actions">the action database</a>. They are displayed in-game through this widget, found in the "Battle Phases" file. This widget iterates across the "actions" array of a character with a for loop to create the links you use to select actions in the game.
{{{
<<capture _action>>
}}}
Note that before we do anything, we need to {{{<<capture>>}}} the current {{{_action}}} for our code. Links are activated by the user after the page has already rendered, and thus after the loop is finished. If we don't capture our iterator variable, every link will behave based on the data from the last action found by the loop. {{{<<capture>>}}} holds variables within its bounds, so the variable can be used correctly by the link.

<h3 id="actions1">Special Cases</h3>
The default {{{<<else>>}}} case, which determines how things normally look, is listed last, so special cases come first in the code.
{{{
<<if $inbattle && !_action.passive>>
}}}
The first clause handles passive abilities. We don't want to display passive abilities in battle, so we will only run the code for the display if the action's {{{passive}}} property is not {{{true}}}.

We then run into this clause:
{{{
<<if actionStandardCheck(_action)>>
}}}
which refers to this function in {{{1_support_functions.js}}}:
{{{
window.actionStandardCheck = function actionStandardCheck (action) {
	return (temporary().char.en < action.cost)
	|| (typeof(action.uses) == "number" && action.uses < 1)
	|| (typeof(action.cd) == "number" && action.cd !== 0)
	|| (action.used === true)
	|| (action.crisis && temporary().char.crisisPoints < 100);
}
}}}
This is for checking the most obvious cases: When the character has insufficient energy, uses, or cooldown to perform an action, obviously the player shouldn't be able to choose the action. This will also disable "once per turn" actions such as Mage's "Sacrifice" if they have already been used. (Note that we have to check if the action has a defined {{{uses}}} property, because not all of them do, and unexpected behavior could occur if we try to use a comparison operator with an {{{undefined}}} value.)

If the character can't pay the cost, the action's name is displayed as plain text with no special properties. (If you want it to display some other way, you can add your own HTML and CSS to give it a different appearance.)
{{{
<<if (def _action.cd && _action.cd !== 0)>>&nbsp;<span class="cooldowndisplay">[CD <<print _action.cd>>]</span><</if>>
}}}
We also display a cooldown message next to the action's name if it's on cooldown.
{{{
window.actionLockCheck = function actionLockCheck (action) {
	return (temporary().char.dizzy && !action.basic);
}
}}}
The next clause handles the "Dizzy" effect. Most RPGs have a "skill lock" effect that prevents characters from using anything but basic attacks; the example you are probably most familiar with is the "Silence" effect from the <i>Final Fantasy</i> series of games. Since <i>Cartoon Battle</i> had a lot of physical skills, I chose to use the name "Dizzy" instead, implying that the characters could not perform complex actions while disoriented.
{{{
<<elseif actionLockCheck(_action)>>
<del>_action.name</del> <span class="dizzy">Dizzy!</span>
}}}
What this clause says is that if the character's "dizzy" flag is marked true, the action name is crossed out next to a "Dizzy!" message, again with no clickable link -- unless the action is flagged "basic", in which case the {{{!_action.basic}}} conditional will fail and this section will be bypassed.

Despite being functionally identical to the first clause, I chose to make this a separate clause to convey more information to the player. If the action looks the same regardless of whether the character is dizzy or out of energy, the player might be confused about why they're deactivated. Making a different display for each helps the player understand what's going on.
{{{
window.actionHPCheck = function actionHPCheck (action) {
	return (action.hpcost && temporary().char.hp <= action.hpcost);
}

(...)

<<elseif actionHPCheck(_action)>>
<del>_action.name</del> <span class="dizzy">Not enough HP!</span>
}}}
The next case deactivates the link for HP-consuming skills if the character does not have the requisite HP, with a unique message again for clarity for the player. Some games will let characters kill themselves with HP-consuming skills, but I chose to be nice and prevent this possibility in <i>Cartoon Battle</i>. (If the {{{hpcost}}} attribute is undefined this conditional will simply be skipped, so you don't have to worry about defining it for every action.)
{{{
window.actionElementCheck = function actionElementCheck (action) {
	return (action.needsPriorElement && typeof(temporary().char.lastUsed) !== "string");
}

(...)

<<elseif actionElementCheck(_action)>>
<del>_action.name</del> <span class="dizzy">No element.</span>
}}}
Lastly, there's this very specific check I had to make for Artist's abilities. If the action needs to read the user's last used element and no such property exists, the action needs to be disabled.

<h3 id="actions2">The Functional Link</h3>
So what happens when everything's in order, and the player can select the action? That's handled by the final {{{else}}} clause:
{{{
<<else>>
	<<link "_action.name">>
		<<actionLink>>
	<</link>>
<</if>>
}}}
The functionality here is offloaded to a widget:
{{{
<<widget "actionLink">>
	<<if $args.length > 0>>
		<<set _action = $args[0]>>
	<</if>>

<<if !(actionStandardCheck(_action) || actionLockCheck(_action) || actionHPCheck(_action) || actionElementCheck(_action))>>

	<<unset _s>>
	<<if _action.passagejump>>
		<<goto _action.phase>>
	<<else>>
		<<set $action = clone(_action)>>
		<<if !$action.nosave>>
			<<set $B.subject.lastAction = $action.name>>
		<</if>>
		<<set $B.targeting = _action.target>>
		<<set $B.noself = _action.noself>>
		<<if _action.phase is "confirm phase">>
			<<set $B.target = null>>
			<<set $B.targeting = null>>
		<<elseif _action.phase is "spell phase">>
			<<set $B.mincost = _action.cost>>
			<<set $B.targeting = null>>
		<</if>>
		<<replace "#actorlist">><<include "actorlist">><</replace>>
		<<replace "#phase">><<include _action.phase>><</replace>>
	<</if>>

<</if>>
<</widget>>
}}}
This code assigns a <i>clone</i> of the action to the permanent {{{$action}}} variable, or in other words, a copy. As discussed in <a class="noExternal" href="#chain">the {{{<<chain>>}}} widget</a>, what is done to one object variable is done to all variables that reference the same object. So if we were to manipulate {{{$action}}} (such as by modifying the {{{cost}}} attribute for variable-cost spells), we would run the risk of passing on that change to the permanent action in the character's array as well. The clone avoids this problem.

Various other variable adjustments are made, depending on if the action has special properties. If the action is a spell, the link also stores the minimum cost, which will be used later in the spell phase.

After processing is finished, the link forwards the player to the next phase, based on what the action's {{{phase}}} property specified.

<h3 id="actions3">Info Display</h3>
We could stop here, and we'd technically still have a functioning game. However, players wouldn't know what any the actions do! We need to display that information somehow. This is handled through the {{{actionInfo}}} widget.
{{{
<<widget "actionInfo">>
<<run console.assert($args.length > 0 && ($args[0] instanceof Action),"ERROR in actionInfo: no arguments passed")>>
<<if $args[1] instanceof Puppet>>
	<<set _char = $args[1]>>
<</if>>
<<set _act = $args[0]>>
<<if !$args.includes("no name")>><b><<print _act.name>></b><</if>>
<<if def _act.uses>>&nbsp;<span class="usedisplay">(Uses: <<print _act.uses>>/<<print _act.maxUses>>)</span><</if>>
<span style="float:right; margin-left:0.5em;">
<<if $args.includes("full")>>
	<<if !$inbattle && _char.defaultAction.name === _act.name>>
		<b>[Default]</b>&nbsp;
	<</if>>
	<<if _act.crisis>>
		<b>[Crisis]</b>&nbsp;
	<</if>>
	<<if _act.basic>>
		[Basic]&nbsp;
	<</if>>
	<<if _act.instant>>
		[Instant]&nbsp;
	<</if>>
	<<if _act.passive>>
		[Passive]
	<</if>>
<</if>>
<<if _act instanceof ItemAction>>
	x<<print _v.stock>>
<<else>>
	<<if !_act.passive && Number.isInteger(_act.cost) && ((!_act.crisis && _act.cost >= 0) || (_act.crisis && _act > 0))>>
		<<print _act.cost>><<if _act.phase === "spell phase">>+<</if>> EN
	<</if>>
<</if>>
</span>
<<if !$inbattle && !_act.noDefault && _char.defaultAction.name !== _act.name>>
	<div style="font-size:9pt">
	<<capture _act>>
	<<link "[Set as default]">>
		<<set _char.defaultAction = _act>>
		<<replace "#menuActionList">><<actionlist _display>><</replace>>
	<</link>>
	<</capture>>
	</div>
<</if>>
<<if $args.includes("full")>>
	<<if _act instanceof ItemAction>>
		<<set _act = new Item(_act.name)>>
	<</if>>
	<div><<print _act.info>></div>
	<<if _act.desc !== null>><div class="actdesc"><<print _act.desc>></div><</if>>
<</if>>
<</widget>>
}}}
This widget is used for display of actions both in and out of battle, so there are many branches to account for. We will be focusing just on the in-battle branches.

There is additional branching functionality depending on if we want the widget to display the full information of the action, in which case the action is passed the argument "full", or if we only want to display the minimum cruical information.
{{{
<<if def _act.uses>>&nbsp;<span class="usedisplay">(Uses: <<print _act.uses>>/<<print _act.maxUses>>)</span><</if>>
}}}
The action's uses are always displayed after the action name if it's a limited-use action, which we can check with {{{if def _act.uses}}}.
{{{
<span style="float:right; margin-left:0.5em;">
<<if $args.includes("full")>>
	(...)
	<<if _act.basic>>
		[Basic]&nbsp;
	<</if>>
	<<if _act.instant>>
		[Instant]&nbsp;
	<</if>>
	<<if _act.passive>>
		[Passive]
	<</if>>
<</if>>
}}}
We then create an element that is aligned to the right edge of the container. If we're displaying the full action details, we use it to display special tags such as whether the action is basic or instant.
{{{
<<if _act instanceof ItemAction>>
	x<<print _v.stock>>
<<else>>
	<<if !_act.passive && _act.cost !== null>><<print _act.cost>><<if _act.phase is "spell phase">>+<</if>> EN<</if>>
<</if>>
}}}
We will always display the cost of the action (or the stock if it's a usable item). If the action points to the spell phase, it has a variable cost, which is noted with a "+" marker after the cost number.
{{{
<<if $args.includes("full")>>
	<<if _act instanceof ItemAction>>
		<<set _act = new Item(_act.name)>>
	<</if>>
	<div><<print _act.info>></div>
	<<if _act.desc !== null>><div class="actdesc"><<print _act.desc>></div><</if>>
<</if>>
}}}
We then display the action's info and description, but only if we are displaying full information. For usable items, these properties are tied to the item rather than the action, so we need to create an Item object with the same name to correctly reference the data.

Why do we need all these handlers? Because the action list can be displayed two different ways, depending on the player's preference: compressed or uncompressed.
{{{
<<if $COMPRESSED_ACTIONS === true>>
	<<set _actionClass = "compressed">>
<<else>>
	<<set _actionClass = "">>
<</if>>
<div id="actionlist" @class="_actionClass">
<<actionlist $B.subject>>
</div>
<<if $COMPRESSED_ACTIONS === true>>
<br/>
<div id="actionInfo">
</div>
<</if>>

(...)

<<if $COMPRESSED_ACTIONS === true && $inbattle>>
	<<actionInfo _action "no name">>
<<else>>
	<<actionInfo _action "no name" "full">>
	<br/>
<</if>>
}}}
The first block of code is in the "actions" passage. If actions are compressed, the action list's containing element will gain a new class that changes its display to a two-column grid, allowing it to display twice as many actions in the same space. We then display only minimal information for the action rather than a full description to save space.

However, players using the compressed display still need a way to see the full information somehow. How can we do that?
{{{
<<mouseover>>
(...)
<<onmouseover>>
	<<if $COMPRESSED_ACTIONS === true>>
		<<replace '#actionInfo'>>
			<<actionInfo _action "full">>
		<</replace>>
	<</if>>
<<onmouseout>>
	<<if $COMPRESSED_ACTIONS === true>>
		<<replace '#actionInfo'>><</replace>>
	<</if>>
<</mouseover>>
}}}
The answer: with the {{{mouseover}}} macro. This code is wrapped around the action name in {{{actionlist}}}, and will make the action name a mouse-sensitive element. When the player mouses over the action name, we will populate the {{{#actionInfo}}} element with the action's full information using {{{actionInfo}}}. When the mouse leaves the element, the info box will become blank again. (This is why we needed to wrap the {{{capture}}} macro around the whole name display code, rather than just the link.)

<h3 id="crossbow">How does Rogue's crossbow work?</h3>
[img[setup.ImagePath + "documentation/054.PNG"]]
[img[setup.ImagePath + "documentation/055.PNG"]]

When Rogue uses the Crossbow ability, it's replaced by a new ability, Reload, which must be used before Crossbow can be used again. How is this accomplished?
{{{
"Crossbow": {
	"cost":		0,
	"weight":	1,
	"basic":	true,
	"pierce":	true,
	"info":	function (action) {return 	`Attack with a weight of ${action.weight} and ignore defense. Needs reloading after use.`},
	"desc":		`Ah, the marvel of modern technology: while other fools tire themselves out swinging those heavy weapons, Rogue can send death flying through the air with just a twitch of the finger.`,
	"useText": null,
	"actText": function () {
		return `${subject().name} fires their crossbow with a <i>twang</i>.`;
	},
	"act": function () {
		return `<<echoDamage>>`+
		`<<find "$B.subject.actions" "name" "\'Crossbow\'">>`+
		`<<set $B.subject.actions[_pos] = new Action("Reload")>>`;
	},
},

"Reload": {
	"cost":		2,
	"phase":	"confirm phase",
	"basic":	true,
	"invisible": true,
	"info":	function (action) {return 	`Reload crossbow.`},
	"desc":		`...Of course, crossbows also take an age and a half to reload.`,
	"preview": "",
	"act": function () {
		var x = subject().actions.find(function(a) { return a && a.name == "Reload" });
		subject().actions[subject().actions.indexOf(x)] = new Action("Crossbow");
	}
}
}}}
To begin with, observe that these are both defined as separate actions in the action database. This allows us to easily create either a "Crossbow" or "Reload" action as needed. Then, look at the behavior for the Reload action:
{{{
var x = subject().actions.find(function(a) { return a && a.name == "Reload" });
subject().actions[subject().actions.indexOf(x)] = new Action("Crossbow");
}}}
This is a little clunky, but it allows us to locate exactly where the "Reload" action is in the {{{actions}}} array so we can replace it. The position of Crossbow and Reload are fixed in Rogue's actions, but for another character it might be different, or we might want to allow the player to move the order around. This ensures we'll always target the right action.

The principles behind this mechanic are useful if you want to make a game like <i>Final Fantasy VII</i> where skills can be swapped out like equipment.

<h3 id="items">Items</h3>
Items are coded almost exactly the same way as actions. The only real difference is that the link reads the item's {{{action}}} attribute, which is defined exactly the same way as a regular action.

<h3 id="delayed">Delayed Attacks</h3>
You may want to have a delayed attack that requires one or more turns of "charge time" before being executed, during which the character can't do anything else. You can see an example of this in the Jump ability of <i>Final Fantasy</i>'s Dragoon class, or in the banishing and daybreak spells featured in the Marceline fight in <i>Cartoon Battle</i>.

These are bit tricky to implement in this engine, because you will need to keep track of the target between turns, and <a class="noExternal" href="#chain">Twine can't preserve object references.</a> I recommend capturing a unique property of the target instead, such as their name or ID, and saving it to a property of the subject used exclusively for delayed attack targets. Then, on the turn it is to execute, you can find the target again by plugging that attribute into a {{{find}}} function.

In the default engine, there is no initiative order, so the delayed attack should happen immediately at the start of the turn. Run a check to see if any characters are executing a delayed attack (set a flag on the setup action so you can track this), then set the subject, target, and action to whatever is appropriate, and immediately forward the player to the action phase with {{{<<goto "action phase">>}}}. However, you should <b>not</b> use {{{<<newTurn>>}}} for this purpose, as that widget also contains a {{{<<goto>>}}}. Because {{{<<goto>>}}} does not end the passage and all code after it continues to execute, placing a {{{<<goto>>}}} before the end of {{{<<newTurn>>}}} will cause {{{<<goto>>}}} commands to pile up and execute simultaneously, preventing the player from seeing the effects of the action. <b>Use {{{<<specialcheck>>}}} for this purpose instead.</b> Though it is called continuously, so long as you remember to unset the "executing delayed attack" flag, it will only trigger the delayed attack once. The continuous call is also advantageous in the case that multiple characters are using delayed attacks simultaneously, as opposed to {{{<<newTurn>>}}}, which is only called once.

In a system with initiative order, this is simpler, as you would simply execute the delayed attack on the character's turn.

<h2 id="damage">Calculating and applying damage</h2>
Because these widgets are complicated, they are placed in their own twee file, "Damage and Formulas".

The widgets for calculating and displaying damage are separate, due to the need to pre-calculate damage for the {{{<<preview>>}}} widget.

<h3 id="damage.1">Calculating damage</h3>
{{{<<damageCalc>>}}}'s control flow is as follows:
{{{
<<set _w = $action.weight>>
(...)
<<set _atk = ($B.subject.get("Attack") * (1 - $action.useSpecial)) + ($B.subject.get("Special") * $action.useSpecial)>>

/* Piercing? */
<<if $action.pierce>>
	<<set _def = Math.min(_target.get("Defense"),setup.MIN_STAT)>>
<<else>>
	<<set _def = _target.get("Defense")>>
<</if>>
}}}
First, extract some attributes into shorter variable names, for convenience. The attack factor is a weighted average of the subject's Attack and Special stats, determined by the action's {{{useSpecial}}} attribute, which is a number between 0 and 1. An action with a {{{useSpecial}}} of 1 would be completely dependent on Special (as the Attack factor would be multiplied by 0), while an action with {{{useSpecial}}} of 0.25 would only have 25% of its power based on Special.

If the attack is piercing, tracked through the {{{$action.pierce}}} flag, we set {{{_def}}} to a minimum value. Pay attention to what that minimum value is; it can be 0 in a subtractive system, but you're going to run into division by zero errors if you try that in a divisive system.
{{{
<<if !$action.formula>>

<<switch setup.formula>>
	<<case "subtractive">>
		<<set $dmg to ((setup.base+setup.damper*_atk)*_w)-setup.damper*_def>>
	<<case "subtractive lumped">>
		<<set $dmg to (setup.base+setup.damper*(_atk-_def))*_w>>
	<<case "rpgmaker">>
		<<set $dmg to (_atk*4-_def*2)*setup.damper*_w>>
	<<case "divisive">>
		<<set $dmg to (setup.base*(_atk/_def))*_w>>
	<<default>>
		/* add your own here! */
<</switch>>

<<else>>
	<<set $dmg = $action.formula()>>
<</if>>
}}}
Then damage is actually calculated through a call to "damageCalc formula". I've provided functionality for 4 possible formulas, though it's set to "subtractive" by default. The construction behind these damage formulas is discussed in [[the design page|Design]]. You may want to change it for your game. Actions can also have a unique formula, which will be used instead if one is detected.
{{{
<<set _factor = 1; _flatFactor = 0>>
<<if typeof($action.element) == "string">>
	<<set _factor = _target.getElement($action.element,"percent")>>
	<<set _flatFactor = _target.getElement($action.element,"flat")>>
<<elseif $action.element instanceof Array>>
	<<set _factor = 0>>
	<<if setup.AVERAGE_ELEMENTS === true>>
		<<for _v range $action.element>>
			<<set _factor += _target.getElement(_v,"percent")>>
			<<set _flatFactor += _target.getElement(_v,"flat")>>
		<</for>>
		<<set _factor = _factor*1.0/$action.element.length>>
		<<set _flatFactor = _flatFactor*1.0/$action.element.length>>
	<<else>>
		<<for _v range $action.element>>
			<<set _factor = Math.max(_target.getElement(_v,"percent"),_factor)>>
			<<set _flatFactor = Math.min(_target.getElement(_v,"flat"),_flatFactor)>>
		<</for>>
	<</if>>
<</if>>
<<set _baseDmg = $dmg>>
<<set $dmg *= _factor; $dmg -= _flatFactor>>
}}}
We then check for elemental effects. If the action has an element, we'll use it to find the target's affinity value for that element, then apply it to the damage value. (This is checked for both flat additive values and percent-based values.) If there wasn't an element or the target has no associated resistance value {{{_factor}}} will be undefined and cause an error when we attempt to apply it to {{{$dmg}}}, so we start by initializing it to a base value that doesn't affect anything.

There is also a second branch here for the handling of attacks with multiple elements. If you assign an array instead of a string to the action's {{{element}}} property, you can give the action multiple elements that will all be used to calculate the final result. This can work in one of two ways, depending on how you set the {{{AVERAGE_ELEMENTS}}} variable.
{{{
<<if setup.AVERAGE_ELEMENTS === true>>
	<<for _v range $action.element>>
		<<set _factor += _target.getElement(_v,"percent")>>
		<<set _flatFactor += _target.getElement(_v,"flat")>>
	<</for>>
	<<set _factor = _factor*1.0/$action.element.length>>
	<<set _flatFactor = _flatFactor*1.0/$action.element.length>>
}}}
If {{{AVERAGE_ELEMENTS}}} is {{{true}}}, the resulting modifier factors will be the average of each element; for example, if the enemy takes 0.5x damage from Blue and 1x damage from Red, an attack with the property {{{["red","blue"]}}} will inflict 0.75x damage. (Note that we have to multiply the variables by 1.0 in the averaging calculation to ensure the result comes out as a decimal number rather than an integer.)
{{{
<<else>>
	<<for _v range $action.element>>
		<<set _factor = Math.max(_target.getElement(_v,"percent"),_factor)>>
		<<set _flatFactor = Math.min(_target.getElement(_v,"flat"),_flatFactor)>>
	<</for>>
}}}
If {{{AVERAGE_ELEMENTS}}} is not {{{true}}}, we simply pick the best modifier (from the attacker's perspective). For example, if the enemy takes 0.5x damage from Blue and 1x damage from Red, an attack with the property {{{["red","blue"]}}} will inflict 1x damage because that is the higher modifier, ignoring the resistance to Blue completely. (This is how RPG Maker handles multi-element attacks.)
{{{
<<if _baseDmg < $dmg>>
	<<set _elntmsg = setup.elementMessages.weakpoint>>
<<elseif _baseDmg > $dmg && $dmg > 0>>
	<<set _elntmsg = setup.elementMessages.resist>>
<<elseif $dmg < _baseDmg && $dmg == 0>>
	<<set _elntmsg = setup.elementMessages.immune>>
<<elseif $dmg < _baseDmg && $dmg < 0>>
	<<set _elntmsg = setup.elementMessages.absorb>>
<</if>>
}}}
After we're done with the calculation, there is then a check for if the elemental attack hit a weakness or a resistance. If it's a weakness ({{{$dmg}}} is greater than the original damage), we store a message informing the player they hit a weak point; if it's a resistance ({{{$dmg}}} is less than the original damage), we store a message informing the player they hit a resistance; and so on. These messages are defined in {{{StoryInit}}}; by default, they use the messages from <i>Pokemon</i>. This is a means of transparency to the player, to let them know when they've hit a weakness or resistance. You can customize these messages or even remove them entirely if you see fit; you could even expand the code to create a unique message for every element, if you want!
{{{
<<if $B.subject.berserker is true>>
	<<set $dmg *= (1+setup.BERSERK_FACTOR)>>
<</if>>
<<if $B.target.berserker is true>>
	<<set $dmg *= (1+setup.BERSERK_FACTOR)>>
<</if>>
<<if $B.subject.defender is true>>
	<<set $dmg *= setup.DEFEND_FACTOR>>
<</if>>
<<if $B.target.defender is true>>
	<<set $dmg *= setup.DEFEND_FACTOR>>
<</if>>
<<if $B.target.shield is true>>
	<<set $dmg *= (1-setup.SHIELD_FACTOR)>>
<</if>>
}}}
Then there's a call to "damageCalc custom factors", additional factors for modifying the final damage value. In the default engine, that's these effects. (Note that there are two branches each for Berserker and Defender; that's because they affect both incoming and outgoing damage.)
{{{
<<if ($dmg < _baseDmg && $dmg <= 0)>>
	/* If elemental factors pushed damage to 0 or below, we shouldn't bump it up to the minimum; do nothing */
<<elseif _noDmgFloor && $dmg < 0>>
	<<set $dmg = 0>>
	<<set _noDmgFloor = false>> /* preventing data bleed */
<<elseif $dmg < setup.MIN_DMG>>
	<<set $dmg = setup.MIN_DMG>>
<</if>>
}}}
Finally, the widget checks if the final damage value is lower than the minimum damage value. This should probably be a positive value; we don't want to accidentally heal people with our attacks by dealing negative damage, after all. (Unless they absorb the element, of course, so this check is bypassed if that's the case.) Some games will allow 0 damage to occur, but others have minimum damage values. For <i>Cartoon Battle</i>, I chose to be nice and have attacks always deal at least 1 damage, even if that may as well be nothing with the HP values I chose.

There is also a branch here that will set damage to 0 instead of the usual minimum damage through the flag {{{_noDmgFloor}}}. By default, this is used by the "Invincible" status effect, which renders someone immune to damage.
{{{
<<set $dmg = Math.round($dmg)>>
}}}
Finally, we must use the {{{Math.round()}}} function to remove any decimal values.

<h3 id="damage.2">Applying damage</h3>
{{{<<echoDamage>>}}} applies previously-calculated damage and alerts the player to this fact with a message.
{{{
<<if $args[0] instanceof Actor>>
	<<set $B.target = $args[0]>>
<</if>>
}}}
The beginning allows you to apply these effects to a specific target other than the {{{$B.target}}} variable, by passing the character as the first argument to the widget. (Because Puppet and Enemy are subclasses of Actor, they will both fulfill the {{{instanceof Actor}}} evaluation.)
{{{
<<if !($args.includes("indirect") || target().dead) && subject() instanceof Puppet && target() instanceof Enemy && target().protectedBy !== null>>
	<<set _temp = $B.target.name>>
	<<set $B.target = $enemies.find(function(t) { return t && t.id === $B.target.protectedBy; })>>
	<<print $B.target.name+" took the hit for "+_temp+"!\n">>
<</if>>
}}}
Then there's a check for protected characters. If the target is protected by someone, we need to change the target to their protector, and also print a message informing the player of this fact.
{{{
<<if def $bestiary && target() instanceof Enemy && $action.element>>
	<<set $bestiary.fetch(target().name).statsKnown[$action.element] = true>>
<</if>>
}}}
This clause reveals the enemy's elemental affinity to the player if they are struck with an elemental attack. (For more information, see the Bestiary section in [[Additional Features]].)
{{{
<<if !($args.includes("nocalc") || $args.includes("indirect"))>>
	<<damageCalc>>
<</if>>
}}}
For simplicity, {{{<<damageCalc>>}}} is run again here, but you may notice there's a clause to prevent this call if a "nocalc" argument is passed in. This allows functionality for special damaging attacks that don't use the normal damage formula, such as mass attack items. Indirect damage also bypasses this, as indirect damage has no subject and therefore cannot use the standard damage formula.
{{{
<<if !target().dead>>
}}}
Then we do a common-sense check to make sure the target isn't already defeated. There's no point in beating a dead goblin.
{{{
<<if target().shielded && !$args.includes("unblockable")>>
	<<set _shield = target().effects.find(function (eff) { return eff && eff.shield; })>>
	<<if ndef _shield>>
		<<run console.log("ERROR in echoDamage: target is shielded but has no shield effect")>>
	<<elseif _shield.onHit instanceof Function>>
		<<run _shield.uses -= 1>>
		<<print _shield.onHit(target())>>
	<<else>>
		<<run console.log("ERROR in echoDamage: shield effect has no onHit function")>>
	<</if>>
}}}
Certain status effects also interact with direct damage, denoted by providing the "shielded" flag. If the target has the flag, we use the {{{find}}} function to obtain the shielding effect from the character's effects. (Note that {{{find}}} terminates at the first match regardless of how many matches actually exist in the array, so you will need more complex code if you want a strict hierarchy.) We then do a common-sense check to make sure we actually got something; it's not impossible that a coding oversight could make a {{{shielded}}} flag persist even after the shield effect is removed. If we did, we reduce the shield's {{{uses}}} (the number of attacks it can block) by 1 and call the shield's {{{onHit}}} function.
{{{
<<if def _elntmsg>><b><<print _elntmsg>></b><</if>>
<<if $dmg < 0>>
$B.target feeds on the energy, and recovers <<print $dmg*-1>> HP.
<<else>>
$B.target.name takes $dmg damage!
<</if>>
}}}
If {{{_elntmsg}}} exists (which is to say, the element mattered), it's displayed before the damage message. You can move it elsewhere if you prefer. I also chose to make a totally separate message for absorbing an attack, because <i>[Name] takes -10 damage!</i> would probably look very confusing to a player even if it does give you the information you need.
{{{
<<set $B.target.hp -= $dmg>>
(...)
<<deathcheck>>
}}}
And now we apply damage. Since absorbed damage is negative, {{{$B.target.hp -= $dmg}}} will work for all cases and doesn't require multiple clauses. After, we run {{{<<deathcheck>>}}} to apply the "dead" flag if the character has fallen below 0 HP.
{{{
<<if target().offbalance && $dmg >= 0>>
	<<addEffect $B.target "Knocked Down" -1>>
<</if>>
}}}
But wait, there's more! After taking damage, the character is checked for the "Off-Balance" effect. If they have it, they gain a new "Knocked Down" effect. (As discussed in <a class="noExternal" href="#effects1">Applying Effects</a>, this will also remove the Off-Balance effect, but this functionality is built in to {{{<<addEffect>>}}}.) I chose to disallow this if the attack was absorbed, since logically you shouldn't be hurt by getting healed, but you could remove the clause if you think that's more logical.

Note that this check will not run for indirect damage, nor if the target has died from the attack.

<h4 id="dmgreflection">Damage Reflection</h4>
Some RPGs feature "damage reflection", which inflicts damage on an attacking character equal to the damage they dealt (or some proportion thereof). That's also handled through this widget.
{{{
<<if target().dmgreflection && !_dmgreflecting && target() !== subject() && $dmg > 0>>
	<<set $dmg = Math.round($dmg * target().dmgreflection)>>
	<<set _OG = {target: $B.target, subject: $B.subject}>>
	<<set $B.target = _OG.subject; $B.subject = _OG.target>>
	<<set _dmgreflecting = true>>
	<<echoDamage "nocalc">>
	<<set $B.target = _OG.target; $B.subject = _OG.subject>>
	<<unset _OG; _dmgreflecting>>
<</if>>
}}}
Immediately after damage is applied to the target, we check if the target has a defined {{{dmgreflection}}} property. If it does, we calculate a new {{{$dmg}}} proportional to the target's {{{dmgreflection}}} value. (So, for instance, a {{{dmgreflection}}} of 1 would reflect all of the original damage, a {{{dmgreflection}}} of 0.5 would reflect half, etc.) We make sure to deactivate this clause if the subject is attacking itself, because being hit with your own damage reflection does not make logical sense and is liable to generate an infinite loop.
{{{
<<set _OG = {target: $B.target, subject: $B.subject}>>
<<set $B.target = _OG.subject; $B.subject = _OG.target>>
<<set _dmgreflecting = true>>
<<echoDamage "nocalc">>
<<set $B.target = _OG.target; $B.subject = _OG.subject>>
}}}
We then have to apply the damage to the attacker, the previous subject -- but wait! There are other effects that could occur after this action that are supposed to apply to the original target and subject. That means we have to store them in a temporary holder variable and set them back to the originals when we're done. We also set the {{{_dmgreflection}}} flag, which prevents further damage reflection within this action. This prevents an infinite loop from occurring if a damage reflector attacks another damage reflector.

We then apply the damage with a recursive call to {{{<<echoDamage>>}}}. You could bypass all of this by just applying the damage to the {{{subject}}} directly here, but the default engine chooses to run {{{<<echoDamage>>}}} for thoroughness, in case complications like the Bubble and Off-Balance effects are in play. (Note that reflected damage IS considered direct damage, for precisely this purpose.)

<b>NOTE:</b> {{{<<deathcheck>>}}} is only run <i>after</i> this section, which means a damage reflector will still reflect damage even if they're defeated by the attack. You can move it if you want different behavior.

<h4 id="dmg.onhit">onHit</h4>
{{{
<<if target().onHit instanceof Array && target().onHit.length > 0 && !_dmgreflecting && target().id !== subject().id>>
/* If target has onHit functions, they are executed here. Note that the target and subject are not reversed here, so if you want the effect to target the attacker, use "subject" as the selector, and vice versa. */
	<<for _action range target().onHit>>
		<<if _action instanceof Function>>
			<<print _action()>>
		<<else>>
			<<run console.log("ERROR in onHit: onHit elements must be functions")>>
		<</if>>
	<</for>>
<</if>>
}}}
After attack reflection, we check for {{{onHit}}} effects. {{{onHit}}} effects are functions added to a character's {{{onHit}}} property, and they will execute here. These can be things like a toxic slime monster poisoning anyone who touches it, or Experiment 01 compelling hatred on anyone who attacks. These functions cannot be triggered by damage reflection or by a character attacking itself.

<i>(Note that {{{onHit}}} functions are distinct from counterattacks. Counterattacks are full actions that are executed after the initial action is completely resolved. These functions are resolved within the current action as part of damage application.)</i>

<h4 id="dmg.shock">Shock cures</h4>
After {{{<<deathcheck>>}}} but before the knockdown check, we check for shock cures. "Shock", in this case, refers to direct damage. In some RPGs, certain status effects like sleeping or confusion can be cured by direct damage, and this functionality is applied here.
{{{
<<if !$action.noShock>>
	<<for _effect range target().effects.filter(function (eff) { return eff && Number.isInteger(eff.shock)})>>
		<<set _shock = random(1,100)>>
		<<if _shock <= _effect.shock>>
			<<print target().removeEffect(_effect)>>
		<</if>>
	<</for>>
<</if>>
}}}
First we check to make sure the action does not have a {{{noShock}}} flag. This flag will prevent the action from triggering shock cures if it is {{{true}}}. (As an example, most RPGs only wake sleeping characters when they are struck by physical attacks, not by magic.) If not, we run a loop over the target's effects that have a {{{shock}}} property that is an integer value. (Any noninteger values for {{{shock}}} will be converted through a getter function into a Boolean {{{false}}} and fail this check.) We then roll a percentile die and check if we rolled under the effect's {{{shock}}} value. If yes, the effect is cured, and we run {{{removeEffect}}}, making sure to {{{<<print>>}}} the resulting removal message so the player knows what happened. (This means that a {{{shock}}} value of 100 will always result in a cure from direct damage. A Boolean value of {{{true}}} assigned to the effect's {{{shock}}} property will be converted to this value.)

Because we use a loop for this check, all viable effects will be checked, meaning it is possible for multiple effects to be removed by the same attack.

<h4 id="dmg.counters">Setting up counterattacks</h4>
This widget also sets up counterattacks.
{{{
	<<if !(_dmgMods.includes("indirect") || _dmgMods.includes("nocounter") || _counterActive || target().dead || target().noact || target().retaliations === 0 || target() === subject())
		&& _counters instanceof Array
		&& !_counters.includes(target().id)
		&& target().counter instanceof Action>>
		<<if target().counter.trigger>>
			<<run _counters.push(target().id)>>
			<<run $B.actionQueue.push([target().id,target().counter])>>
			<<if target().retaliations > 0>>
				<<set target().retaliations -= 1>>
			<</if>>
		<</if>>
	<</if>>
}}}
The first conditional does a lot of checks to see if we can use counters at all. To prevent infinite "countering counters" loops, we disallow this if there is already a {{{_counterActive}}}. Then, unlike with damage reflection, we will prevent the enemy from countering if they're dead or under a hold effect. The target must also have a nonzero number of retaliations, and the target must not be attacking itself. We will also disallow counters to indirect damage. With those checks passed, the {{{_counters}}} variable must exist and be an array, the target must not already be held in said array, and the target must have an Action stored in its {{{counter}}} attribute. Whew! That's a lot, but it's mostly just to confirm we don't have any {{{undefined}}} variables before proceeding.
{{{
<<run _counters.push(target().id)>>
<<run $B.actionQueue.push([target().id,target().counter])>>
<<if target().retaliations > 0>>
	<<set target().retaliations -= 1>>
<</if>>
}}}
If all is well, we add the target's ID to the {{{_counters}}} array, and reduce their {{{retaliations}}} by 1. (Only if it's above 0 to start with, though -- if you set it to a negative number, the enemy can make unlimited counterattacks.) Note that the counterattack doesn't happen here -- we're only storing data that will be read later in <a class="noExternal" href="#actionqueue">the action queue</a>.
{{{
<<if target().counter.trigger>>
}}}
We also have this check. Counterattacks can also have a {{{trigger}}} attribute that determines when they will trigger. In <i>Pokemon</i>, for instance, there are some counters that only trigger on attacks that make contact; ranged attacks are safe. Or perhaps you want a counter to trigger <i>only</i> on ranged attacks? Only if the character is struck by an elemental weakness or resistance? There are lots of possibilities. You can define a custom {{{trigger}}} function in your counter action and have it return {{{true}}} only when the counter should be activated. By default, an undefined {{{trigger}}} always returns {{{true}}}, so this clause will always execute.

<h2 id="effects">Status Effects</h2>
Status effects are a common feature of RPGs, and give them greater tactical depth. They do things like temporarily changing your stats, or affecting what actions you can use.

In Another RPG Engine, status effects for each character are stored in an array, defined in the story JavaScript as an attribute of the <b>Actor</b> class. Most aspects of status effects are defined in the effect database, but the logic for applying an effect is handled through a set of functions defined in {{{effect-manager.js}}}.

<h3 id="effects1">Applying effects</h3>
You would think that adding effects to a character is just a matter adding the effect to the character's {{{effects}}} array, using an {{{Array.push()}}} command. But what if we want some rules for how effects are applied? Do we want players to be able to apply multiple copies of the same effect, or can only one instance be active at a time? Perhaps we want that rule applied to some effects, but not all?

Resolving these questions is the purpose of the {{{addEffect}}} function.
{{{
Actor.prototype.addEffect = function (name,mods) {
}}}
Adding effects is, fundamentally, something we do to {{{Actor}}} objects, so we will add the effect addition function to {{{Actor}}}'s <i>prototype</i>. Object prototypes contain properties shared by all instances of an object; the details are rather complicated, but all you need to understand in this case is that this code is functionally the same as defining this as a method function in the class definition. Doing it this way is a bit more awkward, but allows you to modify these functions modually without needing to redo the entire class definition.

We're going to start with a few preliminary things:
{{{
E = new Effect(name);
}}}
We want to make an Effect object using just the effect's name. This is because the object's getter functions take care of some things for us based on the name, as can be seen in {{{database-effects.js}}}:
{{{
"Injury": {
	"stackable": true,
	"statmod": true
}}}
Attributes such as {{{stackable}}} will be useful to divide effects by desired behavior.
{{{
if (!this.dead || E.persistAfterDeath)
}}}
Then a common sense check: no point in applying effects to dead people, unless you want that. Some games, such as <i>Final Fantasy XII</i>, do have some status effects persist past unconsciousness and revival, and this feature is enabled through the {{{persistAfterDeath}}} attribute.
{{{
let found = false;
let power;
let subj;
subj = mods.actor instanceof Actor ? mods.actor : subject();
}}}
Our last preliminary action is to initialize these variables. We will reference them later.

<h4 id="effects1.1">Accounting for protective effects</h4>
{{{
if (!(E.unblockable || mods.unblockable === true)) {
	if (!E.buff) {
		$.wiki('<<shieldCheck>>');
		if (temporary().hit === false) {
			return "";
		}
	}

	this.effects.filter(function (e) { return e && e.block })
		.sort(function(a,b) { return a.priority - b.priority; })
		.forEach(function (effect) {
			if (effect.blockCondition(E)) {
				this.addPopup({shake: false, type: "block", content: "BLOCKED"});
				return effect.blockText(this)+"\r\n";
			}
		},this);
}}}
First, we need to check if we can apply the effect at all. There are two things that can block an effect outright: <i>shield</i> and <i>block</i> effects.

As you should recall from [[Documentation (Basic)]], shield effects block a set number of attacks; this includes applications of negative effects, so we need to include a check for that. We do this through an invocation of {{{shieldCheck}}}, which will set the variable {{{_hit}}} to {{{false}}} if a shield blocked the attack. If it did, we end the function immediately by returning an empty string.

Block effects are different: they will block all applications of a certain type of effect as long as they are active. (In the default engine, there are three such effects: <b>Alert</b>, which protects against Stunned; <b>Chi Shield</b>, which protects against all negative ailments; and <b>Stasis</b>, which prevents any changes to effects at all.) We check for these effects by filtering the character's effects array to only return effects with the {{{block}}} property, and then running over the results with a {{{forEach}}} loop. If the effect to be applied satisfies the effect's {{{blockCondition}}}, it is blocked, and we end the function immediately by returning the block effect's {{{blockText}}}.
{{{
.sort(function(a,b) { return a.priority - b.priority; })
}}}
But what happens if this character has <i>multiple</i> block effects? How do we decide which ones we should test first? For example, since Stasis blocks all effects but Chi Shield only blocks some, it probably makes more sense for Stasis to take precedence. We can do this by sorting the array in order of the effects' {{{priority}}} properties before the final loop.
{{{
let n = (E.synonym || E.name);
if (this.tolerances.get(n).current != 0 && !mods.pierceImmunity) {
	(...)
	if (mods.pierceTol === true && this.tolerances.get(n).current > 0) {
		this.tolerances.get(n).currentVal = 0;
	}

	if (this.getTol(n) === -1) {
		this.addPopup({shake: false, type: "block", content: "IMMUNE"});
		return `${this.name} is immune to ${name}.`+"\r\n";
	}
	else if (this.getTol(n) > 0) {
		this.decTol(n);
		this.addPopup({shake: true, type: "block", content: "RESISTED"});
		return `${this.name}'s tolerance to ${name} was weakened.`+"\r\n";
	}
	else if (this.getTol(n) === 0) {
		this.resetTol(n);
	}
}
}}}
If the effect makes it through protective effects, it is then checked against the target's tolerances. {{{if this.tolerances.get(n).current != 0}}} checks if the target has a tolerance for the status effect at all; if they don't, we can ignore this entire check. (Recall from <a class="noExternal" href="#JS.tolerances">the Tolerance class</a> that a negative {{{current}}} value in a Tolerance conveys immunity, while a positive value conveys resistance; a value of 0 means the target has no tolerance.) Otherwise, we check what the current tolerance value is. If it's -1, the target has an immunity, and we end the function by returning a message informing the player of this fact. Otherwise, we go on to check if it's above 0. If it is, the same thing happens, but the target's tolerance is decreased by 1 through the {{{decTol}}} function. If a tolerance has been exhausted, the program skips to the {{{else}}} clause, resets the tolerance, and applies the effect as normal.

The preceding {{{let n = (E.synonym || E.name)}}} line is for when we want certain effects to have entangled tolerances. In the default engine, one example is the "Forsaken" effect: Because it is a derivative of the "Curse" ability, I chose to have the same tolerance apply to both. For this to work, we need to alter the variable used to check against the target's tolerances: if the effect is Forsaken, we check against Curse tolerance rather than Forsaken tolerance. In all other cases, {{{n}}} becomes the same as the effect's name, and everything proceeds as expected.

<h4 id="effects1.2">Numerical components</h4>
{{{
power = typeof(mods.power) == "number" ? power = mods.power : E.calculatePower(this,subj);
}}}
Some effects only operate in binary, but some have variable, numerical components. For instance, take a stat-modifying effect. How do we calculate exactly how much the stat will be changed? You could implement it as a flat rate, such as a 50% boost or penalty. Many RPGs, such as the <i>Final Fantasy</i> series, do this. But what if we wanted to do something more complex, where the numerical component depends on something like the caster's Special stat? In that case, we'll need to calculate it every time the effect is applied.

This is handled by a different function, this time applied to the {{{Effect}}} prototype:
{{{
Effect.prototype.calculatePower = function (target,subject) {
  (...)
  let power;
  let check = this.buff ? setup.min_buff : setup.min_debuff;

  if (subject.stats["Special"] !== undefined) {
    if (this.statmod) {
      let def = this.buff ? 0 : target.get("Special");
      power = Math.round(
        (setup.effbase + setup.effdamper * (subject.get("Special") - def)) * action().effweight);
    } else if (this.dot) {
      return subject.get("Special");
    }
  }
  else {
    power = (this.effectData.power || 0);
  }

  return Math.max(power,check);
}
}}}
There are slightly different formulas for buffs, debuffs, and damage-over-time effects. Debuff power is reduced by the target's Special, while buffs are not. Damage-over-time effects simply return the subject's Special. (These are the default formulas, but they can be changed if you wish.)

If you'd rather just set the effect's power as a flat number, you can do this by passing it as the {{{power}}} attribute of the {{{mods}}} object in {{{addEffect}}}.

<h4 id="effects1.3">Exclusivity</h4>
The next checks are for effects that have limits on how many instances can be present at once. We start with the broadest exlusivity work our way to the most narrow.
{{{
if (E.unique) {
	this.ownParty.filter(function (a) { return a && a.name !== this.name },this).forEach(function (actor) {
		actor.removeEffect(E.name,{pierce: true, unsticky: true, removeStack: true, noPopup: true});
	});
}
}}}
First, we check for {{{unique}}} effects. Unique effects are limited to one effect per the entire party. (In the default engine, only the "Martyr" effect has this property; because Martyr draws all attacks that would otherwise be directed against other characters, it would be illogical for multiple characters to have Martyr at once -- which one would take precedence?) This is done by simply looping over the character's party and running {{{removeEffect}}} for the named effect. ({{{removeEffect}}} does nothing if the passed effect name is not present, so we don't have to worry about errors.) This loop excludes the current character themselves so that the effect is not removed if they currently have it.
{{{
if (E.exclusive) {
	this.effects.filter(function (e) { return e && e.exclusive}).forEach(function (effect) {
		this.removeEffect(effect,{pierce: true, unsticky: true, noPopup: true});
	},this);
}
}}}
Next, we check for {{{exclusive}}} effects. No two effects with this property can exist on the same character at once. This means that if we are applying a new exclusive effect, we have to remove any others that already exist on the character. We do this by filtering the character's {{{effects}}} to only exclusive effects, then run over the results and remove every one.
{{{
if (!E.stackable)
}}}
Then we have to do this check. Some effects are "stackable", which means multiple copies of the same effect can exist on a character; these can be added without further complications. Non-stackable effects, however, require more work.
{{{
found = this.effects.find(function (e) { return e && e.name === name});
if (found instanceof Effect) {
	found.duration += dur;
	if (found.dot) {
		E = new Effect(name,dur,power,{weight: action().effweight});
		if (E.damage(this) > found.damage(this)) {
			found.power = power;
			found.weight = action().effweight;
		}
	} else if (power > found.power) {
		found.onRemove(this); found.power = power; found.onApply(this);
	}
	(...)
	return E.addText(this.name)+"\r\n";
}}}
Obviously, we start by searching for a matching effect. If we don't find anything, we can ignore the rest of this; but otherwise, we have more to do. The existing effect's duration will be increased by the duration of the effect to be applied, and its power will be replaced if the effect to be applied would have higher power. (We will need to run {{{onRemove()}}} and {{{onApply()}}} in-between adjusting the power, because we need to clear the effects of the old value before recalculating.)
{{{
if (found.dot) {
	E = new Effect(name,dur,power,{weight: action().effweight});
	if (E.damage(this) > found.damage(this)) {
		found.power = power;
		found.weight = action().effweight;
	}
}
}}}
...For normal effects, that is. Damage-over-time effects are more complicated, because there are more factors at play than just their raw power. We have to create a fully-functional effect out of the effect to be applied, and simulate what its damage would be compared to the existing damage-over-time effect. Only if the resulting damage is higher will the power be replaced.
{{{
return E.addText(this.name)+"\r\n";
}}}
Once that's all done, we still return the effect's {{{addText}}} as if it had been applied normally, so that the player doesn't get confused.
{{{
if (name === "Off-Balance" && this.down) {
	return `${this.name} would have been pushed off-balance, but ${this.theyre} already knocked down!`+"\r\n";
}

if (name === "Knocked Down") {
	this.removeEffect("Off-Balance",{pierce: true, noPopup: true});
}

if (E.dot) mods.weight = action().effweight;
if (name === "Protector") {
	mods.target = target();
	target().protectedBy = this.id;
}
}}}
Finally, we have some special handlers for certain effects. Getting knocked down removes Off-Balance, Protector needs to record both who's protected and who's doing the protecting, etc.
{{{
this.effects.push(E);
E.onApply(this);
}}}
It's only after all this is done that we finally {{{push}}} our new effect. We must also run {{{onApply()}}} to ensure that any effects it has, such as stat modifications, are applied.
{{{
var text = E.addText(this.name);
(...)
return text;
}}}
We end by returning the effect's addition message. Returning text in this way allows us to use it with the {{{<<print>>}}} macro to display it in Twine in a single line of code.

<h3 id="effects.calc.dot">Damage-over-time effects</h3>
Damage-over-time calculation is handled through the effect database. Before the definitions for each effect, several functions are defined in the Effect class definition:
{{{
var physical = function (puppet) {
	return this.weight*(setup.base + (setup.damper * (this.power - puppet.get("Defense"))));
}
var special = function (puppet) {
	return this.weight*(setup.base + (setup.damper * (this.power - puppet.get("Special"))));
}
var piercing = function (puppet) {
	return this.weight*(setup.base + (setup.damper * this.power));
}
var proportional = function (puppet) {
	return this.weight * puppet.maxhp;
}
var fixed = function (puppet) {
	return this.power;
}
}}}
In the default engine, there are five kinds of DoT behaviors: physical, special, piercing, proportional, and fixed. Physical damage, used by the "Burning" effect, is reduced by the target's Defense; special damage, used by the "Poisoned" effect, is reduced by the target's Special; piercing damage, used by the "Peridition" effect, ignores defenses; proportional damage inflicts damage based on a proportion of the target's max HP; and fixed damage is just whatever you set as the object's power value.

(Note that proportional damage <b>multiplies</b> HP by its weight. The weight of a proportional effect is equal to the proportion it takes off; a weight of 0.125 or (1/8) will take an eighth of the character's HP per turn.)

The actual application of damage is performed through the {{{damage()}}} function of the DoT class, which is defined later in the database file:
{{{
window.DoT = class DoT extends Effect {
	constructor(name,time,power,weight){
		super(name,time,power);
		this.weight = weight;
		this._dot = true;
		this.damage = function (puppet) {
			var dmg = Math.round(this.dmgtype(puppet));
			if (dmg < setup.min_DoT){
				dmg = setup.min_DoT;
			}
			return dmg;
		}
	}
}
}}}
This function is passed a target that is then used to calculate damage based on the formula type, followed by cleanup -- rounding to an integer, and checking against the minimum DoT damage. (This value is set to 1 by default, and can be changed in StoryInit.)

<h3 id="effects.loss">Loss-of-control Effects</h3>
Loss-of-control effects are status effects that allow the character to continue acting, but take control away from you, causing them to instead act under an AI routine. You may be familiar with these from the "Berserk" and "Confusion" effects in many RPGs.

In this engine, we handle these effects through a passage included in {{{<<specialcheck>>}}}, which is called constantly during battle:
{{{
<<set _u = $puppets.find(function (p) { return (p.uncontrollable && !(p.isDone || p.noact || p.dead)); })>>
<<if def _u>>
	<<set $B.subject = _u>>
	<<if subject().name == "Mage">>
		<<set $action = new Action("Blast")>>
	<<elseif subject().name == "Witch">>
		<<set $action = new Action("Pox")>>
	<<else>>
		<<set $action = clone(subject().defaultAction)>>
	<</if>>
	<<if subject().en < $action.cost>>
		<<set subject().isDone = true>>
		<<goto "Battle!">> /* necessary to find other potential uncontrollables */
	<<else>>
		<<if _u.confusion>>
			<<set $B.target = Hitlist.targetEnemy(["any"])>>
		<<elseif _u.charmed>>
			<<set $B.target = Hitlist.targetEnemy(["allies"])>>
		<<elseif _u.hatred>>
			<<set $B.target = Hitlist.targetEnemy(["enemies"])>>
		<</if>>
		<<goto "action phase">>
	<</if>>
<</if>>
}}}
This code finds the first puppet who has been marked "uncontrollable" (excluding, of course, puppets who are done, paralyzed, or dead). If no such puppet is found, {{{_u}}} will be undefined and the rest of this code will be ignored. If a puppet is found and stored in {{{_u}}}, we make it the active subject, set the active action to its default attack, and forward them to the action phase, forcing them to attack. (For most cases we can use the puppet's {{{defaultAction}}} for this, but Mage and Witch have nondamaging default actions, so we need special handlers for them.)
{{{
<<if subject().en < $action.cost>>
	<<set subject().isDone = true>>
	<<goto "Battle!">> /* necessary to find other potential uncontrollables */
}}}
Of course, we need to be mindful of action limitations. Basic attacks aren't free in the default system, so it's possible an uncontrollable character is unable to pay the cost. There are a lot of ways you can handle this eventuality, but for simplicity, I just end the character's turn. We then have to refresh the passage so we can run this check again, in case there's another uncontrollable puppet. (The {{{find}}} function only finds the <i>first</i> element that matches its criteria, not all of them.)
{{{
<<if _u.confusion>>
	<<set $B.target = Hitlist.targetEnemy(["any"])>>
<<elseif _u.charmed>>
	<<set $B.target = Hitlist.targetEnemy(["allies"])>>
<<elseif _u.hatred>>
	<<set $B.target = Hitlist.targetEnemy(["enemies"])>>
<</if>>
}}}
The puppet needs a target before they can attack, also. That's handled through the {{{Hitlist.targetEnemy}}} function (see <a class="noExternal" href="#targeting.basic">Standard Targeting</a>), with branches for specialized behavior depending on the exact effect the puppet is under. Confused puppets can target anyone, charmed puppets will only target their allies, and hateful puppets will only target their enemies. The effects will also take precedence in that order, a necessary feature if the puppet is under multiple loss-of-control effects simultaneously.

This is a pretty bare-bones functionality. For more discussion on these effects and what you can do with them, see [[Design]].

<h2 id="targeting">Targeting and Enemy AI</h2>
Enemies need to be able to select attacks and targets just like players. But unlike with player choices, there's no person to make selections, so we need a program to do it instead.

We could just have enemies choose actions and targets randomly, but that wouldn't make for a very engaging game; the difficulty of a battle will vary depending on whether enemies target a more vulnerable character, if they gang up on one character or if they spread damage out... etc. If that's all random, the game isn't very fair; a player might do the exact same thing and get a completely different result, just because, say, Mage never got targeted through the simple luck of the draw. So we want to make enemies a bit more intelligent, to make the player's experience more even. We also need a way to determine behavior for player characters under <a class="noExternal" href="#effects.loss">loss-of-control effects</a>.

The functions used to accomplish this are stored in their own file, {{{targeting.js}}}.

<h3 id="hitlist-class">Making a Hitlist</h3>
Targeting is governed through the {{{Hitlist}}} class, which is defined in {{{targeting.js}}}. {{{Hitlist}}}s are specialized arrays that contain a list of battling characters, with functions to select which of them becomes a target. However, rather than adding the characters as you would to a normal array, we use another function, {{{Hitlist.addTarget}}}. This function is called when a {{{Hitlist}}} is made, but can also be called at any point afterwards.
{{{
function addTarget (target,mods) {
	(...)
	if (target instanceof Actor) {
		var initChance = 1;
		(...)
		if (
				!target.dead &&
				!(mods.includes("noself") && target == subject()) &&
				(target.martyr || mods.includes("ignore untargetable") || !target.untargetable)
				) {
			this.push({target: target, chance: initChance});
		}
	}
	(...)
}
}}}
The purpose of this function is to ensure that all targets are initialized using the same rules. Dead and untargetable targets are ignored, except for certain special cases. (We can pass {{{mods}}} to the function to take specify if these exceptions should apply; note that {{{mods}}} must be an array, or it won't work.) We can also see here that the {{{Hitlist}}} contains not just the character object itself, but a corresponding {{{chance}}} value for each as well. This value is used to determine the likelihood of being targeted; higher values are more likely. Everyone starts on even ground, with an initial chance of {{{1}}}. (Or their threat value, if <a href="#targeting.threat">threat targeting</a> is used.)
{{{
returnTarget (mods,bypass) {
	(...)
	for (let t of this) {
		if (t.target.martyr && !t.target.dead && !(mods.includes("ignore martyr") || mods.includes("ally"))) {
			return t.target;
		}
		if (t.target.dead || (t.target.untargetable && !(mods.includes("ignore untargetable") || mods.includes("ally")))) {
			t.chance = 0;
		} else if (bypass !== true) {
			if (t.target.firefly) {
				t.chance *= setup.FIREFLY_FACTOR;
			}
			if (t.target.wallflower) {
				t.chance *= setup.WALLFLOWER_FACTOR;
			}
		}
	}

	i = 0;
	while (i < this.length) {
		if (this[i].chance > 0) i++;
		else this.splice(i, 1);
	}

	(...)

	var chance = this.map(function (t) { return t.chance });
	const total = chance.reduce((a, c) => a + c, 0);
	this.forEach((el, i) => el.chance = el.chance/total, this);

	var i, sum=0, r=Math.random();
	for (i of this) {
		sum += i["chance"];
		if (r <= sum) return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods);
	}
	temporary().targetfail = true;
	console.log(`ERROR in returnTarget: failed to find target. Likely cause is empty hitlist; check targeting logic.`);
	console.log(`Echoing hitlist for verification.`);
	console.log(this);
	return;
}
}}}
The other half of this is what we want to come <i>out</i> of our {{{Hitlist}}}. For that, we use this function, {{{returnTarget}}}. If there's a martyr in the {{{Hitlist}}}, it will just return that immediately and we'll be done (unless you pass an "ignore martyr" mod). Otherwise, it will automatically apply the factors from Firefly and Wallflower, and remove any untargetables that managed to slip through.
{{{
var chance = this.map(function (t) { return t.chance });
const total = chance.reduce((a, c) => a + c, 0);
this.forEach((el, i) => el.chance = el.chance/total, this);

var i, sum=0, r=Math.random();
for (i of this) {
	sum += i["chance"];
	if (r <= sum) return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods);
}
}}}
Then it's time to actually choose a target. To make this easier on our random number generator, we standardize all the {{{chance}}} values to a proportion of the total {{{chance}}} of all targets. For instance, if we had a chance array of {{{[1,2,1]}}}, this would reduce it to {{{[0.25,0.5,0.25]}}}, corresponding to the percent chance of each being selected. With that, we can use {{{Math.random}}} to generate a random number between 0 and 1, then if it's less than or equal to a character's {{{chance}}} value, they're the target! (Note that we have to keep a running total of the {{{chance}}} values and compare against that rather than the individual {{{chance}}}s; otherwise, a high random value would result in nobody being selected.)
{{{
return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods)
}}}
However, we don't just return the target straight: We also run them through two more functions, {{{Hitlist.guardCheck}}} and {{{Hitlist.protectionCheck}}}. These check if the character is being guarded by a front-row character or someone with the Protector effect, respectively, and reassign to the correct target if so.
{{{
temporary().targetfail = true;
console.log(`ERROR in returnTarget: failed to find target. Likely cause is empty hitlist; check targeting logic.`);
console.log(`Echoing hitlist for verification.`);
console.log(this);
return;
}}}
However, we must not succumb to the hubris of assuming our code will always work! In case something strange happens and a target couldn't be found (such as if we tried to call this on an empty hitlist), the loop will terminate without executing the {{{return}}} statement, and this code will run. It flags {{{_targetfail}}} to avoid errors on the player's end, and logs some details to the console for debugging.

The purpose of defining these functions here, instead of in enemy AI or other logic functions, is to standardize them. You don't have to remember to manually initialize everyone's {{{chance}}} values, or to exclude untargetables, or to run protection checks. You can populate and modify the {{{Histlist}}} with specific logic, and then trust that the fundamental selection rules will always work as intended.

Let's look at some of those logic functions now that we know the basics:

<h3 id="targeting.basic">Standard Targeting</h3>
Regular targeting is handled by the {{{Hitlist.targetEnemy}}} function.

The first thing to note here is that this is a <b>static</b> function, which means it functions differently than most method functions. Method functions are usually called on an existing object of their class, and can use {{{this}}} to reference that object. Static functions, by contrast, are attached to <i>the class itself</i>, and can be used anywhere as long as that class is referenced. Practically, this means that you must always preface your function calls with {{{Hitlist.}}} for them to work.
{{{
if (deadCount() == puppets().length || enemies().filter(function (e) { return e.dead; }).length == enemies().length) {
	temporary().targetfail = true;
	return null;
}
}}}
In the function itself, the very first thing we have to do is check if all the characters in a party are already defeated. This can happen if the party is wiped in the middle of the turn or a multi-hit attack. Since dead characters can't be targeted, we'll run into an error if we try to run the widget in this state. So instead, we set a {{{_targetfail}}} flag and end the widget here.
{{{
var mods = [];
if (args instanceof Array) {
	mods = args;
} else if (typeof(args) == "string") {
	mods = [args];
}
}}}
Then we do some processing on the arguments passed to the function. Later logic will assume {{{mods}}} is an array, but I give you a little leeway: if you only passed a single string, it will get turned into a one-element array for compatibility with the rest of the function.
{{{
if (subject().uncontrollable) {
	if (mods.includes("any")) {
		let selector = random(1,2);
		switch (selector) {
			case 1:
				party = V().puppets;
				break;
			case 2:
				party = V().enemies;
				break;
		}
	}
	else if (mods.includes("enemies")) {
		party = subject().otherParty;
	}
	else if (mods.includes("allies")) {
		party = subject().ownParty;
	}
}
}}}
Next, remember that we use this widget for both enemies <i>and</i> puppets. If the subject is under a loss-of-control effect, their target party is variable. We determine the target party from the first argument passed to the widget, or we flip a coin if the argument is "any".
{{{
if (!mods.includes("ignore untargetable")) {
	let untargetTest = party.filter(function (p) { return (p.dead || p.untargetable) });
	if (untargetTest.length == party.length) {
		mods.push("ignore untargetable");
	}
}
}}}
With the target party found, we have to do a quick check for untargetables. If the only living targets are untargetable, we have to add the mod "ignore untargetable" so they can be selected; otherwise, the attack will whiff.
{{{
var hitlist = new Hitlist(party,mods);
}}}
Then we make a {{{Hitlist}}} object using our party and mods.

From here, the widget runs through the targeting criteria in highest to lowest priority, so our special cases come first.

<h4 id="targeting.basic.1">Martyr check</h4>
{{{
(Hitlist class definition:)
	martyrCheck () {
		var test = this.find(function (t) { return t && t.target.martyr && !t.target.dead });
		return typeof(test) === "object" ? test.target : false;
	}

(in targetEnemy:)
	if (!mods.includes("ignore martyr") && hitlist.martyrCheck() instanceof Actor) {
		return hitlist.martyrCheck();
	}
}}}
In the default engine there's an effect, "Martyr", that forces all attacks to target the recipient. This ought to bypass any normal enemy behavior, so we should implement it first. For this, we define a simple {{{martyrCheck}}} function in {{{Hitlist}}} that searches itself to find any battlers with the {{{martyr}}} flag. If so, that battler will be returned; if not, we return {{{false}}}. We can then use this function to quickly check if a martyr is present with the test {{{hitlist.martyrCheck() instanceof Actor}}}: it'll be {{{true}}} if one is, and {{{false}}} if one isn't. If it's {{{true}}}, we're done -- we return the martyr and we have our target.

(Note that due to the way {{{find}}} works, this will stop at the first position it finds even if there are multiple matches. As previously discussed in <a class="noExternal" href="#effects1">the effect adder</a>, there is a check to ensure only one Martyr can exist at a time.)

<h4 id="targeting.basic.3">Mercy</h4>
{{{
var mercy = 0;
if (subject().mercy < 1 || mods.includes("smart")) {
// if enemy's mercy is below 1, they will always use smart targeting
	mercy = 2;
}
else {
// 1 in (mercy) chance of random targeting, to give players a break
	mercy = random(1,subject().mercy);
}
}}}
The next thing we do is set the {{{mercy}}} variable. You might consider the game too hard if enemies always make the perfectly optimal choices. You can use the mercy mechanic to give players a bit of a break. If {{{mercy}}} is 1, the enemy won't behave intelligently and will just target randomly. You can customize each enemy's intelligence level with their "mercy" attribute, defined in the story JavaScript. It's a little unintuitive: the chance of bypassing smart targeting will be the inverse of their "mercy" value, so a higher value will make an enemy more merciless. If you set "mercy" to 1, the enemy will always target randomly. Conversely, if you set "mercy" to 0, the first {{{if}}} statement will ensure they always use smart targeting. You can also accomplish this by passing the string "smart" to this function.

In the default engine, all enemies have their "mercy" values set to 3, so they have a 1-in-3 chance of targeting randomly. You can give specific enemies different values by manually setting their "mercy" values in the enemy database.

<h4 id="targeting.basic.4">Smart targeting</h4>
Smart targeting is handled via another {{{Histlist}}} function, {{{addFactors}}}. This function accepts a large number of potential mods, and adjusts targeting chances based on them.
{{{
if (mods.includes("least HP") && t.target.hp <= lowestHP) {
	t.chance += 1;
} else if (mods.includes("most HP") && t.target.hp >= greatestHP) {
	t.chance += 1;
} else if (mods.includes("most damage") && t.target.lastDmg >= mostDamaging) {
	t.chance += 1;
} (etc.)
else if (mods.includes("exclusive")) {
	t.chance = 0;
}
}}}
This function is roughly divided into two types of modifiers: exclusive and non-exclusive. Exclusive mods only care about a single character: the one with the most or least of something, be that HP or a particular stat. The highest and lowest of each stat in the party are found before this, and this {{{if}}} tree will compare each target against those values to see how they measure up. Anyone who doesn't match the criteria gets removed from the hitlist. (However, due to the sheer number of potential mods, it's unfeasible to check for every single one in the final {{{else if}}}, so you'll need to add the "exclusive" mod to remove other characters.)
{{{
else {
	if (!mods.includes("ignore downed") && (t.target.offbalance || t.target.down)) {
		t.chance += 1;
	}
	if (mods.includes("effect") && !(t.target.chi || t.target.stasis)
		&& t.target.get("Special") < t.target.getBase("Special")) {
			t.chance += 1;
	}
	if (!mods.includes("ignore threat") && t.target.lastDmg >= mostDamaging) {
		t.chance += 1;
	}
	if (mods.includes("pierce") && t.target.get("Defense") >= highestStat["Defense"]) {
		t.chance += 1;
	}
	else if (!mods.includes("ignore vulnerable") && t.target.get("Defense") < t.target.getBase("Defense")) {
		t.chance += 1;
	}
	if (mods.includes("ruthless")) {
		t.chance += (1-((t.target.hp)/t.target.maxhp))*setup.RUTHLESS_FACTOR;
	}
	else if (!mods.includes("ignore vulnerable")) {
		t.chance += (1-((t.target.hp)/t.target.maxhp));
	}
}
}}}
If no exclusive mods were found, we move on to non-exclusive mods. These will give characters higher chances to be targeted based on various factors. By default, all attacks will preferentially target Off-Balance characters to proc Knocked Down, preferentially target characters will debuffed Defense and lowered HP to finish them off, and preferentially target the character who inflicted the most damage last turn to prioritize the greatest threats. Piercing attacks will instead prefer the target with the highest Defense, and debuffing attacks will prefer targets with debuffed Special to get the most bang for their buck.

You can add more modifiers here as you wish.
{{{
switch (V().difficulty) {
	case "hard":
	// Hard difficulty: If any puppets are vulnerable, non-vulnerable puppets will be ignored
		if (mercy > 1) {
			hitlist.addFactors(mods);
			hitlist.onlyVulnerable();
		}
		break;

	case "medium":
		// Medium difficulty: All puppets will be considered, but vulnerable puppets will get additional chances to be selected.
		if (mercy > 1) {
			hitlist.addFactors(mods);
		}
		break;

		case "easy":
			// Easy difficulty: Smart targeting is only used with the "smart" mod.
			if (mods.includes("smart")) {
				hitlist.addFactors(mods);
			}
			break;
}
}}}
Back to {{{targetEnemy}}}, we apply these factors, but with branching functionality based on the difficulty setting. On easy difficulty, we will only use smart factors if the attack has the "smart" mod, and on hard difficulty, we will not only use smart factors, we will <i>remove</i> targets that <i>weren't</i> noticed by smart targeting. This can make enemies very dangerous on hard mode, as they will only ever target the most vulnerable characters.

After that, we are finally done, and we can return our target.

<h3 id="targeting.threat">Threat-based/Aggro Targeting</h3>
There's an alternative to normal targeting you may like to use, especially if you're using a system like <i>Dungeons & Dragons</i> where range and positioning is important.

<b>Threat-based targeting</b>, enabled by activating the {{{THREAT_TARGETING}}} variable in {{{StoryInit}}}, uses a statistic, called "threat" here, to determine which character enemies attack. There are a lot of ways this can be done, and it may be instructive to look into aggro systems in other games if you'd like to modify the default system.
{{{
if (setup.THREAT_TARGETING === true) {
	this.threat = new Map();
	V().puppets.forEach(function(puppet) {
		this.threat.set(puppet.name,puppet.initialThreat());
	}, this);
}
}}}
The very first thing we have to do is to initialize the threat statistic so we have one at all. That's taken care of through this code in <a class="noExternal" href="#JS.enemies">the Enemy class constructor</a>. If we've enabled threat targeting, we create a {{{Map}}} with a numerical threat value keyed to every puppet on the field, and assign it as a property of the Enemy object.
{{{
initialThreat(){
	return 1;
}
}}}
<code>initialThreat</code> is defined in the Puppet class. In theory, you may want to implement some more code here that modifies the initial threat based on some other variables, but by default it just returns a value of 1.
{{{
<<if setup.THREAT_TARGETING === true && subject() instanceof Puppet && target() instanceof Enemy>>
	<<include "echoDamage threat gain">>
<</if>>

(...)

<<set _threatGain = 1 * ($dmg / target().maxhp)>>
<<run target().threat.inc(subject().name,_threatGain)>>
}}}
Additional threat is generated when player characters inflict damage in {{{<<echoDamage>>}}}. Threat gain is equal to the proportion of maximum HP inflicted by the attack. You can also add special cases for various circumstances -- perhaps certain attacks draw more or less threat, or, as here, special traits like Firefly affect it -- or make a completely different formula. The threat formula is offloaded to its own passage, "echoDamage threat gain", to make this easier.
{{{
<<if setup.THREAT_TARGETING === true && target() instanceof Enemy && subject() instanceof Puppet>>
	<<run target().threat.inc(subject().name,$action.threat)>>
<</if>>
}}}
You can also make actions provide a flat threat increase. In <i>Dragon Age</i>, this typically included ranged attacks and spells, which makes sense, as those attacks are used by dangerous yet vulnerable targets that smart opponents should prioritize. You can also use this to make non-damaging attacks draw threat.
{{{
decayThreat () {
	if (setup.THREAT_TARGETING === true) {
		this.threat.forEach(function(value,key) {
			this.threat.set(key,value-setup.THREAT_DECAY);
			if (this.threat.get(key) < 1) {
				this.threat.set(key,1);
			}
		}, this);
	}
}
}}}
Finally, we want a way for threat to change over time -- if a character stops attacking, logicially they should draw less attention. This method function, defined in the Enemy class and called at the end of the enemy turn, reduces threat by a small amount specified in {{{StoryInit}}} (10 by default).

Threat targeting otherwise functions the same as regular targeting, so with these variables set up you're good to go.

This threat system is based on the targeting system from <i>Dragon Age</i>, and has a number of built-in assumptions and limitations. You can read more about the implications of this system and other possibilities in [[Design]].

<h3 id="dispel">Dispel Targeting</h3>
Some enemies have abilities that can remove positive effects from player characters. Logically, these abilities should prioritize targets with buffs to dispel so they can get the most bang for their buck. This functionality is split across two functions: {{{dispelFactors}}} in {{{Hitlist}}}, and {{{dispelCheck}}} in {{{logic-functions.js}}}.

{{{dispelFactors}}} is very simple: It runs over the hitlist and boosts everyone's {{{chance}}} value by the {{{threat}}} value of all their buff effects. (The {{{threat}}} value is defined in the effect database, and allows you to value certain effects more highly.) It also takes an additional mod, "exclusive dispel", which removes any character with no buffs if passed to the function. This will be run just before smart targeting in {{{Hitlist.targetEnemy}}} if you pass the "dispel" mod.

However, targeting logic is only run after an action is already selected. How does an enemy determine if the dispel should be used at all? If no one has any buffs, there's no reason to use it over another attack in the first place.
{{{
function dispelCheck (mods) {
	(...)
	var party = puppets().filter(function (a) { return a && !a.dead });
	var martyr = party.find(function (p) { return p && p.martyr === true });
	if (!(mods.includes("mass") || mods.includes("ignore martyr")) && martyr instanceof Actor) {
		return martyr.effectCount("buff",mods);
	} else {
		var count = 0;
		for (let p of party) {
			if (mods.includes("ignore untargetable") || !p.untargetable) {
				count += p.effectCount("buff",mods);
			}
		}
		return count;
	}
}
}}}
This is handled by the function {{{dispelCheck}}}, which can be found in {{{logic-functions.js}}}, a set of functions that assist with enemy logic. This counts up the threat value of all buffs on all puppets and returns that total, allowing you to quickly check if a dispel is worth using based on how many effects are found. Since this simulates an attack, we also have to check for martyrs and exclude untargetables. (There is also a complementary {{{cureCheck}}} function that counts ailments among allies instead.)

<h3 id="targeting.ally">Ally Targeting</h3>
Some enemy actions target their allies instead of the player characters. We need something to handle that too.
{{{
static targetAlly (args) {
	(...)
	var mods = [];
	if (args instanceof Array) {
		mods = args;
	} else if (typeof(args) == "string") {
		mods = [args];
	}
	mods.push("ally");

	var party = subject().ownParty.filter(function (a) { return a !== null; });
	var hitlist = new Hitlist(party,mods);
	if (!mods.includes("random")) {
		hitlist.allyFactors(mods);
	}
	return hitlist.returnTarget(mods,true);
}
}}}
Fortunately, this functionality is much simpler. We basically just have to create a {{{Hitlist}}} object, and we're done. Note that we do, however, include the "ally" mod to alter some things. Ally targeting ignores martyrs, untargetability, and protection checks.
{{{
allyFactors (mods) {
	(...)
	if (mods.includes("pragmatic")) {
		for (let t of this) {
			if (t.target.hp < (t.target.maxhp * Math.clamp(setup.PRAGMATIC_CUTOFF,0,1))) {
				t.chance = 0;
			}
		}
	}

	if (mods.includes("most vulnerable")) {
		var lowestHP = Math.min(...this.filter(function (t) { return t.chance > 0 }).map(function (t) { return t.target.hp }));
	}
	for (let t of this) {
		if (mods.includes("most vulnerable") && t.target.hp <= lowestHP) {
			t.chance += 1;
		} else if (mods.includes("most vulnerable")) {
			t.chance = 0;
		} else {
			if (mods.includes("vulnerable")) {
				t.chance += (1-((t.target.hp)/t.target.maxhp))*2;
			}
			if (mods.includes("ailments")) {
				t.chance += t.target.effectCount("ailment",["threat","nosticky"])
			}
		}
	}
}
}}}
As with enemy targeting, we have a function to add weight to certain targets, but it is a different function since the logic for applying support abilities is different from the logic you want for attacks. Fewer mods are used here: we can prioritize characters with reduced HP or characters with ailments, or limit ourselves to only the target with the lowest HP. As with {{{addFactors}}}, more clauses can be added to suit your needs.

There is also a "pragmatic" mod that will exclude characters that are below a certain proportion of HP -- the enemy may not want to use an expensive buff move on an ally that's about to die anyway. <b>Note that this can reduce the number of possible targets to 0, which will cause an error.</b> Make sure to include a check in your enemy AI to ensure it will never be used in this case.

<h2 id="menus">Menu Functionality</h2>
A lot of RPGs involve managing characters and resources both in and out of battle. To do so requires some kind of menu where you can see your characters, items, equipment, etc. The functionality for these features can be found in the "party menu" file.
{{{
<span id="status">
<span style="display:inline-block; line-height:1.2; float:right; font-family:monospace">
[A] <br/>
[D] 
</span>
<<for _n, _option range setup.MENU_OPTIONS>>
<<if _n != $menu_screen>>
<<capture _n, _option>>
<span @id="'menu'+_n">
<<link _option>>
	<<set $menu_screen = _n>>
	<<print '<<goto \"Menu: '+_option+'\">>'>>
<</link>></span><</capture>>
<<else>>
<b>_option</b>
<</if>>
<br/>
<</for>>
<span id="menu-return"><<longreturn>></span>
</span>
}}}
What makes the menu an actual menu is this little passage right here. This is {{{<<include>>}}}d at the top of every menu page, and creates a navbar the player can use to access different submenus. For modularity, this functionality is tied to {{{setup.MENU_OPTIONS}}}, a variable defined in StoryInit. You can modify it to easily add or remove menu screens without needing to change this passage, but note that you must follow its strict format: every menu passage must have the title "Menu: " followed by exactly what you wrote in {{{setup.MENU_OPTIONS}}}.

{{{<<longreturn>>}}} is a widget that can be found in "Widgets (General)". It functions like the {{{<<return>>}}} macro, but skips over passages tagged "noreturn". Since the player will be moving through multiple passages while navigating the menu, a regular {{{<<return>>}}} macro won't cut it -- it'll return them only to the previous menu passage, not the game area they opened the menu from. Make sure to tag all your menu passages "noreturn" so this works properly.

<h3 id="menus.status">Status</h3>
It's typical for RPG menus to include a general status screen that tells you relevant information about your characters, such as their stats and abilities. That's handled by this screen.

I won't copy the full code for this passage here, because it's mostly formatting and graphical design. I don't recommend modifying it unless you want to change how it looks and you're sure you know what you're doing.

By default, this screen mimics the appearance of RPG Maker VX Ace's menu screen. Each character's entry displays their portrait (if they have one), then their name and level, then their HP and MP, and then their experience points. By clicking the character's name or using the numbered hotkeys, you can expand the small info box into a more detailed one that provides additional information. Again, this is based on RPG Maker VX Ace's status screen: the character's stats are displayed on the left, and their current equipment on the right. Similarly to the in-battle status screen, you can define additional screens here using the {{{menu}}} property of the {{{setup.STATUS_SCREENS}}} variable. By default, the engine displays information for equipment, elemental affinities, and ailment tolerances; you'll have to design your own panes if you want to add others.

The character's available abilities are also listed below the detailed status screen. There is not currently functionality for using abilities outside of battle, but this is planned in a future update.

<h3 id="menus.inventory">Inventory</h3>
Most RPGs feature items and inventory management. It's therefore useful to give players a way to easily refer to their inventory.

Because of the sheer number of items it's possible to accumulate, this screen is more stripped-down compared to some of the others. The inventory list shows only the items and their stock values. To see more information, the player can click on an item to have its details appear at the top of the screen. This is accomplished by dividing the passage into two major parts, the inventory list and the detail display box:
{{{
<span id="content"><<nobr>>
<<set _filter = "all">>
<div id="itemdisplay">
<<include "inventory item display">>
</div>
<div id="itemlist">
<<include "inventory item list">>
</div>
<</nobr>>
</span>
}}}
Because we will be frequently updating these sections, it's helpful to offload their contents to separate passages so we can easily update them by {{{<<replace>>}}}ing them with themselves. Remember that Twine does not automatically update its passages after variable changes, so we need to refresh the content manually to reflect any changes we make.
{{{
<div style="display:flex; justify-content:space-evenly;">
<<if _filter == "all">>
	<b>All</b>
<<else>>
	<<link "All">>
		<<set _filter = "all">>
		<<replace "#itemlist">><<include "inventory item list">><</replace>>
	<</link>>
<</if>>
<<if _filter == "usable">>
	<b>Usable</b>
<<else>>
	<<link "Usable">>
		<<set _filter = "usable">>
		<<replace "#itemlist">><<include "inventory item list">><</replace>>
	<</link>>
<</if>>
<<if _filter == "equipment">>
	<b>Equipment</b>
<<else>>
	<<link "Equipment">>
		<<set _filter = "equipment">>
		<<replace "#itemlist">><<include "inventory item list">><</replace>>
	<</link>>
<</if>>
</div>
}}}
The first thing we include in "inventory item list" is a set of filtering options. This helps the player find an item they need if they have a lot of items. By default, the filters are all items, usable items, and equippable items. These buttons are links that change the {{{_filter}}} variable and refresh the item list when clicked.
{{{
<div class="itemcontainer">
<<set _p = 2>>
<<for _name, _item range $inventory>>
	<<if _filter == "all" || (_filter == "usable" && _item.usable.includes("inmenu")) || (_filter == "equipment" && _item.equippable)>>
	<<if _p == 1>>
		<<set _p = 2>>
	<<elseif _p == 2>>
		<<set _p = 1>>
	<</if>>
	<div @class="'item'+_p">
	<b>
	<<capture _item>>
	<<link "_name">>
		<<set _display = _item>>
		<<replace "#itemdisplay">><<include "inventory item display">><</replace>>
	<</link>>
	<</capture>>
	</b> <span class="itemstock">(_item.stock)</span>
	</div>
	<</if>>
<</for>>
</div>
}}}
We then display the item list itself. The actual layout of the list is handled in {{{menu.css}}}; this code only handles the filtering and detail links. We display the items by running a {{{<<for>>}}} loop across the player's inventory, but for every iteration of the loop, we check against the filter: if "usable" is clicked, only items usable in the menu are shown, and if "equipment" is clicked, only items with equipment data are shown. The item name is then made into a link; when clicked, it copies the item to the {{{_display}}} variable and refreshes the display section.
{{{
<<if ndef _display || _display === null>>
	<div style="text-align: center; line-height: 70px; color: gray">Click on an item to see info</div>
<<else>>
<b>_display.name</b><br/>
<<if def _display.equippable>><i style="font-size:12px"><<print _display.equippable.slot>></i><br/><</if>>
_display.info<br/>
<div class="actdesc">_display.desc</div>
<<if _display.usable.includes('inmenu') || _display.equippable>>
<div style="display: flex; justify-content: space-evenly">
	<<set _b = 0>>
	<<if _display.usable.includes('inmenu') && _display.stock > 0>>
		<<set _b++>>
		<span @id="'button'+_b">
			<span id="usebutton">
			<<include "inventory use button">>
			</span>
		</span>
	<</if>>
	<<if _display.equippable && _display.stock > 0>>
		<<set _b++>>
		<span @id="'button'+_b">
			<span id="equipbutton">
			<<include "equip button">>
			</span>
		</span>
	<</if>>
</div>
<</if>>
<</if>>
}}}
The display section simply prints the item's data in an easily-readable fashion, provided you've selected an item to {{{_display}}}. (By default, it will direct you to click an item. We could simply not display the box at all until the player clicks on an item, but it's jarring for a new element to suddenly appear on the screen, especially when it appears at the top and pushes all the other elements on the page. Maintaining a default appearance for the box provides better aesthetic consistency and a smoother experience for the player.)

(Don't worry too much about the weird variables and IDs here, they're just to help direct the hotkeys in the rare circumstance that an item is both usable and equippable.)

The interesting part comes if the item is usable or equippable. In that case, we must provide functionality for the player to use or equip it. This functionality is, once again, offloaded to a set of child passages:
{{{
<<button "USE">>
	<<set _itemcancel = true; _target = 1; _event = "use">>
	<<if document.getElementById("usebutton")>><<replace "#usebutton">><<include "inventory cancel button">><</replace>><</if>>
	<<if document.getElementById("equipbutton")>><<replace "#equipbutton">><<include "equip button">><</replace>><</if>>
	<<replace "#itemlist">><<include "inventory puppets">><</replace>>
<</button>>
}}}
When the "USE" or "EQUIP" buttons are pressed, several things happen. Most of them are handlers for hotkeys or the rare case that an item is both usable and equippable, but the important event is that the button and the item list are replaced with new passages. We want to replace the button the player just clicked with a cancel button so that they can back out if they want to select a different item; but also, now that the player has selected an item to use, we need to provide a way for the player to use it.
{{{
<<set _HPmeters = []>>
<<set _MPmeters = []>>
<<for _i, _puppet range $puppets>>
	<div class="menuactor" @id="_i" style="display:grid; grid-template-columns: 33% 1fr">
		<div class="menuactor-nameblock" style="position:static; padding-left:14px; padding-top:5px; padding-bottom:0.5em; grid-row:1; grid-column:1; border-right:1px solid">
			<div class="menuactor-name">
			<<capture _i, _puppet>>
			<<if _event == "equip">>
				<<link _puppet.name>>
					<<run _puppet.equip(_display)>>
					<<unset _display>>
					<<replace "#itemdisplay">><<include "inventory item display">><</replace>>
					<<replace "#itemlist">><<include "inventory item list">><</replace>>
				<</link>>
			<<elseif _event == "use">>
				<<link _puppet.name>>
					<<run _display.onUse(_puppet); console.log("item used"); console.log(_puppet.maxhp); console.log($puppets.indexOf(_puppet).maxhp)>>
					<<unset _display>>
					<<replace "#itemdisplay">><<include "inventory item display">><</replace>>
					<<replace "#itemlist">><<include "inventory item list">><</replace>>
				<</link>>
			<</if>>
			<</capture>>
			</div>
			<div class="menuactor-stats" style="grid-row:unset; grid-column:unset; grid-template-columns:40% 3em 4em; border-right:none; top-padding:0">
			<<for _k, _v range _puppet.stats>>
				<div class="menuactor-statname" style="margin-left:0">_k</div>
				<div class="menuactor-statvalue">_v.base</div>
				<<if _v.bonus != 0>>
					<div class="menuactor-statmod">
					<<if _v.bonus > 0>>
						@@.green;<<print "\+"+_v.bonus>>@@
					<<elseif _v.bonus < 0>>
						@@.stat-lowered;<<print "-"+_v.bonus>>@@
					<</if>>
					</div>
				<</if>>
			<</for>>
			</div>
		</div>
		<<if _event == "equip">>
			<div style="grid-row:1; grid-column:2; margin-left:1em; margin-top:0.5em; margin-bottom:0.5em; margin-right:1em">
			<<for _k, _v range _puppet.equipment>>
				<div class="menuactor-equipment-slot">_k</div>
				<<if _v === null>><span class="menuactor-equipment-name">&nbsp;</span>
				<<else>>
					<div class="menuactor-equipment-name">_v.name<br/>
					<span class="actdesc">_v.info</span>
					</div>
				<</if>>
			<</for>>
			</div>
		<<elseif _event == "use">>
			<<set _id = 'hp'+_i>>
			<<run _HPmeters.push(_id)>>
			<<newmeter _id 1>>
				<<colors setup.PLAYER_BAR_COLOR>>
				<<animation false>>
				<<sizing 100% 0.5em>>
			<</newmeter>>
			<<set _id = 'mp'+_i>>
			<<run _MPmeters.push(_id)>>
			<<newmeter _id 1>>
				<<colors setup.MP_BAR_COLOR>>
				<<animation false>>
				<<sizing 100% 0.5em>>
			<</newmeter>>
			<div class="menuactor-hpmpblock" style="top:0.75em; width:260px">
				<div class="hpmp">HP: <span style="float:right"><div class="hpmpvalue">_puppet.hp</div>/<div class="hpmpvalue">_puppet.maxhp</div></span></div>
				<<showmeter _HPmeters[_i] `_puppet.hp / _puppet.maxhp`>>
				<div class="hpmp">MP: <span style="float:right"><div class="hpmpvalue">_puppet.en</div>/<div class="hpmpvalue">_puppet.maxen</div></span></div>
				<<showmeter _MPmeters[_i] `_puppet.en / _puppet.maxen`>>
			</div>
		<</if>>
	</div>
<</for>>
}}}
We accomplish this by replacing the space occupied by the item list with "inventory puppets". This code may look complicated, but most of it is actually copied from the status screen, with a few tweaks for formatting. What's important is this part:
{{{
<<capture _i, _puppet>>
<<if _event == "equip">>
	<<link _puppet.name>>
		<<run _puppet.equip(_display)>>
		<<unset _display>>
		<<replace "#itemdisplay">><<include "inventory item display">><</replace>>
		<<replace "#itemlist">><<include "inventory item list">><</replace>>
	<</link>>
<<elseif _event == "use">>
	<<link _puppet.name>>
		<<run _display.onUse(_puppet)>>
		<<unset _display>>
		<<replace "#itemdisplay">><<include "inventory item display">><</replace>>
		<<replace "#itemlist">><<include "inventory item list">><</replace>>
	<</link>>
<</if>>
<</capture>>
}}}
Clicking on the character's name will use the item on them. However, we have to branch this functionality depending on if we're using or equipping the item, because those do different things. If we're equipping an item, we run {{{_puppet.equip}}}; if we're using an item, we run {{{_display.onUse}}}. In either case, we reset the {{{_display}}} variable and refresh the page so that the item list is displayed again.
{{{
<<if _event == "equip">>
	<div style="grid-row:1; grid-column:2; margin-left:1em; margin-top:0.5em; margin-bottom:0.5em; margin-right:1em">
	<<for _k, _v range _puppet.equipment>>
		<div class="menuactor-equipment-slot">_k</div>
		<<if _v === null>><span class="menuactor-equipment-name">&nbsp;</span>
		<<else>>
			<div class="menuactor-equipment-name">_v.name<br/>
			<span class="actdesc">_v.info</span>
			</div>
		<</if>>
	<</for>>
	</div>
<<elseif _event == "use">>
	<<set _id = 'hp'+_i>>
	<<run _HPmeters.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.PLAYER_BAR_COLOR>>
		<<animation false>>
		<<sizing 100% 0.5em>>
	<</newmeter>>
	<<set _id = 'mp'+_i>>
	<<run _MPmeters.push(_id)>>
	<<newmeter _id 1>>
		<<colors setup.MP_BAR_COLOR>>
		<<animation false>>
		<<sizing 100% 0.5em>>
	<</newmeter>>
	<div class="menuactor-hpmpblock" style="top:0.75em; width:260px">
		<div class="hpmp">HP: <span style="float:right"><div class="hpmpvalue">_puppet.hp</div>/<div class="hpmpvalue">_puppet.maxhp</div></span></div>
		<<showmeter _HPmeters[_i] `_puppet.hp / _puppet.maxhp`>>
		<div class="hpmp">MP: <span style="float:right"><div class="hpmpvalue">_puppet.en</div>/<div class="hpmpvalue">_puppet.maxen</div></span></div>
		<<showmeter _MPmeters[_i] `_puppet.en / _puppet.maxen`>>
	</div>
<</if>>
}}}
I also chose to branch the display, because the player should see information relevant to their decision. If you're equipping people, it stands to reason that you'll want to see what they already have equipped; but if you're using a healing potion, you'll probably want to see how everyone's health is doing instead.

<h3 id="partypicker">Party Picker</h3>
In some RPGs, you're only given a single party of characters to play with throughout the whole game. Some are a bit more ambitious, and give you additional reserve characters you can swap out with your active ones.
{{{
<span id="content"><center style="font-weight:bold">ACTIVE PUPPETS</center>
<<nobr>>
<div class="actors" id="puppets">
<<include "party manager puppets">>
</div>
<</nobr>>
<center style="font-weight:bold">RESERVE PUPPETS</center>
<<nobr>>
<div class="actors" id="reserve">
<<include "party manager reserve">>
</div>
<</nobr>>

<<unequipAll>>
</span>
}}}
This functionality is provided through the "Party Picker" passage, which you can access from the landing. Like the "Battle!" passage, the actual passage the player visits is only a container for complex code outsourced to other passages.
{{{
<<for _i, _puppet range $puppets>>
	<div class="actor" @id="_i" style="min-width:150px">
	<center>
	<<capture _i>>
	<<link _puppet.name>>
		<<if def _s>>
			<<run $('#' + _s).removeClass("selected")>>
			<<if _s != _i>>
				<<set _s = _i>>
				<<run $('#' + _s).addClass("selected")>>
			<<else>>
				<<unset _s>>
			<</if>>
		<<else>>
			<<set _s = _i>>
			<<run $('#' + _i).addClass("selected")>>
		<</if>>
		<<replace "#status">><<include "party manager reserve">><</replace>>
	<</link>>
	<</capture>>
	</center><br/>
	<<for _k, _v range _puppet.stats>>
		<span class="statname"><<print _k>>:</span>
		<<statOOB _k _puppet>>
		<br/>
	<</for>>
	</div>
<</for>>
}}}
Active puppets are displayed through the "party manager puppets" passage. Here, similarly to the actorlist, we create stat blocks for every puppet with a for loop. The key here is that we're going to need a unique ID for every block. We can do this with the {{{@}}} operator and the {{{_i}}} index variable of the for loop: every "actor" block will be given the ID 0, 1, or 2 as the loop runs. (Thanks to Twinery user greyelf for helping me with this.)

Within each block, we're going to {{{<<capture>>}}} the index value {{{_i}}} and create a {{{<<link>>}}} out of each puppet's name. When clicked, we're going to assign a separate value, {{{_s}}}, the value of {{{_i}}}, and then use a jQuery function to add the "selected" class to the current block. (It's theoretically possible to use SugarCube's {{{<<addclass>>}}} macro instead, but passing variables as IDs is a bit more difficult there.) The "selected" class just turns the block a bright cyan color, thus making it clear to the player that the puppet is selected.
{{{
<<run $('#' + _s).removeClass("selected")>>
}}}
We also need a quick line of code to remove the "selected" class from the <i>last</i> selected puppet, in case the player has already selected one. Otherwise, the cyan coloring wouldn't disappear, and the player might be confused who they're selecting.

We also need to update the "party manager reserve", for reasons that will be explained shortly.

The rest of the block can be anything; in the default engine, it's stats, since that's the major distinguishing feature of the default party members. You could include more info if you like; though you might need to change the size or display of the blocks to accommodate it.
{{{
<center>Reserve Puppets:</center><br/>
<<for _i, _puppet range $Reserve_Puppets>>
	<span class="statname">
	<<if def _s>>
		<<capture _puppet, _i>>
		<<link _puppet.name>>
			<<run $Reserve_Puppets[_i] = $puppets[_s]>>
			<<set $puppets[_s] = _puppet>>
			<<unset _s>>
			<<replace "#puppets">><<include "party manager puppets">><</replace>>
			<<replace "#status">><<include "party manager reserve">><</replace>>
		<</link>>
		<</capture>>
	<<else>>
		_puppet.name
	<</if>>
	</span><br/><br/>
<</for>>
}}}
Finally, we need to let the player pick a party member from the reserve. As before, we iterate over a puppet array, but this time it's the {{{$Reserve_Puppets}}} array defined in {{{<<puppetsInit>>}}}. (To prevent the player from cloning people, {{{$Reserve_Puppets}}} shouldn't have any overlap with the active {{{$puppets}}} array.) If {{{_s}}} is defined (so, someone was selected), clicking their name will swap them with the selected character. Finally, we reset {{{_s}}} and refresh both character lists so the player can do it all again.

<h3 id="equipmanager">Equipment Manager</h3>
Though the player can already manage equipment through the inventory screen, I created a dedicated equipment screen for additional convenience. The conceit here is that while the inventory method was item-centric, this screen is character-centric. You select a character and then the equipment you want to give them, rather than the other way around.
{{{
<span id="content"><<unequipAll>>

<<nobr>>
<div id="puppets">
<<include "equip manager puppets">>
</div>
<div id="equipment-list">
<<equipmentlist>>
</div>
<</nobr>>
</span>
}}}
Similarly to our other menu passages, most of the functionality is offloaded to child passages. This passage is something of a hybrid of the status and inventory screens; we display the characters' status boxes up top, and the equipment down below.

The "equip manager puppets" passage is nearly identical to the status screen, but with equipment and stats displayed in place of HP/MP. When a character's name is clicked, a selector variable is similarly stored, which influences {{{<<equipmentlist>>}}}. That's a widget, not a passage, and can be found in "Widgets (Menu)".
{{{
<<if def _s>>
<div style="line-height:1.4">
<<set _count = 0>>
<<for _k, _v range $inventory>>
<<if _v.equippable && _v.stock > 0>>
<br/>
<<set _count++>>
<<if (def _s && _v.checkRestriction($puppets[_s])) || ndef _s>>
<div @id="_k">
<b>
<<if def _s>>
	<<capture _v, _k>>
	<<link _k>>
		<<run $puppets[_s].equip(_v)>>
		<<replace "#puppets">><<include "equip manager puppets">><</replace>>
		<<replace "#equipment">><<equipmentlist>><</replace>>
	<</link>>
	<</capture>>
<<else>>
_k
<</if>>
</b>
<span style="float:right">(_v.stock)</span><br/>
<i style="font-size:12px"><<print _v.equippable.slot>></i><br/>
<<if _v.equippable.restrictedTo.length > 0>>
<span style="font-size:12px; color:gray">Restriction: <<for _char range _v.equippable.restrictedTo>><<print _char>><</for>></span>
<</if>>
<<print _v.desc>><br/>
<span class="actdesc"><<print _v.info>></span>
</div>
<</if>>
<</if>>
<</for>>
<<if _count == 0>>
You don't have any equipment.
<</if>>
</div>
<</if>>
}}}
This widget runs through the entire inventory ({{{<<for _k, _v range $inventory>>}}}) but will <b>only</b> display equippable items, thanks to the {{{<<if _v.equippable && _v.stock > 0>>}}} filter. Every time it finds an equippable item, it'll make a note of it through the {{{_count}}} variable; this is just so that we can confirm if the player has no equipment. (This is a courteous message to provide, as the player may just be confused if they try to pull up their equipment and see nothing at all.)

From there, it creates the link the player can use to equip the item.
{{{
<<if (def _s && _v.checkRestriction($puppets[_s])) || ndef _s>>
}}}
In English, this says: <b>If a character has been selected and that character isn't restricted from using this item <i>OR</i> no character is selected, execute the following code.</b> This removes items the selected character can't wear from the listing entirely, reducing the amount of chaff a player has to scroll through.
{{{
<<if def _s>>
	<<capture _v, _k>>
	<<link _k>>
		<<run $puppets[_s].equip(_v)>>
		<<replace "#puppets">><<include "equip manager puppets">><</replace>>
		<<replace "#status">><<equipmentlist>><</replace>>
	<</link>>
	<</capture>>
<<else>>
_k
<</if>>
}}}
This says: <b>If a character has been selected, display the item's name as a link; otherwise, display the name as plain text.</b> Clicking the link will equip the item to the character, reset the selection, and update the screen so the player can see the difference.

Notice that this widget displays the full information of all equippable items -- something that was too expansive for the inventory screen, but a useful feature here, as it allows you to directly compare multiple pieces of equipment at once. Notice also that unlike the inventory screen, it does <b>not</b> reset the selector variable; this allows the player to equip multiple pieces of equipment all at once instead of having to go through the entire menu each time. So while this screen may not provide any truly unique functionality, it can still make the player's life easier.

<h3 id="itemshop">Item Shop</h3>
The item shop allows the player to alter the composition of their inventory.
{{{
Points: $currency<br/>
<br/>
<<for _k, _v range $inventory>>
<<if _v.usable == 0 || _v.usable == 1>>
<div>
<b>_k</b> (Stock: _v.maxstock)
<div style="display:inline-block; float:right">
<<capture _v>>
	<<if $currency >= _v.value && _v.maxstock < 9>>
	[<<link "BUY">>
		<<replace "#items">>
			<<run _v.maxstock++>>
			<<run $currency -= _v.value>>
			<<include "item shop display">>
		<</replace>>
	<</link>>]
	<</if>>
	<<if $currency >= _v.value and _v.maxstock > 0>> / <</if>>
	<<if _v.maxstock > 0>>
	[<<link "SELL">>
		<<replace "#items">>
			<<run _v.maxstock-->>
			<<run $currency += _v.value>>
			<<include "item shop display">>
		<</replace>>
	<</link>>]
	<</if>>
<</capture>>
 <b>Cost: _v.value</b>
</div>
</div>
<<print _v.info>><br/>
<span class="actdesc"><<print _v.desc>></span><br/>
<br/>
<</if>>
<</for>>
}}}
This code is very similar to the point-buy interface, which is explained in [[Additional Features]]. We display every one of the player's items with a {{{for}}} loop, similar to the {{{<<itemlist>>}}} widget. However, we also include BUY and SELL buttons. These buttons add or subtract from the item's stock and adjust the player's money based on the cost of the item, then refresh the item display to display the new value.

This functionality is rudementary, and designed for <i>Cartoon Battle</i>'s limited inventory system. For more complicated shop mechanics, such as shops that contain different items than those in the player's inventory, you may require separate tabs for buying and selling. If you have a lot of items to display, you may also want to defer the info and description displays.

<h2 id="hotkeys">Hotkeys</h2>
The engine's hotkeys are made through <a href="https://twinelab.net/custom-macros-for-sugarcube-2/#/./event-macros" target="_blank">Chapel's event macro set.</a> They are defined in StoryInit, but the code is compartmentalized into the "hotkey definitions" passage for modularity. After reading this section, you should have everything you need to edit the engine's hotkeys or add your own. The website <a href="https://keycode.info/" target="_blank">keycode.info</a> may be helpful for finding the keycode for your desired hotkeys.

There are way too many hotkeys to go over everything, and most of the code is very similar anyway. I'll use the Q key as our representative example.

I chose the Q key as the "confirm" key for the engine. This key does four things:
<ol>
<li>Select the "Act" link for the selected character in the command phase.</li>
<li>Select the default action for the character in the action selection phase.</li>
<li>Confirm the selection in the confirm phase.</li>
<li>Trigger any "Continue" buttons that occur in other battle phases, such as the buttons to advance battle after the action and enemy phases.</li>
</ol>
Let's look at how each of these features are built.
{{{
<<which 81>> /* Q pressed */
	<<if $inbattle>>
		<<switch $B.phase>>
			<<case "command">>
				<<if $B.subject !== null>>
					<<set _id = "#actbtn a">>
					<<trigger 'click' _id>>
				<</if>>
			<<case "actions">>
				<<if def $B.subject.defaultAction && $B.subject.defaultAction !== null>>
					<<set _action = $B.subject.defaultAction>>
					<<actionLink>>
				<</if>>
			<<case "confirm">>
				<<trigger 'click' "#confirmLink a">>
			<<default>>
				<<trigger 'click' "button.macro-button">>
		<</switch>>
	<<elseif passage() == "Menu: Inventory" && def _display && _itemcancel !== true>>
		<<set _id = '#button1 button'>>
		<<trigger 'click' _id>>
	<</if>>
}}}
We start with {{{<<which 81>>}}}. The {{{<<which>>}}} macro tells the program to look for a key, and {{{81}}} is the code for the Q key. (It's handy to add comments for the corresponding key when you work with keycodes, to make things clearer for yourself or the end user.)

Because we want this key to have special functionality for battles, we check for the {{{$inbattle}}} flag before we tell it to execute any code. We also want the key to have different functionality depending on the phase of battle, so we create a {{{<<switch>>}}} for {{{$B.phase}}}.

Our first function is: <i>Select the "Act" link for the selected character in the command phase.</i>
{{{
<<case "command">>
	<<if $B.subject !== null>>
		<<set _id = "#act"+$puppets.indexOf($B.subject)+" a">>
		<<trigger 'click' _id>>
	<</if>>
}}}
This one is pretty simple. <a class="noExternal" href="#commands">We've already designed all the code for the Act button in the Battle Phases passage</a>; instead of copying all that over, we just need to make the link act as if it was clicked. We can do this through the {{{<<trigger>>}}} macro, but it needs to know what to target. Going back to {{{commands}}}, you can see we created IDs for each character's Act buttons for this exact purpose:
{{{
<span @id="'act'+_i"><<act $puppets[_i]>></span>
}}}
Each character's Act button has a unique ID that contains their index in the {{{$puppets}}} array. Because the {{{$B.subject}}} variable is an object from the {{{$puppets}}} array in the command phase, we can plug it into {{{indexOf}}} to find the selected character's index, and from there, pass the correct ID to the {{{<<trigger>>}}} macro.

There's just one wrinkle: We placed that ID on a {{{<span>}}} element surrounding the link, not on the link itself. If we were to just leave it at that, the {{{<<trigger>>}}} would only click that {{{<span>}}} element, which of course would do nothing. We need to provide {{{<<trigger>>}}} with one more bit of information: the specific element it needs to target. In this case, that's a link, which is an anchor {{{<a>}}} element. By appending that to the target argument (separated by a space), the {{{<<trigger>>}}} macro now knows to simulate a click on the anchor element <i>within</i> the element tagged "#act".

Lastly, things are going to get weird if {{{$B.subject}}} is {{{null}}}, so just to be safe, we also have to wrap this in an {{{<<if>>}}} that checks against that.

That's our first function done. Our next one is: <i>Select the default action for the character in the action selection phase.</i>

The setup we have to do for this function is to <i>create</i> a default action to reference in the first place. All of the default characters have one that's set in their constructors, but you can change this or even allow the player to select it themselves. (I caution against doing this with actions that can be changed or swapped out, such as Rogue's "Crossbow" and "Reload" actions, as the {{{defaultAction}}} property stores a separate copy that <b>will not be updated to reflect changes in the {{{actions}}} property</b> unless you do so manually.)
{{{
<<case "actions">>
	<<if def $B.subject.defaultAction && $B.subject.defaultAction !== null>>
		<<set _action = $B.subject.defaultAction>>
		<<actionLink>>
	<</if>>
}}}
For this one, I did choose to copy the action button code rather than use a {{{<<trigger>>}}}. You could make unique IDs for every single action link and do a search to find the one that matches the default action, but that was too much work for me. (This is why action button code is condensed into a widget: It allows for easy consistency between the two places it can be called.)

The player will get no notification if the action can't be used for whatever reason; the code simply won't execute. I doubt players will be too confused by this, as they can look at the action button itself to see why they can't use it, but you could also set an audio or visual indicator to play when this happens, as most video games do.

As before, we wrap the whole thing in an {{{<<if>>}}} to make sure our crucial variable exists before we start executing code on it.

Our next function is: <i>Confirm the selection in the confirm phase.</i>
{{{
<<case "confirm">>
	<<trigger 'click' "#confirmLink a">>
}}}
This one is trivial compared to the others. You may be tempted to forego the {{{<<trigger>>}}} entirely and just use {{{<<goto "action phase">>}}}, and that will work in the default engine, but there may be cases where you want the confirm link to perform additional code or processing, so we make sure to trigger it just to be safe.

Out last function is: <i>Trigger any "Continue" buttons that occur in other battle phases, such as the buttons to advance battle after the action and enemy phases.</i>
{{{
<<default>>
	<<trigger click "button.macro-button">>
}}}
For this one we do want to use {{{<<trigger>>}}} -- it's easier to use than before, as we're targeting general elements instead of an ID we have to make ourselves. In Twine, there is one additional wrinkle here: We want to make sure we're only activating the buttons inside the Twine game, and not anything outside of it. This is an important distinction, because the UI sidebar also contains {{{<button>}}} elements that will be activated by something that targets all buttons. Fortunately, SugarCube automatically labels all macros and elements within the game area with classes labeling them as such, so we only need to add a {{{.macro-button}}} extension to limit our trigger to buttons within the game area.

<h3 id="hotkeys.summary">Summary</h3>
To do anything with key presses, create an {{{<<event keydown>>}}}.

Create functions for each key under {{{<<which [keycode]>>}}}. Any code within will be executed on the key press, the same as if the user had clicked a {{{<<link>>}}}.

Use {{{<<trigger>>}}} to trigger existing events on the page, but remember that the code is effectively "blind" and can only see specific elements if you give them an ID. Remember also that SugarCube's macros generate their own elements that you can't directly modify, so append an element target to your ID if you want to trigger one.

The UI bar contains HTML elements that can be affected by hotkeys. If you want to restrict hotkeys to elements within the game area, inspect them with the Inspect functionality (right-click or Ctrl+Shift+I) to see their unique classes and append them to your target. (Typically, these classes are some variation of "macro" or "internal".)

<h2 id="widgets">Other Widgets</h2>
This section will cover miscellaneous widgets and their purpose.

<h3 id="chain">The {{{<<chain>>}}} widget</h3>
Twine has a difficult quirk: object addresses are not preserved through passages.

[img[setup.ImagePath + "documentation/variable_types.PNG"]]

Normally, when you define a variable, the value of the variable is stored in the computer's memory at the variable's address. When you define an object, the variable you set as its name does not store the object itself, only the memory address. The object variable therefore serves as a pointer to the actual object. This means that you can pass the object's name to other variables and still have those new variables point to the same object.

For instance, if we wanted to store the currently acting character in a "subject" variable, we might do this:
{{{
<<set $subject = $puppets[1]>>
}}}
If we did this in a standard coding engine, {{{$subject}}} would refer to the same object as {{{$puppets[1]}}}, and everything we did to {{{$subject}}} would also affect {{{$puppets[1]}}}.

Twine, for various reasons, does not work this way. Every time the user travels to a new passage, a new copy of every object is generated, and this breaks shared object references. In our example, {{{$subject}}} would now point to a completely new object, and acting on it would not affect our {{{$puppets[1]}}} object.
{{{
<<widget "chain">>
<<if $B.target !== null>>
<<run getActor("target")>>
<</if>>
<<if $B.subject !== null>>
<<run getActor("subject")>>
<</if>>
<<if $B.actor !== null>>
<<run getActor("actor")>>
<</if>>
<</widget>>

window.getActor = function getActor(x) {
	var targets = [];
	var id;
	var actor;
	switch(x) {
		case "target": id = V().B.target.id; break;
		case "subject": id = V().B.subject.id; break;
		case "actor": id = V().B.actor.id; break;
		default: console.log("ERROR in getActor: invalid argument");
	}
    switch(id.charAt(0)) {
        case "p": targets = State.variables.puppets; break;
        case "e": targets = State.variables.enemies; break;
		default: console.log("ERROR: Target ID does not match any known party.");
    }
    actor = targets.find(function(t) { return t && t.id === id; });
	switch(x) {
		case "target": V().B.target = actor; break;
		case "subject": V().B.subject = actor; break;
		case "actor": V().B.actor = actor; break;
		default: console.log("ERROR in getActor: invalid argument");
	}
	return;
}
}}}
The {{{<<chain>>}}} widget (found in the "General Widgets" passage) and the {{{getActor()}}} function (found in 0config.js) are a workaround for this issue. It is based on the fact that shared object references still work <i>within the same passage</i>. If we were to run {{{<<set $subject = $puppets[1]>>}}} at the start of every passage, {{{$subject}}} would behave the way we want.

This is essentially what {{{getActor()}}} does. Every character is assigned an ID based on a randomly generated value when their instance is created; by reading this attribute in the stored object, we can find the matching character at any time using the {{{find}}} function, which returns the entry in an array matching a key value (in this case, {{{id}}}).

One additional wrinkle is that we need to know the correct array to search -- {{{$puppets}}} or {{{$enemies}}}. To facilitate this, there's a special feature in the ID generation code that adds a fixed symbol at the start of the ID depending on whether the character is a puppet or enemy; all we need to do is check that marker and we know which array to search.
{{{
<<if $inbattle>>
	<<chain>>
<</if>>
}}}
{{{<<chain>>}}} is then added to PassageReady, a special passage that runs at the beginning of every passage. This lets {{{$B.subject}}}, {{{$B.target}}}, and {{{$B.actor}}} retain their object links through passages, which greatly simplifies many widgets.

<h3 id="refreshPuppets">{{{<<refreshPuppets>>}}}</h3>
{{{
<<widget "refreshPuppets">>
<<for _puppet range $puppets>>
	<<set _puppet.isDone = false>>
	<<set _puppet.inspired = false>>
	<<set _puppet.lastUsed = null>>
	<<if !$lastingDamage || $reviveAfterBattle>>
		<<set _puppet.dead = false>>
		<<set _puppet.hp = Math.round(_puppet.maxhp * setup.RESPAWN_HP)>>
	<</if>>
	<<if !$lastingDamage>>
		<<set _puppet.hp = _puppet.maxhp>>
		<<set _puppet.en = 5>>
	<</if>>
	<<if !$actionRefillAfterBattle>>
		<<for _action range _puppet.actions.filter(function (a) { return a.uses !== undefined })>>
			<<run _action.refill()>>
		<</for>>
	<</if>>
	<<for _effect range _puppet.effects.filter(function (eff) { return !eff.persistAfterBattle })>>
		<<run _puppet.removeEffect(_effect,{pierce: true, unsticky: true})>>
	<</for>>
	<<for _k, _v range _puppet.tolerances>>
		<<run _puppet.resetTol(_k)>>
	<</for>>
	<<if def _puppet._respawn>>
		<<run _puppet._respawn.refill()>>
	<</if>>
	<<if def _puppet._retaliations>>
		<<run _puppet._retaliations.refill()>>
	<</if>>
	<<set _x = _puppet.actions.find(function (a) { return a && a.name == "Reload" })>>
	<<if def _x>>
		<<set $B.subject = _puppet; _x.act()>>
	<</if>>
<</for>>
<</widget>>
}}}
{{{<<refreshPuppets>>}}} is defined in "Widgets (General)". This widget is used to standardize the states of player characters before and after battles. Flags such as {{{isDone}}} are reset, non-persistent status effects are cleared, {{{FillStat}}}s are refilled, and Rogue's crossbow is reloaded if it's empty.

There is modifiable behavior depending on if you want puppets to restore HP after battle and to what extent. By default, puppets will be restored to full HP and have their EN reset to baseline. If you don't want this to happen, you can use the {{{lastingDamage}}} variable to bypass it.

For additional nuance, you can also decide whether you want puppets to be revived after battle, regardless of if they're normally healed. You can enable this even with {{{lastingDamage}}} active through the {{{reviveAfterBattle}}} variable. By default, puppets will be revived to a proportion of the max HP determined by {{{RESPAWN_HP}}}. Note that this comes before the standard HP reset, meaning that they will be restored to full HP anyway if lasting damage is not enabled. There is also a separate variable that determines if you want limited-use actions to be refilled after battle.

<h3 id="deathcheck">{{{<<deathcheck>>}}}</h3>
{{{
<<if $args.length > 0>>
	<<set _targ = $args[0]>>
<<else>>
	<<set _targ = target()>>
<</if>>
<<if _targ.hp <= 0 && !_targ.dead>>
	<<if _targ.specialdeath && !$B.specialdeath.includes(_targ._deathMessage)>>
		<<run $B.specialdeath.push(_targ._deathMessage)>>
	<<elseif !_targ.immortal>>
		<<set _targ.dead to true>>
		<<if _targ._deathMessage !== null>>
			<<print _targ.deathMessage>>
		<</if>>
		<<if _targ instanceof Enemy>>
			<<run $B.kills.push(_targ)>>
			<<if typeof(subject().kills) == 'number'>>
				<<set subject().kills++>>
			<</if>>
			<<set $B.XPreward += _targ.xp; $B.moneyReward += _targ.gp>>
		<<elseif _targ instanceof Puppet>>
			<<run _targ.defeats++>>
		<</if>>

		/* Remove all effects unless they are meant to persist past unconsciousness */
		<<for _k, _effect range _targ.effects.filter(function (eff) { return !eff.persistAfterDeath; })>>
			<<run _targ.removeEffect(_effect,{pierce: true, unsticky: true})>>
		<</for>>

		/* If defeated character was protected, their protector's protection effect must be removed */
		<<if _targ.protectedBy !== null>>
			<<switch _targ.protectedBy.charAt(0)>>
				<<case "p">>
					<<set _targets = $puppets>>
				<<case "e">>
					<<set _targets = $enemies>>
				<<default>>
					<<run console.log("ERROR in deathcheck: protected character's protector has invalid ID")>>
			<</switch>>
			<<set _temp = _targets.find(function(t) { return t && t.id === _targ.protectedBy; })>>
			<<find "_temp.effects" "name" "\'Protector\'">>
			<<print _temp.removeEffect(_temp.effects[_pos],{pierce: true})>>
		<</if>>

	<<elseif _targ.immortal>>
		<<if _targ._deathMessage !== null>>
			<<print _targ.deathMessage>>
		<</if>>
	<</if>>
<</if>>
<</widget>>
}}}
This widget applies the "dead" tag to defeated characters, and adds their names to the "kills" array in case that's something you want to keep track of.
{{{
<<if _targ.specialdeath && !$B.specialdeath.includes(_targ._deathMessage)>>
	<<run $B.specialdeath.push(_targ._deathMessage)>>
}}}
The first thing is a check for characters with special death messages. You might want certain enemies to have a full passage's worth of description when they're defeated, such as if they're a climactic villain. If you set their {{{specialdeath}}} attribute to {{{true}}}, the player will be directed to the passage with a name matching their {{{deathMessage}}}. (To prevent possible stacking of these passages, which can occur if this code is triggered multiple times at once, such as from multi-hit attacks, there is also a check that their special death isn't in the queue already.)

Otherwise, as long as the target isn't flagged as immortal, the normal death message will be displayed and the target will be flagged as dead. (Note that this requires the target be set correctly! Usually this won't be a problem, as the damage widgets require a target as well. However, you'll need to update the {{{$B.target}}} value or pass an argument any time a character could be damaged, such as from damage-over-time effects.) If the target <i>is</i> immortal, only their death message is displayed.
{{{
<<if _targ instanceof Enemy>>
	<<run $B.kills.push(_targ)>>
	<<if typeof(subject().kills) == 'number'>>
		<<set subject().kills++>>
	<</if>>
	<<set $B.XPreward += _targ.xp; $B.moneyReward += _targ.gp>>
<<elseif _targ instanceof Puppet>>
	<<run _targ.defeats++>>
<</if>>
}}}
If the target was an Enemy, we add them to the "kills" array held by the battle controller, if that's something you want to keep track of. (For example, in <i>Cartoon Battle</i>, there were achievements based on which enemy you defeated last.) We also increment the subject's "kills" attribute, though we have to check to make sure it's the correct data type just in case something weird has happened and we'll produce an error by trying to increment it. (One possible example might be an enemy killing another enemy; enemies do not have a defined <code>kills</code> attribute by default, so this will generate an error.) Finally, we add the enemy's XP and GP rewards to the total that will be read at the end of battle.

If the target was a Puppet, we increment their "defeats" counter.
{{{
<<if _targ.protectedBy !== null>>
	<<switch _targ.protectedBy.charAt(0)>>
		<<case "p">>
			<<set _targets = $puppets>>
		<<case "e">>
			<<set _targets = $enemies>>
		<<default>>
			<<run console.log("ERROR in deathcheck: protected character's protector has invalid ID")>>
	<</switch>>
	<<set _temp = _targets.find(function(t) { return t && t.id === _targ.protectedBy; })>>
	<<find "_temp.effects" "name" "\'Protector\'">>
	<<print _temp.removeEffect(_temp.effects[_pos],{pierce: true})>>
<</if>>
}}}
There is also a special handler here for the "Protector" status effect. If the person the protector is protecting dies, it no longer makes sense to keep the effect. We use the target's {{{protectedBy}}} attribute to see if they were being protected by anyone and find their protector if so, then we find the Protector effect in their {{{effects}}} array and remove it.

<h3 id="statusDoc">{{{<<status>>}}}</h3>
{{{
<<widget "status">>
<<link "[*]">>
	<<if $args[0] eq $B.actor>>
		<<set $B.actor = null>>
	<<else>>
		<<set $B.actor to $args[0]>>
		<<if ndef $stScreen>>
			<<set $stScreen = 1>>
		<</if>>
	<</if>>
	<<replace "#status">><<include "status">><</replace>>
<</link>>
<</widget>>
}}}
This widget creates that little [*] button you use to get information on characters.

You may recall from the "actorlist" passage that the widget is called like this:
{{{
<<status _enemy>>
}}}
That passes the character's data to the widget as {{{$args[0]}}}. So, when the {{{<<link>>}}} macro is activated (i.e., when the [*] is clicked), the widget first checks if the passed information matches what's already stored in {{{$B.actor}}}. If it does, {{{$B.actor}}} is set to null, which clears the information in the status pane. This is how the status button is "toggleable": if you click it once, you get that character's information; if you click it again for the same character, the pane clears.

By default, {{{$actor}}} is set to the information for the new character, and the {{{$stScreen}}} value is set to 1 (defaulting to the pane displaying stats). A {{{<<replace>>}}} macro is then used to refresh the status pane to display the new character.

Recall that {{{$B.actor}}} is one of the variables run by {{{<<chain>>}}}, so the status pane will update to reflect changes to the character.

<h3 id="endofbattle">{{{<<endofbattle>>}}}</h3>
{{{
<<widget "endofbattle">>
<<set $inbattle = false>>

<<for _id range $B.playerBars>>
	<<run Meter.del(_id)>>
<</for>>
<<for _id range $B.enemyBars>>
	<<run Meter.del(_id)>>
<</for>>

<<if deadCount() == $puppets.length>>
	<<set $B.defeated = true>>
<<elseif deadCount() == $puppets.length-1>>
	<<set $B.SoleSurvivor = true>>
<<elseif deadCount() == 0>>
	<<set $B.Perfect = true>>
<</if>>

<<if !$B.defeated>>
	<<set $encounters[$scenario] = true>>
<</if>>

<<if $B.style>>
	<<addclass "body" $B.style>>
	<<removeclass "html" $B.style>>
<</if>>

<<refreshPuppets>>

<<include "custom end of battle">>

<<unset $B; $enemies>>
<</widget>>
}}}
This widget is called to clean up variables after battle. It resets {{{$inbattle}}} to {{{false}}}, clears the health meters, battle controller, and {{{$enemies}}} variable since we no longer need them, flags the encounter as done in the {{{$encounters}}} object, resets the style if there was one, and restores puppets to their resting states (see {{{<<refreshPuppets>>}}}).

There is also a block that records how many puppets were defeated in the battle. This was used for calculating some achievements in <i>Cartoon Battle</i>; you may use it for whatever purposes you wish. Note, however, that since {{{$B}}} is cleared at the end of this widget, you will have to record these flags to another variable in "custom end of battle" if you wish to use them past this point.

By default, the only thing in "custom end of battle" is a call to the {{{<<restock>>}}} widget, which replenishes all items.

<h3 id="backbtn">{{{<<backbtn>>}}}</h3>
{{{
<<widget "backbtn">>
<span class="btn back right" id="battlebackbtn">[[Back [R]|Battle!][$B.phase = "command"; $B.targeting = null; $action = null; $B.target = null; $B.subject = null; $removed_effects = [];]]</span>
<</widget>>
}}}
The {{{<<backbtn>>}}} widget (an abbreviation for "back button") is the gray "BACK" button you see in battle. It's just a link back to the battle hub, plus a whole host of variable assignments to reset any flags triggered while selecting actions, such as {{{$B.target}}}. If this wasn't done, flags might be able to "bleed over" into other actions when they weren't supposed to -- enabling you to select characters to attack outside of the targeting phase, for instance.

<h3 id="victorycheck">{{{<<victorycheck>>}}}</h3>
{{{
<<widget "victorycheck">>
<<set _victory to 0>>
<<set _defeat to 0>>
<<for _enemy range $enemies>>
	<<if _enemy.dead>>
		<<set _victory++>>
	<</if>>
<</for>>
<<if _victory eq $enemies.length>>
	<<set $B.victory = true>>
	<<goto "Victory">>
<</if>>
<<for _puppet range $puppets>>
	<<if _puppet.dead>>
		<<set _defeat++>>
	<</if>>
<</for>>
<<if _defeat eq $puppets.length>>
	<<set $B.defeat = true>>
	<<goto "Defeat">>
<</if>>
<</widget>>
}}}
You need to have some handler to determine when your player wins or loses the game. This widget, called at the start of the "Battle!" passage (so, constantly throughout the battle) runs over the enemy and ally parties and uses a temporary variable to track how many have been defeated. If the dead characters equal the length of the array (that is to say, all the characters have been defeated), the player is immediately moved to a new passage: "Victory" for the enemies' defeat, and "Defeat" for the player's defeat.

Note that the check and move for the "victory" handler is performed before the "defeat" check. This means that if the player and enemy are defeated simultaneously, the win will default to the player. This situation is very rare, as it requires an action that hurts both sides, but if you plan to implement actions like that, it is a good idea to think about how you want that situation to be handled.
{{{
<<set $B.victory = true>>
(...)
<<set $B.defeat = true>>
}}}
Additionally, we need to explicitly set a flag when victory or defeat has happened. This is because of <a class="noExternal" href="#auto-end">the auto-endturn feature</a>; because it also uses a forced passage change, it is possible for the {{{<<goto "Victory">>}}} and {{{<<goto "end of round">>}}} commands to stack, sending the player in a loop that causes strange effects.

<h3 id="stat">{{{<<stat>>}}}</h3>
{{{
<<widget "stat">>
/* Designed by greyelf */
	/* Check that a Stat Name was passed to the widget. */
	<<if $args.length is 0>>
		ERROR
	<<else>>
		<<set _current to $B.actor.get($args[0]) >>
		<<set _base to $B.actor.getBase($args[0]) + $B.actor.getBonus($args[0]) >>

		/* Check if the Stat has been raised. */
		<<if _current > _base >>
			@@.stat-raised;_current@@

		/* Check if the Stat has been lowered. */
		<<elseif _current < _base >>
			@@.stat-lowered;_current@@

		/* The Stat has not changed. */
		<<else>>
			_current
		<</if>>

	<</if>>
<</widget>>
}}}
This widget was provided by Twinery user greyelf in response to one of my questions. It enables the conditional coloring of the stats that display in the status pane depending on if they've been raised or lowered by stat mod effects.

The {{{@@}}} symbols here modify webpage elements. The first line adds the given class to the current element, and the second line (after the semicolon) populates the current element with text. In this case, it always populates the element with {{{_current}}}, but adds the {{{.stat-raised}}} class if the stat has been raised, and adds the {{{.stat-lowered}}} class if the stat has been lowered. The rules for these classes are defined in the story stylesheet; they color the text blue and red, respectively.

<h3 id="itemdrop">{{{<<itemDrop>>}}}</h3>
{{{
<<widget "itemDrop">>
<<set _item = new Item($args[0])>>
<<if def $args[1] && typeof($args[1]) == 'number'>>
	<<set _amt = $args[1]>>
<<else>>
	<<set _amt = 1>>
<</if>>

<<set _added = $inventory.addItem($args[0],_amt)>>
<center>
<div class="itembox">
<b>_item.name<span style="float:right">x<<print _amt>></span></b><br/>
<<print _item.info>><br/>
<span class="actdesc"><<print _item.desc>></span>
</div>
<<if _added === false>>
	<i>You can't hold any more of these! Use or sell some and then come back.</i>
<</if>>
</center>
<</widget>>
}}}
This widget provides a standardized method for informing the player they've received an item. Pass the name of the item as the first argument and the amount as the second. If no amount is set, it will default to 1. The widget then displays the item's information in a fancy box, and notifies the player if they've run out of inventory space.

<h3 id="musicwidgets">Music widgets</h3>
{{{
<<widget "playMusic">>
<<if $args.length > 0 && typeof($args[0]) == 'string'>>
    <<if !SimpleAudio.tracks.get(_trackId).isPlaying()>>
		<<audio ":playing" stop>>
	<</if>>
    <<set $music = new Music($args[0])>>
    <<set _trackId = $args[0].split(' ').join('_')>>
    <<if !$args.includes("instant") && !SimpleAudio.tracks.get(_trackId).isPlaying()>>
        <<script>>
		/* code provided by The Mad Exile */
        var selector = State.temporary.trackId;
        setTimeout(function () {
            SimpleAudio.select(selector)
                .loop(true)
                .volume(1)
                .play();
        }, 500); /* in milliseconds */
        <</script>>
    <<else>>
        <<audio _trackId volume 1 play loop>>
    <</if>>
	<<if document.getElementById("musicInfo")>>
		<<replace "#musicInfo">><<include "music info">><</replace>>
	<</if>>
<<else>>
    <<run console.log("ERROR in playMusic: non-string argument passed")>>
<</if>>
<</widget>>

<<widget "clearMusic">>
	<<audio ":playing" volume 1 stop>>
	<<unset $music>>
	<<if document.getElementById("musicInfo")>>
		<<replace "#musicInfo">><<include "music info">><</replace>>
	<</if>>
<</widget>>
}}}
These widgets handle the playing and stopping of background music. Their main purpose is to sync the current track with the {{{music}}} variable, which is used to display information for the currently playing track in the sidebar, but there are some other functions as well.
{{{
<<if !SimpleAudio.tracks.get(_trackId).isPlaying()>>
	<<audio ":playing" stop>>
<</if>>
}}}
The start of the widget stops all currently playing audio aside from the called track, because generally, you only want one background music track playing at a time. (If you plan to use other audio, such as sound effects, you may want to create a "BGM" audio group and limit your {{{stop}}} command to that group.)
{{{
<<set $music = new Music($args[0])>>
}}}
The {{{Music}}} class is defined in the {{{database-music.js}}} file. There, you can create a database mapping composer, license, album, and etc. to the track name, instead of needing to set all of that information manually every time you change a track.
{{{
<<set _trackId = $args[0].split(' ').join('_')>>
}}}
Track names in SugarCube cannot contain spaces. Standard practice is to substitute underscores instead. This code allows the program to correctly call the track ID while allowing you to input the name with spaces, for convenience.
{{{
<<script>>
/* code provided by The Mad Exile */
var selector = State.temporary.trackId;
setTimeout(function () {
	SimpleAudio.select(selector)
		.loop(true)
		.volume(1)
		.play();
}, 500); /* in milliseconds */
<</script>>
}}}
This is raw JavaScript code that makes a call to the {{{SimpleAudio}}} feature, which controls audio in SugarCube. The important feature here is that it adds a half-second delay. Audio processing can sometimes happen too fast in Twine, starting the track before the passage has finished rendering. This short delay typically allows the audio to sync up more nicely with the passage loading times, especially when calling battle music.
{{{
<<if !$args.includes("instant") && !SimpleAudio.tracks.get(_trackId).isPlaying()>>
(...)
<<else>>
	<<audio _trackId volume 1 play loop>>
<</if>>
}}}
If you don't want it, though, you can pass the "instant" argument to the widget, which will call the normal {{{<<audio>>}}} macro.
{{{
<<if document.getElementById("musicInfo")>>
	<<replace "#musicInfo">><<include "music info">><</replace>>
<</if>>
}}}
Finally, we refresh the music info in the sidebar to update it to display our new track.

{{{<<clearMuisc>>}}} is much simpler, and just stops the current audio while erasing the {{{music}}} variable.

<h3 id="find">{{{<<find>>}}}</h3>
{{{
<<widget "find">>
/* args0 is target array, args1 is attribute, args2 is key value */
/* Note that if your key is a string, it must be in quotes in the final code, which means you must send it to the widget with an extra pair of literal quotes (preceeded by the escape slash) */
<<print '<<set _pos = '+$args[0]+'.map(function(x) { return(x.'+$args[1]+') }).indexOf('+$args[2]+')>>'>>
<</widget>>
}}}
This widget was made early in the engine's design, before I knew about JavaScript's {{{Array.find}}} function. It essentially replicates this functionality, but in most cases you are better off just using {{{find}}}.

What you see here is a JavaScript function that searches through an array of objects and returns the index of a given attribute that matches a given value. The array, the attribute, and the value are given as arguments to the widget, in that order. After it's done, it'll store the index value in {{{_pos}}} for you to use elsewhere. If it didn't find anything, {{{_pos}}} will be set to -1.

Why is it wrapped in a {{{<<print>>}}} statement? This is something the Twine community calls the "Stupid Print Trick", because it looks stupid, but it actually works. If you use the {{{<<print>>}}} statement to print code, that code will be executed. Because {{{<<print>>}}} can concatenate strings, this is handy for creating code with variable parameters. The only trick is that every one of the arguments has to be a string literal (surrounded by quotes), or it won't work. The other caveat is that if you're searching for a string value, that value must <i>display in the code</i> as a string literal, which requires you to add an extra pair of quotes. You must do this by using the escape slash {{{\}}} character so they're parsed as literal.

If you didn't understand that, don't worry! Just follow the directions in the comment and you should be fine.
