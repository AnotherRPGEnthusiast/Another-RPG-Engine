<!DOCTYPE html>
<html data-init="no-js">
<head>
<meta charset="UTF-8" />
<title>Another RPG Engine</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!--

SugarCube (v2.36.1): A free (gratis and libre) story format.

Copyright © 2013–2021 Thomas Michael Edwards <thomasmedwards@gmail.com>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<script id="script-libraries" type="text/javascript">
if(document.head&&document.addEventListener&&document.querySelector&&Object.create&&Object.freeze&&JSON){document.documentElement.setAttribute("data-init", "loading");
/*! @source http://purl.eligrey.com/github/classList.js/blob/1.2.20171210/classList.js */
"document"in self&&("classList"in document.createElement("_")&&(!document.createElementNS||"classList"in document.createElementNS("http://www.w3.org/2000/svg","g"))||!function(t){"use strict";if("Element"in t){var e="classList",n="prototype",i=t.Element[n],s=Object,r=String[n].trim||function(){return this.replace(/^\s+|\s+$/g,"")},o=Array[n].indexOf||function(t){for(var e=0,n=this.length;n>e;e++)if(e in this&&this[e]===t)return e;return-1},c=function(t,e){this.name=t,this.code=DOMException[t],this.message=e},a=function(t,e){if(""===e)throw new c("SYNTAX_ERR","The token must not be empty.");if(/\s/.test(e))throw new c("INVALID_CHARACTER_ERR","The token must not contain space characters.");return o.call(t,e)},l=function(t){for(var e=r.call(t.getAttribute("class")||""),n=e?e.split(/\s+/):[],i=0,s=n.length;s>i;i++)this.push(n[i]);this._updateClassName=function(){t.setAttribute("class",this.toString())}},u=l[n]=[],h=function(){return new l(this)};if(c[n]=Error[n],u.item=function(t){return this[t]||null},u.contains=function(t){return~a(this,t+"")},u.add=function(){var t,e=arguments,n=0,i=e.length,s=!1;do t=e[n]+"",~a(this,t)||(this.push(t),s=!0);while(++n<i);s&&this._updateClassName()},u.remove=function(){var t,e,n=arguments,i=0,s=n.length,r=!1;do for(t=n[i]+"",e=a(this,t);~e;)this.splice(e,1),r=!0,e=a(this,t);while(++i<s);r&&this._updateClassName()},u.toggle=function(t,e){var n=this.contains(t),i=n?e!==!0&&"remove":e!==!1&&"add";return i&&this[i](t),e===!0||e===!1?e:!n},u.replace=function(t,e){var n=a(t+"");~n&&(this.splice(n,1,e),this._updateClassName())},u.toString=function(){return this.join(" ")},s.defineProperty){var f={get:h,enumerable:!0,configurable:!0};try{s.defineProperty(i,e,f)}catch(p){void 0!==p.number&&-2146823252!==p.number||(f.enumerable=!1,s.defineProperty(i,e,f))}}else s[n].__defineGetter__&&i.__defineGetter__(e,h)}}(self),function(){"use strict";var t=document.createElement("_");if(t.classList.add("c1","c2"),!t.classList.contains("c2")){var e=function(t){var e=DOMTokenList.prototype[t];DOMTokenList.prototype[t]=function(t){var n,i=arguments.length;for(n=0;i>n;n++)t=arguments[n],e.call(this,t)}};e("add"),e("remove")}if(t.classList.toggle("c3",!1),t.classList.contains("c3")){var n=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(t,e){return 1 in arguments&&!this.contains(t)==!e?e:n.call(this,t)}}"replace"in document.createElement("_").classList||(DOMTokenList.prototype.replace=function(t,e){var n=this.toString().split(" "),i=n.indexOf(t+"");~i&&(n=n.slice(i),this.remove.apply(this,n),this.add(e),this.add.apply(this,n.slice(1)))}),t=null}());
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/v4.5.14/LICENSE
 */
(function(t,r){"use strict";if(typeof define==="function"&&define.amd){define(r)}else if(typeof exports==="object"){module.exports=r()}else{t.returnExports=r()}})(this,function(){var t=Array;var r=t.prototype;var e=Object;var n=e.prototype;var i=Function;var a=i.prototype;var o=String;var f=o.prototype;var u=Number;var l=u.prototype;var s=r.slice;var c=r.splice;var v=r.push;var h=r.unshift;var p=r.concat;var y=r.join;var d=a.call;var g=a.apply;var w=Math.max;var b=Math.min;var T=n.toString;var m=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";var D;var S=Function.prototype.toString,x=/^\s*class /,O=function isES6ClassFn(t){try{var r=S.call(t);var e=r.replace(/\/\/.*\n/g,"");var n=e.replace(/\/\*[.\s\S]*\*\//g,"");var i=n.replace(/\n/gm," ").replace(/ {2}/g," ");return x.test(i)}catch(a){return false}},E=function tryFunctionObject(t){try{if(O(t)){return false}S.call(t);return true}catch(r){return false}},j="[object Function]",I="[object GeneratorFunction]",D=function isCallable(t){if(!t){return false}if(typeof t!=="function"&&typeof t!=="object"){return false}if(m){return E(t)}if(O(t)){return false}var r=T.call(t);return r===j||r===I};var M;var U=RegExp.prototype.exec,$=function tryRegexExec(t){try{U.call(t);return true}catch(r){return false}},F="[object RegExp]";M=function isRegex(t){if(typeof t!=="object"){return false}return m?$(t):T.call(t)===F};var N;var C=String.prototype.valueOf,k=function tryStringObject(t){try{C.call(t);return true}catch(r){return false}},A="[object String]";N=function isString(t){if(typeof t==="string"){return true}if(typeof t!=="object"){return false}return m?k(t):T.call(t)===A};var R=e.defineProperty&&function(){try{var t={};e.defineProperty(t,"x",{enumerable:false,value:t});for(var r in t){return false}return t.x===t}catch(n){return false}}();var P=function(t){var r;if(R){r=function(t,r,n,i){if(!i&&r in t){return}e.defineProperty(t,r,{configurable:true,enumerable:false,writable:true,value:n})}}else{r=function(t,r,e,n){if(!n&&r in t){return}t[r]=e}}return function defineProperties(e,n,i){for(var a in n){if(t.call(n,a)){r(e,a,n[a],i)}}}}(n.hasOwnProperty);var J=function isPrimitive(t){var r=typeof t;return t===null||r!=="object"&&r!=="function"};var Y=u.isNaN||function isActualNaN(t){return t!==t};var z={ToInteger:function ToInteger(t){var r=+t;if(Y(r)){r=0}else if(r!==0&&r!==1/0&&r!==-(1/0)){r=(r>0||-1)*Math.floor(Math.abs(r))}return r},ToPrimitive:function ToPrimitive(t){var r,e,n;if(J(t)){return t}e=t.valueOf;if(D(e)){r=e.call(t);if(J(r)){return r}}n=t.toString;if(D(n)){r=n.call(t);if(J(r)){return r}}throw new TypeError},ToObject:function(t){if(t==null){throw new TypeError("can't convert "+t+" to object")}return e(t)},ToUint32:function ToUint32(t){return t>>>0}};var Z=function Empty(){};P(a,{bind:function bind(t){var r=this;if(!D(r)){throw new TypeError("Function.prototype.bind called on incompatible "+r)}var n=s.call(arguments,1);var a;var o=function(){if(this instanceof a){var i=g.call(r,this,p.call(n,s.call(arguments)));if(e(i)===i){return i}return this}else{return g.call(r,t,p.call(n,s.call(arguments)))}};var f=w(0,r.length-n.length);var u=[];for(var l=0;l<f;l++){v.call(u,"$"+l)}a=i("binder","return function ("+y.call(u,",")+"){ return binder.apply(this, arguments); }")(o);if(r.prototype){Z.prototype=r.prototype;a.prototype=new Z;Z.prototype=null}return a}});var G=d.bind(n.hasOwnProperty);var H=d.bind(n.toString);var W=d.bind(s);var B=g.bind(s);if(typeof document==="object"&&document&&document.documentElement){try{W(document.documentElement.childNodes)}catch(X){var L=W;var q=B;W=function arraySliceIE(t){var r=[];var e=t.length;while(e-- >0){r[e]=t[e]}return q(r,L(arguments,1))};B=function arraySliceApplyIE(t,r){return q(W(t),r)}}}var K=d.bind(f.slice);var Q=d.bind(f.split);var V=d.bind(f.indexOf);var _=d.bind(v);var tt=d.bind(n.propertyIsEnumerable);var rt=d.bind(r.sort);var et=t.isArray||function isArray(t){return H(t)==="[object Array]"};var nt=[].unshift(0)!==1;P(r,{unshift:function(){h.apply(this,arguments);return this.length}},nt);P(t,{isArray:et});var it=e("a");var at=it[0]!=="a"||!(0 in it);var ot=function properlyBoxed(t){var r=true;var e=true;var n=false;if(t){try{t.call("foo",function(t,e,n){if(typeof n!=="object"){r=false}});t.call([1],function(){"use strict";e=typeof this==="string"},"x")}catch(i){n=true}}return!!t&&!n&&r&&e};P(r,{forEach:function forEach(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=-1;var i=z.ToUint32(e.length);var a;if(arguments.length>1){a=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.forEach callback must be a function")}while(++n<i){if(n in e){if(typeof a==="undefined"){t(e[n],n,r)}else{t.call(a,e[n],n,r)}}}}},!ot(r.forEach));P(r,{map:function map(r){var e=z.ToObject(this);var n=at&&N(this)?Q(this,""):e;var i=z.ToUint32(n.length);var a=t(i);var o;if(arguments.length>1){o=arguments[1]}if(!D(r)){throw new TypeError("Array.prototype.map callback must be a function")}for(var f=0;f<i;f++){if(f in n){if(typeof o==="undefined"){a[f]=r(n[f],f,e)}else{a[f]=r.call(o,n[f],f,e)}}}return a}},!ot(r.map));P(r,{filter:function filter(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i=[];var a;var o;if(arguments.length>1){o=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.filter callback must be a function")}for(var f=0;f<n;f++){if(f in e){a=e[f];if(typeof o==="undefined"?t(a,f,r):t.call(o,a,f,r)){_(i,a)}}}return i}},!ot(r.filter));P(r,{every:function every(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.every callback must be a function")}for(var a=0;a<n;a++){if(a in e&&!(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return false}}return true}},!ot(r.every));P(r,{some:function some(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.some callback must be a function")}for(var a=0;a<n;a++){if(a in e&&(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return true}}return false}},!ot(r.some));var ft=false;if(r.reduce){ft=typeof r.reduce.call("es5",function(t,r,e,n){return n})==="object"}P(r,{reduce:function reduce(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduce callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduce of empty array with no initial value")}var i=0;var a;if(arguments.length>=2){a=arguments[1]}else{do{if(i in e){a=e[i++];break}if(++i>=n){throw new TypeError("reduce of empty array with no initial value")}}while(true)}for(;i<n;i++){if(i in e){a=t(a,e[i],i,r)}}return a}},!ft);var ut=false;if(r.reduceRight){ut=typeof r.reduceRight.call("es5",function(t,r,e,n){return n})==="object"}P(r,{reduceRight:function reduceRight(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduceRight callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduceRight of empty array with no initial value")}var i;var a=n-1;if(arguments.length>=2){i=arguments[1]}else{do{if(a in e){i=e[a--];break}if(--a<0){throw new TypeError("reduceRight of empty array with no initial value")}}while(true)}if(a<0){return i}do{if(a in e){i=t(i,e[a],a,r)}}while(a--);return i}},!ut);var lt=r.indexOf&&[0,1].indexOf(1,2)!==-1;P(r,{indexOf:function indexOf(t){var r=at&&N(this)?Q(this,""):z.ToObject(this);var e=z.ToUint32(r.length);if(e===0){return-1}var n=0;if(arguments.length>1){n=z.ToInteger(arguments[1])}n=n>=0?n:w(0,e+n);for(;n<e;n++){if(n in r&&r[n]===t){return n}}return-1}},lt);var st=r.lastIndexOf&&[0,1].lastIndexOf(0,-3)!==-1;P(r,{lastIndexOf:function lastIndexOf(t){var r=at&&N(this)?Q(this,""):z.ToObject(this);var e=z.ToUint32(r.length);if(e===0){return-1}var n=e-1;if(arguments.length>1){n=b(n,z.ToInteger(arguments[1]))}n=n>=0?n:e-Math.abs(n);for(;n>=0;n--){if(n in r&&t===r[n]){return n}}return-1}},st);var ct=function(){var t=[1,2];var r=t.splice();return t.length===2&&et(r)&&r.length===0}();P(r,{splice:function splice(t,r){if(arguments.length===0){return[]}else{return c.apply(this,arguments)}}},!ct);var vt=function(){var t={};r.splice.call(t,0,0,1);return t.length===1}();P(r,{splice:function splice(t,r){if(arguments.length===0){return[]}var e=arguments;this.length=w(z.ToInteger(this.length),0);if(arguments.length>0&&typeof r!=="number"){e=W(arguments);if(e.length<2){_(e,this.length-t)}else{e[1]=z.ToInteger(r)}}return c.apply(this,e)}},!vt);var ht=function(){var r=new t(1e5);r[8]="x";r.splice(1,1);return r.indexOf("x")===7}();var pt=function(){var t=256;var r=[];r[t]="a";r.splice(t+1,0,"b");return r[t]==="a"}();P(r,{splice:function splice(t,r){var e=z.ToObject(this);var n=[];var i=z.ToUint32(e.length);var a=z.ToInteger(t);var f=a<0?w(i+a,0):b(a,i);var u=arguments.length===0?0:arguments.length===1?i-f:b(w(z.ToInteger(r),0),i-f);var l=0;var s;while(l<u){s=o(f+l);if(G(e,s)){n[l]=e[s]}l+=1}var c=W(arguments,2);var v=c.length;var h;if(v<u){l=f;var p=i-u;while(l<p){s=o(l+u);h=o(l+v);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l+=1}l=i;var y=i-u+v;while(l>y){delete e[l-1];l-=1}}else if(v>u){l=i-u;while(l>f){s=o(l+u-1);h=o(l+v-1);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l-=1}}l=f;for(var d=0;d<c.length;++d){e[l]=c[d];l+=1}e.length=i-u+v;return n}},!ht||!pt);var yt=r.join;var dt;try{dt=Array.prototype.join.call("123",",")!=="1,2,3"}catch(X){dt=true}if(dt){P(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return yt.call(N(this)?Q(this,""):this,r)}},dt)}var gt=[1,2].join(undefined)!=="1,2";if(gt){P(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return yt.call(this,r)}},gt)}var wt=function push(t){var r=z.ToObject(this);var e=z.ToUint32(r.length);var n=0;while(n<arguments.length){r[e+n]=arguments[n];n+=1}r.length=e+n;return e+n};var bt=function(){var t={};var r=Array.prototype.push.call(t,undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();P(r,{push:function push(t){if(et(this)){return v.apply(this,arguments)}return wt.apply(this,arguments)}},bt);var Tt=function(){var t=[];var r=t.push(undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();P(r,{push:wt},Tt);P(r,{slice:function(t,r){var e=N(this)?Q(this,""):this;return B(e,arguments)}},at);var mt=function(){try{[1,2].sort(null)}catch(t){try{[1,2].sort({})}catch(r){return false}}return true}();var Dt=function(){try{[1,2].sort(/a/);return false}catch(t){}return true}();var St=function(){try{[1,2].sort(undefined);return true}catch(t){}return false}();P(r,{sort:function sort(t){if(typeof t==="undefined"){return rt(this)}if(!D(t)){throw new TypeError("Array.prototype.sort callback must be a function")}return rt(this,t)}},mt||!St||!Dt);var xt=!tt({toString:null},"toString");var Ot=tt(function(){},"prototype");var Et=!G("x","0");var jt=function(t){var r=t.constructor;return r&&r.prototype===t};var It={$applicationCache:true,$console:true,$external:true,$frame:true,$frameElement:true,$frames:true,$innerHeight:true,$innerWidth:true,$onmozfullscreenchange:true,$onmozfullscreenerror:true,$outerHeight:true,$outerWidth:true,$pageXOffset:true,$pageYOffset:true,$parent:true,$scrollLeft:true,$scrollTop:true,$scrollX:true,$scrollY:true,$self:true,$webkitIndexedDB:true,$webkitStorageInfo:true,$window:true,$width:true,$height:true,$top:true,$localStorage:true};var Mt=function(){if(typeof window==="undefined"){return false}for(var t in window){try{if(!It["$"+t]&&G(window,t)&&window[t]!==null&&typeof window[t]==="object"){jt(window[t])}}catch(r){return true}}return false}();var Ut=function(t){if(typeof window==="undefined"||!Mt){return jt(t)}try{return jt(t)}catch(r){return false}};var $t=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"];var Ft=$t.length;var Nt=function isArguments(t){return H(t)==="[object Arguments]"};var Ct=function isArguments(t){return t!==null&&typeof t==="object"&&typeof t.length==="number"&&t.length>=0&&!et(t)&&D(t.callee)};var kt=Nt(arguments)?Nt:Ct;P(e,{keys:function keys(t){var r=D(t);var e=kt(t);var n=t!==null&&typeof t==="object";var i=n&&N(t);if(!n&&!r&&!e){throw new TypeError("Object.keys called on a non-object")}var a=[];var f=Ot&&r;if(i&&Et||e){for(var u=0;u<t.length;++u){_(a,o(u))}}if(!e){for(var l in t){if(!(f&&l==="prototype")&&G(t,l)){_(a,o(l))}}}if(xt){var s=Ut(t);for(var c=0;c<Ft;c++){var v=$t[c];if(!(s&&v==="constructor")&&G(t,v)){_(a,v)}}}return a}});var At=e.keys&&function(){return e.keys(arguments).length===2}(1,2);var Rt=e.keys&&function(){var t=e.keys(arguments);return arguments.length!==1||t.length!==1||t[0]!==1}(1);var Pt=e.keys;P(e,{keys:function keys(t){if(kt(t)){return Pt(W(t))}else{return Pt(t)}}},!At||Rt);var Jt=new Date(-0xc782b5b342b24).getUTCMonth()!==0;var Yt=new Date(-0x55d318d56a724);var zt=new Date(14496624e5);var Zt=Yt.toUTCString()!=="Mon, 01 Jan -45875 11:59:59 GMT";var Gt;var Ht;var Wt=Yt.getTimezoneOffset();if(Wt<-720){Gt=Yt.toDateString()!=="Tue Jan 02 -45875";Ht=!/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(zt))}else{Gt=Yt.toDateString()!=="Mon Jan 01 -45875";Ht=!/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(zt))}var Bt=d.bind(Date.prototype.getFullYear);var Xt=d.bind(Date.prototype.getMonth);var Lt=d.bind(Date.prototype.getDate);var qt=d.bind(Date.prototype.getUTCFullYear);var Kt=d.bind(Date.prototype.getUTCMonth);var Qt=d.bind(Date.prototype.getUTCDate);var Vt=d.bind(Date.prototype.getUTCDay);var _t=d.bind(Date.prototype.getUTCHours);var tr=d.bind(Date.prototype.getUTCMinutes);var rr=d.bind(Date.prototype.getUTCSeconds);var er=d.bind(Date.prototype.getUTCMilliseconds);var nr=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];var ir=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];var ar=function daysInMonth(t,r){return Lt(new Date(r,t,0))};P(Date.prototype,{getFullYear:function getFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);if(t<0&&Xt(this)>11){return t+1}return t},getMonth:function getMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Xt(this);if(t<0&&r>11){return 0}return r},getDate:function getDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Xt(this);var e=Lt(this);if(t<0&&r>11){if(r===12){return e}var n=ar(0,t+1);return n-e+1}return e},getUTCFullYear:function getUTCFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);if(t<0&&Kt(this)>11){return t+1}return t},getUTCMonth:function getUTCMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);var r=Kt(this);if(t<0&&r>11){return 0}return r},getUTCDate:function getUTCDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);var r=Kt(this);var e=Qt(this);if(t<0&&r>11){if(r===12){return e}var n=ar(0,t+1);return n-e+1}return e}},Jt);P(Date.prototype,{toUTCString:function toUTCString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Vt(this);var r=Qt(this);var e=Kt(this);var n=qt(this);var i=_t(this);var a=tr(this);var o=rr(this);return nr[t]+", "+(r<10?"0"+r:r)+" "+ir[e]+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"}},Jt||Zt);P(Date.prototype,{toDateString:function toDateString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();return nr[t]+" "+ir[e]+" "+(r<10?"0"+r:r)+" "+n}},Jt||Gt);if(Jt||Ht){Date.prototype.toString=function toString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();var i=this.getHours();var a=this.getMinutes();var o=this.getSeconds();var f=this.getTimezoneOffset();var u=Math.floor(Math.abs(f)/60);var l=Math.floor(Math.abs(f)%60);return nr[t]+" "+ir[e]+" "+(r<10?"0"+r:r)+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"+(f>0?"-":"+")+(u<10?"0"+u:u)+(l<10?"0"+l:l)};if(R){e.defineProperty(Date.prototype,"toString",{configurable:true,enumerable:false,writable:true})}}var or=-621987552e5;var fr="-000001";var ur=Date.prototype.toISOString&&new Date(or).toISOString().indexOf(fr)===-1;var lr=Date.prototype.toISOString&&new Date(-1).toISOString()!=="1969-12-31T23:59:59.999Z";var sr=d.bind(Date.prototype.getTime);P(Date.prototype,{toISOString:function toISOString(){if(!isFinite(this)||!isFinite(sr(this))){throw new RangeError("Date.prototype.toISOString called on non-finite value.")}var t=qt(this);var r=Kt(this);t+=Math.floor(r/12);r=(r%12+12)%12;var e=[r+1,Qt(this),_t(this),tr(this),rr(this)];t=(t<0?"-":t>9999?"+":"")+K("00000"+Math.abs(t),0<=t&&t<=9999?-4:-6);for(var n=0;n<e.length;++n){e[n]=K("00"+e[n],-2)}return t+"-"+W(e,0,2).join("-")+"T"+W(e,2).join(":")+"."+K("000"+er(this),-3)+"Z"}},ur||lr);var cr=function(){try{return Date.prototype.toJSON&&new Date(NaN).toJSON()===null&&new Date(or).toJSON().indexOf(fr)!==-1&&Date.prototype.toJSON.call({toISOString:function(){return true}})}catch(t){return false}}();if(!cr){Date.prototype.toJSON=function toJSON(t){var r=e(this);var n=z.ToPrimitive(r);if(typeof n==="number"&&!isFinite(n)){return null}var i=r.toISOString;if(!D(i)){throw new TypeError("toISOString property is not callable")}return i.call(r)}}var vr=Date.parse("+033658-09-27T01:46:40.000Z")===1e15;var hr=!isNaN(Date.parse("2012-04-04T24:00:00.500Z"))||!isNaN(Date.parse("2012-11-31T23:59:59.000Z"))||!isNaN(Date.parse("2012-12-31T23:59:60.000Z"));var pr=isNaN(Date.parse("2000-01-01T00:00:00.000Z"));if(pr||hr||!vr){var yr=Math.pow(2,31)-1;var dr=Y(new Date(1970,0,1,0,0,0,yr+1).getTime());Date=function(t){var r=function Date(e,n,i,a,f,u,l){var s=arguments.length;var c;if(this instanceof t){var v=u;var h=l;if(dr&&s>=7&&l>yr){var p=Math.floor(l/yr)*yr;var y=Math.floor(p/1e3);v+=y;h-=y*1e3}c=s===1&&o(e)===e?new t(r.parse(e)):s>=7?new t(e,n,i,a,f,v,h):s>=6?new t(e,n,i,a,f,v):s>=5?new t(e,n,i,a,f):s>=4?new t(e,n,i,a):s>=3?new t(e,n,i):s>=2?new t(e,n):s>=1?new t(e instanceof t?+e:e):new t}else{c=t.apply(this,arguments)}if(!J(c)){P(c,{constructor:r},true)}return c};var e=new RegExp("^"+"(\\d{4}|[+-]\\d{6})"+"(?:-(\\d{2})"+"(?:-(\\d{2})"+"(?:"+"T(\\d{2})"+":(\\d{2})"+"(?:"+":(\\d{2})"+"(?:(\\.\\d{1,}))?"+")?"+"("+"Z|"+"(?:"+"([-+])"+"(\\d{2})"+":(\\d{2})"+")"+")?)?)?)?"+"$");var n=[0,31,59,90,120,151,181,212,243,273,304,334,365];var i=function dayFromMonth(t,r){var e=r>1?1:0;return n[r]+Math.floor((t-1969+e)/4)-Math.floor((t-1901+e)/100)+Math.floor((t-1601+e)/400)+365*(t-1970)};var a=function toUTC(r){var e=0;var n=r;if(dr&&n>yr){var i=Math.floor(n/yr)*yr;var a=Math.floor(i/1e3);e+=a;n-=a*1e3}return u(new t(1970,0,1,0,0,e,n))};for(var f in t){if(G(t,f)){r[f]=t[f]}}P(r,{now:t.now,UTC:t.UTC},true);r.prototype=t.prototype;P(r.prototype,{constructor:r},true);var l=function parse(r){var n=e.exec(r);if(n){var o=u(n[1]),f=u(n[2]||1)-1,l=u(n[3]||1)-1,s=u(n[4]||0),c=u(n[5]||0),v=u(n[6]||0),h=Math.floor(u(n[7]||0)*1e3),p=Boolean(n[4]&&!n[8]),y=n[9]==="-"?1:-1,d=u(n[10]||0),g=u(n[11]||0),w;var b=c>0||v>0||h>0;if(s<(b?24:25)&&c<60&&v<60&&h<1e3&&f>-1&&f<12&&d<24&&g<60&&l>-1&&l<i(o,f+1)-i(o,f)){w=((i(o,f)+l)*24+s+d*y)*60;w=((w+c+g*y)*60+v)*1e3+h;if(p){w=a(w)}if(-864e13<=w&&w<=864e13){return w}}return NaN}return t.parse.apply(this,arguments)};P(r,{parse:l});return r}(Date)}if(!Date.now){Date.now=function now(){return(new Date).getTime()}}var gr=l.toFixed&&(8e-5.toFixed(3)!=="0.000"||.9.toFixed(0)!=="1"||1.255.toFixed(2)!=="1.25"||(1000000000000000128).toFixed(0)!=="1000000000000000128");var wr={base:1e7,size:6,data:[0,0,0,0,0,0],multiply:function multiply(t,r){var e=-1;var n=r;while(++e<wr.size){n+=t*wr.data[e];wr.data[e]=n%wr.base;n=Math.floor(n/wr.base)}},divide:function divide(t){var r=wr.size;var e=0;while(--r>=0){e+=wr.data[r];wr.data[r]=Math.floor(e/t);e=e%t*wr.base}},numToString:function numToString(){var t=wr.size;var r="";while(--t>=0){if(r!==""||t===0||wr.data[t]!==0){var e=o(wr.data[t]);if(r===""){r=e}else{r+=K("0000000",0,7-e.length)+e}}}return r},pow:function pow(t,r,e){return r===0?e:r%2===1?pow(t,r-1,e*t):pow(t*t,r/2,e)},log:function log(t){var r=0;var e=t;while(e>=4096){r+=12;e/=4096}while(e>=2){r+=1;e/=2}return r}};var br=function toFixed(t){var r,e,n,i,a,f,l,s;r=u(t);r=Y(r)?0:Math.floor(r);if(r<0||r>20){throw new RangeError("Number.toFixed called with invalid number of decimals")}e=u(this);if(Y(e)){return"NaN"}if(e<=-1e21||e>=1e21){return o(e)}n="";if(e<0){n="-";e=-e}i="0";if(e>1e-21){a=wr.log(e*wr.pow(2,69,1))-69;f=a<0?e*wr.pow(2,-a,1):e/wr.pow(2,a,1);f*=4503599627370496;a=52-a;if(a>0){wr.multiply(0,f);l=r;while(l>=7){wr.multiply(1e7,0);l-=7}wr.multiply(wr.pow(10,l,1),0);l=a-1;while(l>=23){wr.divide(1<<23);l-=23}wr.divide(1<<l);wr.multiply(1,1);wr.divide(2);i=wr.numToString()}else{wr.multiply(0,f);wr.multiply(1<<-a,0);i=wr.numToString()+K("0.00000000000000000000",2,2+r)}}if(r>0){s=i.length;if(s<=r){i=n+K("0.0000000000000000000",0,r-s+2)+i}else{i=n+K(i,0,s-r)+"."+K(i,s-r)}}else{i=n+i}return i};P(l,{toFixed:br},gr);var Tr=function(){try{return 1..toPrecision(undefined)==="1"}catch(t){return true}}();var mr=l.toPrecision;P(l,{toPrecision:function toPrecision(t){return typeof t==="undefined"?mr.call(this):mr.call(this,t)}},Tr);if("ab".split(/(?:ab)*/).length!==2||".".split(/(.?)(.?)/).length!==4||"tesst".split(/(s)*/)[1]==="t"||"test".split(/(?:)/,-1).length!==4||"".split(/.?/).length||".".split(/()()/).length>1){(function(){var t=typeof/()??/.exec("")[1]==="undefined";var r=Math.pow(2,32)-1;f.split=function(e,n){var i=String(this);if(typeof e==="undefined"&&n===0){return[]}if(!M(e)){return Q(this,e,n)}var a=[];var o=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),f=0,u,l,s,c;var h=new RegExp(e.source,o+"g");if(!t){u=new RegExp("^"+h.source+"$(?!\\s)",o)}var p=typeof n==="undefined"?r:z.ToUint32(n);l=h.exec(i);while(l){s=l.index+l[0].length;if(s>f){_(a,K(i,f,l.index));if(!t&&l.length>1){l[0].replace(u,function(){for(var t=1;t<arguments.length-2;t++){if(typeof arguments[t]==="undefined"){l[t]=void 0}}})}if(l.length>1&&l.index<i.length){v.apply(a,W(l,1))}c=l[0].length;f=s;if(a.length>=p){break}}if(h.lastIndex===l.index){h.lastIndex++}l=h.exec(i)}if(f===i.length){if(c||!h.test("")){_(a,"")}}else{_(a,K(i,f))}return a.length>p?W(a,0,p):a}})()}else if("0".split(void 0,0).length){f.split=function split(t,r){if(typeof t==="undefined"&&r===0){return[]}return Q(this,t,r)}}var Dr=f.replace;var Sr=function(){var t=[];"x".replace(/x(.)?/g,function(r,e){_(t,e)});return t.length===1&&typeof t[0]==="undefined"}();if(!Sr){f.replace=function replace(t,r){var e=D(r);var n=M(t)&&/\)[*?]/.test(t.source);if(!e||!n){return Dr.call(this,t,r)}else{var i=function(e){var n=arguments.length;var i=t.lastIndex;t.lastIndex=0;var a=t.exec(e)||[];t.lastIndex=i;_(a,arguments[n-2],arguments[n-1]);return r.apply(this,a)};return Dr.call(this,t,i)}}}var xr=f.substr;var Or="".substr&&"0b".substr(-1)!=="b";P(f,{substr:function substr(t,r){var e=t;if(t<0){e=w(this.length+t,0)}return xr.call(this,e,r)}},Or);var Er="\t\n\x0B\f\r \xa0\u1680\u2000\u2001\u2002\u2003"+"\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028"+"\u2029\ufeff";var jr="\u200b";var Ir="["+Er+"]";var Mr=new RegExp("^"+Ir+Ir+"*");var Ur=new RegExp(Ir+Ir+"*$");var $r=f.trim&&(Er.trim()||!jr.trim());P(f,{trim:function trim(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}return o(this).replace(Mr,"").replace(Ur,"")}},$r);var Fr=d.bind(String.prototype.trim);var Nr=f.lastIndexOf&&"abc\u3042\u3044".lastIndexOf("\u3042\u3044",2)!==-1;P(f,{lastIndexOf:function lastIndexOf(t){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var r=o(this);var e=o(t);var n=arguments.length>1?u(arguments[1]):NaN;var i=Y(n)?Infinity:z.ToInteger(n);var a=b(w(i,0),r.length);var f=e.length;var l=a+f;while(l>0){l=w(0,l-f);var s=V(K(r,l,a+f),e);if(s!==-1){return l+s}}return-1}},Nr);var Cr=f.lastIndexOf;P(f,{lastIndexOf:function lastIndexOf(t){return Cr.apply(this,arguments)}},f.lastIndexOf.length!==1);if(parseInt(Er+"08")!==8||parseInt(Er+"0x16")!==22){parseInt=function(t){var r=/^[-+]?0[xX]/;return function parseInt(e,n){if(typeof e==="symbol"){""+e}var i=Fr(String(e));var a=u(n)||(r.test(i)?16:10);return t(i,a)}}(parseInt)}if(1/parseFloat("-0")!==-Infinity){parseFloat=function(t){return function parseFloat(r){var e=Fr(String(r));var n=t(e);return n===0&&K(e,0,1)==="-"?-0:n}}(parseFloat)}if(String(new RangeError("test"))!=="RangeError: test"){var kr=function toString(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var t=this.name;if(typeof t==="undefined"){t="Error"}else if(typeof t!=="string"){t=o(t)}var r=this.message;if(typeof r==="undefined"){r=""}else if(typeof r!=="string"){r=o(r)}if(!t){return r}if(!r){return t}return t+": "+r};Error.prototype.toString=kr}if(R){var Ar=function(t,r){if(tt(t,r)){var e=Object.getOwnPropertyDescriptor(t,r);if(e.configurable){e.enumerable=false;Object.defineProperty(t,r,e)}}};Ar(Error.prototype,"message");if(Error.prototype.message!==""){Error.prototype.message=""}Ar(Error.prototype,"name")}if(String(/a/gim)!=="/a/gim"){var Rr=function toString(){var t="/"+this.source+"/";if(this.global){t+="g"}if(this.ignoreCase){t+="i"}if(this.multiline){t+="m"}return t};RegExp.prototype.toString=Rr}});
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.4/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function(e,t){if(typeof define==="function"&&define.amd){define(t)}else if(typeof exports==="object"){module.exports=t()}else{e.returnExports=t()}})(this,function(){"use strict";var e=Function.call.bind(Function.apply);var t=Function.call.bind(Function.call);var r=Array.isArray;var n=Object.keys;var o=function notThunker(t){return function notThunk(){return!e(t,this,arguments)}};var i=function(e){try{e();return false}catch(t){return true}};var a=function valueOrFalseIfThrows(e){try{return e()}catch(t){return false}};var u=o(i);var f=function(){return!i(function(){return Object.defineProperty({},"x",{get:function(){}})})};var s=!!Object.defineProperty&&f();var c=function foo(){}.name==="foo";var l=Function.call.bind(Array.prototype.forEach);var p=Function.call.bind(Array.prototype.reduce);var v=Function.call.bind(Array.prototype.filter);var y=Function.call.bind(Array.prototype.some);var h=function(e,t,r,n){if(!n&&t in e){return}if(s){Object.defineProperty(e,t,{configurable:true,enumerable:false,writable:true,value:r})}else{e[t]=r}};var b=function(e,t,r){l(n(t),function(n){var o=t[n];h(e,n,o,!!r)})};var g=Function.call.bind(Object.prototype.toString);var d=typeof/abc/==="function"?function IsCallableSlow(e){return typeof e==="function"&&g(e)==="[object Function]"}:function IsCallableFast(e){return typeof e==="function"};var m={getter:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}Object.defineProperty(e,t,{configurable:true,enumerable:false,get:r})},proxy:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,{configurable:n.configurable,enumerable:n.enumerable,get:function getKey(){return e[t]},set:function setKey(r){e[t]=r}})},redefine:function(e,t,r){if(s){var n=Object.getOwnPropertyDescriptor(e,t);n.value=r;Object.defineProperty(e,t,n)}else{e[t]=r}},defineByDescriptor:function(e,t,r){if(s){Object.defineProperty(e,t,r)}else if("value"in r){e[t]=r.value}},preserveToString:function(e,t){if(t&&d(t.toString)){h(e,"toString",t.toString.bind(t),true)}}};var O=Object.create||function(e,t){var r=function Prototype(){};r.prototype=e;var o=new r;if(typeof t!=="undefined"){n(t).forEach(function(e){m.defineByDescriptor(o,e,t[e])})}return o};var w=function(e,t){if(!Object.setPrototypeOf){return false}return a(function(){var r=function Subclass(t){var r=new e(t);Object.setPrototypeOf(r,Subclass.prototype);return r};Object.setPrototypeOf(r,e);r.prototype=O(e.prototype,{constructor:{value:r}});return t(r)})};var j=function(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")};var S=j();var T=S.isFinite;var I=Function.call.bind(String.prototype.indexOf);var E=Function.apply.bind(Array.prototype.indexOf);var P=Function.call.bind(Array.prototype.concat);var C=Function.call.bind(String.prototype.slice);var M=Function.call.bind(Array.prototype.push);var x=Function.apply.bind(Array.prototype.push);var N=Function.call.bind(Array.prototype.shift);var A=Math.max;var R=Math.min;var _=Math.floor;var k=Math.abs;var L=Math.exp;var F=Math.log;var D=Math.sqrt;var z=Function.call.bind(Object.prototype.hasOwnProperty);var q;var W=function(){};var G=S.Map;var H=G&&G.prototype["delete"];var V=G&&G.prototype.get;var B=G&&G.prototype.has;var U=G&&G.prototype.set;var $=S.Symbol||{};var J=$.species||"@@species";var X=Number.isNaN||function isNaN(e){return e!==e};var K=Number.isFinite||function isFinite(e){return typeof e==="number"&&T(e)};var Z=d(Math.sign)?Math.sign:function sign(e){var t=Number(e);if(t===0){return t}if(X(t)){return t}return t<0?-1:1};var Y=function log1p(e){var t=Number(e);if(t<-1||X(t)){return NaN}if(t===0||t===Infinity){return t}if(t===-1){return-Infinity}return 1+t-1===0?t:t*(F(1+t)/(1+t-1))};var Q=function isArguments(e){return g(e)==="[object Arguments]"};var ee=function isArguments(e){return e!==null&&typeof e==="object"&&typeof e.length==="number"&&e.length>=0&&g(e)!=="[object Array]"&&g(e.callee)==="[object Function]"};var te=Q(arguments)?Q:ee;var re={primitive:function(e){return e===null||typeof e!=="function"&&typeof e!=="object"},string:function(e){return g(e)==="[object String]"},regex:function(e){return g(e)==="[object RegExp]"},symbol:function(e){return typeof S.Symbol==="function"&&typeof e==="symbol"}};var ne=function overrideNative(e,t,r){var n=e[t];h(e,t,r,true);m.preserveToString(e[t],n)};var oe=typeof $==="function"&&typeof $["for"]==="function"&&re.symbol($());var ie=re.symbol($.iterator)?$.iterator:"_es6-shim iterator_";if(S.Set&&typeof(new S.Set)["@@iterator"]==="function"){ie="@@iterator"}if(!S.Reflect){h(S,"Reflect",{},true)}var ae=S.Reflect;var ue=String;var fe=typeof document==="undefined"||!document?null:document.all;var se=fe==null?function isNullOrUndefined(e){return e==null}:function isNullOrUndefinedAndNotDocumentAll(e){return e==null&&e!==fe};var ce={Call:function Call(t,r){var n=arguments.length>2?arguments[2]:[];if(!ce.IsCallable(t)){throw new TypeError(t+" is not a function")}return e(t,r,n)},RequireObjectCoercible:function(e,t){if(se(e)){throw new TypeError(t||"Cannot call method on "+e)}return e},TypeIsObject:function(e){if(e===void 0||e===null||e===true||e===false){return false}return typeof e==="function"||typeof e==="object"||e===fe},ToObject:function(e,t){return Object(ce.RequireObjectCoercible(e,t))},IsCallable:d,IsConstructor:function(e){return ce.IsCallable(e)},ToInt32:function(e){return ce.ToNumber(e)>>0},ToUint32:function(e){return ce.ToNumber(e)>>>0},ToNumber:function(e){if(g(e)==="[object Symbol]"){throw new TypeError("Cannot convert a Symbol value to a number")}return+e},ToInteger:function(e){var t=ce.ToNumber(e);if(X(t)){return 0}if(t===0||!K(t)){return t}return(t>0?1:-1)*_(k(t))},ToLength:function(e){var t=ce.ToInteger(e);if(t<=0){return 0}if(t>Number.MAX_SAFE_INTEGER){return Number.MAX_SAFE_INTEGER}return t},SameValue:function(e,t){if(e===t){if(e===0){return 1/e===1/t}return true}return X(e)&&X(t)},SameValueZero:function(e,t){return e===t||X(e)&&X(t)},IsIterable:function(e){return ce.TypeIsObject(e)&&(typeof e[ie]!=="undefined"||te(e))},GetIterator:function(e){if(te(e)){return new q(e,"value")}var t=ce.GetMethod(e,ie);if(!ce.IsCallable(t)){throw new TypeError("value is not an iterable")}var r=ce.Call(t,e);if(!ce.TypeIsObject(r)){throw new TypeError("bad iterator")}return r},GetMethod:function(e,t){var r=ce.ToObject(e)[t];if(se(r)){return void 0}if(!ce.IsCallable(r)){throw new TypeError("Method not callable: "+t)}return r},IteratorComplete:function(e){return!!e.done},IteratorClose:function(e,t){var r=ce.GetMethod(e,"return");if(r===void 0){return}var n,o;try{n=ce.Call(r,e)}catch(i){o=i}if(t){return}if(o){throw o}if(!ce.TypeIsObject(n)){throw new TypeError("Iterator's return method returned a non-object.")}},IteratorNext:function(e){var t=arguments.length>1?e.next(arguments[1]):e.next();if(!ce.TypeIsObject(t)){throw new TypeError("bad iterator")}return t},IteratorStep:function(e){var t=ce.IteratorNext(e);var r=ce.IteratorComplete(t);return r?false:t},Construct:function(e,t,r,n){var o=typeof r==="undefined"?e:r;if(!n&&ae.construct){return ae.construct(e,t,o)}var i=o.prototype;if(!ce.TypeIsObject(i)){i=Object.prototype}var a=O(i);var u=ce.Call(e,a,t);return ce.TypeIsObject(u)?u:a},SpeciesConstructor:function(e,t){var r=e.constructor;if(r===void 0){return t}if(!ce.TypeIsObject(r)){throw new TypeError("Bad constructor")}var n=r[J];if(se(n)){return t}if(!ce.IsConstructor(n)){throw new TypeError("Bad @@species")}return n},CreateHTML:function(e,t,r,n){var o=ce.ToString(e);var i="<"+t;if(r!==""){var a=ce.ToString(n);var u=a.replace(/"/g,"&quot;");i+=" "+r+'="'+u+'"'}var f=i+">";var s=f+o;return s+"</"+t+">"},IsRegExp:function IsRegExp(e){if(!ce.TypeIsObject(e)){return false}var t=e[$.match];if(typeof t!=="undefined"){return!!t}return re.regex(e)},ToString:function ToString(e){return ue(e)}};if(s&&oe){var le=function defineWellKnownSymbol(e){if(re.symbol($[e])){return $[e]}var t=$["for"]("Symbol."+e);Object.defineProperty($,e,{configurable:false,enumerable:false,writable:false,value:t});return t};if(!re.symbol($.search)){var pe=le("search");var ve=String.prototype.search;h(RegExp.prototype,pe,function search(e){return ce.Call(ve,e,[this])});var ye=function search(e){var t=ce.RequireObjectCoercible(this);if(!se(e)){var r=ce.GetMethod(e,pe);if(typeof r!=="undefined"){return ce.Call(r,e,[t])}}return ce.Call(ve,t,[ce.ToString(e)])};ne(String.prototype,"search",ye)}if(!re.symbol($.replace)){var he=le("replace");var be=String.prototype.replace;h(RegExp.prototype,he,function replace(e,t){return ce.Call(be,e,[this,t])});var ge=function replace(e,t){var r=ce.RequireObjectCoercible(this);if(!se(e)){var n=ce.GetMethod(e,he);if(typeof n!=="undefined"){return ce.Call(n,e,[r,t])}}return ce.Call(be,r,[ce.ToString(e),t])};ne(String.prototype,"replace",ge)}if(!re.symbol($.split)){var de=le("split");var me=String.prototype.split;h(RegExp.prototype,de,function split(e,t){return ce.Call(me,e,[this,t])});var Oe=function split(e,t){var r=ce.RequireObjectCoercible(this);if(!se(e)){var n=ce.GetMethod(e,de);if(typeof n!=="undefined"){return ce.Call(n,e,[r,t])}}return ce.Call(me,r,[ce.ToString(e),t])};ne(String.prototype,"split",Oe)}var we=re.symbol($.match);var je=we&&function(){var e={};e[$.match]=function(){return 42};return"a".match(e)!==42}();if(!we||je){var Se=le("match");var Te=String.prototype.match;h(RegExp.prototype,Se,function match(e){return ce.Call(Te,e,[this])});var Ie=function match(e){var t=ce.RequireObjectCoercible(this);if(!se(e)){var r=ce.GetMethod(e,Se);if(typeof r!=="undefined"){return ce.Call(r,e,[t])}}return ce.Call(Te,t,[ce.ToString(e)])};ne(String.prototype,"match",Ie)}}var Ee=function wrapConstructor(e,t,r){m.preserveToString(t,e);if(Object.setPrototypeOf){Object.setPrototypeOf(e,t)}if(s){l(Object.getOwnPropertyNames(e),function(n){if(n in W||r[n]){return}m.proxy(e,n,t)})}else{l(Object.keys(e),function(n){if(n in W||r[n]){return}t[n]=e[n]})}t.prototype=e.prototype;m.redefine(e.prototype,"constructor",t)};var Pe=function(){return this};var Ce=function(e){if(s&&!z(e,J)){m.getter(e,J,Pe)}};var Me=function(e,t){var r=t||function iterator(){return this};h(e,ie,r);if(!e[ie]&&re.symbol(ie)){e[ie]=r}};var xe=function createDataProperty(e,t,r){if(s){Object.defineProperty(e,t,{configurable:true,enumerable:true,writable:true,value:r})}else{e[t]=r}};var Ne=function createDataPropertyOrThrow(e,t,r){xe(e,t,r);if(!ce.SameValue(e[t],r)){throw new TypeError("property is nonconfigurable")}};var Ae=function(e,t,r,n){if(!ce.TypeIsObject(e)){throw new TypeError("Constructor requires `new`: "+t.name)}var o=t.prototype;if(!ce.TypeIsObject(o)){o=r}var i=O(o);for(var a in n){if(z(n,a)){var u=n[a];h(i,a,u,true)}}return i};if(String.fromCodePoint&&String.fromCodePoint.length!==1){var Re=String.fromCodePoint;ne(String,"fromCodePoint",function fromCodePoint(e){return ce.Call(Re,this,arguments)})}var _e={fromCodePoint:function fromCodePoint(e){var t=[];var r;for(var n=0,o=arguments.length;n<o;n++){r=Number(arguments[n]);if(!ce.SameValue(r,ce.ToInteger(r))||r<0||r>1114111){throw new RangeError("Invalid code point "+r)}if(r<65536){M(t,String.fromCharCode(r))}else{r-=65536;M(t,String.fromCharCode((r>>10)+55296));M(t,String.fromCharCode(r%1024+56320))}}return t.join("")},raw:function raw(e){var t=ce.ToObject(e,"bad callSite");var r=ce.ToObject(t.raw,"bad raw value");var n=r.length;var o=ce.ToLength(n);if(o<=0){return""}var i=[];var a=0;var u,f,s,c;while(a<o){u=ce.ToString(a);s=ce.ToString(r[u]);M(i,s);if(a+1>=o){break}f=a+1<arguments.length?arguments[a+1]:"";c=ce.ToString(f);M(i,c);a+=1}return i.join("")}};if(String.raw&&String.raw({raw:{0:"x",1:"y",length:2}})!=="xy"){ne(String,"raw",_e.raw)}b(String,_e);var ke=function repeat(e,t){if(t<1){return""}if(t%2){return repeat(e,t-1)+e}var r=repeat(e,t/2);return r+r};var Le=Infinity;var Fe={repeat:function repeat(e){var t=ce.ToString(ce.RequireObjectCoercible(this));var r=ce.ToInteger(e);if(r<0||r>=Le){throw new RangeError("repeat count must be less than infinity and not overflow maximum string size")}return ke(t,r)},startsWith:function startsWith(e){var t=ce.ToString(ce.RequireObjectCoercible(this));if(ce.IsRegExp(e)){throw new TypeError('Cannot call method "startsWith" with a regex')}var r=ce.ToString(e);var n;if(arguments.length>1){n=arguments[1]}var o=A(ce.ToInteger(n),0);return C(t,o,o+r.length)===r},endsWith:function endsWith(e){var t=ce.ToString(ce.RequireObjectCoercible(this));if(ce.IsRegExp(e)){throw new TypeError('Cannot call method "endsWith" with a regex')}var r=ce.ToString(e);var n=t.length;var o;if(arguments.length>1){o=arguments[1]}var i=typeof o==="undefined"?n:ce.ToInteger(o);var a=R(A(i,0),n);return C(t,a-r.length,a)===r},includes:function includes(e){if(ce.IsRegExp(e)){throw new TypeError('"includes" does not accept a RegExp')}var t=ce.ToString(e);var r;if(arguments.length>1){r=arguments[1]}return I(this,t,r)!==-1},codePointAt:function codePointAt(e){var t=ce.ToString(ce.RequireObjectCoercible(this));var r=ce.ToInteger(e);var n=t.length;if(r>=0&&r<n){var o=t.charCodeAt(r);var i=r+1===n;if(o<55296||o>56319||i){return o}var a=t.charCodeAt(r+1);if(a<56320||a>57343){return o}return(o-55296)*1024+(a-56320)+65536}}};if(String.prototype.includes&&"a".includes("a",Infinity)!==false){ne(String.prototype,"includes",Fe.includes)}if(String.prototype.startsWith&&String.prototype.endsWith){var De=i(function(){return"/a/".startsWith(/a/)});var ze=a(function(){return"abc".startsWith("a",Infinity)===false});if(!De||!ze){ne(String.prototype,"startsWith",Fe.startsWith);ne(String.prototype,"endsWith",Fe.endsWith)}}if(oe){var qe=a(function(){var e=/a/;e[$.match]=false;return"/a/".startsWith(e)});if(!qe){ne(String.prototype,"startsWith",Fe.startsWith)}var We=a(function(){var e=/a/;e[$.match]=false;return"/a/".endsWith(e)});if(!We){ne(String.prototype,"endsWith",Fe.endsWith)}var Ge=a(function(){var e=/a/;e[$.match]=false;return"/a/".includes(e)});if(!Ge){ne(String.prototype,"includes",Fe.includes)}}b(String.prototype,Fe);var He=["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join("");var Ve=new RegExp("(^["+He+"]+)|(["+He+"]+$)","g");var Be=function trim(){return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve,"")};var Ue=["\x85","\u200b","\ufffe"].join("");var $e=new RegExp("["+Ue+"]","g");var Je=/^[-+]0x[0-9a-f]+$/i;var Xe=Ue.trim().length!==Ue.length;h(String.prototype,"trim",Be,Xe);var Ke=function(e){return{value:e,done:arguments.length===0}};var Ze=function(e){ce.RequireObjectCoercible(e);this._s=ce.ToString(e);this._i=0};Ze.prototype.next=function(){var e=this._s;var t=this._i;if(typeof e==="undefined"||t>=e.length){this._s=void 0;return Ke()}var r=e.charCodeAt(t);var n,o;if(r<55296||r>56319||t+1===e.length){o=1}else{n=e.charCodeAt(t+1);o=n<56320||n>57343?1:2}this._i=t+o;return Ke(e.substr(t,o))};Me(Ze.prototype);Me(String.prototype,function(){return new Ze(this)});var Ye={from:function from(e){var r=this;var n;if(arguments.length>1){n=arguments[1]}var o,i;if(typeof n==="undefined"){o=false}else{if(!ce.IsCallable(n)){throw new TypeError("Array.from: when provided, the second argument must be a function")}if(arguments.length>2){i=arguments[2]}o=true}var a=typeof(te(e)||ce.GetMethod(e,ie))!=="undefined";var u,f,s;if(a){f=ce.IsConstructor(r)?Object(new r):[];var c=ce.GetIterator(e);var l,p;s=0;while(true){l=ce.IteratorStep(c);if(l===false){break}p=l.value;try{if(o){p=typeof i==="undefined"?n(p,s):t(n,i,p,s)}f[s]=p}catch(v){ce.IteratorClose(c,true);throw v}s+=1}u=s}else{var y=ce.ToObject(e);u=ce.ToLength(y.length);f=ce.IsConstructor(r)?Object(new r(u)):new Array(u);var h;for(s=0;s<u;++s){h=y[s];if(o){h=typeof i==="undefined"?n(h,s):t(n,i,h,s)}Ne(f,s,h)}}f.length=u;return f},of:function of(){var e=arguments.length;var t=this;var n=r(t)||!ce.IsCallable(t)?new Array(e):ce.Construct(t,[e]);for(var o=0;o<e;++o){Ne(n,o,arguments[o])}n.length=e;return n}};b(Array,Ye);Ce(Array);q=function(e,t){this.i=0;this.array=e;this.kind=t};b(q.prototype,{next:function(){var e=this.i;var t=this.array;if(!(this instanceof q)){throw new TypeError("Not an ArrayIterator")}if(typeof t!=="undefined"){var r=ce.ToLength(t.length);for(;e<r;e++){var n=this.kind;var o;if(n==="key"){o=e}else if(n==="value"){o=t[e]}else if(n==="entry"){o=[e,t[e]]}this.i=e+1;return Ke(o)}}this.array=void 0;return Ke()}});Me(q.prototype);var Qe=Array.of===Ye.of||function(){var e=function Foo(e){this.length=e};e.prototype=[];var t=Array.of.apply(e,[1,2]);return t instanceof e&&t.length===2}();if(!Qe){ne(Array,"of",Ye.of)}var et={copyWithin:function copyWithin(e,t){var r=ce.ToObject(this);var n=ce.ToLength(r.length);var o=ce.ToInteger(e);var i=ce.ToInteger(t);var a=o<0?A(n+o,0):R(o,n);var u=i<0?A(n+i,0):R(i,n);var f;if(arguments.length>2){f=arguments[2]}var s=typeof f==="undefined"?n:ce.ToInteger(f);var c=s<0?A(n+s,0):R(s,n);var l=R(c-u,n-a);var p=1;if(u<a&&a<u+l){p=-1;u+=l-1;a+=l-1}while(l>0){if(u in r){r[a]=r[u]}else{delete r[a]}u+=p;a+=p;l-=1}return r},fill:function fill(e){var t;if(arguments.length>1){t=arguments[1]}var r;if(arguments.length>2){r=arguments[2]}var n=ce.ToObject(this);var o=ce.ToLength(n.length);t=ce.ToInteger(typeof t==="undefined"?0:t);r=ce.ToInteger(typeof r==="undefined"?o:r);var i=t<0?A(o+t,0):R(t,o);var a=r<0?o+r:r;for(var u=i;u<o&&u<a;++u){n[u]=e}return n},find:function find(e){var r=ce.ToObject(this);var n=ce.ToLength(r.length);if(!ce.IsCallable(e)){throw new TypeError("Array#find: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0,a;i<n;i++){a=r[i];if(o){if(t(e,o,a,i,r)){return a}}else if(e(a,i,r)){return a}}},findIndex:function findIndex(e){var r=ce.ToObject(this);var n=ce.ToLength(r.length);if(!ce.IsCallable(e)){throw new TypeError("Array#findIndex: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0;i<n;i++){if(o){if(t(e,o,r[i],i,r)){return i}}else if(e(r[i],i,r)){return i}}return-1},keys:function keys(){return new q(this,"key")},values:function values(){return new q(this,"value")},entries:function entries(){return new q(this,"entry")}};if(Array.prototype.keys&&!ce.IsCallable([1].keys().next)){delete Array.prototype.keys}if(Array.prototype.entries&&!ce.IsCallable([1].entries().next)){delete Array.prototype.entries}if(Array.prototype.keys&&Array.prototype.entries&&!Array.prototype.values&&Array.prototype[ie]){b(Array.prototype,{values:Array.prototype[ie]});if(re.symbol($.unscopables)){Array.prototype[$.unscopables].values=true}}if(c&&Array.prototype.values&&Array.prototype.values.name!=="values"){var tt=Array.prototype.values;ne(Array.prototype,"values",function values(){return ce.Call(tt,this,arguments)});h(Array.prototype,ie,Array.prototype.values,true)}b(Array.prototype,et);if(1/[true].indexOf(true,-0)<0){h(Array.prototype,"indexOf",function indexOf(e){var t=E(this,arguments);if(t===0&&1/t<0){return 0}return t},true)}Me(Array.prototype,function(){return this.values()});if(Object.getPrototypeOf){Me(Object.getPrototypeOf([].values()))}var rt=function(){return a(function(){return Array.from({length:-1}).length===0})}();var nt=function(){var e=Array.from([0].entries());return e.length===1&&r(e[0])&&e[0][0]===0&&e[0][1]===0}();if(!rt||!nt){ne(Array,"from",Ye.from)}var ot=function(){return a(function(){return Array.from([0],void 0)})}();if(!ot){var it=Array.from;ne(Array,"from",function from(e){if(arguments.length>1&&typeof arguments[1]!=="undefined"){return ce.Call(it,this,arguments)}else{return t(it,this,e)}})}var at=-(Math.pow(2,32)-1);var ut=function(e,r){var n={length:at};n[r?(n.length>>>0)-1:0]=true;return a(function(){t(e,n,function(){throw new RangeError("should not reach here")},[]);return true})};if(!ut(Array.prototype.forEach)){var ft=Array.prototype.forEach;ne(Array.prototype,"forEach",function forEach(e){return ce.Call(ft,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.map)){var st=Array.prototype.map;ne(Array.prototype,"map",function map(e){return ce.Call(st,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.filter)){var ct=Array.prototype.filter;ne(Array.prototype,"filter",function filter(e){return ce.Call(ct,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.some)){var lt=Array.prototype.some;ne(Array.prototype,"some",function some(e){return ce.Call(lt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.every)){var pt=Array.prototype.every;ne(Array.prototype,"every",function every(e){return ce.Call(pt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.reduce)){var vt=Array.prototype.reduce;ne(Array.prototype,"reduce",function reduce(e){return ce.Call(vt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.reduceRight,true)){var yt=Array.prototype.reduceRight;ne(Array.prototype,"reduceRight",function reduceRight(e){return ce.Call(yt,this.length>=0?this:[],arguments)},true)}var ht=Number("0o10")!==8;var bt=Number("0b10")!==2;var gt=y(Ue,function(e){return Number(e+0+e)===0});if(ht||bt||gt){var dt=Number;var mt=/^0b[01]+$/i;var Ot=/^0o[0-7]+$/i;var wt=mt.test.bind(mt);var jt=Ot.test.bind(Ot);var St=function(e){var t;if(typeof e.valueOf==="function"){t=e.valueOf();if(re.primitive(t)){return t}}if(typeof e.toString==="function"){t=e.toString();if(re.primitive(t)){return t}}throw new TypeError("No default value")};var Tt=$e.test.bind($e);var It=Je.test.bind(Je);var Et=function(){var e=function Number(t){var r;if(arguments.length>0){r=re.primitive(t)?t:St(t,"number")}else{r=0}if(typeof r==="string"){r=ce.Call(Be,r);if(wt(r)){r=parseInt(C(r,2),2)}else if(jt(r)){r=parseInt(C(r,2),8)}else if(Tt(r)||It(r)){r=NaN}}var n=this;var o=a(function(){dt.prototype.valueOf.call(n);return true});if(n instanceof e&&!o){return new dt(r)}return dt(r)};return e}();Ee(dt,Et,{});b(Et,{NaN:dt.NaN,MAX_VALUE:dt.MAX_VALUE,MIN_VALUE:dt.MIN_VALUE,NEGATIVE_INFINITY:dt.NEGATIVE_INFINITY,POSITIVE_INFINITY:dt.POSITIVE_INFINITY});Number=Et;m.redefine(S,"Number",Et)}var Pt=Math.pow(2,53)-1;b(Number,{MAX_SAFE_INTEGER:Pt,MIN_SAFE_INTEGER:-Pt,EPSILON:2.220446049250313e-16,parseInt:S.parseInt,parseFloat:S.parseFloat,isFinite:K,isInteger:function isInteger(e){return K(e)&&ce.ToInteger(e)===e},isSafeInteger:function isSafeInteger(e){return Number.isInteger(e)&&k(e)<=Number.MAX_SAFE_INTEGER},isNaN:X});h(Number,"parseInt",S.parseInt,Number.parseInt!==S.parseInt);if([,1].find(function(){return true})===1){ne(Array.prototype,"find",et.find)}if([,1].findIndex(function(){return true})!==0){ne(Array.prototype,"findIndex",et.findIndex)}var Ct=Function.bind.call(Function.bind,Object.prototype.propertyIsEnumerable);var Mt=function ensureEnumerable(e,t){if(s&&Ct(e,t)){Object.defineProperty(e,t,{enumerable:false})}};var xt=function sliceArgs(){var e=Number(this);var t=arguments.length;var r=t-e;var n=new Array(r<0?0:r);for(var o=e;o<t;++o){n[o-e]=arguments[o]}return n};var Nt=function assignTo(e){return function assignToSource(t,r){t[r]=e[r];return t}};var At=function(e,t){var r=n(Object(t));var o;if(ce.IsCallable(Object.getOwnPropertySymbols)){o=v(Object.getOwnPropertySymbols(Object(t)),Ct(t))}return p(P(r,o||[]),Nt(t),e)};var Rt={assign:function(e,t){var r=ce.ToObject(e,"Cannot convert undefined or null to object");return p(ce.Call(xt,1,arguments),At,r)},is:function is(e,t){return ce.SameValue(e,t)}};var _t=Object.assign&&Object.preventExtensions&&function(){var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return e[1]==="y"}}();if(_t){ne(Object,"assign",Rt.assign)}b(Object,Rt);if(s){var kt={setPrototypeOf:function(e,r){var n;var o=function(e,t){if(!ce.TypeIsObject(e)){throw new TypeError("cannot set prototype on a non-object")}if(!(t===null||ce.TypeIsObject(t))){throw new TypeError("can only set prototype to an object or null"+t)}};var i=function(e,r){o(e,r);t(n,e,r);return e};try{n=e.getOwnPropertyDescriptor(e.prototype,r).set;t(n,{},null)}catch(a){if(e.prototype!=={}[r]){return}n=function(e){this[r]=e};i.polyfill=i(i({},null),e.prototype)instanceof e}return i}(Object,"__proto__")};b(Object,kt)}if(Object.setPrototypeOf&&Object.getPrototypeOf&&Object.getPrototypeOf(Object.setPrototypeOf({},null))!==null&&Object.getPrototypeOf(Object.create(null))===null){(function(){var e=Object.create(null);var t=Object.getPrototypeOf;var r=Object.setPrototypeOf;Object.getPrototypeOf=function(r){var n=t(r);return n===e?null:n};Object.setPrototypeOf=function(t,n){var o=n===null?e:n;return r(t,o)};Object.setPrototypeOf.polyfill=false})()}var Lt=!i(function(){return Object.keys("foo")});if(!Lt){var Ft=Object.keys;ne(Object,"keys",function keys(e){return Ft(ce.ToObject(e))});n=Object.keys}var Dt=i(function(){return Object.keys(/a/g)});if(Dt){var zt=Object.keys;ne(Object,"keys",function keys(e){if(re.regex(e)){var t=[];for(var r in e){if(z(e,r)){M(t,r)}}return t}return zt(e)});n=Object.keys}if(Object.getOwnPropertyNames){var qt=!i(function(){return Object.getOwnPropertyNames("foo")});if(!qt){var Wt=typeof window==="object"?Object.getOwnPropertyNames(window):[];var Gt=Object.getOwnPropertyNames;ne(Object,"getOwnPropertyNames",function getOwnPropertyNames(e){var t=ce.ToObject(e);if(g(t)==="[object Window]"){try{return Gt(t)}catch(r){return P([],Wt)}}return Gt(t)})}}if(Object.getOwnPropertyDescriptor){var Ht=!i(function(){return Object.getOwnPropertyDescriptor("foo","bar")});if(!Ht){var Vt=Object.getOwnPropertyDescriptor;ne(Object,"getOwnPropertyDescriptor",function getOwnPropertyDescriptor(e,t){return Vt(ce.ToObject(e),t)})}}if(Object.seal){var Bt=!i(function(){return Object.seal("foo")});if(!Bt){var Ut=Object.seal;ne(Object,"seal",function seal(e){if(!ce.TypeIsObject(e)){return e}return Ut(e)})}}if(Object.isSealed){var $t=!i(function(){return Object.isSealed("foo")});if(!$t){var Jt=Object.isSealed;ne(Object,"isSealed",function isSealed(e){if(!ce.TypeIsObject(e)){return true}return Jt(e)})}}if(Object.freeze){var Xt=!i(function(){return Object.freeze("foo")});if(!Xt){var Kt=Object.freeze;ne(Object,"freeze",function freeze(e){if(!ce.TypeIsObject(e)){return e}return Kt(e)})}}if(Object.isFrozen){var Zt=!i(function(){return Object.isFrozen("foo")});if(!Zt){var Yt=Object.isFrozen;ne(Object,"isFrozen",function isFrozen(e){if(!ce.TypeIsObject(e)){return true}return Yt(e)})}}if(Object.preventExtensions){var Qt=!i(function(){return Object.preventExtensions("foo")});if(!Qt){var er=Object.preventExtensions;ne(Object,"preventExtensions",function preventExtensions(e){if(!ce.TypeIsObject(e)){return e}return er(e)})}}if(Object.isExtensible){var tr=!i(function(){return Object.isExtensible("foo")});if(!tr){var rr=Object.isExtensible;ne(Object,"isExtensible",function isExtensible(e){if(!ce.TypeIsObject(e)){return false}return rr(e)})}}if(Object.getPrototypeOf){var nr=!i(function(){return Object.getPrototypeOf("foo")});if(!nr){var or=Object.getPrototypeOf;ne(Object,"getPrototypeOf",function getPrototypeOf(e){return or(ce.ToObject(e))})}}var ir=s&&function(){var e=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags");return e&&ce.IsCallable(e.get)}();if(s&&!ir){var ar=function flags(){if(!ce.TypeIsObject(this)){throw new TypeError("Method called on incompatible type: must be an object.")}var e="";if(this.global){e+="g"}if(this.ignoreCase){e+="i"}if(this.multiline){e+="m"}if(this.unicode){e+="u"}if(this.sticky){e+="y"}return e};m.getter(RegExp.prototype,"flags",ar)}var ur=s&&a(function(){return String(new RegExp(/a/g,"i"))==="/a/i"});var fr=oe&&s&&function(){var e=/./;e[$.match]=false;return RegExp(e)===e}();var sr=a(function(){return RegExp.prototype.toString.call({source:"abc"})==="/abc/"});var cr=sr&&a(function(){return RegExp.prototype.toString.call({source:"a",flags:"b"})==="/a/b"});if(!sr||!cr){var lr=RegExp.prototype.toString;h(RegExp.prototype,"toString",function toString(){var e=ce.RequireObjectCoercible(this);if(re.regex(e)){return t(lr,e)}var r=ue(e.source);var n=ue(e.flags);return"/"+r+"/"+n},true);m.preserveToString(RegExp.prototype.toString,lr)}if(s&&(!ur||fr)){var pr=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags").get;var vr=Object.getOwnPropertyDescriptor(RegExp.prototype,"source")||{};var yr=function(){return this.source};var hr=ce.IsCallable(vr.get)?vr.get:yr;var br=RegExp;var gr=function(){return function RegExp(e,t){var r=ce.IsRegExp(e);var n=this instanceof RegExp;if(!n&&r&&typeof t==="undefined"&&e.constructor===RegExp){return e}var o=e;var i=t;if(re.regex(e)){o=ce.Call(hr,e);i=typeof t==="undefined"?ce.Call(pr,e):t;return new RegExp(o,i)}else if(r){o=e.source;i=typeof t==="undefined"?e.flags:t}return new br(e,t)}}();Ee(br,gr,{$input:true});RegExp=gr;m.redefine(S,"RegExp",gr)}if(s){var dr={input:"$_",lastMatch:"$&",lastParen:"$+",leftContext:"$`",rightContext:"$'"};l(n(dr),function(e){if(e in RegExp&&!(dr[e]in RegExp)){m.getter(RegExp,dr[e],function get(){return RegExp[e]})}})}Ce(RegExp);var mr=1/Number.EPSILON;var Or=function roundTiesToEven(e){return e+mr-mr};var wr=Math.pow(2,-23);var jr=Math.pow(2,127)*(2-wr);var Sr=Math.pow(2,-126);var Tr=Math.E;var Ir=Math.LOG2E;var Er=Math.LOG10E;var Pr=Number.prototype.clz;delete Number.prototype.clz;var Cr={acosh:function acosh(e){var t=Number(e);if(X(t)||e<1){return NaN}if(t===1){return 0}if(t===Infinity){return t}var r=1/(t*t);if(t<2){return Y(t-1+D(1-r)*t)}var n=t/2;return Y(n+D(1-r)*n-1)+1/Ir},asinh:function asinh(e){var t=Number(e);if(t===0||!T(t)){return t}var r=k(t);var n=r*r;var o=Z(t);if(r<1){return o*Y(r+n/(D(n+1)+1))}return o*(Y(r/2+D(1+1/n)*r/2-1)+1/Ir)},atanh:function atanh(e){var t=Number(e);if(t===0){return t}if(t===-1){return-Infinity}if(t===1){return Infinity}if(X(t)||t<-1||t>1){return NaN}var r=k(t);return Z(t)*Y(2*r/(1-r))/2},cbrt:function cbrt(e){var t=Number(e);if(t===0){return t}var r=t<0;var n;if(r){t=-t}if(t===Infinity){n=Infinity}else{n=L(F(t)/3);n=(t/(n*n)+2*n)/3}return r?-n:n},clz32:function clz32(e){var t=Number(e);var r=ce.ToUint32(t);if(r===0){return 32}return Pr?ce.Call(Pr,r):31-_(F(r+.5)*Ir)},cosh:function cosh(e){var t=Number(e);if(t===0){return 1}if(X(t)){return NaN}if(!T(t)){return Infinity}var r=L(k(t)-1);return(r+1/(r*Tr*Tr))*(Tr/2)},expm1:function expm1(e){var t=Number(e);if(t===-Infinity){return-1}if(!T(t)||t===0){return t}if(k(t)>.5){return L(t)-1}var r=t;var n=0;var o=1;while(n+r!==n){n+=r;o+=1;r*=t/o}return n},hypot:function hypot(e,t){var r=0;var n=0;for(var o=0;o<arguments.length;++o){var i=k(Number(arguments[o]));if(n<i){r*=n/i*(n/i);r+=1;n=i}else{r+=i>0?i/n*(i/n):i}}return n===Infinity?Infinity:n*D(r)},log2:function log2(e){return F(e)*Ir},log10:function log10(e){return F(e)*Er},log1p:Y,sign:Z,sinh:function sinh(e){var t=Number(e);if(!T(t)||t===0){return t}var r=k(t);if(r<1){var n=Math.expm1(r);return Z(t)*n*(1+1/(n+1))/2}var o=L(r-1);return Z(t)*(o-1/(o*Tr*Tr))*(Tr/2)},tanh:function tanh(e){var t=Number(e);if(X(t)||t===0){return t}if(t>=20){return 1}if(t<=-20){return-1}return(Math.expm1(t)-Math.expm1(-t))/(L(t)+L(-t))},trunc:function trunc(e){var t=Number(e);return t<0?-_(-t):_(t)},imul:function imul(e,t){var r=ce.ToUint32(e);var n=ce.ToUint32(t);var o=r>>>16&65535;var i=r&65535;var a=n>>>16&65535;var u=n&65535;return i*u+(o*u+i*a<<16>>>0)|0},fround:function fround(e){var t=Number(e);if(t===0||t===Infinity||t===-Infinity||X(t)){return t}var r=Z(t);var n=k(t);if(n<Sr){return r*Or(n/Sr/wr)*Sr*wr}var o=(1+wr/Number.EPSILON)*n;var i=o-(o-n);if(i>jr||X(i)){return r*Infinity}return r*i}};var Mr=function withinULPDistance(e,t,r){return k(1-e/t)/Number.EPSILON<(r||8)};b(Math,Cr);h(Math,"sinh",Cr.sinh,Math.sinh(710)===Infinity);h(Math,"cosh",Cr.cosh,Math.cosh(710)===Infinity);h(Math,"log1p",Cr.log1p,Math.log1p(-1e-17)!==-1e-17);h(Math,"asinh",Cr.asinh,Math.asinh(-1e7)!==-Math.asinh(1e7));h(Math,"asinh",Cr.asinh,Math.asinh(1e300)===Infinity);h(Math,"atanh",Cr.atanh,Math.atanh(1e-300)===0);h(Math,"tanh",Cr.tanh,Math.tanh(-2e-17)!==-2e-17);
h(Math,"acosh",Cr.acosh,Math.acosh(Number.MAX_VALUE)===Infinity);h(Math,"acosh",Cr.acosh,!Mr(Math.acosh(1+Number.EPSILON),Math.sqrt(2*Number.EPSILON)));h(Math,"cbrt",Cr.cbrt,!Mr(Math.cbrt(1e-300),1e-100));h(Math,"sinh",Cr.sinh,Math.sinh(-2e-17)!==-2e-17);var xr=Math.expm1(10);h(Math,"expm1",Cr.expm1,xr>22025.465794806718||xr<22025.465794806718);var Nr=Math.round;var Ar=Math.round(.5-Number.EPSILON/4)===0&&Math.round(-.5+Number.EPSILON/3.99)===1;var Rr=mr+1;var _r=2*mr-1;var kr=[Rr,_r].every(function(e){return Math.round(e)===e});h(Math,"round",function round(e){var t=_(e);var r=t===-1?-0:t+1;return e-t<.5?t:r},!Ar||!kr);m.preserveToString(Math.round,Nr);var Lr=Math.imul;if(Math.imul(4294967295,5)!==-5){Math.imul=Cr.imul;m.preserveToString(Math.imul,Lr)}if(Math.imul.length!==2){ne(Math,"imul",function imul(e,t){return ce.Call(Lr,Math,arguments)})}var Fr=function(){var e=S.setTimeout;if(typeof e!=="function"&&typeof e!=="object"){return}ce.IsPromise=function(e){if(!ce.TypeIsObject(e)){return false}if(typeof e._promise==="undefined"){return false}return true};var r=function(e){if(!ce.IsConstructor(e)){throw new TypeError("Bad promise constructor")}var t=this;var r=function(e,r){if(t.resolve!==void 0||t.reject!==void 0){throw new TypeError("Bad Promise implementation!")}t.resolve=e;t.reject=r};t.resolve=void 0;t.reject=void 0;t.promise=new e(r);if(!(ce.IsCallable(t.resolve)&&ce.IsCallable(t.reject))){throw new TypeError("Bad promise constructor")}};var n;if(typeof window!=="undefined"&&ce.IsCallable(window.postMessage)){n=function(){var e=[];var t="zero-timeout-message";var r=function(r){M(e,r);window.postMessage(t,"*")};var n=function(r){if(r.source===window&&r.data===t){r.stopPropagation();if(e.length===0){return}var n=N(e);n()}};window.addEventListener("message",n,true);return r}}var o=function(){var e=S.Promise;var t=e&&e.resolve&&e.resolve();return t&&function(e){return t.then(e)}};var i=ce.IsCallable(S.setImmediate)?S.setImmediate:typeof process==="object"&&process.nextTick?process.nextTick:o()||(ce.IsCallable(n)?n():function(t){e(t,0)});var a=function(e){return e};var u=function(e){throw e};var f=0;var s=1;var c=2;var l=0;var p=1;var v=2;var y={};var h=function(e,t,r){i(function(){g(e,t,r)})};var g=function(e,t,r){var n,o;if(t===y){return e(r)}try{n=e(r);o=t.resolve}catch(i){n=i;o=t.reject}o(n)};var d=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.fulfillReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+l],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=s;r.reactionLength=0};var m=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.rejectReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+p],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=c;r.reactionLength=0};var O=function(e){var t=false;var r=function(r){var n;if(t){return}t=true;if(r===e){return m(e,new TypeError("Self resolution"))}if(!ce.TypeIsObject(r)){return d(e,r)}try{n=r.then}catch(o){return m(e,o)}if(!ce.IsCallable(n)){return d(e,r)}i(function(){j(e,r,n)})};var n=function(r){if(t){return}t=true;return m(e,r)};return{resolve:r,reject:n}};var w=function(e,r,n,o){if(e===I){t(e,r,n,o,y)}else{t(e,r,n,o)}};var j=function(e,t,r){var n=O(e);var o=n.resolve;var i=n.reject;try{w(r,t,o,i)}catch(a){i(a)}};var T,I;var E=function(){var e=function Promise(t){if(!(this instanceof e)){throw new TypeError('Constructor Promise requires "new"')}if(this&&this._promise){throw new TypeError("Bad construction")}if(!ce.IsCallable(t)){throw new TypeError("not a valid resolver")}var r=Ae(this,e,T,{_promise:{result:void 0,state:f,reactionLength:0,fulfillReactionHandler0:void 0,rejectReactionHandler0:void 0,reactionCapability0:void 0}});var n=O(r);var o=n.reject;try{t(n.resolve,o)}catch(i){o(i)}return r};return e}();T=E.prototype;var P=function(e,t,r,n){var o=false;return function(i){if(o){return}o=true;t[e]=i;if(--n.count===0){var a=r.resolve;a(t)}}};var C=function(e,t,r){var n=e.iterator;var o=[];var i={count:1};var a,u;var f=0;while(true){try{a=ce.IteratorStep(n);if(a===false){e.done=true;break}u=a.value}catch(s){e.done=true;throw s}o[f]=void 0;var c=t.resolve(u);var l=P(f,o,r,i);i.count+=1;w(c.then,c,l,r.reject);f+=1}if(--i.count===0){var p=r.resolve;p(o)}return r.promise};var x=function(e,t,r){var n=e.iterator;var o,i,a;while(true){try{o=ce.IteratorStep(n);if(o===false){e.done=true;break}i=o.value}catch(u){e.done=true;throw u}a=t.resolve(i);w(a.then,a,r.resolve,r.reject)}return r.promise};b(E,{all:function all(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=ce.GetIterator(e);i={iterator:o,done:false};return C(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{ce.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},race:function race(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=ce.GetIterator(e);i={iterator:o,done:false};return x(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{ce.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},reject:function reject(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}var n=new r(t);var o=n.reject;o(e);return n.promise},resolve:function resolve(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}if(ce.IsPromise(e)){var n=e.constructor;if(n===t){return e}}var o=new r(t);var i=o.resolve;i(e);return o.promise}});b(T,{"catch":function(e){return this.then(null,e)},then:function then(e,t){var n=this;if(!ce.IsPromise(n)){throw new TypeError("not a promise")}var o=ce.SpeciesConstructor(n,E);var i;var b=arguments.length>2&&arguments[2]===y;if(b&&o===E){i=y}else{i=new r(o)}var g=ce.IsCallable(e)?e:a;var d=ce.IsCallable(t)?t:u;var m=n._promise;var O;if(m.state===f){if(m.reactionLength===0){m.fulfillReactionHandler0=g;m.rejectReactionHandler0=d;m.reactionCapability0=i}else{var w=3*(m.reactionLength-1);m[w+l]=g;m[w+p]=d;m[w+v]=i}m.reactionLength+=1}else if(m.state===s){O=m.result;h(g,i,O)}else if(m.state===c){O=m.result;h(d,i,O)}else{throw new TypeError("unexpected Promise state")}return i.promise}});y=new r(E);I=T.then;return E}();if(S.Promise){delete S.Promise.accept;delete S.Promise.defer;delete S.Promise.prototype.chain}if(typeof Fr==="function"){b(S,{Promise:Fr});var Dr=w(S.Promise,function(e){return e.resolve(42).then(function(){})instanceof e});var zr=!i(function(){return S.Promise.reject(42).then(null,5).then(null,W)});var qr=i(function(){return S.Promise.call(3,W)});var Wr=function(e){var t=e.resolve(5);t.constructor={};var r=e.resolve(t);try{r.then(null,W).then(null,W)}catch(n){return true}return t===r}(S.Promise);var Gr=s&&function(){var e=0;var t=Object.defineProperty({},"then",{get:function(){e+=1}});Promise.resolve(t);return e===1}();var Hr=function BadResolverPromise(e){var t=new Promise(e);e(3,function(){});this.then=t.then;this.constructor=BadResolverPromise};Hr.prototype=Promise.prototype;Hr.all=Promise.all;var Vr=a(function(){return!!Hr.all([1,2])});if(!Dr||!zr||!qr||Wr||!Gr||Vr){Promise=Fr;ne(S,"Promise",Fr)}if(Promise.all.length!==1){var Br=Promise.all;ne(Promise,"all",function all(e){return ce.Call(Br,this,arguments)})}if(Promise.race.length!==1){var Ur=Promise.race;ne(Promise,"race",function race(e){return ce.Call(Ur,this,arguments)})}if(Promise.resolve.length!==1){var $r=Promise.resolve;ne(Promise,"resolve",function resolve(e){return ce.Call($r,this,arguments)})}if(Promise.reject.length!==1){var Jr=Promise.reject;ne(Promise,"reject",function reject(e){return ce.Call(Jr,this,arguments)})}Mt(Promise,"all");Mt(Promise,"race");Mt(Promise,"resolve");Mt(Promise,"reject");Ce(Promise)}var Xr=function(e){var t=n(p(e,function(e,t){e[t]=true;return e},{}));return e.join(":")===t.join(":")};var Kr=Xr(["z","a","bb"]);var Zr=Xr(["z",1,"a","3",2]);if(s){var Yr=function fastkey(e,t){if(!t&&!Kr){return null}if(se(e)){return"^"+ce.ToString(e)}else if(typeof e==="string"){return"$"+e}else if(typeof e==="number"){if(!Zr){return"n"+e}return e}else if(typeof e==="boolean"){return"b"+e}return null};var Qr=function emptyObject(){return Object.create?Object.create(null):{}};var en=function addIterableToMap(e,n,o){if(r(o)||re.string(o)){l(o,function(e){if(!ce.TypeIsObject(e)){throw new TypeError("Iterator value "+e+" is not an entry object")}n.set(e[0],e[1])})}else if(o instanceof e){t(e.prototype.forEach,o,function(e,t){n.set(t,e)})}else{var i,a;if(!se(o)){a=n.set;if(!ce.IsCallable(a)){throw new TypeError("bad map")}i=ce.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=ce.IteratorStep(i);if(u===false){break}var f=u.value;try{if(!ce.TypeIsObject(f)){throw new TypeError("Iterator value "+f+" is not an entry object")}t(a,n,f[0],f[1])}catch(s){ce.IteratorClose(i,true);throw s}}}}};var tn=function addIterableToSet(e,n,o){if(r(o)||re.string(o)){l(o,function(e){n.add(e)})}else if(o instanceof e){t(e.prototype.forEach,o,function(e){n.add(e)})}else{var i,a;if(!se(o)){a=n.add;if(!ce.IsCallable(a)){throw new TypeError("bad set")}i=ce.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=ce.IteratorStep(i);if(u===false){break}var f=u.value;try{t(a,n,f)}catch(s){ce.IteratorClose(i,true);throw s}}}}};var rn={Map:function(){var e={};var r=function MapEntry(e,t){this.key=e;this.value=t;this.next=null;this.prev=null};r.prototype.isRemoved=function isRemoved(){return this.key===e};var n=function isMap(e){return!!e._es6map};var o=function requireMapSlot(e,t){if(!ce.TypeIsObject(e)||!n(e)){throw new TypeError("Method Map.prototype."+t+" called on incompatible receiver "+ce.ToString(e))}};var i=function MapIterator(e,t){o(e,"[[MapIterator]]");this.head=e._head;this.i=this.head;this.kind=t};i.prototype={isMapIterator:true,next:function next(){if(!this.isMapIterator){throw new TypeError("Not a MapIterator")}var e=this.i;var t=this.kind;var r=this.head;if(typeof this.i==="undefined"){return Ke()}while(e.isRemoved()&&e!==r){e=e.prev}var n;while(e.next!==r){e=e.next;if(!e.isRemoved()){if(t==="key"){n=e.key}else if(t==="value"){n=e.value}else{n=[e.key,e.value]}this.i=e;return Ke(n)}}this.i=void 0;return Ke()}};Me(i.prototype);var a;var u=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}if(this&&this._es6map){throw new TypeError("Bad construction")}var e=Ae(this,Map,a,{_es6map:true,_head:null,_map:G?new G:null,_size:0,_storage:Qr()});var t=new r(null,null);t.next=t.prev=t;e._head=t;if(arguments.length>0){en(Map,e,arguments[0])}return e};a=u.prototype;m.getter(a,"size",function(){if(typeof this._size==="undefined"){throw new TypeError("size method called on incompatible Map")}return this._size});b(a,{get:function get(e){o(this,"get");var t;var r=Yr(e,true);if(r!==null){t=this._storage[r];if(t){return t.value}else{return}}if(this._map){t=V.call(this._map,e);if(t){return t.value}else{return}}var n=this._head;var i=n;while((i=i.next)!==n){if(ce.SameValueZero(i.key,e)){return i.value}}},has:function has(e){o(this,"has");var t=Yr(e,true);if(t!==null){return typeof this._storage[t]!=="undefined"}if(this._map){return B.call(this._map,e)}var r=this._head;var n=r;while((n=n.next)!==r){if(ce.SameValueZero(n.key,e)){return true}}return false},set:function set(e,t){o(this,"set");var n=this._head;var i=n;var a;var u=Yr(e,true);if(u!==null){if(typeof this._storage[u]!=="undefined"){this._storage[u].value=t;return this}else{a=this._storage[u]=new r(e,t);i=n.prev}}else if(this._map){if(B.call(this._map,e)){V.call(this._map,e).value=t}else{a=new r(e,t);U.call(this._map,e,a);i=n.prev}}while((i=i.next)!==n){if(ce.SameValueZero(i.key,e)){i.value=t;return this}}a=a||new r(e,t);if(ce.SameValue(-0,e)){a.key=+0}a.next=this._head;a.prev=this._head.prev;a.prev.next=a;a.next.prev=a;this._size+=1;return this},"delete":function(t){o(this,"delete");var r=this._head;var n=r;var i=Yr(t,true);if(i!==null){if(typeof this._storage[i]==="undefined"){return false}n=this._storage[i].prev;delete this._storage[i]}else if(this._map){if(!B.call(this._map,t)){return false}n=V.call(this._map,t).prev;H.call(this._map,t)}while((n=n.next)!==r){if(ce.SameValueZero(n.key,t)){n.key=e;n.value=e;n.prev.next=n.next;n.next.prev=n.prev;this._size-=1;return true}}return false},clear:function clear(){o(this,"clear");this._map=G?new G:null;this._size=0;this._storage=Qr();var t=this._head;var r=t;var n=r.next;while((r=n)!==t){r.key=e;r.value=e;n=r.next;r.next=r.prev=t}t.next=t.prev=t},keys:function keys(){o(this,"keys");return new i(this,"key")},values:function values(){o(this,"values");return new i(this,"value")},entries:function entries(){o(this,"entries");return new i(this,"key+value")},forEach:function forEach(e){o(this,"forEach");var r=arguments.length>1?arguments[1]:null;var n=this.entries();for(var i=n.next();!i.done;i=n.next()){if(r){t(e,r,i.value[1],i.value[0],this)}else{e(i.value[1],i.value[0],this)}}}});Me(a,a.entries);return u}(),Set:function(){var e=function isSet(e){return e._es6set&&typeof e._storage!=="undefined"};var r=function requireSetSlot(t,r){if(!ce.TypeIsObject(t)||!e(t)){throw new TypeError("Set.prototype."+r+" called on incompatible receiver "+ce.ToString(t))}};var o;var i=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}if(this&&this._es6set){throw new TypeError("Bad construction")}var e=Ae(this,Set,o,{_es6set:true,"[[SetData]]":null,_storage:Qr()});if(!e._es6set){throw new TypeError("bad set")}if(arguments.length>0){tn(Set,e,arguments[0])}return e};o=i.prototype;var a=function(e){var t=e;if(t==="^null"){return null}else if(t==="^undefined"){return void 0}else{var r=t.charAt(0);if(r==="$"){return C(t,1)}else if(r==="n"){return+C(t,1)}else if(r==="b"){return t==="btrue"}}return+t};var u=function ensureMap(e){if(!e["[[SetData]]"]){var t=new rn.Map;e["[[SetData]]"]=t;l(n(e._storage),function(e){var r=a(e);t.set(r,r)});e["[[SetData]]"]=t}e._storage=null};m.getter(i.prototype,"size",function(){r(this,"size");if(this._storage){return n(this._storage).length}u(this);return this["[[SetData]]"].size});b(i.prototype,{has:function has(e){r(this,"has");var t;if(this._storage&&(t=Yr(e))!==null){return!!this._storage[t]}u(this);return this["[[SetData]]"].has(e)},add:function add(e){r(this,"add");var t;if(this._storage&&(t=Yr(e))!==null){this._storage[t]=true;return this}u(this);this["[[SetData]]"].set(e,e);return this},"delete":function(e){r(this,"delete");var t;if(this._storage&&(t=Yr(e))!==null){var n=z(this._storage,t);return delete this._storage[t]&&n}u(this);return this["[[SetData]]"]["delete"](e)},clear:function clear(){r(this,"clear");if(this._storage){this._storage=Qr()}if(this["[[SetData]]"]){this["[[SetData]]"].clear()}},values:function values(){r(this,"values");u(this);return new f(this["[[SetData]]"].values())},entries:function entries(){r(this,"entries");u(this);return new f(this["[[SetData]]"].entries())},forEach:function forEach(e){r(this,"forEach");var n=arguments.length>1?arguments[1]:null;var o=this;u(o);this["[[SetData]]"].forEach(function(r,i){if(n){t(e,n,i,i,o)}else{e(i,i,o)}})}});h(i.prototype,"keys",i.prototype.values,true);Me(i.prototype,i.prototype.values);var f=function SetIterator(e){this.it=e};f.prototype={isSetIterator:true,next:function next(){if(!this.isSetIterator){throw new TypeError("Not a SetIterator")}return this.it.next()}};Me(f.prototype);return i}()};var nn=S.Set&&!Set.prototype["delete"]&&Set.prototype.remove&&Set.prototype.items&&Set.prototype.map&&Array.isArray((new Set).keys);if(nn){S.Set=rn.Set}if(S.Map||S.Set){var on=a(function(){return new Map([[1,2]]).get(1)===2});if(!on){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){en(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,S.Map.prototype);return e};S.Map.prototype=O(G.prototype);h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var an=new Map;var un=function(){var e=new Map([[1,0],[2,0],[3,0],[4,0]]);e.set(-0,e);return e.get(0)===e&&e.get(-0)===e&&e.has(0)&&e.has(-0)}();var fn=an.set(1,2)===an;if(!un||!fn){ne(Map.prototype,"set",function set(e,r){t(U,this,e===0?0:e,r);return this})}if(!un){b(Map.prototype,{get:function get(e){return t(V,this,e===0?0:e)},has:function has(e){return t(B,this,e===0?0:e)}},true);m.preserveToString(Map.prototype.get,V);m.preserveToString(Map.prototype.has,B)}var sn=new Set;var cn=Set.prototype["delete"]&&Set.prototype.add&&Set.prototype.has&&function(e){e["delete"](0);e.add(-0);return!e.has(0)}(sn);var ln=sn.add(1)===sn;if(!cn||!ln){var pn=Set.prototype.add;Set.prototype.add=function add(e){t(pn,this,e===0?0:e);return this};m.preserveToString(Set.prototype.add,pn)}if(!cn){var vn=Set.prototype.has;Set.prototype.has=function has(e){return t(vn,this,e===0?0:e)};m.preserveToString(Set.prototype.has,vn);var yn=Set.prototype["delete"];Set.prototype["delete"]=function SetDelete(e){return t(yn,this,e===0?0:e)};m.preserveToString(Set.prototype["delete"],yn)}var hn=w(S.Map,function(e){var t=new e([]);t.set(42,42);return t instanceof e});var bn=Object.setPrototypeOf&&!hn;var gn=function(){try{return!(S.Map()instanceof S.Map)}catch(e){return e instanceof TypeError}}();if(S.Map.length!==0||bn||!gn){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){en(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Map.prototype);return e};S.Map.prototype=G.prototype;h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var dn=w(S.Set,function(e){var t=new e([]);t.add(42,42);return t instanceof e});var mn=Object.setPrototypeOf&&!dn;var On=function(){try{return!(S.Set()instanceof S.Set)}catch(e){return e instanceof TypeError}}();if(S.Set.length!==0||mn||!On){var wn=S.Set;S.Set=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}var e=new wn;if(arguments.length>0){tn(Set,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Set.prototype);return e};S.Set.prototype=wn.prototype;h(S.Set.prototype,"constructor",S.Set,true);m.preserveToString(S.Set,wn)}var jn=new S.Map;var Sn=!a(function(){return jn.keys().next().done});if(typeof S.Map.prototype.clear!=="function"||(new S.Set).size!==0||jn.size!==0||typeof S.Map.prototype.keys!=="function"||typeof S.Set.prototype.keys!=="function"||typeof S.Map.prototype.forEach!=="function"||typeof S.Set.prototype.forEach!=="function"||u(S.Map)||u(S.Set)||typeof jn.keys().next!=="function"||Sn||!hn){b(S,{Map:rn.Map,Set:rn.Set},true)}if(S.Set.prototype.keys!==S.Set.prototype.values){h(S.Set.prototype,"keys",S.Set.prototype.values,true)}Me(Object.getPrototypeOf((new S.Map).keys()));Me(Object.getPrototypeOf((new S.Set).keys()));if(c&&S.Set.prototype.has.name!=="has"){var Tn=S.Set.prototype.has;ne(S.Set.prototype,"has",function has(e){return t(Tn,this,e)})}}b(S,rn);Ce(S.Map);Ce(S.Set)}var In=function throwUnlessTargetIsObject(e){if(!ce.TypeIsObject(e)){throw new TypeError("target must be an object")}};var En={apply:function apply(){return ce.Call(ce.Call,null,arguments)},construct:function construct(e,t){if(!ce.IsConstructor(e)){throw new TypeError("First argument must be a constructor.")}var r=arguments.length>2?arguments[2]:e;if(!ce.IsConstructor(r)){throw new TypeError("new.target must be a constructor.")}return ce.Construct(e,t,r,"internal")},deleteProperty:function deleteProperty(e,t){In(e);if(s){var r=Object.getOwnPropertyDescriptor(e,t);if(r&&!r.configurable){return false}}return delete e[t]},has:function has(e,t){In(e);return t in e}};if(Object.getOwnPropertyNames){Object.assign(En,{ownKeys:function ownKeys(e){In(e);var t=Object.getOwnPropertyNames(e);if(ce.IsCallable(Object.getOwnPropertySymbols)){x(t,Object.getOwnPropertySymbols(e))}return t}})}var Pn=function ConvertExceptionToBoolean(e){return!i(e)};if(Object.preventExtensions){Object.assign(En,{isExtensible:function isExtensible(e){In(e);return Object.isExtensible(e)},preventExtensions:function preventExtensions(e){In(e);return Pn(function(){return Object.preventExtensions(e)})}})}if(s){var Cn=function get(e,t,r){var n=Object.getOwnPropertyDescriptor(e,t);if(!n){var o=Object.getPrototypeOf(e);if(o===null){return void 0}return Cn(o,t,r)}if("value"in n){return n.value}if(n.get){return ce.Call(n.get,r)}return void 0};var Mn=function set(e,r,n,o){var i=Object.getOwnPropertyDescriptor(e,r);if(!i){var a=Object.getPrototypeOf(e);if(a!==null){return Mn(a,r,n,o)}i={value:void 0,writable:true,enumerable:true,configurable:true}}if("value"in i){if(!i.writable){return false}if(!ce.TypeIsObject(o)){return false}var u=Object.getOwnPropertyDescriptor(o,r);if(u){return ae.defineProperty(o,r,{value:n})}else{return ae.defineProperty(o,r,{value:n,writable:true,enumerable:true,configurable:true})}}if(i.set){t(i.set,o,n);return true}return false};Object.assign(En,{defineProperty:function defineProperty(e,t,r){In(e);return Pn(function(){return Object.defineProperty(e,t,r)})},getOwnPropertyDescriptor:function getOwnPropertyDescriptor(e,t){In(e);return Object.getOwnPropertyDescriptor(e,t)},get:function get(e,t){In(e);var r=arguments.length>2?arguments[2]:e;return Cn(e,t,r)},set:function set(e,t,r){In(e);var n=arguments.length>3?arguments[3]:e;return Mn(e,t,r,n)}})}if(Object.getPrototypeOf){var xn=Object.getPrototypeOf;En.getPrototypeOf=function getPrototypeOf(e){In(e);return xn(e)}}if(Object.setPrototypeOf&&En.getPrototypeOf){var Nn=function(e,t){var r=t;while(r){if(e===r){return true}r=En.getPrototypeOf(r)}return false};Object.assign(En,{setPrototypeOf:function setPrototypeOf(e,t){In(e);if(t!==null&&!ce.TypeIsObject(t)){throw new TypeError("proto must be an object or null")}if(t===ae.getPrototypeOf(e)){return true}if(ae.isExtensible&&!ae.isExtensible(e)){return false}if(Nn(e,t)){return false}Object.setPrototypeOf(e,t);return true}})}var An=function(e,t){if(!ce.IsCallable(S.Reflect[e])){h(S.Reflect,e,t)}else{var r=a(function(){S.Reflect[e](1);S.Reflect[e](NaN);S.Reflect[e](true);return true});if(r){ne(S.Reflect,e,t)}}};Object.keys(En).forEach(function(e){An(e,En[e])});var Rn=S.Reflect.getPrototypeOf;if(c&&Rn&&Rn.name!=="getPrototypeOf"){ne(S.Reflect,"getPrototypeOf",function getPrototypeOf(e){return t(Rn,S.Reflect,e)})}if(S.Reflect.setPrototypeOf){if(a(function(){S.Reflect.setPrototypeOf(1,{});return true})){ne(S.Reflect,"setPrototypeOf",En.setPrototypeOf)}}if(S.Reflect.defineProperty){if(!a(function(){var e=!S.Reflect.defineProperty(1,"test",{value:1});var t=typeof Object.preventExtensions!=="function"||!S.Reflect.defineProperty(Object.preventExtensions({}),"test",{});return e&&t})){ne(S.Reflect,"defineProperty",En.defineProperty)}}if(S.Reflect.construct){if(!a(function(){var e=function F(){};return S.Reflect.construct(function(){},[],e)instanceof e})){ne(S.Reflect,"construct",En.construct)}}if(String(new Date(NaN))!=="Invalid Date"){var _n=Date.prototype.toString;var kn=function toString(){var e=+this;if(e!==e){return"Invalid Date"}return ce.Call(_n,this)};ne(Date.prototype,"toString",kn)}var Ln={anchor:function anchor(e){return ce.CreateHTML(this,"a","name",e)},big:function big(){return ce.CreateHTML(this,"big","","")},blink:function blink(){return ce.CreateHTML(this,"blink","","")},bold:function bold(){return ce.CreateHTML(this,"b","","")},fixed:function fixed(){return ce.CreateHTML(this,"tt","","")},fontcolor:function fontcolor(e){return ce.CreateHTML(this,"font","color",e)},fontsize:function fontsize(e){return ce.CreateHTML(this,"font","size",e)},italics:function italics(){return ce.CreateHTML(this,"i","","")},link:function link(e){return ce.CreateHTML(this,"a","href",e)},small:function small(){return ce.CreateHTML(this,"small","","")},strike:function strike(){return ce.CreateHTML(this,"strike","","")},sub:function sub(){return ce.CreateHTML(this,"sub","","")},sup:function sub(){return ce.CreateHTML(this,"sup","","")}};l(Object.keys(Ln),function(e){var r=String.prototype[e];var n=false;if(ce.IsCallable(r)){var o=t(r,"",' " ');var i=P([],o.match(/"/g)).length;n=o!==o.toLowerCase()||i>2}else{n=true}if(n){ne(String.prototype,e,Ln[e])}});var Fn=function(){if(!oe){return false}var e=typeof JSON==="object"&&typeof JSON.stringify==="function"?JSON.stringify:null;if(!e){return false}if(typeof e($())!=="undefined"){return true}if(e([$()])!=="[null]"){return true}var t={a:$()};t[$()]=true;if(e(t)!=="{}"){return true}return false}();var Dn=a(function(){if(!oe){return true}return JSON.stringify(Object($()))==="{}"&&JSON.stringify([Object($())])==="[{}]"});if(Fn||!Dn){var zn=JSON.stringify;ne(JSON,"stringify",function stringify(e){if(typeof e==="symbol"){return}var n;if(arguments.length>1){n=arguments[1]}var o=[e];if(!r(n)){var i=ce.IsCallable(n)?n:null;var a=function(e,r){var n=i?t(i,this,e,r):r;if(typeof n!=="symbol"){if(re.symbol(n)){return Nt({})(n)}else{return n}}};o.push(a)}else{o.push(n)}if(arguments.length>2){o.push(arguments[2])}return zn.apply(this,o)})}return S});
/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.6.0",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(j).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^([^.]*)(?:\.(.+)|)/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ee(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Se(this,e,Ce),!1},trigger:function(){return Se(this,e),!0},_default:function(){return!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=/<script|<style|<link/i,Ae=/checked\s*(?:[^=]|=\s*.checked.)/i,Ne=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function je(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function De(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function qe(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(Ne,""),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Re=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Me=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ie=new RegExp(ne.join("|"),"i");function We(e,t,n){var r,i,o,a,s=e.style;return(n=n||Re(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Pe.test(a)&&Ie.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function Fe(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var Be=["Webkit","Moz","ms"],$e=E.createElement("div").style,_e={};function ze(e){var t=S.cssProps[e]||_e[e];return t||(e in $e?e:_e[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Be.length;while(n--)if((e=Be[n]+t)in $e)return e}(e)||e)}var Ue=/^(none|table(?!-c[ea]).+)/,Xe=/^--/,Ve={position:"absolute",visibility:"hidden",display:"block"},Ge={letterSpacing:"0",fontWeight:"400"};function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Qe(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Je(e,t,n){var r=Re(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=We(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Qe(e,t,n||(i?"border":"content"),o,r,a)+"px"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=We(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Xe.test(t),l=e.style;if(u||(t=ze(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Xe.test(t)||(t=ze(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=We(e,t,r)),"normal"===i&&t in Ge&&(i=Ge[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ue.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,u,n):Me(e,Ve,function(){return Je(e,u,n)})},set:function(e,t,n){var r,i=Re(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Qe(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Qe(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Ye(0,t,s)}}}),S.cssHooks.marginLeft=Fe(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(We(e,"marginLeft"))||e.getBoundingClientRect().left-Me(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Ye)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Re(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=Ke).prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}}).init.prototype=Ke.prototype,(Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[ze(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=Ke.prototype.init,S.fx.step={};var Ze,et,tt,nt,rt=/^(?:toggle|show|hide)$/,it=/queueHooks$/;function ot(){et&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(ot):C.setTimeout(ot,S.fx.interval),S.fx.tick())}function at(){return C.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function st(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ut(e,t,n){for(var r,i=(lt.tweeners[t]||[]).concat(lt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function lt(o,e,t){var n,a,r=0,i=lt.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=Ze||at(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:Ze||at(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=lt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ut,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(lt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],lt.tweeners[n]=lt.tweeners[n]||[],lt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],rt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ut(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?lt.prefilters.unshift(e):lt.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=lt(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&it.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(st(r,!0),e,t,n)}}),S.each({slideDown:st("show"),slideUp:st("hide"),slideToggle:st("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),Ze=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){et||(et=!0,ot())},S.fx.stop=function(){et=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},tt=E.createElement("input"),nt=E.createElement("select").appendChild(E.createElement("option")),tt.type="checkbox",y.checkOn=""!==tt.value,y.optSelected=nt.selected,(tt=E.createElement("input")).value="t",tt.type="radio",y.radioValue="t"===tt.value;var ct,ft=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?ct:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ct={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=ft[t]||S.find.attr;ft[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=ft[o],ft[o]=r,r=null!=a(e,t,n)?o:null,ft[o]=i),r}});var pt=/^(?:input|select|textarea|button)$/i,dt=/^(?:a|area)$/i;function ht(e){return(e.match(P)||[]).join(" ")}function gt(e){return e.getAttribute&&e.getAttribute("class")||""}function vt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):pt.test(e.nodeName)||dt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,gt(this)))});if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&" "+ht(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=ht(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,gt(this)))});if(!arguments.length)return this.attr("class","");if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&" "+ht(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=ht(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,gt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=vt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=gt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+ht(gt(n))+" ").indexOf(t))return!0;return!1}});var yt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(yt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:ht(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var mt=/^(?:focusinfocus|focusoutblur)$/,xt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!mt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,mt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,xt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,xt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var bt=C.location,wt={guid:Date.now()},Tt=/\?/;S.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||S.error("Invalid XML: "+(n?S.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var Ct=/\[\]$/,Et=/\r?\n/g,St=/^(?:submit|button|image|reset|file)$/i,kt=/^(?:input|select|textarea|keygen)/i;function At(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||Ct.test(n)?i(n,t):At(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)At(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)At(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&kt.test(this.nodeName)&&!St.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(Et,"\r\n")}}):{name:t.name,value:n.replace(Et,"\r\n")}}).get()}});var Nt=/%20/g,jt=/#.*$/,Dt=/([?&])_=[^&]*/,qt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Lt=/^(?:GET|HEAD)$/,Ht=/^\/\//,Ot={},Pt={},Rt="*/".concat("*"),Mt=E.createElement("a");function It(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Wt(t,i,o,a){var s={},u=t===Pt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Ft(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Mt.href=bt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:bt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Rt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Ft(Ft(e,S.ajaxSettings),t):Ft(S.ajaxSettings,e)},ajaxPrefilter:It(Ot),ajaxTransport:It(Pt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=qt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||bt.href)+"").replace(Ht,bt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Mt.protocol+"//"+Mt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Wt(Ot,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Lt.test(v.type),f=v.url.replace(jt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Nt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Tt.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Dt,"$1"),o=(Tt.test(f)?"&":"?")+"_="+wt.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+Rt+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Wt(Pt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&S.inArray("json",v.dataTypes)<0&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Bt={0:200,1223:204},$t=S.ajaxSettings.xhr();y.cors=!!$t&&"withCredentials"in $t,y.ajax=$t=!!$t,S.ajaxTransport(function(i){var o,a;if(y.cors||$t&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Bt[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var _t,zt=[],Ut=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=zt.pop()||S.expando+"_"+wt.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Ut.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ut.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Ut,"$1"+r):!1!==e.jsonp&&(e.url+=(Tt.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,zt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((_t=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===_t.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=ht(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=Fe(y.pixelPosition,function(e,t){if(t)return t=We(e,n),Pe.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Xt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Xt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Vt=C.jQuery,Gt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Gt),e&&C.jQuery===S&&(C.jQuery=Vt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
/*
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function(b,c){var $=b.jQuery||b.Cowboy||(b.Cowboy={}),a;$.throttle=a=function(e,f,j,i){var h,d=0;if(typeof f!=="boolean"){i=j;j=f;f=c}function g(){var o=this,m=+new Date()-d,n=arguments;function l(){d=+new Date();j.apply(o,n)}function k(){h=c}if(i&&!h){l()}h&&clearTimeout(h);if(i===c&&m>e){l()}else{if(f!==true){h=setTimeout(i?k:l,i===c?e-m:e)}}}if($.guid){g.guid=j.guid=j.guid||$.guid++}return g};$.debounce=function(d,e,f){return f===c?a(d,e,false):a(d,f,e!==false)}})(this);
/*!
 * imagesLoaded PACKAGED v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
!function(e,t){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",t):"object"==typeof module&&module.exports?module.exports=t():e.EvEmitter=t()}("undefined"!=typeof window?window:this,function(){function e(){}var t=e.prototype;return t.on=function(e,t){if(e&&t){var i=this._events=this._events||{},n=i[e]=i[e]||[];return n.indexOf(t)==-1&&n.push(t),this}},t.once=function(e,t){if(e&&t){this.on(e,t);var i=this._onceEvents=this._onceEvents||{},n=i[e]=i[e]||{};return n[t]=!0,this}},t.off=function(e,t){var i=this._events&&this._events[e];if(i&&i.length){var n=i.indexOf(t);return n!=-1&&i.splice(n,1),this}},t.emitEvent=function(e,t){var i=this._events&&this._events[e];if(i&&i.length){i=i.slice(0),t=t||[];for(var n=this._onceEvents&&this._onceEvents[e],o=0;o<i.length;o++){var r=i[o],s=n&&n[r];s&&(this.off(e,r),delete n[r]),r.apply(this,t)}return this}},t.allOff=function(){delete this._events,delete this._onceEvents},e}),function(e,t){"use strict";"function"==typeof define&&define.amd?define(["ev-emitter/ev-emitter"],function(i){return t(e,i)}):"object"==typeof module&&module.exports?module.exports=t(e,require("ev-emitter")):e.imagesLoaded=t(e,e.EvEmitter)}("undefined"!=typeof window?window:this,function(e,t){function i(e,t){for(var i in t)e[i]=t[i];return e}function n(e){if(Array.isArray(e))return e;var t="object"==typeof e&&"number"==typeof e.length;return t?d.call(e):[e]}function o(e,t,r){if(!(this instanceof o))return new o(e,t,r);var s=e;return"string"==typeof e&&(s=document.querySelectorAll(e)),s?(this.elements=n(s),this.options=i({},this.options),"function"==typeof t?r=t:i(this.options,t),r&&this.on("always",r),this.getImages(),h&&(this.jqDeferred=new h.Deferred),void setTimeout(this.check.bind(this))):void a.error("Bad element for imagesLoaded "+(s||e))}function r(e){this.img=e}function s(e,t){this.url=e,this.element=t,this.img=new Image}var h=e.jQuery,a=e.console,d=Array.prototype.slice;o.prototype=Object.create(t.prototype),o.prototype.options={},o.prototype.getImages=function(){this.images=[],this.elements.forEach(this.addElementImages,this)},o.prototype.addElementImages=function(e){"IMG"==e.nodeName&&this.addImage(e),this.options.background===!0&&this.addElementBackgroundImages(e);var t=e.nodeType;if(t&&u[t]){for(var i=e.querySelectorAll("img"),n=0;n<i.length;n++){var o=i[n];this.addImage(o)}if("string"==typeof this.options.background){var r=e.querySelectorAll(this.options.background);for(n=0;n<r.length;n++){var s=r[n];this.addElementBackgroundImages(s)}}}};var u={1:!0,9:!0,11:!0};return o.prototype.addElementBackgroundImages=function(e){var t=getComputedStyle(e);if(t)for(var i=/url\((['"])?(.*?)\1\)/gi,n=i.exec(t.backgroundImage);null!==n;){var o=n&&n[2];o&&this.addBackground(o,e),n=i.exec(t.backgroundImage)}},o.prototype.addImage=function(e){var t=new r(e);this.images.push(t)},o.prototype.addBackground=function(e,t){var i=new s(e,t);this.images.push(i)},o.prototype.check=function(){function e(e,i,n){setTimeout(function(){t.progress(e,i,n)})}var t=this;return this.progressedCount=0,this.hasAnyBroken=!1,this.images.length?void this.images.forEach(function(t){t.once("progress",e),t.check()}):void this.complete()},o.prototype.progress=function(e,t,i){this.progressedCount++,this.hasAnyBroken=this.hasAnyBroken||!e.isLoaded,this.emitEvent("progress",[this,e,t]),this.jqDeferred&&this.jqDeferred.notify&&this.jqDeferred.notify(this,e),this.progressedCount==this.images.length&&this.complete(),this.options.debug&&a&&a.log("progress: "+i,e,t)},o.prototype.complete=function(){var e=this.hasAnyBroken?"fail":"done";if(this.isComplete=!0,this.emitEvent(e,[this]),this.emitEvent("always",[this]),this.jqDeferred){var t=this.hasAnyBroken?"reject":"resolve";this.jqDeferred[t](this)}},r.prototype=Object.create(t.prototype),r.prototype.check=function(){var e=this.getIsImageComplete();return e?void this.confirm(0!==this.img.naturalWidth,"naturalWidth"):(this.proxyImage=new Image,this.proxyImage.addEventListener("load",this),this.proxyImage.addEventListener("error",this),this.img.addEventListener("load",this),this.img.addEventListener("error",this),void(this.proxyImage.src=this.img.src))},r.prototype.getIsImageComplete=function(){return this.img.complete&&this.img.naturalWidth},r.prototype.confirm=function(e,t){this.isLoaded=e,this.emitEvent("progress",[this,this.img,t])},r.prototype.handleEvent=function(e){var t="on"+e.type;this[t]&&this[t](e)},r.prototype.onload=function(){this.confirm(!0,"onload"),this.unbindEvents()},r.prototype.onerror=function(){this.confirm(!1,"onerror"),this.unbindEvents()},r.prototype.unbindEvents=function(){this.proxyImage.removeEventListener("load",this),this.proxyImage.removeEventListener("error",this),this.img.removeEventListener("load",this),this.img.removeEventListener("error",this)},s.prototype=Object.create(r.prototype),s.prototype.check=function(){this.img.addEventListener("load",this),this.img.addEventListener("error",this),this.img.src=this.url;var e=this.getIsImageComplete();e&&(this.confirm(0!==this.img.naturalWidth,"naturalWidth"),this.unbindEvents())},s.prototype.unbindEvents=function(){this.img.removeEventListener("load",this),this.img.removeEventListener("error",this)},s.prototype.confirm=function(e,t){this.isLoaded=e,this.emitEvent("progress",[this,this.element,t])},o.makeJQueryPlugin=function(t){t=t||e.jQuery,t&&(h=t,h.fn.imagesLoaded=function(e,t){var i=new o(this,e,t);return i.jqDeferred.promise(h(this))})},o.makeJQueryPlugin(),o});
/*! lz-string-1.3.3-min.js | (c) 2013 Pieroxy | Licensed under a WTFPL license */
var LZString={_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_f:String.fromCharCode,compressToBase64:function(e){if(e==null)return"";var t="";var n,r,i,s,o,u,a;var f=0;e=LZString.compress(e);while(f<e.length*2){if(f%2==0){n=e.charCodeAt(f/2)>>8;r=e.charCodeAt(f/2)&255;if(f/2+1<e.length)i=e.charCodeAt(f/2+1)>>8;else i=NaN}else{n=e.charCodeAt((f-1)/2)&255;if((f+1)/2<e.length){r=e.charCodeAt((f+1)/2)>>8;i=e.charCodeAt((f+1)/2)&255}else r=i=NaN}f+=3;s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+LZString._keyStr.charAt(s)+LZString._keyStr.charAt(o)+LZString._keyStr.charAt(u)+LZString._keyStr.charAt(a)}return t},decompressFromBase64:function(e){if(e==null)return"";var t="",n=0,r,i,s,o,u,a,f,l,c=0,h=LZString._f;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(c<e.length){u=LZString._keyStr.indexOf(e.charAt(c++));a=LZString._keyStr.indexOf(e.charAt(c++));f=LZString._keyStr.indexOf(e.charAt(c++));l=LZString._keyStr.indexOf(e.charAt(c++));i=u<<2|a>>4;s=(a&15)<<4|f>>2;o=(f&3)<<6|l;if(n%2==0){r=i<<8;if(f!=64){t+=h(r|s)}if(l!=64){r=o<<8}}else{t=t+h(r|i);if(f!=64){r=s<<8}if(l!=64){t+=h(r|o)}}n+=3}return LZString.decompress(t)},compressToUTF16:function(e){if(e==null)return"";var t="",n,r,i,s=0,o=LZString._f;e=LZString.compress(e);for(n=0;n<e.length;n++){r=e.charCodeAt(n);switch(s++){case 0:t+=o((r>>1)+32);i=(r&1)<<14;break;case 1:t+=o(i+(r>>2)+32);i=(r&3)<<13;break;case 2:t+=o(i+(r>>3)+32);i=(r&7)<<12;break;case 3:t+=o(i+(r>>4)+32);i=(r&15)<<11;break;case 4:t+=o(i+(r>>5)+32);i=(r&31)<<10;break;case 5:t+=o(i+(r>>6)+32);i=(r&63)<<9;break;case 6:t+=o(i+(r>>7)+32);i=(r&127)<<8;break;case 7:t+=o(i+(r>>8)+32);i=(r&255)<<7;break;case 8:t+=o(i+(r>>9)+32);i=(r&511)<<6;break;case 9:t+=o(i+(r>>10)+32);i=(r&1023)<<5;break;case 10:t+=o(i+(r>>11)+32);i=(r&2047)<<4;break;case 11:t+=o(i+(r>>12)+32);i=(r&4095)<<3;break;case 12:t+=o(i+(r>>13)+32);i=(r&8191)<<2;break;case 13:t+=o(i+(r>>14)+32);i=(r&16383)<<1;break;case 14:t+=o(i+(r>>15)+32,(r&32767)+32);s=0;break}}return t+o(i+32)},decompressFromUTF16:function(e){if(e==null)return"";var t="",n,r,i=0,s=0,o=LZString._f;while(s<e.length){r=e.charCodeAt(s)-32;switch(i++){case 0:n=r<<1;break;case 1:t+=o(n|r>>14);n=(r&16383)<<2;break;case 2:t+=o(n|r>>13);n=(r&8191)<<3;break;case 3:t+=o(n|r>>12);n=(r&4095)<<4;break;case 4:t+=o(n|r>>11);n=(r&2047)<<5;break;case 5:t+=o(n|r>>10);n=(r&1023)<<6;break;case 6:t+=o(n|r>>9);n=(r&511)<<7;break;case 7:t+=o(n|r>>8);n=(r&255)<<8;break;case 8:t+=o(n|r>>7);n=(r&127)<<9;break;case 9:t+=o(n|r>>6);n=(r&63)<<10;break;case 10:t+=o(n|r>>5);n=(r&31)<<11;break;case 11:t+=o(n|r>>4);n=(r&15)<<12;break;case 12:t+=o(n|r>>3);n=(r&7)<<13;break;case 13:t+=o(n|r>>2);n=(r&3)<<14;break;case 14:t+=o(n|r>>1);n=(r&1)<<15;break;case 15:t+=o(n|r);i=0;break}s++}return LZString.decompress(t)},compress:function(e){if(e==null)return"";var t,n,r={},i={},s="",o="",u="",a=2,f=3,l=2,c="",h=0,p=0,d,v=LZString._f;for(d=0;d<e.length;d+=1){s=e.charAt(d);if(!Object.prototype.hasOwnProperty.call(r,s)){r[s]=f++;i[s]=true}o=u+s;if(Object.prototype.hasOwnProperty.call(r,o)){u=o}else{if(Object.prototype.hasOwnProperty.call(i,u)){if(u.charCodeAt(0)<256){for(t=0;t<l;t++){h=h<<1;if(p==15){p=0;c+=v(h);h=0}else{p++}}n=u.charCodeAt(0);for(t=0;t<8;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}else{n=1;for(t=0;t<l;t++){h=h<<1|n;if(p==15){p=0;c+=v(h);h=0}else{p++}n=0}n=u.charCodeAt(0);for(t=0;t<16;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}a--;if(a==0){a=Math.pow(2,l);l++}delete i[u]}else{n=r[u];for(t=0;t<l;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}a--;if(a==0){a=Math.pow(2,l);l++}r[o]=f++;u=String(s)}}if(u!==""){if(Object.prototype.hasOwnProperty.call(i,u)){if(u.charCodeAt(0)<256){for(t=0;t<l;t++){h=h<<1;if(p==15){p=0;c+=v(h);h=0}else{p++}}n=u.charCodeAt(0);for(t=0;t<8;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}else{n=1;for(t=0;t<l;t++){h=h<<1|n;if(p==15){p=0;c+=v(h);h=0}else{p++}n=0}n=u.charCodeAt(0);for(t=0;t<16;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}a--;if(a==0){a=Math.pow(2,l);l++}delete i[u]}else{n=r[u];for(t=0;t<l;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}}a--;if(a==0){a=Math.pow(2,l);l++}}n=2;for(t=0;t<l;t++){h=h<<1|n&1;if(p==15){p=0;c+=v(h);h=0}else{p++}n=n>>1}while(true){h=h<<1;if(p==15){c+=v(h);break}else p++}return c},decompress:function(e){if(e==null)return"";if(e=="")return null;var t=[],n,r=4,i=4,s=3,o="",u="",a,f,l,c,h,p,d,v=LZString._f,m={string:e,val:e.charCodeAt(0),position:32768,index:1};for(a=0;a<3;a+=1){t[a]=a}l=0;h=Math.pow(2,2);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}switch(n=l){case 0:l=0;h=Math.pow(2,8);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}d=v(l);break;case 1:l=0;h=Math.pow(2,16);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}d=v(l);break;case 2:return""}t[3]=d;f=u=d;while(true){if(m.index>m.string.length){return""}l=0;h=Math.pow(2,s);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}switch(d=l){case 0:l=0;h=Math.pow(2,8);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}t[i++]=v(l);d=i-1;r--;break;case 1:l=0;h=Math.pow(2,16);p=1;while(p!=h){c=m.val&m.position;m.position>>=1;if(m.position==0){m.position=32768;m.val=m.string.charCodeAt(m.index++)}l|=(c>0?1:0)*p;p<<=1}t[i++]=v(l);d=i-1;r--;break;case 2:return u}if(r==0){r=Math.pow(2,s);s++}if(t[d]){o=t[d]}else{if(d===i){o=f+f.charAt(0)}else{return null}}u+=o;t[i++]=f+o.charAt(0);r--;f=o;if(r==0){r=Math.pow(2,s);s++}}}};if(typeof module!=="undefined"&&module!=null){module.exports=LZString}
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/dist/FileSaver.js */
(function(a,b){if("function"==typeof define&&define.amd)define([],b);else if("undefined"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,"undefined"!=typeof module&&(module.exports=g)});
/*! seedrandom.js v2.3.3 | (c) 2013 David Bau, all rights reserved. | Licensed under a BSD-style license */
!function(a,b,c,d,e,f,g,h,i){function j(a){var b,c=a.length,e=this,f=0,g=e.i=e.j=0,h=e.S=[];for(c||(a=[c++]);d>f;)h[f]=f++;for(f=0;d>f;f++)h[f]=h[g=r&g+a[f%c]+(b=h[f])],h[g]=b;(e.g=function(a){for(var b,c=0,f=e.i,g=e.j,h=e.S;a--;)b=h[f=r&f+1],c=c*d+h[r&(h[f]=h[g=r&g+b])+(h[g]=b)];return e.i=f,e.j=g,c})(d)}function k(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)try{d.push(k(a[c],b-1))}catch(f){}return d.length?d:"string"==e?a:a+"\0"}function l(a,b){for(var c,d=a+"",e=0;e<d.length;)b[r&e]=r&(c^=19*b[r&e])+d.charCodeAt(e++);return n(b)}function m(c){try{return a.crypto.getRandomValues(c=new Uint8Array(d)),n(c)}catch(e){return[+new Date,a,(c=a.navigator)&&c.plugins,a.screen,n(b)]}}function n(a){return String.fromCharCode.apply(0,a)}var o=c.pow(d,e),p=c.pow(2,f),q=2*p,r=d-1,s=c["seed"+i]=function(a,f,g){var h=[],r=l(k(f?[a,n(b)]:null==a?m():a,3),h),s=new j(h);return l(n(s.S),b),(g||function(a,b,d){return d?(c[i]=a,b):a})(function(){for(var a=s.g(e),b=o,c=0;p>a;)a=(a+c)*d,b*=d,c=s.g(1);for(;a>=q;)a/=2,b/=2,c>>>=1;return(a+c)/b},r,this==c)};l(c[i](),b),g&&g.exports?g.exports=s:h&&h.amd&&h(function(){return s})}(this,[],Math,256,6,52,"object"==typeof module&&module,"function"==typeof define&&define,"random");
/*! console_hack.js | (c) 2015 Thomas Michael Edwards | Licensed under SugarCube's Simple BSD license */
!function(){for(var methods=["assert","clear","count","debug","dir","dirxml","error","exception","group","groupCollapsed","groupEnd","info","log","markTimeline","profile","profileEnd","table","time","timeEnd","timeline","timelineEnd","timeStamp","trace","warn"],length=methods.length,noop=function(){},console=window.console=window.console||{};length--;){var method=methods[length];console[method]||(console[method]=noop)}}();
}else{document.documentElement.setAttribute("data-init", "lacking");}
</script>
<style id="style-normalize" type="text/css">/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}</style>
<style id="style-init-screen" type="text/css">@-webkit-keyframes init-loading-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-o-keyframes init-loading-spin{0%{-o-transform:rotate(0);transform:rotate(0)}100%{-o-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes init-loading-spin{0%{-webkit-transform:rotate(0);-o-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);-o-transform:rotate(360deg);transform:rotate(360deg)}}#init-screen{display:none;z-index:500000;position:fixed;top:0;left:0;height:100%;width:100%;font:28px/1 Helmet,Freesans,sans-serif;font-weight:700;color:#eee;background-color:#111;text-align:center}#init-screen>div{display:none;position:relative;margin:0 auto;max-width:1136px;top:25%}html[data-init=lacking] #init-screen,html[data-init=loading] #init-screen,html[data-init=no-js] #init-screen{display:block}html[data-init=lacking] #init-lacking,html[data-init=no-js] #init-no-js{display:block;padding:0 1em}html[data-init=no-js] #init-no-js{color:red}html[data-init=loading] #init-loading{display:block;border:24px solid transparent;border-radius:50%;border-top-color:#7f7f7f;border-bottom-color:#7f7f7f;width:100px;height:100px;-webkit-animation:init-loading-spin 2s linear infinite;-o-animation:init-loading-spin 2s linear infinite;animation:init-loading-spin 2s linear infinite}html[data-init=loading] #init-loading>div{text-indent:9999em;overflow:hidden;white-space:nowrap}html[data-init=loading] #passages,html[data-init=loading] #ui-bar{display:none}</style>
<style id="style-font" type="text/css">@font-face{font-family:tme-fa-icons;src:url('data:application/octet-stream;base64,d09GRgABAAAAADLAAA8AAAAAWHgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY+IEkIY21hcAAAAdgAAAG8AAAF3rob9jFjdnQgAAADlAAAABMAAAAgBtX/BGZwZ20AAAOoAAAFkAAAC3CKkZBZZ2FzcAAACTgAAAAIAAAACAAAABBnbHlmAAAJQAAAI6gAADv+gJOpzGhlYWQAACzoAAAAMwAAADYY1IZaaGhlYQAALRwAAAAgAAAAJAfCBClobXR4AAAtPAAAAJEAAAFMBfb/0WxvY2EAAC3QAAAAqAAAAKhjiHI5bWF4cAAALngAAAAgAAAAIAFjDA9uYW1lAAAumAAAAY0AAAL94+zEpHBvc3QAADAoAAACHAAAA11cG/YjcHJlcAAAMkQAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZNZgnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4vGF4EMgf9z2KIYg5imAYUZgTJAQDSIQumAHic7dTVbltRAETR7dpNCikzQ8rMzMxt/M39mHnsU1/TfZz5jFpaV7pXJunMDLAZmOqaZjD5y4Tx+uPTyeL5lG2L5zN+L94zG8+ztr7ulXH1fra4bvK9M79xiWW2sNXPbWeFHexkF7vZw172sZ8DHOQQhznCUY5xnBOc5BSnOcNZVjnHeS5wkUtc5gpX/f3r3OAmt7jNHe5yj/s84CGPeMwTnvKM57zgJa94zRve8o73fOAjn/jMF77yje/84Ce/WGPun1zi/2tlXKbp3Xyc44bFyZanSWokJDXOOjXSk/LUSXn+pEwCKTNBaqQqZU5IjX+XMjukTBEp80TKZJEyY6RMGylzR8oEkjKLpEwlKfNJyqSSMrOkTC8pc0zKRJMy26RMOSnzTsrkk7IDpGwDKXtByoaQsiukbA0p+0PKJpGyU6RsFyl7RmosQcrukbKFpOwjKZtJyo6Ssq2k7C0pG0zKLpOy1aTsNymbTsrOk7L9pNwBUi4CKbeBlCtByr0g5XKQckNIuSak3BVSLgwpt4aUq0PK/SHlEpFyk0i5TqTcKVIuFim3i5QrRso9I+WykXLjXOYNzP8BuAPUwHicY2BAAxIQyBz0PwuEARJsA90AeJytVml300YUHXlJnIQsJQstamHExGmwRiZswYAJQbJjIF2crZWgixQ76b7xid/gX/Nk2nPoN35a7xsvJJC053Cak6N3583VzNtlElqS2AvrkZSbL8XU1iaN7DwJ6YZNy1F8KDt7IWWKyd8FURCtltq3HYdERCJQta6wRBD7HlmaZHzoUUbLtqRXTcotPekuW+NBvVXffho6yrE7oaRmM3RoPbIlVRhVokimPVLSpmWo+itJK7y/wsxXzVDCiE4iabwZxtBI3htntMpoNbbjKIpsstwoUiSa4UEUeZTVEufkigkMygfNkPLKpxHlw/yIrNijnFawS7bT/L4vead3OT+xX29RtuRAH8iO7ODsdCVfhFtbYdy0k+0oVBF213dCbNnsVP9mj/KaRgO3KzK90IxgqXyFECs/ocz+IVktnE/5kkejWrKRE0HrZU7sSz6B1uOIKXHNGFnQ3dEJEdT9kjMM9pg+Hvzx3imWCxMCeBzLekclnAgTKWFzNEnaMHJgJWWLKqn1rpg45XVaxFvCfu3a0ZfOaONQd2I8Ww8dWzlRyfFoUqeZTJ3aSc2jKQ2ilHQmeMyvAyg/oklebWM1iZVH0zhmxoREIgIt3EtTQSw7saQpBM2jGb25G6a5di1apMkD9dyj9/TmVri501PaDvSzRn9Wp2I62AvT6WnkL/Fp2uUiRen66Rl+TOJB1gIykS02w5SDB2/9DtLL15YchdcG2O7t8yuofdZE8KQB+xvQHk/VKQlMhZhViFZAYq1rWZbJ1awWqcjUd0OaVr6s0wSKchwXx76Mcf1fMzOWmBK+34nTsyMuPXPtSwjTHHybdT2a16nFcgFxZnlOp1mW7+s0x/IDneZZntfpCEtbp6MsP9RpgeVHOh1jeUELmnTfwZCLMOQCDpAwhKUDQ1hegiEsFQxhuQhDWBZhCMslGMLyYxjCchmGsLysZdXUU0nj2plYBmxCYGKOHrnMReVqKrlUQrtoVGpDnhJulVQUz6p/ZaBePPKGObAWSJfIml8xzpWPRuX41hUtbxo7V8Cx6m8fjvY58VLWi4U/Bf/V1lQlvWLNw5Or8BuGnmwnqjapeHRNl89VPbr+X1RUWAv0G0iFWCjKsmxwZyKEjzqdhmqglUPMbMw8tOt1y5qfw/03MUIWUP34NxQaC9yDTllJWe3grNXX27LcO4NyOBMsSTE38/pW+CIjs9J+kVnKno98HnAFjEpl2GoDrRW82ScxD5neJM8EcVtRNkja2M4EiQ0c84B5850EJmHqqg3kTuGGDfgFYW7BeSdconqjLIfuRezzKKT8W6fiRPaoaIzAs9kbYa/vQspvcQwkNPmlfgxUFaGpGDUV0DRSbqgGX8bZum1Cxg70Iyp2w7Ks4sPHFveVkm0ZhHykiNWjo5/WXqJOqtx+ZhSX752+BcEgNTF/e990cZDKu1rJMkdtA1O3GpVT15pD41WH6uZR9b3j7BM5a5puuiceel/TqtvBxVwssPZtDtJSJhfU9WGFDaLLxaVQ6mU0Se+4BxgWGNDvUIqN/6v62HyeK1WF0XEk307Ut9HnYAz8D9h/R/UD0Pdj6HINLs/3mhOfbvThbJmuohfrp+g3MGutuVm6BtzQdAPiIUetjrjKDXynBnF6pLkc6SHgY90V4gHAJoDF4BPdtYzmUwCj+Yw5PsDnzGHQZA6DLeYw2GbOGsAOcxjsMofBHnMYfMGcdYAvmcMgZA6DiDkMnjAnAHjKHAZfMYfB18xh8A1z7gN8yxwGMXMYJMxhsK/p1jDMLV7QXaC2QVWgA1NPWNzD4lBTZcj+jheG/b1BzP7BIKb+qOn2kPoTLwz1Z4OY+otBTP1V050h9TdeGOrvBjH1D4OY+ky/GMtlBr+MfJcKB5RdbD7n74n3D9vFQLkAAQAB//8AD3icrXsLcFzlleZ//v+++nb37dfte/VotVrdrW5JltuKpO6WJVluPyXbsmOEbGRjO4KVjWPZlsM4QIU4IYGlgCE2yxqKIQkJg2GreKQCTCZb1CZkiswjzOwOmSTATNVWTZLdDUwSMrVDsomD23vOf69assFAqgbk+773P4//nPOdc/5mwNjFl8WjosbaWblmxiOmIlTGYXzb11M7Z2ohAMbZCcZ5iG9prZl4whfwGju05xtttitUdwXYEUgkbQtWga5lC+XBaqJI285qpb8dVEc8Gnm5L5QM/f58yAlB399a7dD0mWAmdAqaMvBmKPKX9TdDwSjod9yhx03FAPcvI6Gk2lV33XoXUtKgL8C6Wa0WSzXbVjhg6JoqIPShCK0FOvOuE48K1V4B1VUQAVevugmP7Fz2CmTzW5/8+ZGP/+Kp7h/8oI4MuOZ7M5B9IvujH2Wf+PnCAjzn8ZK6AieMKRcvXnxWWSWCzGARlPcqtqs21WZzEBFgYIVDAYWzVJIrXBlH+hXGlWNM00GAJmYZ8sKBzTJFVZVppijqDFMVdTIWLa0o5JrdaHusPZGIG1IjFhQGK2mAZEe56kJnR1bTY7ZT7eivFGODBTdma3pHtlCNDVbwmgMHx/aO4R8ffeet5/ZCG6TfuV03IaSJU3oIzKsGO9+5PV+BwU5xqnOQx1aO8fW71yvD9fPn55/fA22PmsaFvfSgwZ8wzPiFvZ2DUMnzJ2hHVDMmHucPsSRrq7UQo4DMAV/AW7CANw/Zru3NIx20bBEpXwukArlxxOPReibaG63/SyQyiftzcBy3k1HuOHgjEgFHnkYfh4VodDJC4138Ff8hv5PlWbrWmm2O6grNEgGNCWGnbFtRm1Z04gzQPPWvkqMWF4eWU8DB267Df+gNe84bBvfRpfNI5Ny5yAmHDh5/PPLuByMlekDS9DsRR73nWHetwBShSO5PqCBQONO4E2wGlSvYZG6gMzeQ09SWFZC0tWION3oOVVXGTbGM+hrAzQj0O25yoN8R8YzzRsaZdzLwhpsGPEm783hAJ9+kq286eDX5pn/VydDjvk7i8EuchU21JJ3DNOqFzeABmywPcNXxhu/wB+3whrqwVw7Cn1j8vPfdDH6O7PR3fDV/Cb85wua/waSit309grZJHHOhHEQ9CA7zTGVCUb0ZvXzc1lrRe5Af+4An0aSL9op0IU9y6vRFtAYGKy7KJGFbQrdg2dXqGAwWilld0zUy9xLqd6A/zeFuy7gzYFmBOwOhZ6NNhZakm8YTI7S1pyM1mM032V26qevXGlzZ8+TKvROlB/BBkO9ACDalB7OZuBnuC5tRcAItpalENNOfhajVH1A2a1HjbHZ4N4r54oWLz4qPoe4jrMo2sonapm5QRQBQ3XycKVxwRRxjQuVCnWc6mrzOZ5FvBiraOmia5FubYRpok8n0ioRTKOQMNbWiszxYWAFZrQ1sB+dDJTFYghzyiBN3oB857ndIAha4Se/+YGUtjAkXXUO2xPE2eoe3TWPeMOXmzNi+j9w1HghvVbSAmu4c6nFac6MgbzXFU2baDr1241+98TfHtU/9t7df+MzU4msmfPYj06Wbw8Gqohda0/FkSyiyvtPGG/FsMKq1pLqmPvndkye/+y+08eYIHEJZpFmJra2Nop/VWuKcCwPvgRhnGlOFps6iIdAEmFVAKh53jblZyBU6nAFdbfX03tGwioZ9oGnEyDSWTQCyFzhoR+s/jdjgWLmc3L2K21zEmXCsM5aDm4g9Ny5v0PZVb+dY9Rcd/sl5eTiPj0nTaeiU+BhhW2qbuzJcUy2Nc2gCrjBkxWCqZiArGgOuwSzjAlDb5L91XfpvfYbpij6ZRIUWYoVcLqC2+UqNLddsMrekY3GZztVl2uQjpl4xjedIM+Uybc/r5viShuHgcgXuwQtpuoMHz8utCe/s8S+Y/7xMaYu2DX1yDrez3lp3cyyKdop+HLcLi878Uh9SKOSlj73cOIUFRVKVKHhaSS9JP452RCcYoJ3w85bz8Ckp9VN4xeZj9atpH4FnPCV4OtiDNIVYCrWwsbauK81VxUlaQnA+riFBisoUsiU0LbQpASCmmRAwg1MNJoH19uQ6WpriUV1jIQjphA5QjosiTfiy1tF+kPJKMTFYpAu6lkx40odnTv7VjYtC/QtTJyGH9HmMnKamGrcaqmaagRsMUwR9WeLmwsQREvIRevSvYa8uVFXo9Sc0w5A8/Rp5+jcxhXLuYAOIx/pbY+ggFp0FV8lNoLNAEQvyDkwBZR9T1ZC6xR0qFgsybix3DJcR7iIGwCsCHHQM0nYKVSBXQZPnqG7KDZiqrn8K524gpN9ghAx42k4GsvF3nohnA0kbnglkC9mrl7h4Db2TommKcVE1QOPRd97K5WJxsKO5nIjHbHtx/og3kK8iWys1he/EkKlqCbFOB6iKQp5Q5Yp6DB0AsjmPvHEFSGsoFraPaVpI2zLc2lmudErjJ/eeQwbKPoRBZulcwhwXYc6i1SdiEpiCF+KrFOIrAzKaHdhQ79tw4MAGuJv4rt8sQQu80jloGnnDfNVJBa+vn1WjSg1d8NHrg44FbTgdJ5+T77yy/gDI5wY7633yTbI7+CdyMDyEL2paDd0BvZjyfIYXH2/H+aqjDfXUisgnk3rFYMePoyZBegWanQpM5hKdlUSU1JnoQH2iG1d90IYADi0JPV2/oxMEeB7apm+aBngFw/ObMjzHzv7dgzyOh48fHZnmO9c8Wv+2RAGwHiP20UNnzx46mvYxyaMixDpZX22lQqQgRDqG4kYcMo92cpypAOo0Ti+iSYXJRGc5l8wvQhPfqpE0SYa7nDwkeQyh26OOlbecqVumoCwJ8+mDm+9/5T4eOyOt+4wk8WjavYTIG+7nD5Li2cWv8zGkMYoz51q2u3Y1JQSwfcumSn9JUxW0CZIWQ5isqKCo8zoGFPybx/lyHD2w4AaCBw7Ap1HIxAaHyZlr1tXG1owMt7h5Ox5QmxF4Iv6vDhaQoTFAYADuYIlnLa7b7RwtiOBDtVK1dbyCMXXxn5azOIIKfLFKaQP9K3HKIMYEQosvhkIWH23TQ9wIpCq9M4WxycnJsQIUYrEJ/bPGuOZohfHVzdmMaAmHm418c7DU3xdoyYPebFktPJtpHu7fefjw4R0VHiNTa06ZUTPe09a1sdTUVNrYtbo3nth11VW7tBa1d/U1a1t71rdG2u1IJNkWDYdbUs0pnnFT+OloWzISsdsjqVpvy9prqrNjed41POfPx2+J7TIXaWP5Wgf5bvToBEvpppQYOXPOJoda4gTQE6TsNK8sAvUSSHBFygfnfM9wL+8aK/Bddv0tZ8SufyKZ7ml7s20iCWdsPpPu4YVaXuur/2M6WX8riReTE21vtPUAnn4iyTxdf0vJ+/QM0pwsUL4D5BmUBQEeXpaU4W6RtExzN1In7eT9qHPpIoUdqAzSrdyHIPo1JNRps1uioCWJyIm2U/JG8oO4aZMXozF8b4RupRd5JJv7Nn8ZeUyxjlrakhJHcwO2gHMUDgGLR0MmS0GrIoMRWos0K81LUnPZYgmkw6sM8HtCoQTaT9y0Wu3f/MZuCYfijhMPhUVQNdL2hY8kMroS/8UvEqqeSfC/xzPV07k3vsqyrL+2ykYnhJjEz45OLIdbu4ncrbrWhImzltU7oqqaXAEdMWiHxPsSdvuF70K6/xf6FejjL13YBvFVP+UXrkwnyelZjBcltoLypQIoEmsoiDUw4C2QFS/I/J6yx5ybWOOqaMad0kJlKo+ElAdLqvRTMqOsgucuM64j3hgHU1H1mIkQ084Oje3eXT1lZwL1nwaD0BZMNfFTcHpv+sf7v6LEo4oZMlRbFNqH9tb60nEN0UkQ0mYawZNpR878eFuD1lWsl/Jb9J5iMbPlDKnkh3raBmS66U1M9Jm5rKUmMel1dKLOcxrVSgf5dJqU4o0g0pJyTlV37x4bytpCATOG8VUT4+m9cPoURiakE34ZMes/wbB0Roun+2p7h9oLSlwzQqZq2eIr+xe2/Rhp5QF8hHn5Hh/FfM9ibs32UrNG+l22ZbrnJ8N+fERAcD6YCp6nuPc2Aq/vWXiMfzKaye/BDfzTLPwe33MT8ns4P/y0uiLBdyZw3qRvNvGZegjF6H+escXvreOnkD7zm7IkADTbJEkU4sdw1jmwzpTj42smHLB82ijenjfx9YsXkccR+B5+I1azGtQk+4maTpnLlsBL75E7O1IPea+mzfPmUwQt00FJoG+nPxN/zruZzZprTljyx2GpXiHdYWBZtcINeB+2xVP16/GT9euDwf00TbqgK5gK7QvCmfp/wPn15WDa3BcM1l/Hy8F9wZQ31nf4Q2IjjrXyG+BnzXnMmqXiTuB5CLa01gINjvb8mesSTwHuSAEtzm8anp+uvwbdprkfhUs0wCNIxH6TP1l/vf6aPDThK0TXI5I+tjj+SX/8wIcaPxWX4y+CqsCiEIiAIzhsKrgfh+6qv+4L4RETPl6/zqMKukki9AA96OseZb3Zk7UKVKxZKt65tpR1J9p1sTGgP5Z4ah+KEzl73R/xEfr+I8H5fchlN/Jr0n0c3fSGkrz+vbhd5m2ZWltThDeKUaKh3WTZXWauS+WomBdMkjGvOCRuT9YfcIZxk0x24/5cT3q8redxe8TpTsLn03b9LIaFo/I0eQ7uxtjQm6rffI4elnTcJfbwX/qRFyG+Vw+SaJdyFIpugk0WXCcnaZFo1323viNAWHZPvk1+ugfjTf2sbcPR5LDT442bhwPj6Z5z9qi9wr8B85Ji51yXb3tISxlpSUtaZEYnFX8ZbHI6C8vk4ll2h5/YdRQbM0CUbSmXHsd5rH5zWz7fBnc/5iA1NLANwyQZ2+5JjiYfQ4mle+BxJA1prT9g+770dv4zTz9RnTPp+JlY4DJKoroOucmyT4fnsGIeFC3H9EtmB+qnGyP6413tPvs4BhIwipskDKakeIg+KKTgbl92JBkkHn1J3c8t+9ia2vBKhMFkGBJtEjrGDIzKE1SeAgTJiDAVRYpKmSGwMlksJor5gUWgjKlXYS0gurS4neaYflXJnaWBUjDKNAVhkWoF1WhHz7uJ2PapE8NHJkulySPD62/qVmLapMq10a997JqvnphQarc8dO3UQ2smYr38pfOWszK6fTs+eBKfHy4j8t2uWNrWnbDx5CNfe+TkxrHVE/EEW4ynxM9H2FhtpAeE2tnGFUH1J4xXChxD5hACLNXbLgOA3WU353rI37Y44SipbwdxwED/mEC0rOmuIzmlGkw7SBzNxZ6NN3519+zXRhV1Uosp3TdtGD68s4eXJo8uzHVtjyXc85gC9MYmRh+euuaRk+vhAG43Tm3RLGW7Clp52Oesq3N7dKVjnW9KxCdWjyFvi/nUs+Ja5CnPxtn+2t4NnVwLrELw76JqDMz1MacMGJoR0I5RVsA1lR/DLEdonLJLQWnOMcSamKlrszLnWWZ3mzcVOjsrnYWynTfVNmQ6aQFxrWtL9SQtgjqsojbxf5lp+qquSF1rVGyk02qZZEEKRkPdlv9ff3LVQ6MTFMas8xSft3fNVbd+vqg1KaF5w7RwBsirUye24UVXDS3oIcj/nz+56mF6qQlUAQ++gGoNytcxFG7P98DWMXMoHIL/6l/Z7p1riv8ko2oiyiru129WsSrmUjO1XdtWc0Pr7miOoWOV9YUQ07WQPmsCisWYDge5puAUAI3NIk6EQACmaQ+BGRaAwOSemV1TH90+vnlDrZBNFOi/nEUlLL96lYx5VZLqB5zDQLFQzGm6KuUX89L6YqxRuaPsCwXYTlJE1EVJt9ycWTo8bereoW7Wv38ewfOzmgI/N42Kn53LatjTxUCv85zbEyg+Y5hTcDddq99M2ysc8/51lABfjZ++8KvSxvUlnpCj7U+mIG3vR8yhXSbXEbaB3cDmatdds4lrhi9Z8hskNo2hkI+RQHWN6fMIUwKGFZiNhDmCNq6BoR1gejCoTzNdD86woB6cPDh33YFr91w99dHJLePr1tp525NylKZkzJtthLplN+ADzhOxjpiN1trRPwb/vhKfqIcMg8Mr3DDqd38o4cM36y9KWa+Tsn7v4/ocj134Vcg2TZsf/ABFKH4tYwrtObZYYxoF3QiQC+PjATwUho5+W8MkQlOOqUDxnlMNjZpsfB8zjJCxZe2afKeTjXeuboqT2XcOlsACB6XROFhWch7AeNy/VsZfx4fO5Aj8EjTVRPjLdtrmTS1NX7Azce6kmjZnnHf+1iuBiG0duzsmQTiZPzfjEoTGAqZ7xqt/nmmai8gXOWb0/sG9z8vyyPNOZjKDf9DlRgmQR93keVlHOU/9RTkfH8W8ieTQzWpsc21DGRM0Xw4soAUWDEDPtMB0oS9I5qeXC0PhMySPyTWjuYFctn9JEgWLp6FSXdz71TeSgzuQBmnXVHPXGqWhIhXkF+H2lQXxVqiSO5OthN9CQQSazmBOhdycwSgoZRJvQ28Yz8SVltDiwd3PUxMLN9De1dWehinH5783RvA9xhpyoHgnWAfGvE3sqtqOFT25rGIoMB4GBa0NAaepg2KYyiwVijQqFKGtopEeUFFYgQCboj0jZ8cCk7U1Q2W3MBBLjMRi0SCKxO0od6gD6Muon6Q35JGLDZS9DEpfLNZTA4aqrmrD0rwHCAO8Cs/Ur4a3J0Lql9WU4RfBJiYySfg+cviqaczLvipt59LuhbjXflPdSuRLUUd/9VV422jRv6SF/NbehYrcQ1p2AZ6jd80L5+kSRwE3WV+OVGTs9GvnU6yLDbJsrZ2aE+iijskqPtuHgTAktgz0r+xtaUaslZRRH6FKlRJrBwO9bK+lef8YXipg7j8GSJjM+GRPmSApRv6n//T4VrH3qqbRaNxoqoxSNMfwD6MV18yPulftrX+xZ7gXeka7vMCPgf2aQ8+N4bPuaKz7lg2LIGjjTT3x4T4jvubPYKL+cFtPTxscwm0DA+yVNaMjbFNt/cE9k+sUpoxgas8Gu1qjhG7GqUu+oAFel8B2gTDcgt+54If2XXv1VVsmVvRkM4m4TnnrYCGLtt5foc4F2rWO/NrIbxENvBHUy0WJBYqEg8hbyklAxoATvupfHMCZ3wAHaASEAFz/Y7pUPh+ZumWK7z65G1KGftgMJro0NbIzrOvbm1sCuhL9tBGKtrof1aLaZkdRjS4zYhzSDTDVw4bldnrPGtubWgKGiH0adR1JuR9VI/qErSgB72HMk0emp2+anr6F7kfTydZ+zdKSO0EdDRuTqaip3xAIjapaLa1aWqg/kmqNQEiXzza3ZFbqId3euezR4Iiqbkj5j7ZEIeTX7X4n9vLvLmKL2mAXILVUp0WPoyLCVJVGQ+/yNlGhjP8PNLq4y9vNy9rPrn+eW36OaPmdX0nTF7EIpu9XPlvW1XMgOiHbSHIL1ji1nsbpBdbAyXtlTRwjSHuCqyJvkjfAVEiMe317oeLEURlNKa/CI7tfVLxLp5qb4tFwUFVYJ3R6/STHqy1Xi1R9RLvvd6lSPIba14rZoo6zwa3w/7L18OGzRwC+N7B52+HD2zYPfA8OP3iIH9kyjkd4Fdwj9x85skUPzfXhQd9cSN96mB+97yjgoYUXvZ7kxYu/UW7mL7Eo+rwKK9byTKWsSWWz6N8VBaZxB5ShgDJZHerscm0J6L1at2fNGPH4CqQNZ+gAGTeaPZVNBB52IJ7nt/uI3N/B0707Do+8vmEH37rpdTLX8eEDd47Xr564Y3aIj+67azM8Q4dwYHjpHbJoOu1/8OkH++lk4s59Y2Lo+tsevG1ukA/N3uHb9f9TbkFebNRET61I/GEuOEtdCkxKcdfISpPptmSn01kdVNF4Y4NjHF1rWnh0cxWZKImsJdKcKPPIkZR5RIoYkcJ7dh665dDOHqV/4jgc2ILXkYz77zgwypGsH1zKst/L+ir6nJVsPdtR2zaC4aQTZC9CR4p0jigDQ6gmexJcUeeXdbS0xY7WslzDdpPF8uryAPX0L+tqoVNFD5QrFi7rbKGXwYnkJGCpwra4XMZe1th6JZcOCL0VgV445HepqL+l5jVdKMHP1VeH89a/WtYaK2/9Z/g4noyFYduzjf6WpSS0FIKDRovrC4aaQ9ZArQ9b1r/K58P0Yhi/4Msl4WPhFbUuzCTBb1OitsjmCVsAn+Qs3eokTJ1FeEQlI1nGXNlfnbS8tcc/sYz4wU8vsbd+lr/UII5u7mncOYBJ+WKc+5jsETe/L03AXCfmN4IlTVnCOYiVSxyWr5h45up7d/Lpu568c7ey4zRcu6yjzk9P3Xvu3im5qb9yaf98ab2AwZIsy0Zrq6nXxkG22zi121ScGiC71IoiZwcZqlAmzUCmvaU5GgkkzaQfoNCjlKimWnxvGhtR5b4r0roYFX59BZLFsvVB5NMRIVAGQ65bJoBsRuaFbLJM/0n3nZCLlZaWYKj+efWy88WezKv+yiG5dKnN23mX2uUJbi5bY+Rc4XgxBrHXGnlYb637gwLPEuXVBmD1ViiIyzgRfl5f9NddvfoB9NDxw0clWD9KV0FbdhMMjzfc+H7uJXEG8fo6Ns4O1q5fU+KCCq16PhXG3JuJcczFw6GwEaLSBXkQwNwF4DgLs1AgHDqA2FToAXEgCDpj+jTudDaDgUmnGsaG9bWx1UOVctJGzBlDf2HJWgZyh1HHkeV53RK5WC6Gc8fr45AzKSByxwlWHShTsxydSgfVLhALUZsXOiS8w0TlVOdJ006bC4ZayA43j7cN9WCqeCgYDTvGJzKnKG0Jn7ou6KSC18Frs8FUk2Jch1frv65/kWLdMMbf2fWfDKac4HFdaYpb8HY9ZDXZhnEylEgHP7t2L6YMcO46M22b111HA113zoFBDJQUpy/WLx6B36K+MxQdmlHBKerm0BIJKqUu68GgoLY0VSpexdChJiDC1WpC9qwK1cQYpS7U0BW0JAzeMrX6P+hRI2Dy4z/hqqmb4gS3jG8GLT77P1Ue5E4wfOFTFoioAS8NYVYZhv9umJapaPV6hct6wHdkHiowcqVYnvUivt5Qa+3vK/X2dBXy2Uy6pclBE4pR4XkwxWHTtq93vH+tv0l2U6pFvbNRePWrv51uBFbBWmgHbw/upXv+0LnRc1AxL/RjLrVgmvx/yP0Fq1KJxarV2A+PHct2HDvWwbvxJIYX60/THfzHrcdGH7shQm/iC2l6E/fXRumtaPU/ybeyx+p34UkVL0LJv9PAUHOomzL1w8q9uZaYoV3SIOoujHBKKii60eKMxhJHXUMgTQW0InVqqErq22AbYN6BHOMkFCMtlpWLDDc/0NM23tYLZ1uGMX5ZrWfPtkQj+chQ61lZiH+gZSiai0Sbz4JhDbeswXd2PSVr8E/twqtr8KXdu690Q2KpI6jHMMuhBjdRdbG9iQslEae6YVhDV7gBdOiHgK4iKtSERkv4yOpAP8ZMpimmNqtSRuUFG50FDD2AeaYRNrasGS0P2LTwuGDncpRJNtZ5Fpev85SVhMY6T3ewBJrtjAFIs8XZi95eSXOXLJkW75wKaXmE7afkst1TsjBDJxP3v3I//kG6Z9R+ce7WnfcfrvHRo6fPnT46CpteTMJZ7yXKMb2XTlHieMpspgUYLz+k3UsJV/LFTWNH7vvT08eHlfWHHtx+69yLSbZMRhHWhDn2SG0oYCC3qE/B0qAKuZqPg+b5XkErlwWmYkKlMkNY2eLmUAqF3OJinmKjrPIhuK1/W/IJ6z8kh5K1D2aK+/UTWqOzkz1fC4xVOgKKKqgjZqKV9nhTGGOgUGnZjiK4Mq8jJFKOMwJ0UxSLdlO/Ymvrtq8H3/UG+nBNcG0e7Vh79xt/yOf37KklDMPYaeyc3LZ1y8hwT671KoP8BApooL9agOqYUm2FATeRptTcdeQGxexmC3pWyw2u5ZSr4l9xsLCKW+DaaeqxVskXZql+XdTggY9NDrcHk331MoTzqZSj3fGlCe3GxJQT6IsGjeBkQOGQO53v+VKSb9E1EVMQ5vKs2/R7axiimWAmiVCh4/MZ1eYrecvvMWx9oa71KppmNkVhBs6G6m+veHkw8amOFi0QFY4pTI7RrikRxSd1jgBaCeytDEHmYSsUN/HTEEyqQVQ6ppY4937ER/nPmMXaWK6W8TvQy1cj+s28wcIlS70LHqQsSoS5rB18abP70ubwv0VMqrRhJALnb2SJXZ76vg7pAPc9++oF2+s8XzLyZUMt/3ajhy35encPGy4n+lIy4Xvvou1JERMJFmTa8zqHldSwlaBa9k6VC63heDzM/3cYttfndDMiKlbIwCN7eV2F8FS61toUNZhCzHltUoKChwg/yah6WVnr8jIXJer+ultoizj14CWn/GfvvEU5uIjTdtnx8nw86K1TlzWF5QsXBhYXGlw+3rLk/5IB/G8+gzZuYUagPa8ByoUaWfiRIuA35I4CrJOMVariLtOCaKD+Ryq3gvWTwSDci1AAfVtQi7zzsmWE4F5Vq/+RPKDe8714vX5SVSVGuXjxa2K/iCyN42qyOkbLkXwt6FIjmt5sRsHC11VB2yANZQl1HL+GWjFC9Em4Vx7Q2oKTeB2+oKkeL3xEkBU015zWlri4VEBrpICIlwZ7Eso2mgSVKs8GLeJN5YsLnmn7Lh7/45KS6ncSg5I/Por8NcaWi7UW27Te2JeyTGPqPg3VS9j2CzJyeznjn1qaGXCrpsq8ro655n7+1zi3WwkBRkGuRl5e3eMyi6L0TvDJcnYwTnM14fWG5Xyh5nXVLya56BmNJRUi25oYoiGRJBGXdaO+Rb1Y9R861mlZYzodsf21K8/wZ1mC8I75Hr9viTsF+fsW5BzxTSO1IFQNz6DJvnC/lPv9L6Ab4KcvfJU6gC94y9NfMP31s7i5XY5RIn6LJqKRxjAKDuOVppiQA65ycUhaEvVeQya8dVuF6uCYKClVFADVGd5FyGt9RTWAAgg50ahiNFm2YkcCarHv3QTW/6Jna0TY0VA0FEpnMkbciKJ0RGSrrMN/XzzKfy7p3saOsq21cUl7FVQ2Dboqxg8D38S4hnxooL2bGRU1qurqAtP1Q1M7xzd3Sd4MKlx9aN7cxtWq/1OQAi25ohrK0s0ilVHwbgmKVNGWD1T/IMmcmd2u68h5MhPsLpW6Mf7ZEUPfceC+0zfhdXy9uTm5cQffujnZrMQFzmZdv+n0HyDOnl33Z4RjOcFoIL338N50IIpBxBEd9+2+7fV+vGGHQ5Y18NCTDw1EwkITYRu/JwZe9fPMI+IfxFUsyjbSqvKhAcwt168pdedsTBbTzZxTnRzRxQyV/if8uggP8y2VcpqWw7iyTmgJOy3GuEu5oK35P5xC0L6GZFag308hopD9/6r3KyoE7rKG5Tqi3D9z8s6TM/3+7mEeeCxiPDanxdWDjxmRxwKIeebmVFVePajGtTl5VaWLcGDdLdMVpbTvxD0n9pWUyvQtew1RfioQFOU/1vU/Lotg4KmyMEz9nnuM2OINTVu8ETPuuUeXPuNZUcFYEmd9rFRbYSxfVUjLiN9dFerqyvd2yKWFBEEB548Fup3m1PWnBQHUERnjyKYur0O1v1pBfvl30u2Hnj4EwydOw/CBOyd23vd4+YefpuUbvHb84elmO9HXD1P3Tq1f48YM5VZ17msH5/d1fPtmWQndeOwTd1EnZNeXbtwsoBRbcbJ29T3T0GbGDO+3J95aen6KxViWDVCHL8i5wsPAxPLfE1FDb55RmQnmCYgrEoijOyX+6KeDoE66Tt5ONjkSgheKBA9LqL6qpqchU0E7QaSYtJ3+irSVimrrmpLJU3ej0gsK6vTRXbdlEXtnb9u17Z9B+Un9m9Hg5rmoE93YF4zCPwZ31H9b/6f6b3cEgzvAgAIYO4IwfMe64Q03nOX3fXzD8Lo7brzrLtiCz85tCkajwb6N0b9LJD738MOfSxTs2x7mj3yGsEgjzzBYB9Xw2hGCYAZOzYWG2uR6nFlvxlJeEZfO732ziNsX84be4ffMGz7/gRmQb1dyTX8Q/dtArU8Hb8Wybmgod53NBlQOilxbg9mPCIstK3sTAzE7O5BMJuTKkvJgwfulBskXM0CBMymXLQrpkSoDMVmJ6aA2QjGG4SJkRk38g5sd61dtYGoQ4St+jHY+U23r4aVWOEjtseoMnDgvfwCEm2+hp6r/X91AK4zYkU3HMVEaxnR3qBfqPzn+/wHPnsOreJxjYGRgYABi1vIsoXh+m68M3MwvgCIMt5YoxkDp2P9f/2exVDAHAbkcDEwgUQAz1Qu/AHicY2BkYGAO+p/FwMBS9v/r/68sFQxAERQQDACh8QbyeJxdT0sVwzAMy49AkAxAkbT3UQiAITGAISmAYQiA9th4ttUs7Q568UeSlVidiwSkB3PUPg+ESd6ZD/+8v7HyrtzwghY89ZB6BcyrYqc6RZhw48YhaA1Wc/v1PQtdeXJ/HppUmFM597nvBVK7D+Z+E8/uQZLBgDyaz3Llvxx02S3c/Hv813JrznryZP4F+6lSfQAAAAAAAAAAUAC2ATABaAGyAfoCJAKwAzYDmgQSBFwExgUyBbQF/AZOBvwHRAe2B/YISgigCPIJGglCCWQJignACgAKQAp2CroLAAtGC4oL8gxcDPINng5iDuYPag/6EF4RIBGGEeQSShKYEyQTbhOyFAoUYhS+FVoVphYoFooXHBeGGFoYnhjGGOwZChlOGXgZrBneGhwaWhqgGtIbLhvyHHQc2B1QHZ4d/wABAAAAUwBtAAYAAAAAAAIAIAAwAHMAAAB2C3AAAAAAeJx1kN9q2zAUh39q0441YxcbjN3tXJWWEcc1lEGvWkLbXZeSu8JUV/6T2VKQlY48w95ifYa9zt6jd/vFESUUYiP5O5/O8ZEE4AP+QWH9nHKsWeEdozXv4A0uIu/Sf488IN9G3sMQPyLv0/+MfICv+BV5iI/4wz+owVtGM/yNrPBZfYm8g/fqW+Rd+svIA/Jd5D18UovI+/S/Ix9gqp4iD3GoniduvvR1WQU5mhxLlmap3C/FUdVWN6IXoXK+k3MpnA2maVySuza0ZlToUZ07292YctFov6k2eWp8VzsrJ0m6qa+NNV4H87Dq1j2WWQiFFN61chX7yNy7mclDUoUwPxuPN/tjAoc5lvCoUaJCgOCI9pjfDGk/BPfMEGaus2pYaDQ0GgtWVP1Kx/ico2BkaQ0zGnKCnHNL09KNuK451721rLqhLfmfht5vzdrmp7Sr3nUfC07YL92afU1r+wrd7/Dh5WwdHrmLjDawanUK3+9acPXqPML7Wq3NaHL6pL+1QHuGMd8t5/8PvPGO3QAAAHicbZLnlpswEIV9DRiwvZtseu89Ib333vvmBWRZYMVC0pHEEufpg8BO/kTncOfTaLgMOtPr97o17P1/baKPACEiDBAjQYohRhhjDevYhu3YwA7sxC7sxh7sxT7sxwEcxCEcxhEcxTEcxwmcxCmcxhmcxTmcxwVcxCVkuIwruIpruI4buIlbuI07uIt7uI8HeIhHeIwneIpneI4XeIlXeI03eIt3eI8P+IhP+Iwv+Ipv+I5N/OiF1hEz9JKxUrtFrDl1lWF9NR9QIikToRaVjUouKxvOmNBjLxnlhgo2DbnM1djLKrNGnGPScSUzItzGv93yPP2bSQSX84z9cqFQdJ56yZRmMhW8mLlJJSaBI0XYPDaZKDUviZmvr6DrNjJMi0WcK1MTM02mqpbZlJtEsNx5SI238jSodJtoS7qv+BpPw67IY9xU+dg5TXjROTWwdGrIOzWhT+uA0jolxqjaZrSOnCF2Nmq16651EYpMm1fakAul9SJQeR5QVYQlk1VkZ8SwoVNFIVjWnKQrlBGdMToftdoZjrs77DajqXKrS02YEFxbbtdWkG0x44JJVUS5aBqKSlJwmhDrmOF2Hv9Wqsy4TNqoKhfmSrrQKuNSL5nvPG6p0s0AkEWkSWVZMy1Kx3ljk03qLuZ14lTmB8gNGmByGrGfjLrhlhJV2f7SaIneNF1ypQNbybBUSgZswQaWEUNngeay1/sD4l/60HicY/DewXAiKGIjI2Nf5AbGnRwMHAzJBRsZWJ02MTAyaIEYm7mYGDkgLD4GMIvNaRfTAaA0J5DN7rSLwQHCZmZw2ajC2BEYscGhI2Ijc4rLRjUQbxdHAwMji0NHckgESEkkEGzmYWLk0drB+L91A0vvRiYGFwAMdiP0AAA=') format('woff')}</style>
<style id="style-core" type="text/css">html{font:16px/1 Helmet,Freesans,sans-serif}#store-area,tw-storydata{display:none!important;z-index:0}.no-transition{-webkit-transition:none!important;-o-transition:none!important;transition:none!important}:-webkit-full-screen{height:100%;width:100%}:-ms-fullscreen{height:100%;width:100%}:fullscreen{height:100%;width:100%}body::-ms-backdrop{background:0 0}:focus{outline:thin dotted}:disabled{cursor:not-allowed!important}body{color:#eee;background-color:#111;overflow:auto}a{cursor:pointer;color:#68d;text-decoration:none;-webkit-transition-duration:.2s;-o-transition-duration:.2s;transition-duration:.2s}a:hover{color:#8af;text-decoration:underline}a.link-broken{color:#c22}a.link-broken:hover{color:#e44}a[disabled],span.link-disabled{color:#aaa;cursor:not-allowed!important;text-decoration:none}area{cursor:pointer}button{cursor:pointer;color:#eee;background-color:#35a;border:1px solid #57c;line-height:normal;padding:.4em;-webkit-transition-duration:.2s;-o-transition-duration:.2s;transition-duration:.2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}button:hover{background-color:#57c;border-color:#79e}button:disabled{background-color:#444;border:1px solid #666}input,select,textarea{color:#eee;background-color:transparent;border:1px solid #444;padding:.4em}select{padding:.34em .4em}input[type=text]{min-width:18em}textarea{min-width:30em;resize:vertical}input[type=checkbox],input[type=file],input[type=radio],select{cursor:pointer}input[type=range]{-webkit-appearance:none;min-height:1.2em}input[type=range]:focus{outline:0}input[type=range]::-webkit-slider-runnable-track{background:#222;border:1px solid #444;border-radius:0;cursor:pointer;height:10px;width:100%}input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;background:#35a;border:1px solid #57c;border-radius:0;cursor:pointer;height:18px;margin-top:-5px;width:33px}input[type=range]:focus::-webkit-slider-runnable-track{background:#222}input[type=range]::-moz-range-track{background:#222;border:1px solid #444;border-radius:0;cursor:pointer;height:10px;width:100%}input[type=range]::-moz-range-thumb{background:#35a;border:1px solid #57c;border-radius:0;cursor:pointer;height:18px;width:33px}input[type=range]::-ms-track{background:0 0;border-color:transparent;color:transparent;cursor:pointer;height:10px;width:calc(100% - 1px)}input[type=range]::-ms-fill-lower{background:#222;border:1px solid #444;border-radius:0}input[type=range]::-ms-fill-upper{background:#222;border:1px solid #444;border-radius:0}input[type=range]::-ms-thumb{background:#35a;border:1px solid #57c;border-radius:0;cursor:pointer;height:16px;width:33px}input:not(:disabled):focus,input:not(:disabled):hover,select:not(:disabled):focus,select:not(:disabled):hover,textarea:not(:disabled):focus,textarea:not(:disabled):hover{background-color:#333;border-color:#eee}hr{display:block;height:1px;border:none;border-top:1px solid #eee;margin:1em 0;padding:0}audio,canvas,progress,video{max-width:100%;vertical-align:middle}.error-view{background-color:#511;border-left:.5em solid #c22;display:inline-block;margin:.1em;max-width:100%;padding:0 .25em;position:relative}.error-view>.error-toggle{background-color:transparent;border:none;line-height:inherit;left:0;padding:0;position:absolute;top:0;width:1.75em}.error-view>.error{display:inline-block;margin-left:.25em}.error-view>.error-toggle+.error{margin-left:1.5em}.error-view>.error-source[hidden]{display:none}.error-view>.error-source:not([hidden]){background-color:rgba(0,0,0,.2);display:block;margin:0 0 .25em;overflow-x:auto;padding:.25em}.highlight,.marked{color:#ff0;font-weight:700;font-style:italic}.nobr{white-space:nowrap}.error-view>.error-toggle:before,.error-view>.error:before,[data-icon-after]:after,[data-icon-before]:before,[data-icon]:before,a.link-external:after{font-family:tme-fa-icons!important;font-style:normal;font-weight:900;font-variant:normal;line-height:1;speak:never;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}[data-icon]:before{content:attr(data-icon)}[data-icon-before]:before{content:attr(data-icon-before) "\00a0\00a0"}[data-icon-after]:after{content:"\00a0\00a0" attr(data-icon-after)}.error-view>.error-toggle:before{content:"\e81a"}.error-view>.error-toggle.enabled:before{content:"\e818"}.error-view>.error:before{content:"\e80d\00a0\00a0"}a.link-external:after{content:"\00a0\e80e"}</style>
<style id="style-core-display" type="text/css">#story{z-index:10;margin:2.5em}@media screen and (max-width:1136px){#story{margin-right:1.5em}}#passages{max-width:54em;margin:0 auto}</style>
<style id="style-core-passage" type="text/css">.passage{line-height:1.75;text-align:left;-webkit-transition:opacity .4s ease-in;-o-transition:opacity .4s ease-in;transition:opacity .4s ease-in}.passage-in{opacity:0}.passage ol,.passage ul{margin-left:.5em;padding-left:1.5em}.passage table{margin:1em 0;border-collapse:collapse;font-size:100%}.passage caption,.passage td,.passage th,.passage tr{padding:3px}@media (prefers-reduced-motion:reduce){.passage{-webkit-transition:opacity 0s;-o-transition:opacity 0s;transition:opacity 0s}}</style>
<style id="style-core-macro" type="text/css">@-webkit-keyframes cursor-blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@-o-keyframes cursor-blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@keyframes cursor-blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}.macro-append-insert,.macro-linkappend-insert,.macro-linkprepend-insert,.macro-linkreplace-insert,.macro-prepend-insert,.macro-repeat-insert,.macro-replace-insert,.macro-timed-insert{-webkit-transition:opacity .4s ease-in;-o-transition:opacity .4s ease-in;transition:opacity .4s ease-in}.macro-append-in,.macro-linkappend-in,.macro-linkprepend-in,.macro-linkreplace-in,.macro-prepend-in,.macro-repeat-in,.macro-replace-in,.macro-timed-in{opacity:0}.macro-type-cursor:after{-webkit-animation:cursor-blink 1s infinite;-o-animation:cursor-blink 1s infinite;animation:cursor-blink 1s infinite;content:"\2590";opacity:1}</style>
<style id="style-ui-dialog" type="text/css">html[data-dialog] body{overflow:hidden}#ui-overlay.open{visibility:visible;-webkit-transition:opacity .2s ease-in;-o-transition:opacity .2s ease-in;transition:opacity .2s ease-in}#ui-overlay:not(.open){-webkit-transition:visibility .2s step-end,opacity .2s ease-in;-o-transition:visibility .2s step-end,opacity .2s ease-in;transition:visibility .2s step-end,opacity .2s ease-in}#ui-overlay{visibility:hidden;opacity:0;z-index:100000;position:fixed;top:-50%;left:-50%;height:200%;width:200%}#ui-dialog.open{display:block;-webkit-transition:opacity .2s ease-in;-o-transition:opacity .2s ease-in;transition:opacity .2s ease-in}#ui-dialog{display:none;opacity:0;z-index:100100;position:fixed;top:50px;margin:0;padding:0}#ui-dialog>*{-webkit-box-sizing:border-box;box-sizing:border-box}#ui-dialog-titlebar{position:relative}#ui-dialog-close{display:block;position:absolute;right:0;top:0;white-space:nowrap}#ui-dialog-body{overflow:auto;min-width:280px;height:92%;height:calc(100% - 2.1em)}@media (prefers-reduced-motion:reduce){#ui-overlay.open{-webkit-transition:opacity 0s;-o-transition:opacity 0s;transition:opacity 0s}#ui-overlay:not(.open){-webkit-transition:opacity 0s;-o-transition:opacity 0s;transition:opacity 0s}#ui-dialog.open{-webkit-transition:opacity 0s;-o-transition:opacity 0s;transition:opacity 0s}}#ui-overlay{background-color:#000}#ui-overlay.open{opacity:.8}#ui-dialog{max-width:66em}#ui-dialog.open{opacity:1}#ui-dialog-titlebar{background-color:#444;min-height:24px}#ui-dialog-title{margin:0;padding:.2em 3.5em .2em .5em;font-size:1.5em;text-align:center;text-transform:uppercase}#ui-dialog-close{cursor:pointer;font-size:120%;margin:0;padding:0;width:3.6em;height:92%;background-color:transparent;border:1px solid transparent;-webkit-transition-duration:.2s;-o-transition-duration:.2s;transition-duration:.2s}#ui-dialog-close:hover{background-color:#b44;border-color:#d66}#ui-dialog-body{background-color:#111;border:1px solid #444;text-align:left;line-height:1.5;padding:1em}#ui-dialog-body>:first-child{margin-top:0}#ui-dialog-body hr{background-color:#444}#ui-dialog-body ul.buttons{margin:0;padding:0;list-style:none}#ui-dialog-body ul.buttons li{display:inline-block;margin:0;padding:.4em .4em 0 0}#ui-dialog-body ul.buttons>li+li>button{margin-left:1em}#ui-dialog-close{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#ui-dialog-close{font-family:tme-fa-icons!important;font-style:normal;font-weight:900;font-variant:normal;line-height:1;speak:never;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}</style>
<style id="style-ui" type="text/css">#ui-dialog-body.settings [id|=setting-body]>div:first-child{display:table;width:100%}#ui-dialog-body.settings [id|=setting-label]{display:table-cell;padding:.4em 2em .4em 0}#ui-dialog-body.settings [id|=setting-label]+div{display:table-cell;min-width:8em;text-align:right;vertical-align:middle;white-space:nowrap}#ui-dialog-body.list{padding:0}#ui-dialog-body.list ul{margin:0;padding:0;list-style:none;border:1px solid transparent}#ui-dialog-body.list li{margin:0}#ui-dialog-body.list li:not(:first-child){border-top:1px solid #444}#ui-dialog-body.list li a{display:block;padding:.25em .75em;border:1px solid transparent;color:#eee;text-decoration:none}#ui-dialog-body.list li a:hover{background-color:#333;border-color:#eee}#ui-dialog-body.saves{padding:0 0 1px}#ui-dialog-body.saves>:not(:first-child){border-top:1px solid #444}#ui-dialog-body.saves table{border-spacing:0;width:100%}#ui-dialog-body.saves tr:not(:first-child){border-top:1px solid #444}#ui-dialog-body.saves td{padding:.33em .33em}#ui-dialog-body.saves td:first-child{min-width:1.5em;text-align:center}#ui-dialog-body.saves td:nth-child(3){line-height:1.2}#ui-dialog-body.saves td:last-child{text-align:right}#ui-dialog-body.saves .empty{color:#999;speak:none;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#ui-dialog-body.saves .datestamp{font-size:75%;margin-left:1em}#ui-dialog-body.saves ul.buttons li{padding:.4em}#ui-dialog-body.saves ul.buttons>li+li>button{margin-left:.2em}#ui-dialog-body.saves ul.buttons li:last-child{float:right}#ui-dialog-body.settings div[id|=header-body]{margin:1em 0}#ui-dialog-body.settings div[id|=header-body]:first-child{margin-top:0}#ui-dialog-body.settings div[id|=header-body]:not(:first-child){border-top:1px solid #444;padding-top:1em}#ui-dialog-body.settings div[id|=header-body]>*{margin:0}#ui-dialog-body.settings h2[id|=header-heading]{font-size:1.375em}#ui-dialog-body.settings p[id|=header-desc],#ui-dialog-body.settings p[id|=setting-desc]{font-size:87.5%;margin:0 0 0 .5em}#ui-dialog-body.settings div[id|=setting-body]+div[id|=setting-body]{margin:1em 0}#ui-dialog-body.settings [id|=setting-control]{white-space:nowrap}#ui-dialog-body.settings button[id|=setting-control]{color:#eee;background-color:transparent;border:1px solid #444;padding:.4em}#ui-dialog-body.settings button[id|=setting-control]:hover{background-color:#333;border-color:#eee}#ui-dialog-body.settings button[id|=setting-control].enabled{background-color:#282;border-color:#4a4}#ui-dialog-body.settings button[id|=setting-control].enabled:hover{background-color:#4a4;border-color:#6c6}#ui-dialog-body.settings input[type=range][id|=setting-control]{max-width:35vw}#ui-dialog-body.list a,#ui-dialog-body.settings span[id|=setting-input]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#ui-dialog-body.saves button[id=saves-clear]:before,#ui-dialog-body.saves button[id=saves-export]:before,#ui-dialog-body.saves button[id=saves-import]:before,#ui-dialog-body.settings button[id|=setting-control].enabled:after,#ui-dialog-body.settings button[id|=setting-control]:after{font-family:tme-fa-icons!important;font-style:normal;font-weight:900;font-variant:normal;line-height:1;speak:never;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}#ui-dialog-body.saves button[id=saves-export]:before{content:"\e829\00a0"}#ui-dialog-body.saves button[id=saves-import]:before{content:"\e82a\00a0"}#ui-dialog-body.saves button[id=saves-clear]:before{content:"\e827\00a0"}#ui-dialog-body.settings button[id|=setting-control]:after{content:"\00a0\00a0\e830"}#ui-dialog-body.settings button[id|=setting-control].enabled:after{content:"\00a0\00a0\e831"}</style>
<style id="style-ui-bar" type="text/css">#story{margin-left:20em;-webkit-transition:margin-left .2s ease-in;-o-transition:margin-left .2s ease-in;transition:margin-left .2s ease-in}#ui-bar.stowed~#story{margin-left:4.5em}@media screen and (max-width:1136px){#story{margin-left:19em}#ui-bar.stowed~#story{margin-left:3.5em}}@media screen and (max-width:768px){#story{margin-left:3.5em}}#ui-bar{position:fixed;z-index:50;top:0;left:0;width:17.5em;height:100%;margin:0;padding:0;-webkit-transition:left .2s ease-in;-o-transition:left .2s ease-in;transition:left .2s ease-in}#ui-bar.stowed{left:-15.5em}#ui-bar-tray{position:absolute;top:.2em;left:0;right:0}#ui-bar-body{height:90%;height:calc(100% - 2.5em);margin:2.5em 0;padding:0 1.5em}#ui-bar.stowed #ui-bar-body,#ui-bar.stowed #ui-bar-history{visibility:hidden;-webkit-transition:visibility .2s step-end;-o-transition:visibility .2s step-end;transition:visibility .2s step-end}@media (prefers-reduced-motion:reduce){#story{-webkit-transition:margin-left 0s;-o-transition:margin-left 0s;transition:margin-left 0s}#ui-bar{-webkit-transition:left 0s;-o-transition:left 0s;transition:left 0s}}#ui-bar{background-color:#222;border-right:1px solid #444;text-align:center}#ui-bar a{text-decoration:none}#ui-bar hr{border-color:#444}#ui-bar-history [id|=history],#ui-bar-toggle{font-size:1.2em;line-height:inherit;color:#eee;background-color:transparent;border:1px solid #444}#ui-bar-toggle{display:block;position:absolute;top:0;right:0;border-right:none;padding:.3em .45em .25em}#ui-bar.stowed #ui-bar-toggle{padding:.3em .35em .25em .55em}#ui-bar-toggle:hover{background-color:#444;border-color:#eee}#ui-bar-history{margin:0 auto}#ui-bar-history [id|=history]{padding:.2em .45em .35em}#ui-bar-history #history-jumpto{padding:.2em .665em .35em}#ui-bar-history [id|=history]:not(:first-child){margin-left:1.2em}#ui-bar-history [id|=history]:hover{background-color:#444;border-color:#eee}#ui-bar-history [id|=history]:disabled{color:#444;background-color:transparent;border-color:#444}#ui-bar-body{line-height:1.5;overflow:auto}#ui-bar-body>:not(:first-child){margin-top:2em}#story-title{margin:0;font-size:162.5%}#story-author{margin-top:2em;font-weight:700}#menu ul{margin:1em 0 0;padding:0;list-style:none;border:1px solid #444}#menu ul:empty{display:none}#menu li{margin:0}#menu li:not(:first-child){border-top:1px solid #444}#menu li a{display:block;padding:.25em .75em;border:1px solid transparent;color:#eee;text-transform:uppercase}#menu li a:hover{background-color:#444;border-color:#eee}#menu a,#ui-bar-history [id|=history],#ui-bar-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#menu-core li[id|=menu-item] a:before,#ui-bar-history [id|=history],#ui-bar-toggle:before{font-family:tme-fa-icons!important;font-style:normal;font-weight:900;font-variant:normal;line-height:1;speak:never;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}#ui-bar-toggle:before{content:"\e81d"}#ui-bar.stowed #ui-bar-toggle:before{content:"\e81e"}#menu-item-saves a:before{content:"\e82b\00a0"}#menu-item-settings a:before{content:"\e82d\00a0"}#menu-item-restart a:before{content:"\e82c\00a0"}#menu-item-share a:before{content:"\e82f\00a0"}</style>
<style id="style-ui-debug" type="text/css">#debug-bar{background-color:#222;border-left:1px solid #444;border-top:1px solid #444;bottom:0;margin:0;max-height:75%;padding:.5em;position:fixed;right:0;z-index:99900}#debug-bar>div:not([id])+div{margin-top:.5em}#debug-bar>div>label{margin-right:.5em}#debug-bar>div>input[type=text]{min-width:0;width:8em}#debug-bar>div>select{width:15em}#debug-bar-toggle{color:#eee;background-color:#222;border:1px solid #444;height:101%;height:calc(100% + 1px);left:-2em;left:calc(-2em - 1px);position:absolute;top:-1px;width:2em}#debug-bar-toggle:hover{background-color:#333;border-color:#eee}#debug-bar-hint{bottom:.175em;font-size:4.5em;opacity:.33;pointer-events:none;position:fixed;right:.6em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}#debug-bar-watch{background-color:#222;border-left:1px solid #444;border-top:1px solid #444;bottom:102%;bottom:calc(100% + 1px);font-size:.9em;left:-1px;max-height:650%;max-height:65vh;position:absolute;overflow-x:hidden;overflow-y:scroll;right:0;z-index:99800}#debug-bar-watch[hidden]{display:none}#debug-bar-watch div{color:#999;font-style:italic;margin:1em auto;text-align:center}#debug-bar-watch table{width:100%}#debug-bar-watch tr:nth-child(2n){background-color:rgba(127,127,127,.15)}#debug-bar-watch td{padding:.2em 0}#debug-bar-watch td:first-child+td{padding:.2em .3em .2em .1em}#debug-bar-watch .watch-delete{background-color:transparent;border:none;color:#c00}#debug-bar-watch-all,#debug-bar-watch-none{margin-left:.5em}#debug-bar-views-toggle,#debug-bar-watch-toggle{color:#eee;background-color:transparent;border:1px solid #444;margin-right:1em;padding:.4em}#debug-bar-views-toggle:hover,#debug-bar-watch-toggle:hover{background-color:#333;border-color:#eee}#debug-bar-watch:not([hidden])~div #debug-bar-watch-toggle,html[data-debug-view] #debug-bar-views-toggle{background-color:#282;border-color:#4a4}#debug-bar-watch:not([hidden])~div #debug-bar-watch-toggle:hover,html[data-debug-view] #debug-bar-views-toggle:hover{background-color:#4a4;border-color:#6c6}#debug-bar-hint:after,#debug-bar-toggle:before,#debug-bar-views-toggle:after,#debug-bar-watch .watch-delete:before,#debug-bar-watch-add:before,#debug-bar-watch-all:before,#debug-bar-watch-none:before,#debug-bar-watch-toggle:after{font-family:tme-fa-icons!important;font-style:normal;font-weight:900;font-variant:normal;line-height:1;speak:never;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}#debug-bar-toggle:before{content:"\e838"}#debug-bar-hint:after{content:"\e838\202f\e822"}#debug-bar-watch .watch-delete:before{content:"\e804"}#debug-bar-watch-add:before{content:"\e805"}#debug-bar-watch-all:before{content:"\e83a"}#debug-bar-watch-none:before{content:"\e827"}#debug-bar-views-toggle:after,#debug-bar-watch-toggle:after{content:"\00a0\00a0\e830"}#debug-bar-watch:not([hidden])~div #debug-bar-watch-toggle:after,html[data-debug-view] #debug-bar-views-toggle:after{content:"\00a0\00a0\e831"}html[data-debug-view] .debug{padding:.25em;background-color:#234}html[data-debug-view] .debug[title]{cursor:help}html[data-debug-view] .debug.block{display:inline-block;vertical-align:middle}html[data-debug-view] .debug.invalid{text-decoration:line-through}html[data-debug-view] .debug.hidden,html[data-debug-view] .debug.hidden .debug{background-color:#555}html:not([data-debug-view]) .debug.hidden{display:none}html[data-debug-view] .debug[data-name][data-type].nonvoid:after,html[data-debug-view] .debug[data-name][data-type]:before{background-color:rgba(0,0,0,.25);font-family:monospace,monospace;white-space:pre}html[data-debug-view] .debug[data-name][data-type]:before{content:attr(data-name)}html[data-debug-view] .debug[data-name][data-type|=macro]:before{content:"<<" attr(data-name) ">>"}html[data-debug-view] .debug[data-name][data-type|=macro].nonvoid:after{content:"<</" attr(data-name) ">>"}html[data-debug-view] .debug[data-name][data-type|=html]:before{content:"<" attr(data-name) ">"}html[data-debug-view] .debug[data-name][data-type|=html].nonvoid:after{content:"</" attr(data-name) ">"}html[data-debug-view] .debug[data-name][data-type]:not(:empty):before{margin-right:.25em}html[data-debug-view] .debug[data-name][data-type].nonvoid:not(:empty):after{margin-left:.25em}html[data-debug-view] .debug[data-name][data-type|=special],html[data-debug-view] .debug[data-name][data-type|=special]:before{display:block}</style>
</head>
<body>
	<div id="init-screen">
		<div id="init-no-js"><noscript>JavaScript must be enabled to play.</noscript></div>
		<div id="init-lacking"><p>Browser lacks capabilities required to play.</p><p>Upgrade or switch to another browser.</p></div>
		<div id="init-loading"><div>Loading&hellip;</div></div>
	</div>
	<!-- UUID://3F877547-9365-4513-BC93-4ADDE347D58F// --><tw-storydata name="Another RPG Engine" startnode="185" creator="Tweego" creator-version="2.1.1+81d1d71" ifid="3F877547-9365-4513-BC93-4ADDE347D58F" zoom="1" format="SugarCube" format-version="2.36.1" options="" hidden><style role="stylesheet" id="twine-user-stylesheet" type="text/twine-css">/* twine-user-stylesheet #1: "0main.css" */
html.dyslexic {
	font-family: 'OpenDyslexic';
}

.monospace {
	font-family: monospace;
}

html.dyslexic .monospace {
	font-family: 'OpenDyslexicMono';
	font-size: 10pt;
}

html.greenLinks a {
	color: #090;
}

html.greenLinks a:hover {
	color: #00e600;
}

html.redLinks a {
	color: #c00;
}

html.redLinks a:hover {
	color: #ff3333;
}

#passages {
	border: 0;
	margin: 0;
}

.passage {
	width: auto;

	margin-top: 2em;
	margin-bottom: 2em;

	margin-left: auto;
	margin-right: auto;
}

.passage.battle {
  width: 1030px;
}

#content {
	float: left;
	width: 640px;
	min-height: 85vh;
  border: dotted 1px;
  padding: 1em;
	position: relative;
}

#status {
	position: fixed;
	display: inline-block;
	top: 40px;
	left: 1020px;
	width: 250px;
    min-height: 300px;
	padding-left: 1em;
	padding-right: 1em;
	border-left: 1px solid;
    font-weight: bold;
}


/* Use this #status definition if you do not want the status pane to scroll with the viewport */
#status.static {
	float: right;
	width: 300px;
    min-height: 300px;
	padding: 1em;
	border-left: 1px solid;
    font-weight: bold;
}


#mutebutton {
	padding-top: 6px;
	padding-right: 2px;
	padding-left: 2px;
	background-color: silver;
	border-radius: 4px;
}

.relative {
	position: relative;
}

.relative > .centered {
	position: absolute;
	top: 50%;
	transform: translateY(-50%);
	width: 100%;
	text-align: center;
}

.flex-center {
	display: flex !important;
	align-items: center;
	justify-content: center;
	/* requires a set height value */
}
/* twine-user-stylesheet #2: "actions.css" */
#actFlavor {
  border: solid;
  border-radius: 16px;
  padding: 1em;
  order: 1;
}

#useText {
  text-align: center;
  font-weight: bold;
}

#actEffect, .actEffect {
  color: gray;
  font-style: italic;
  border: solid;
  border-radius: 16px;
  padding: 1em;
  order: 3;
}

.interruption {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em;
}

#actionList {
	overflow-y: auto;
	padding-right: 1em;
	max-height: 350px;
}

#actionList.compressed {
	display: grid;
	grid-template-columns: repeat(2,1fr);
	column-gap: 2em;
	max-height: 250px;
}

#actionBox {
	visibility: hidden;
	position: absolute;
	border: solid 1px;
	min-height: 100px;
	width: 500px;
	padding: 16px;
	font-weight: normal;
	max-height: 90vh;
	overflow: hidden;
	background-color: white;
	color: black;
  z-index: 100;
  -webkit-box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
  -moz-box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
  box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
}

.mockBox {
  position: relative;
	border: solid 1px;
	min-height: 100px;
	width: 500px;
	padding: 16px;
	font-weight: normal;
	max-height: 90vh;
	overflow: hidden;
	background-color: white;
	color: black;
  z-index: 100;
  -webkit-box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
  -moz-box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
  box-shadow: rgba(0,0,0,0.2) 0px 1px 3px;
}

.actionDisplay {
	margin-bottom: 1.5em;
}

.compressed .actionDisplay {
	margin-bottom: 0.5em;
}

.action-name, .item-name {
  font-weight: bold;
  font-size: 125%;
}

.action-tags {
  position: absolute;
  left:15px;
  top:1px;
  font-size:12px;
  max-height:2em;
  overflow: hidden;
}

.action-tags span {
  border: 1px solid;
  border-radius: 2px;
  padding-left: 5px;
  padding-right: 5px;
  margin-right: 5px;
}

.crisis-tag {
  color: red;
  font-weight: bold;
}

.action-cost {
  display:inline-block;
  float:right;
  margin-left: 0.5em;
  font-size: 125%;
}

.action-cost img {
  position: relative;
  top: 3px;
  height: 22px;
  width: 22px;
}

.action-info {

}

.action-desc {
  color: gray;
  font-style: italic;
  font-size: 12px;
}

.action-uses {
	font-size: 12px;
	margin-left: 1em;
}

.action-cooldown {
  color: gray;
  font-weight: bold;
}

.preview {
  color: gray;
  font-style: italic;
}

.action-lock {
  color: gray;
  font-style: italic;
}

.default-link {
  font-size: 9pt;
}

.actionBoxHelp {
  text-align: center;
  line-height: 90px;
  color: gray;
}
/* twine-user-stylesheet #3: "animate.css" */
@charset "UTF-8";/*!
 * animate.css - https://animate.style/
 * Version - 4.1.1
 * Licensed under the MIT license - http://opensource.org/licenses/MIT
 *
 * Copyright (c) 2020 Animate.css
 */
:root {
  --animate-duration: 1s;
  --animate-delay: 1s;
  --animate-repeat: 1;
}
.animate__animated {
  -webkit-animation-duration: 1s;
  animation-duration: 1s;
  -webkit-animation-duration: var(--animate-duration);
  animation-duration: var(--animate-duration);
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
}
.animate__animated.animate__infinite {
  -webkit-animation-iteration-count: infinite;
  animation-iteration-count: infinite;
}
.animate__animated.animate__repeat-1 {
  -webkit-animation-iteration-count: 1;
  animation-iteration-count: 1;
  -webkit-animation-iteration-count: var(--animate-repeat);
  animation-iteration-count: var(--animate-repeat);
}
.animate__animated.animate__repeat-2 {
  -webkit-animation-iteration-count: calc(1 * 2);
  animation-iteration-count: calc(1 * 2);
  -webkit-animation-iteration-count: calc(var(--animate-repeat) * 2);
  animation-iteration-count: calc(var(--animate-repeat) * 2);
}
.animate__animated.animate__repeat-3 {
  -webkit-animation-iteration-count: calc(1 * 3);
  animation-iteration-count: calc(1 * 3);
  -webkit-animation-iteration-count: calc(var(--animate-repeat) * 3);
  animation-iteration-count: calc(var(--animate-repeat) * 3);
}
.animate__animated.animate__delay-1s {
  -webkit-animation-delay: 1s;
  animation-delay: 1s;
  -webkit-animation-delay: var(--animate-delay);
  animation-delay: var(--animate-delay);
}
.animate__animated.animate__delay-2s {
  -webkit-animation-delay: calc(1s * 2);
  animation-delay: calc(1s * 2);
  -webkit-animation-delay: calc(var(--animate-delay) * 2);
  animation-delay: calc(var(--animate-delay) * 2);
}
.animate__animated.animate__delay-3s {
  -webkit-animation-delay: calc(1s * 3);
  animation-delay: calc(1s * 3);
  -webkit-animation-delay: calc(var(--animate-delay) * 3);
  animation-delay: calc(var(--animate-delay) * 3);
}
.animate__animated.animate__delay-4s {
  -webkit-animation-delay: calc(1s * 4);
  animation-delay: calc(1s * 4);
  -webkit-animation-delay: calc(var(--animate-delay) * 4);
  animation-delay: calc(var(--animate-delay) * 4);
}
.animate__animated.animate__delay-5s {
  -webkit-animation-delay: calc(1s * 5);
  animation-delay: calc(1s * 5);
  -webkit-animation-delay: calc(var(--animate-delay) * 5);
  animation-delay: calc(var(--animate-delay) * 5);
}
.animate__animated.animate__faster {
  -webkit-animation-duration: calc(1s / 2);
  animation-duration: calc(1s / 2);
  -webkit-animation-duration: calc(var(--animate-duration) / 2);
  animation-duration: calc(var(--animate-duration) / 2);
}
.animate__animated.animate__fast {
  -webkit-animation-duration: calc(1s * 0.8);
  animation-duration: calc(1s * 0.8);
  -webkit-animation-duration: calc(var(--animate-duration) * 0.8);
  animation-duration: calc(var(--animate-duration) * 0.8);
}
.animate__animated.animate__slow {
  -webkit-animation-duration: calc(1s * 2);
  animation-duration: calc(1s * 2);
  -webkit-animation-duration: calc(var(--animate-duration) * 2);
  animation-duration: calc(var(--animate-duration) * 2);
}
.animate__animated.animate__slower {
  -webkit-animation-duration: calc(1s * 3);
  animation-duration: calc(1s * 3);
  -webkit-animation-duration: calc(var(--animate-duration) * 3);
  animation-duration: calc(var(--animate-duration) * 3);
}
@media print, (prefers-reduced-motion: reduce) {
  .animate__animated {
    -webkit-animation-duration: 1ms !important;
    animation-duration: 1ms !important;
    -webkit-transition-duration: 1ms !important;
    transition-duration: 1ms !important;
    -webkit-animation-iteration-count: 1 !important;
    animation-iteration-count: 1 !important;
  }

  .animate__animated[class*='Out'] {
    opacity: 0;
  }
}
/* Attention seekers  */
@-webkit-keyframes bounce {
  from,
  20%,
  53%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  40%,
  43% {
    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    -webkit-transform: translate3d(0, -30px, 0) scaleY(1.1);
    transform: translate3d(0, -30px, 0) scaleY(1.1);
  }

  70% {
    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    -webkit-transform: translate3d(0, -15px, 0) scaleY(1.05);
    transform: translate3d(0, -15px, 0) scaleY(1.05);
  }

  80% {
    -webkit-transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    -webkit-transform: translate3d(0, 0, 0) scaleY(0.95);
    transform: translate3d(0, 0, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, -4px, 0) scaleY(1.02);
    transform: translate3d(0, -4px, 0) scaleY(1.02);
  }
}
@keyframes bounce {
  from,
  20%,
  53%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  40%,
  43% {
    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    -webkit-transform: translate3d(0, -30px, 0) scaleY(1.1);
    transform: translate3d(0, -30px, 0) scaleY(1.1);
  }

  70% {
    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
    -webkit-transform: translate3d(0, -15px, 0) scaleY(1.05);
    transform: translate3d(0, -15px, 0) scaleY(1.05);
  }

  80% {
    -webkit-transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    -webkit-transform: translate3d(0, 0, 0) scaleY(0.95);
    transform: translate3d(0, 0, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, -4px, 0) scaleY(1.02);
    transform: translate3d(0, -4px, 0) scaleY(1.02);
  }
}
.animate__bounce {
  -webkit-animation-name: bounce;
  animation-name: bounce;
  -webkit-transform-origin: center bottom;
  transform-origin: center bottom;
}
@-webkit-keyframes flash {
  from,
  50%,
  to {
    opacity: 1;
  }

  25%,
  75% {
    opacity: 0;
  }
}
@keyframes flash {
  from,
  50%,
  to {
    opacity: 1;
  }

  25%,
  75% {
    opacity: 0;
  }
}
.animate__flash {
  -webkit-animation-name: flash;
  animation-name: flash;
}
/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */
@-webkit-keyframes pulse {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  50% {
    -webkit-transform: scale3d(1.05, 1.05, 1.05);
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
@keyframes pulse {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  50% {
    -webkit-transform: scale3d(1.05, 1.05, 1.05);
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
.animate__pulse {
  -webkit-animation-name: pulse;
  animation-name: pulse;
  -webkit-animation-timing-function: ease-in-out;
  animation-timing-function: ease-in-out;
}
@-webkit-keyframes rubberBand {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  30% {
    -webkit-transform: scale3d(1.25, 0.75, 1);
    transform: scale3d(1.25, 0.75, 1);
  }

  40% {
    -webkit-transform: scale3d(0.75, 1.25, 1);
    transform: scale3d(0.75, 1.25, 1);
  }

  50% {
    -webkit-transform: scale3d(1.15, 0.85, 1);
    transform: scale3d(1.15, 0.85, 1);
  }

  65% {
    -webkit-transform: scale3d(0.95, 1.05, 1);
    transform: scale3d(0.95, 1.05, 1);
  }

  75% {
    -webkit-transform: scale3d(1.05, 0.95, 1);
    transform: scale3d(1.05, 0.95, 1);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
@keyframes rubberBand {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  30% {
    -webkit-transform: scale3d(1.25, 0.75, 1);
    transform: scale3d(1.25, 0.75, 1);
  }

  40% {
    -webkit-transform: scale3d(0.75, 1.25, 1);
    transform: scale3d(0.75, 1.25, 1);
  }

  50% {
    -webkit-transform: scale3d(1.15, 0.85, 1);
    transform: scale3d(1.15, 0.85, 1);
  }

  65% {
    -webkit-transform: scale3d(0.95, 1.05, 1);
    transform: scale3d(0.95, 1.05, 1);
  }

  75% {
    -webkit-transform: scale3d(1.05, 0.95, 1);
    transform: scale3d(1.05, 0.95, 1);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
.animate__rubberBand {
  -webkit-animation-name: rubberBand;
  animation-name: rubberBand;
}
@-webkit-keyframes shakeX {
  from,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    -webkit-transform: translate3d(-10px, 0, 0);
    transform: translate3d(-10px, 0, 0);
  }

  20%,
  40%,
  60%,
  80% {
    -webkit-transform: translate3d(10px, 0, 0);
    transform: translate3d(10px, 0, 0);
  }
}
@keyframes shakeX {
  from,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    -webkit-transform: translate3d(-10px, 0, 0);
    transform: translate3d(-10px, 0, 0);
  }

  20%,
  40%,
  60%,
  80% {
    -webkit-transform: translate3d(10px, 0, 0);
    transform: translate3d(10px, 0, 0);
  }
}
.animate__shakeX {
  -webkit-animation-name: shakeX;
  animation-name: shakeX;
}
@-webkit-keyframes shakeY {
  from,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    -webkit-transform: translate3d(0, -10px, 0);
    transform: translate3d(0, -10px, 0);
  }

  20%,
  40%,
  60%,
  80% {
    -webkit-transform: translate3d(0, 10px, 0);
    transform: translate3d(0, 10px, 0);
  }
}
@keyframes shakeY {
  from,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  10%,
  30%,
  50%,
  70%,
  90% {
    -webkit-transform: translate3d(0, -10px, 0);
    transform: translate3d(0, -10px, 0);
  }

  20%,
  40%,
  60%,
  80% {
    -webkit-transform: translate3d(0, 10px, 0);
    transform: translate3d(0, 10px, 0);
  }
}
.animate__shakeY {
  -webkit-animation-name: shakeY;
  animation-name: shakeY;
}
@-webkit-keyframes headShake {
  0% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }

  6.5% {
    -webkit-transform: translateX(-6px) rotateY(-9deg);
    transform: translateX(-6px) rotateY(-9deg);
  }

  18.5% {
    -webkit-transform: translateX(5px) rotateY(7deg);
    transform: translateX(5px) rotateY(7deg);
  }

  31.5% {
    -webkit-transform: translateX(-3px) rotateY(-5deg);
    transform: translateX(-3px) rotateY(-5deg);
  }

  43.5% {
    -webkit-transform: translateX(2px) rotateY(3deg);
    transform: translateX(2px) rotateY(3deg);
  }

  50% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }
}
@keyframes headShake {
  0% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }

  6.5% {
    -webkit-transform: translateX(-6px) rotateY(-9deg);
    transform: translateX(-6px) rotateY(-9deg);
  }

  18.5% {
    -webkit-transform: translateX(5px) rotateY(7deg);
    transform: translateX(5px) rotateY(7deg);
  }

  31.5% {
    -webkit-transform: translateX(-3px) rotateY(-5deg);
    transform: translateX(-3px) rotateY(-5deg);
  }

  43.5% {
    -webkit-transform: translateX(2px) rotateY(3deg);
    transform: translateX(2px) rotateY(3deg);
  }

  50% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }
}
.animate__headShake {
  -webkit-animation-timing-function: ease-in-out;
  animation-timing-function: ease-in-out;
  -webkit-animation-name: headShake;
  animation-name: headShake;
}
@-webkit-keyframes swing {
  20% {
    -webkit-transform: rotate3d(0, 0, 1, 15deg);
    transform: rotate3d(0, 0, 1, 15deg);
  }

  40% {
    -webkit-transform: rotate3d(0, 0, 1, -10deg);
    transform: rotate3d(0, 0, 1, -10deg);
  }

  60% {
    -webkit-transform: rotate3d(0, 0, 1, 5deg);
    transform: rotate3d(0, 0, 1, 5deg);
  }

  80% {
    -webkit-transform: rotate3d(0, 0, 1, -5deg);
    transform: rotate3d(0, 0, 1, -5deg);
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 0deg);
    transform: rotate3d(0, 0, 1, 0deg);
  }
}
@keyframes swing {
  20% {
    -webkit-transform: rotate3d(0, 0, 1, 15deg);
    transform: rotate3d(0, 0, 1, 15deg);
  }

  40% {
    -webkit-transform: rotate3d(0, 0, 1, -10deg);
    transform: rotate3d(0, 0, 1, -10deg);
  }

  60% {
    -webkit-transform: rotate3d(0, 0, 1, 5deg);
    transform: rotate3d(0, 0, 1, 5deg);
  }

  80% {
    -webkit-transform: rotate3d(0, 0, 1, -5deg);
    transform: rotate3d(0, 0, 1, -5deg);
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 0deg);
    transform: rotate3d(0, 0, 1, 0deg);
  }
}
.animate__swing {
  -webkit-transform-origin: top center;
  transform-origin: top center;
  -webkit-animation-name: swing;
  animation-name: swing;
}
@-webkit-keyframes tada {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  10%,
  20% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg);
    transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg);
  }

  30%,
  50%,
  70%,
  90% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
  }

  40%,
  60%,
  80% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
@keyframes tada {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  10%,
  20% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg);
    transform: scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg);
  }

  30%,
  50%,
  70%,
  90% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
  }

  40%,
  60%,
  80% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
    transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
.animate__tada {
  -webkit-animation-name: tada;
  animation-name: tada;
}
/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */
@-webkit-keyframes wobble {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  15% {
    -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
  }

  30% {
    -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
  }

  45% {
    -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
  }

  60% {
    -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
  }

  75% {
    -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes wobble {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  15% {
    -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
    transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
  }

  30% {
    -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
    transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
  }

  45% {
    -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
    transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
  }

  60% {
    -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
    transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
  }

  75% {
    -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
    transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__wobble {
  -webkit-animation-name: wobble;
  animation-name: wobble;
}
@-webkit-keyframes jello {
  from,
  11.1%,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  22.2% {
    -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
    transform: skewX(-12.5deg) skewY(-12.5deg);
  }

  33.3% {
    -webkit-transform: skewX(6.25deg) skewY(6.25deg);
    transform: skewX(6.25deg) skewY(6.25deg);
  }

  44.4% {
    -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
    transform: skewX(-3.125deg) skewY(-3.125deg);
  }

  55.5% {
    -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
    transform: skewX(1.5625deg) skewY(1.5625deg);
  }

  66.6% {
    -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
    transform: skewX(-0.78125deg) skewY(-0.78125deg);
  }

  77.7% {
    -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
    transform: skewX(0.390625deg) skewY(0.390625deg);
  }

  88.8% {
    -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
    transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
  }
}
@keyframes jello {
  from,
  11.1%,
  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  22.2% {
    -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
    transform: skewX(-12.5deg) skewY(-12.5deg);
  }

  33.3% {
    -webkit-transform: skewX(6.25deg) skewY(6.25deg);
    transform: skewX(6.25deg) skewY(6.25deg);
  }

  44.4% {
    -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
    transform: skewX(-3.125deg) skewY(-3.125deg);
  }

  55.5% {
    -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
    transform: skewX(1.5625deg) skewY(1.5625deg);
  }

  66.6% {
    -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
    transform: skewX(-0.78125deg) skewY(-0.78125deg);
  }

  77.7% {
    -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
    transform: skewX(0.390625deg) skewY(0.390625deg);
  }

  88.8% {
    -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
    transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
  }
}
.animate__jello {
  -webkit-animation-name: jello;
  animation-name: jello;
  -webkit-transform-origin: center;
  transform-origin: center;
}
@-webkit-keyframes heartBeat {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  14% {
    -webkit-transform: scale(1.3);
    transform: scale(1.3);
  }

  28% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  42% {
    -webkit-transform: scale(1.3);
    transform: scale(1.3);
  }

  70% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}
@keyframes heartBeat {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  14% {
    -webkit-transform: scale(1.3);
    transform: scale(1.3);
  }

  28% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  42% {
    -webkit-transform: scale(1.3);
    transform: scale(1.3);
  }

  70% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}
.animate__heartBeat {
  -webkit-animation-name: heartBeat;
  animation-name: heartBeat;
  -webkit-animation-duration: calc(1s * 1.3);
  animation-duration: calc(1s * 1.3);
  -webkit-animation-duration: calc(var(--animate-duration) * 1.3);
  animation-duration: calc(var(--animate-duration) * 1.3);
  -webkit-animation-timing-function: ease-in-out;
  animation-timing-function: ease-in-out;
}
/* Back entrances */
@-webkit-keyframes backInDown {
  0% {
    -webkit-transform: translateY(-1200px) scale(0.7);
    transform: translateY(-1200px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
@keyframes backInDown {
  0% {
    -webkit-transform: translateY(-1200px) scale(0.7);
    transform: translateY(-1200px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
.animate__backInDown {
  -webkit-animation-name: backInDown;
  animation-name: backInDown;
}
@-webkit-keyframes backInLeft {
  0% {
    -webkit-transform: translateX(-2000px) scale(0.7);
    transform: translateX(-2000px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
@keyframes backInLeft {
  0% {
    -webkit-transform: translateX(-2000px) scale(0.7);
    transform: translateX(-2000px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
.animate__backInLeft {
  -webkit-animation-name: backInLeft;
  animation-name: backInLeft;
}
@-webkit-keyframes backInRight {
  0% {
    -webkit-transform: translateX(2000px) scale(0.7);
    transform: translateX(2000px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
@keyframes backInRight {
  0% {
    -webkit-transform: translateX(2000px) scale(0.7);
    transform: translateX(2000px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
.animate__backInRight {
  -webkit-animation-name: backInRight;
  animation-name: backInRight;
}
@-webkit-keyframes backInUp {
  0% {
    -webkit-transform: translateY(1200px) scale(0.7);
    transform: translateY(1200px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
@keyframes backInUp {
  0% {
    -webkit-transform: translateY(1200px) scale(0.7);
    transform: translateY(1200px) scale(0.7);
    opacity: 0.7;
  }

  80% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }
}
.animate__backInUp {
  -webkit-animation-name: backInUp;
  animation-name: backInUp;
}
/* Back exits */
@-webkit-keyframes backOutDown {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateY(700px) scale(0.7);
    transform: translateY(700px) scale(0.7);
    opacity: 0.7;
  }
}
@keyframes backOutDown {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateY(700px) scale(0.7);
    transform: translateY(700px) scale(0.7);
    opacity: 0.7;
  }
}
.animate__backOutDown {
  -webkit-animation-name: backOutDown;
  animation-name: backOutDown;
}
@-webkit-keyframes backOutLeft {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateX(-2000px) scale(0.7);
    transform: translateX(-2000px) scale(0.7);
    opacity: 0.7;
  }
}
@keyframes backOutLeft {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateX(-2000px) scale(0.7);
    transform: translateX(-2000px) scale(0.7);
    opacity: 0.7;
  }
}
.animate__backOutLeft {
  -webkit-animation-name: backOutLeft;
  animation-name: backOutLeft;
}
@-webkit-keyframes backOutRight {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateX(2000px) scale(0.7);
    transform: translateX(2000px) scale(0.7);
    opacity: 0.7;
  }
}
@keyframes backOutRight {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateX(0px) scale(0.7);
    transform: translateX(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateX(2000px) scale(0.7);
    transform: translateX(2000px) scale(0.7);
    opacity: 0.7;
  }
}
.animate__backOutRight {
  -webkit-animation-name: backOutRight;
  animation-name: backOutRight;
}
@-webkit-keyframes backOutUp {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateY(-700px) scale(0.7);
    transform: translateY(-700px) scale(0.7);
    opacity: 0.7;
  }
}
@keyframes backOutUp {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
    opacity: 1;
  }

  20% {
    -webkit-transform: translateY(0px) scale(0.7);
    transform: translateY(0px) scale(0.7);
    opacity: 0.7;
  }

  100% {
    -webkit-transform: translateY(-700px) scale(0.7);
    transform: translateY(-700px) scale(0.7);
    opacity: 0.7;
  }
}
.animate__backOutUp {
  -webkit-animation-name: backOutUp;
  animation-name: backOutUp;
}
/* Bouncing entrances  */
@-webkit-keyframes bounceIn {
  from,
  20%,
  40%,
  60%,
  80%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  20% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1);
    transform: scale3d(1.1, 1.1, 1.1);
  }

  40% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9);
    transform: scale3d(0.9, 0.9, 0.9);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(1.03, 1.03, 1.03);
    transform: scale3d(1.03, 1.03, 1.03);
  }

  80% {
    -webkit-transform: scale3d(0.97, 0.97, 0.97);
    transform: scale3d(0.97, 0.97, 0.97);
  }

  to {
    opacity: 1;
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
@keyframes bounceIn {
  from,
  20%,
  40%,
  60%,
  80%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  20% {
    -webkit-transform: scale3d(1.1, 1.1, 1.1);
    transform: scale3d(1.1, 1.1, 1.1);
  }

  40% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9);
    transform: scale3d(0.9, 0.9, 0.9);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(1.03, 1.03, 1.03);
    transform: scale3d(1.03, 1.03, 1.03);
  }

  80% {
    -webkit-transform: scale3d(0.97, 0.97, 0.97);
    transform: scale3d(0.97, 0.97, 0.97);
  }

  to {
    opacity: 1;
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}
.animate__bounceIn {
  -webkit-animation-duration: calc(1s * 0.75);
  animation-duration: calc(1s * 0.75);
  -webkit-animation-duration: calc(var(--animate-duration) * 0.75);
  animation-duration: calc(var(--animate-duration) * 0.75);
  -webkit-animation-name: bounceIn;
  animation-name: bounceIn;
}
@-webkit-keyframes bounceInDown {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: translate3d(0, -3000px, 0) scaleY(3);
    transform: translate3d(0, -3000px, 0) scaleY(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(0, 25px, 0) scaleY(0.9);
    transform: translate3d(0, 25px, 0) scaleY(0.9);
  }

  75% {
    -webkit-transform: translate3d(0, -10px, 0) scaleY(0.95);
    transform: translate3d(0, -10px, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, 5px, 0) scaleY(0.985);
    transform: translate3d(0, 5px, 0) scaleY(0.985);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes bounceInDown {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: translate3d(0, -3000px, 0) scaleY(3);
    transform: translate3d(0, -3000px, 0) scaleY(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(0, 25px, 0) scaleY(0.9);
    transform: translate3d(0, 25px, 0) scaleY(0.9);
  }

  75% {
    -webkit-transform: translate3d(0, -10px, 0) scaleY(0.95);
    transform: translate3d(0, -10px, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, 5px, 0) scaleY(0.985);
    transform: translate3d(0, 5px, 0) scaleY(0.985);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__bounceInDown {
  -webkit-animation-name: bounceInDown;
  animation-name: bounceInDown;
}
@-webkit-keyframes bounceInLeft {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: translate3d(-3000px, 0, 0) scaleX(3);
    transform: translate3d(-3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(25px, 0, 0) scaleX(1);
    transform: translate3d(25px, 0, 0) scaleX(1);
  }

  75% {
    -webkit-transform: translate3d(-10px, 0, 0) scaleX(0.98);
    transform: translate3d(-10px, 0, 0) scaleX(0.98);
  }

  90% {
    -webkit-transform: translate3d(5px, 0, 0) scaleX(0.995);
    transform: translate3d(5px, 0, 0) scaleX(0.995);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes bounceInLeft {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    -webkit-transform: translate3d(-3000px, 0, 0) scaleX(3);
    transform: translate3d(-3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(25px, 0, 0) scaleX(1);
    transform: translate3d(25px, 0, 0) scaleX(1);
  }

  75% {
    -webkit-transform: translate3d(-10px, 0, 0) scaleX(0.98);
    transform: translate3d(-10px, 0, 0) scaleX(0.98);
  }

  90% {
    -webkit-transform: translate3d(5px, 0, 0) scaleX(0.995);
    transform: translate3d(5px, 0, 0) scaleX(0.995);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__bounceInLeft {
  -webkit-animation-name: bounceInLeft;
  animation-name: bounceInLeft;
}
@-webkit-keyframes bounceInRight {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    -webkit-transform: translate3d(3000px, 0, 0) scaleX(3);
    transform: translate3d(3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(-25px, 0, 0) scaleX(1);
    transform: translate3d(-25px, 0, 0) scaleX(1);
  }

  75% {
    -webkit-transform: translate3d(10px, 0, 0) scaleX(0.98);
    transform: translate3d(10px, 0, 0) scaleX(0.98);
  }

  90% {
    -webkit-transform: translate3d(-5px, 0, 0) scaleX(0.995);
    transform: translate3d(-5px, 0, 0) scaleX(0.995);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes bounceInRight {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    -webkit-transform: translate3d(3000px, 0, 0) scaleX(3);
    transform: translate3d(3000px, 0, 0) scaleX(3);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(-25px, 0, 0) scaleX(1);
    transform: translate3d(-25px, 0, 0) scaleX(1);
  }

  75% {
    -webkit-transform: translate3d(10px, 0, 0) scaleX(0.98);
    transform: translate3d(10px, 0, 0) scaleX(0.98);
  }

  90% {
    -webkit-transform: translate3d(-5px, 0, 0) scaleX(0.995);
    transform: translate3d(-5px, 0, 0) scaleX(0.995);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__bounceInRight {
  -webkit-animation-name: bounceInRight;
  animation-name: bounceInRight;
}
@-webkit-keyframes bounceInUp {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 3000px, 0) scaleY(5);
    transform: translate3d(0, 3000px, 0) scaleY(5);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(0, -20px, 0) scaleY(0.9);
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  75% {
    -webkit-transform: translate3d(0, 10px, 0) scaleY(0.95);
    transform: translate3d(0, 10px, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, -5px, 0) scaleY(0.985);
    transform: translate3d(0, -5px, 0) scaleY(0.985);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes bounceInUp {
  from,
  60%,
  75%,
  90%,
  to {
    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 3000px, 0) scaleY(5);
    transform: translate3d(0, 3000px, 0) scaleY(5);
  }

  60% {
    opacity: 1;
    -webkit-transform: translate3d(0, -20px, 0) scaleY(0.9);
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  75% {
    -webkit-transform: translate3d(0, 10px, 0) scaleY(0.95);
    transform: translate3d(0, 10px, 0) scaleY(0.95);
  }

  90% {
    -webkit-transform: translate3d(0, -5px, 0) scaleY(0.985);
    transform: translate3d(0, -5px, 0) scaleY(0.985);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__bounceInUp {
  -webkit-animation-name: bounceInUp;
  animation-name: bounceInUp;
}
/* Bouncing exits  */
@-webkit-keyframes bounceOut {
  20% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9);
    transform: scale3d(0.9, 0.9, 0.9);
  }

  50%,
  55% {
    opacity: 1;
    -webkit-transform: scale3d(1.1, 1.1, 1.1);
    transform: scale3d(1.1, 1.1, 1.1);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }
}
@keyframes bounceOut {
  20% {
    -webkit-transform: scale3d(0.9, 0.9, 0.9);
    transform: scale3d(0.9, 0.9, 0.9);
  }

  50%,
  55% {
    opacity: 1;
    -webkit-transform: scale3d(1.1, 1.1, 1.1);
    transform: scale3d(1.1, 1.1, 1.1);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }
}
.animate__bounceOut {
  -webkit-animation-duration: calc(1s * 0.75);
  animation-duration: calc(1s * 0.75);
  -webkit-animation-duration: calc(var(--animate-duration) * 0.75);
  animation-duration: calc(var(--animate-duration) * 0.75);
  -webkit-animation-name: bounceOut;
  animation-name: bounceOut;
}
@-webkit-keyframes bounceOutDown {
  20% {
    -webkit-transform: translate3d(0, 10px, 0) scaleY(0.985);
    transform: translate3d(0, 10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    -webkit-transform: translate3d(0, -20px, 0) scaleY(0.9);
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0) scaleY(3);
    transform: translate3d(0, 2000px, 0) scaleY(3);
  }
}
@keyframes bounceOutDown {
  20% {
    -webkit-transform: translate3d(0, 10px, 0) scaleY(0.985);
    transform: translate3d(0, 10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    -webkit-transform: translate3d(0, -20px, 0) scaleY(0.9);
    transform: translate3d(0, -20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0) scaleY(3);
    transform: translate3d(0, 2000px, 0) scaleY(3);
  }
}
.animate__bounceOutDown {
  -webkit-animation-name: bounceOutDown;
  animation-name: bounceOutDown;
}
@-webkit-keyframes bounceOutLeft {
  20% {
    opacity: 1;
    -webkit-transform: translate3d(20px, 0, 0) scaleX(0.9);
    transform: translate3d(20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0) scaleX(2);
    transform: translate3d(-2000px, 0, 0) scaleX(2);
  }
}
@keyframes bounceOutLeft {
  20% {
    opacity: 1;
    -webkit-transform: translate3d(20px, 0, 0) scaleX(0.9);
    transform: translate3d(20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0) scaleX(2);
    transform: translate3d(-2000px, 0, 0) scaleX(2);
  }
}
.animate__bounceOutLeft {
  -webkit-animation-name: bounceOutLeft;
  animation-name: bounceOutLeft;
}
@-webkit-keyframes bounceOutRight {
  20% {
    opacity: 1;
    -webkit-transform: translate3d(-20px, 0, 0) scaleX(0.9);
    transform: translate3d(-20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0) scaleX(2);
    transform: translate3d(2000px, 0, 0) scaleX(2);
  }
}
@keyframes bounceOutRight {
  20% {
    opacity: 1;
    -webkit-transform: translate3d(-20px, 0, 0) scaleX(0.9);
    transform: translate3d(-20px, 0, 0) scaleX(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0) scaleX(2);
    transform: translate3d(2000px, 0, 0) scaleX(2);
  }
}
.animate__bounceOutRight {
  -webkit-animation-name: bounceOutRight;
  animation-name: bounceOutRight;
}
@-webkit-keyframes bounceOutUp {
  20% {
    -webkit-transform: translate3d(0, -10px, 0) scaleY(0.985);
    transform: translate3d(0, -10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    -webkit-transform: translate3d(0, 20px, 0) scaleY(0.9);
    transform: translate3d(0, 20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0) scaleY(3);
    transform: translate3d(0, -2000px, 0) scaleY(3);
  }
}
@keyframes bounceOutUp {
  20% {
    -webkit-transform: translate3d(0, -10px, 0) scaleY(0.985);
    transform: translate3d(0, -10px, 0) scaleY(0.985);
  }

  40%,
  45% {
    opacity: 1;
    -webkit-transform: translate3d(0, 20px, 0) scaleY(0.9);
    transform: translate3d(0, 20px, 0) scaleY(0.9);
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0) scaleY(3);
    transform: translate3d(0, -2000px, 0) scaleY(3);
  }
}
.animate__bounceOutUp {
  -webkit-animation-name: bounceOutUp;
  animation-name: bounceOutUp;
}
/* Fading entrances  */
@-webkit-keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}
.animate__fadeIn {
  -webkit-animation-name: fadeIn;
  animation-name: fadeIn;
}
@-webkit-keyframes fadeInDown {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInDown {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInDown {
  -webkit-animation-name: fadeInDown;
  animation-name: fadeInDown;
}
@-webkit-keyframes fadeInDownBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0);
    transform: translate3d(0, -2000px, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInDownBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0);
    transform: translate3d(0, -2000px, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInDownBig {
  -webkit-animation-name: fadeInDownBig;
  animation-name: fadeInDownBig;
}
@-webkit-keyframes fadeInLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInLeft {
  -webkit-animation-name: fadeInLeft;
  animation-name: fadeInLeft;
}
@-webkit-keyframes fadeInLeftBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0);
    transform: translate3d(-2000px, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInLeftBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0);
    transform: translate3d(-2000px, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInLeftBig {
  -webkit-animation-name: fadeInLeftBig;
  animation-name: fadeInLeftBig;
}
@-webkit-keyframes fadeInRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInRight {
  -webkit-animation-name: fadeInRight;
  animation-name: fadeInRight;
}
@-webkit-keyframes fadeInRightBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0);
    transform: translate3d(2000px, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInRightBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0);
    transform: translate3d(2000px, 0, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInRightBig {
  -webkit-animation-name: fadeInRightBig;
  animation-name: fadeInRightBig;
}
@-webkit-keyframes fadeInUp {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInUp {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInUp {
  -webkit-animation-name: fadeInUp;
  animation-name: fadeInUp;
}
@-webkit-keyframes fadeInUpBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0);
    transform: translate3d(0, 2000px, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInUpBig {
  from {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0);
    transform: translate3d(0, 2000px, 0);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInUpBig {
  -webkit-animation-name: fadeInUpBig;
  animation-name: fadeInUpBig;
}
@-webkit-keyframes fadeInTopLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, -100%, 0);
    transform: translate3d(-100%, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInTopLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, -100%, 0);
    transform: translate3d(-100%, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInTopLeft {
  -webkit-animation-name: fadeInTopLeft;
  animation-name: fadeInTopLeft;
}
@-webkit-keyframes fadeInTopRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, -100%, 0);
    transform: translate3d(100%, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInTopRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, -100%, 0);
    transform: translate3d(100%, -100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInTopRight {
  -webkit-animation-name: fadeInTopRight;
  animation-name: fadeInTopRight;
}
@-webkit-keyframes fadeInBottomLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 100%, 0);
    transform: translate3d(-100%, 100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInBottomLeft {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 100%, 0);
    transform: translate3d(-100%, 100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInBottomLeft {
  -webkit-animation-name: fadeInBottomLeft;
  animation-name: fadeInBottomLeft;
}
@-webkit-keyframes fadeInBottomRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, 100%, 0);
    transform: translate3d(100%, 100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes fadeInBottomRight {
  from {
    opacity: 0;
    -webkit-transform: translate3d(100%, 100%, 0);
    transform: translate3d(100%, 100%, 0);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__fadeInBottomRight {
  -webkit-animation-name: fadeInBottomRight;
  animation-name: fadeInBottomRight;
}
/* Fading exits */
@-webkit-keyframes fadeOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
}
@keyframes fadeOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
}
.animate__fadeOut {
  -webkit-animation-name: fadeOut;
  animation-name: fadeOut;
}
@-webkit-keyframes fadeOutDown {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }
}
@keyframes fadeOutDown {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }
}
.animate__fadeOutDown {
  -webkit-animation-name: fadeOutDown;
  animation-name: fadeOutDown;
}
@-webkit-keyframes fadeOutDownBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0);
    transform: translate3d(0, 2000px, 0);
  }
}
@keyframes fadeOutDownBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, 2000px, 0);
    transform: translate3d(0, 2000px, 0);
  }
}
.animate__fadeOutDownBig {
  -webkit-animation-name: fadeOutDownBig;
  animation-name: fadeOutDownBig;
}
@-webkit-keyframes fadeOutLeft {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }
}
@keyframes fadeOutLeft {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }
}
.animate__fadeOutLeft {
  -webkit-animation-name: fadeOutLeft;
  animation-name: fadeOutLeft;
}
@-webkit-keyframes fadeOutLeftBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0);
    transform: translate3d(-2000px, 0, 0);
  }
}
@keyframes fadeOutLeftBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(-2000px, 0, 0);
    transform: translate3d(-2000px, 0, 0);
  }
}
.animate__fadeOutLeftBig {
  -webkit-animation-name: fadeOutLeftBig;
  animation-name: fadeOutLeftBig;
}
@-webkit-keyframes fadeOutRight {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }
}
@keyframes fadeOutRight {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }
}
.animate__fadeOutRight {
  -webkit-animation-name: fadeOutRight;
  animation-name: fadeOutRight;
}
@-webkit-keyframes fadeOutRightBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0);
    transform: translate3d(2000px, 0, 0);
  }
}
@keyframes fadeOutRightBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(2000px, 0, 0);
    transform: translate3d(2000px, 0, 0);
  }
}
.animate__fadeOutRightBig {
  -webkit-animation-name: fadeOutRightBig;
  animation-name: fadeOutRightBig;
}
@-webkit-keyframes fadeOutUp {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
}
@keyframes fadeOutUp {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
}
.animate__fadeOutUp {
  -webkit-animation-name: fadeOutUp;
  animation-name: fadeOutUp;
}
@-webkit-keyframes fadeOutUpBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0);
    transform: translate3d(0, -2000px, 0);
  }
}
@keyframes fadeOutUpBig {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(0, -2000px, 0);
    transform: translate3d(0, -2000px, 0);
  }
}
.animate__fadeOutUpBig {
  -webkit-animation-name: fadeOutUpBig;
  animation-name: fadeOutUpBig;
}
@-webkit-keyframes fadeOutTopLeft {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, -100%, 0);
    transform: translate3d(-100%, -100%, 0);
  }
}
@keyframes fadeOutTopLeft {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, -100%, 0);
    transform: translate3d(-100%, -100%, 0);
  }
}
.animate__fadeOutTopLeft {
  -webkit-animation-name: fadeOutTopLeft;
  animation-name: fadeOutTopLeft;
}
@-webkit-keyframes fadeOutTopRight {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, -100%, 0);
    transform: translate3d(100%, -100%, 0);
  }
}
@keyframes fadeOutTopRight {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, -100%, 0);
    transform: translate3d(100%, -100%, 0);
  }
}
.animate__fadeOutTopRight {
  -webkit-animation-name: fadeOutTopRight;
  animation-name: fadeOutTopRight;
}
@-webkit-keyframes fadeOutBottomRight {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 100%, 0);
    transform: translate3d(100%, 100%, 0);
  }
}
@keyframes fadeOutBottomRight {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 100%, 0);
    transform: translate3d(100%, 100%, 0);
  }
}
.animate__fadeOutBottomRight {
  -webkit-animation-name: fadeOutBottomRight;
  animation-name: fadeOutBottomRight;
}
@-webkit-keyframes fadeOutBottomLeft {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 100%, 0);
    transform: translate3d(-100%, 100%, 0);
  }
}
@keyframes fadeOutBottomLeft {
  from {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
  to {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 100%, 0);
    transform: translate3d(-100%, 100%, 0);
  }
}
.animate__fadeOutBottomLeft {
  -webkit-animation-name: fadeOutBottomLeft;
  animation-name: fadeOutBottomLeft;
}
/* Flippers */
@-webkit-keyframes flip {
  from {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg);
    -webkit-animation-timing-function: ease-out;
    animation-timing-function: ease-out;
  }

  40% {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg);
    -webkit-animation-timing-function: ease-out;
    animation-timing-function: ease-out;
  }

  50% {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  80% {
    -webkit-transform: perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg);
    transform: perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  to {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }
}
@keyframes flip {
  from {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg);
    -webkit-animation-timing-function: ease-out;
    animation-timing-function: ease-out;
  }

  40% {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg);
    -webkit-animation-timing-function: ease-out;
    animation-timing-function: ease-out;
  }

  50% {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  80% {
    -webkit-transform: perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg);
    transform: perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  to {
    -webkit-transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg);
    transform: perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }
}
.animate__animated.animate__flip {
  -webkit-backface-visibility: visible;
  backface-visibility: visible;
  -webkit-animation-name: flip;
  animation-name: flip;
}
@-webkit-keyframes flipInX {
  from {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  60% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
  }

  to {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }
}
@keyframes flipInX {
  from {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  60% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
  }

  to {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }
}
.animate__flipInX {
  -webkit-backface-visibility: visible !important;
  backface-visibility: visible !important;
  -webkit-animation-name: flipInX;
  animation-name: flipInX;
}
@-webkit-keyframes flipInY {
  from {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  60% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
  }

  to {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }
}
@keyframes flipInY {
  from {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
    opacity: 0;
  }

  40% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
    -webkit-animation-timing-function: ease-in;
    animation-timing-function: ease-in;
  }

  60% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
  }

  to {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }
}
.animate__flipInY {
  -webkit-backface-visibility: visible !important;
  backface-visibility: visible !important;
  -webkit-animation-name: flipInY;
  animation-name: flipInY;
}
@-webkit-keyframes flipOutX {
  from {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }

  30% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    opacity: 1;
  }

  to {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    opacity: 0;
  }
}
@keyframes flipOutX {
  from {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }

  30% {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
    opacity: 1;
  }

  to {
    -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
    opacity: 0;
  }
}
.animate__flipOutX {
  -webkit-animation-duration: calc(1s * 0.75);
  animation-duration: calc(1s * 0.75);
  -webkit-animation-duration: calc(var(--animate-duration) * 0.75);
  animation-duration: calc(var(--animate-duration) * 0.75);
  -webkit-animation-name: flipOutX;
  animation-name: flipOutX;
  -webkit-backface-visibility: visible !important;
  backface-visibility: visible !important;
}
@-webkit-keyframes flipOutY {
  from {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }

  30% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    opacity: 1;
  }

  to {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    opacity: 0;
  }
}
@keyframes flipOutY {
  from {
    -webkit-transform: perspective(400px);
    transform: perspective(400px);
  }

  30% {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
    opacity: 1;
  }

  to {
    -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
    opacity: 0;
  }
}
.animate__flipOutY {
  -webkit-animation-duration: calc(1s * 0.75);
  animation-duration: calc(1s * 0.75);
  -webkit-animation-duration: calc(var(--animate-duration) * 0.75);
  animation-duration: calc(var(--animate-duration) * 0.75);
  -webkit-backface-visibility: visible !important;
  backface-visibility: visible !important;
  -webkit-animation-name: flipOutY;
  animation-name: flipOutY;
}
/* Lightspeed */
@-webkit-keyframes lightSpeedInRight {
  from {
    -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
    transform: translate3d(100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }

  60% {
    -webkit-transform: skewX(20deg);
    transform: skewX(20deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: skewX(-5deg);
    transform: skewX(-5deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes lightSpeedInRight {
  from {
    -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
    transform: translate3d(100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }

  60% {
    -webkit-transform: skewX(20deg);
    transform: skewX(20deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: skewX(-5deg);
    transform: skewX(-5deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__lightSpeedInRight {
  -webkit-animation-name: lightSpeedInRight;
  animation-name: lightSpeedInRight;
  -webkit-animation-timing-function: ease-out;
  animation-timing-function: ease-out;
}
@-webkit-keyframes lightSpeedInLeft {
  from {
    -webkit-transform: translate3d(-100%, 0, 0) skewX(30deg);
    transform: translate3d(-100%, 0, 0) skewX(30deg);
    opacity: 0;
  }

  60% {
    -webkit-transform: skewX(-20deg);
    transform: skewX(-20deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: skewX(5deg);
    transform: skewX(5deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes lightSpeedInLeft {
  from {
    -webkit-transform: translate3d(-100%, 0, 0) skewX(30deg);
    transform: translate3d(-100%, 0, 0) skewX(30deg);
    opacity: 0;
  }

  60% {
    -webkit-transform: skewX(-20deg);
    transform: skewX(-20deg);
    opacity: 1;
  }

  80% {
    -webkit-transform: skewX(5deg);
    transform: skewX(5deg);
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__lightSpeedInLeft {
  -webkit-animation-name: lightSpeedInLeft;
  animation-name: lightSpeedInLeft;
  -webkit-animation-timing-function: ease-out;
  animation-timing-function: ease-out;
}
@-webkit-keyframes lightSpeedOutRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
    transform: translate3d(100%, 0, 0) skewX(30deg);
    opacity: 0;
  }
}
@keyframes lightSpeedOutRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
    transform: translate3d(100%, 0, 0) skewX(30deg);
    opacity: 0;
  }
}
.animate__lightSpeedOutRight {
  -webkit-animation-name: lightSpeedOutRight;
  animation-name: lightSpeedOutRight;
  -webkit-animation-timing-function: ease-in;
  animation-timing-function: ease-in;
}
@-webkit-keyframes lightSpeedOutLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(-100%, 0, 0) skewX(-30deg);
    transform: translate3d(-100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }
}
@keyframes lightSpeedOutLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(-100%, 0, 0) skewX(-30deg);
    transform: translate3d(-100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }
}
.animate__lightSpeedOutLeft {
  -webkit-animation-name: lightSpeedOutLeft;
  animation-name: lightSpeedOutLeft;
  -webkit-animation-timing-function: ease-in;
  animation-timing-function: ease-in;
}
/* Rotating entrances */
@-webkit-keyframes rotateIn {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -200deg);
    transform: rotate3d(0, 0, 1, -200deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
@keyframes rotateIn {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -200deg);
    transform: rotate3d(0, 0, 1, -200deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
.animate__rotateIn {
  -webkit-animation-name: rotateIn;
  animation-name: rotateIn;
  -webkit-transform-origin: center;
  transform-origin: center;
}
@-webkit-keyframes rotateInDownLeft {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
@keyframes rotateInDownLeft {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
.animate__rotateInDownLeft {
  -webkit-animation-name: rotateInDownLeft;
  animation-name: rotateInDownLeft;
  -webkit-transform-origin: left bottom;
  transform-origin: left bottom;
}
@-webkit-keyframes rotateInDownRight {
  from {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
@keyframes rotateInDownRight {
  from {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
.animate__rotateInDownRight {
  -webkit-animation-name: rotateInDownRight;
  animation-name: rotateInDownRight;
  -webkit-transform-origin: right bottom;
  transform-origin: right bottom;
}
@-webkit-keyframes rotateInUpLeft {
  from {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
@keyframes rotateInUpLeft {
  from {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
.animate__rotateInUpLeft {
  -webkit-animation-name: rotateInUpLeft;
  animation-name: rotateInUpLeft;
  -webkit-transform-origin: left bottom;
  transform-origin: left bottom;
}
@-webkit-keyframes rotateInUpRight {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -90deg);
    transform: rotate3d(0, 0, 1, -90deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
@keyframes rotateInUpRight {
  from {
    -webkit-transform: rotate3d(0, 0, 1, -90deg);
    transform: rotate3d(0, 0, 1, -90deg);
    opacity: 0;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}
.animate__rotateInUpRight {
  -webkit-animation-name: rotateInUpRight;
  animation-name: rotateInUpRight;
  -webkit-transform-origin: right bottom;
  transform-origin: right bottom;
}
/* Rotating exits */
@-webkit-keyframes rotateOut {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 200deg);
    transform: rotate3d(0, 0, 1, 200deg);
    opacity: 0;
  }
}
@keyframes rotateOut {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 200deg);
    transform: rotate3d(0, 0, 1, 200deg);
    opacity: 0;
  }
}
.animate__rotateOut {
  -webkit-animation-name: rotateOut;
  animation-name: rotateOut;
  -webkit-transform-origin: center;
  transform-origin: center;
}
@-webkit-keyframes rotateOutDownLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }
}
@keyframes rotateOutDownLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 45deg);
    transform: rotate3d(0, 0, 1, 45deg);
    opacity: 0;
  }
}
.animate__rotateOutDownLeft {
  -webkit-animation-name: rotateOutDownLeft;
  animation-name: rotateOutDownLeft;
  -webkit-transform-origin: left bottom;
  transform-origin: left bottom;
}
@-webkit-keyframes rotateOutDownRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
}
@keyframes rotateOutDownRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
}
.animate__rotateOutDownRight {
  -webkit-animation-name: rotateOutDownRight;
  animation-name: rotateOutDownRight;
  -webkit-transform-origin: right bottom;
  transform-origin: right bottom;
}
@-webkit-keyframes rotateOutUpLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
}
@keyframes rotateOutUpLeft {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, -45deg);
    transform: rotate3d(0, 0, 1, -45deg);
    opacity: 0;
  }
}
.animate__rotateOutUpLeft {
  -webkit-animation-name: rotateOutUpLeft;
  animation-name: rotateOutUpLeft;
  -webkit-transform-origin: left bottom;
  transform-origin: left bottom;
}
@-webkit-keyframes rotateOutUpRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 90deg);
    transform: rotate3d(0, 0, 1, 90deg);
    opacity: 0;
  }
}
@keyframes rotateOutUpRight {
  from {
    opacity: 1;
  }

  to {
    -webkit-transform: rotate3d(0, 0, 1, 90deg);
    transform: rotate3d(0, 0, 1, 90deg);
    opacity: 0;
  }
}
.animate__rotateOutUpRight {
  -webkit-animation-name: rotateOutUpRight;
  animation-name: rotateOutUpRight;
  -webkit-transform-origin: right bottom;
  transform-origin: right bottom;
}
/* Specials */
@-webkit-keyframes hinge {
  0% {
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
  }

  20%,
  60% {
    -webkit-transform: rotate3d(0, 0, 1, 80deg);
    transform: rotate3d(0, 0, 1, 80deg);
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
  }

  40%,
  80% {
    -webkit-transform: rotate3d(0, 0, 1, 60deg);
    transform: rotate3d(0, 0, 1, 60deg);
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(0, 700px, 0);
    transform: translate3d(0, 700px, 0);
    opacity: 0;
  }
}
@keyframes hinge {
  0% {
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
  }

  20%,
  60% {
    -webkit-transform: rotate3d(0, 0, 1, 80deg);
    transform: rotate3d(0, 0, 1, 80deg);
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
  }

  40%,
  80% {
    -webkit-transform: rotate3d(0, 0, 1, 60deg);
    transform: rotate3d(0, 0, 1, 60deg);
    -webkit-animation-timing-function: ease-in-out;
    animation-timing-function: ease-in-out;
    opacity: 1;
  }

  to {
    -webkit-transform: translate3d(0, 700px, 0);
    transform: translate3d(0, 700px, 0);
    opacity: 0;
  }
}
.animate__hinge {
  -webkit-animation-duration: calc(1s * 2);
  animation-duration: calc(1s * 2);
  -webkit-animation-duration: calc(var(--animate-duration) * 2);
  animation-duration: calc(var(--animate-duration) * 2);
  -webkit-animation-name: hinge;
  animation-name: hinge;
  -webkit-transform-origin: top left;
  transform-origin: top left;
}
@-webkit-keyframes jackInTheBox {
  from {
    opacity: 0;
    -webkit-transform: scale(0.1) rotate(30deg);
    transform: scale(0.1) rotate(30deg);
    -webkit-transform-origin: center bottom;
    transform-origin: center bottom;
  }

  50% {
    -webkit-transform: rotate(-10deg);
    transform: rotate(-10deg);
  }

  70% {
    -webkit-transform: rotate(3deg);
    transform: rotate(3deg);
  }

  to {
    opacity: 1;
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}
@keyframes jackInTheBox {
  from {
    opacity: 0;
    -webkit-transform: scale(0.1) rotate(30deg);
    transform: scale(0.1) rotate(30deg);
    -webkit-transform-origin: center bottom;
    transform-origin: center bottom;
  }

  50% {
    -webkit-transform: rotate(-10deg);
    transform: rotate(-10deg);
  }

  70% {
    -webkit-transform: rotate(3deg);
    transform: rotate(3deg);
  }

  to {
    opacity: 1;
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}
.animate__jackInTheBox {
  -webkit-animation-name: jackInTheBox;
  animation-name: jackInTheBox;
}
/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */
@-webkit-keyframes rollIn {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
    transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes rollIn {
  from {
    opacity: 0;
    -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
    transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
  }

  to {
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__rollIn {
  -webkit-animation-name: rollIn;
  animation-name: rollIn;
}
/* originally authored by Nick Pettit - https://github.com/nickpettit/glide */
@-webkit-keyframes rollOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
    transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
  }
}
@keyframes rollOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
    transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
  }
}
.animate__rollOut {
  -webkit-animation-name: rollOut;
  animation-name: rollOut;
}
/* Zooming entrances */
@-webkit-keyframes zoomIn {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  50% {
    opacity: 1;
  }
}
@keyframes zoomIn {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  50% {
    opacity: 1;
  }
}
.animate__zoomIn {
  -webkit-animation-name: zoomIn;
  animation-name: zoomIn;
}
@-webkit-keyframes zoomInDown {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomInDown {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomInDown {
  -webkit-animation-name: zoomInDown;
  animation-name: zoomInDown;
}
@-webkit-keyframes zoomInLeft {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomInLeft {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomInLeft {
  -webkit-animation-name: zoomInLeft;
  animation-name: zoomInLeft;
}
@-webkit-keyframes zoomInRight {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomInRight {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomInRight {
  -webkit-animation-name: zoomInRight;
  animation-name: zoomInRight;
}
@-webkit-keyframes zoomInUp {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomInUp {
  from {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  60% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomInUp {
  -webkit-animation-name: zoomInUp;
  animation-name: zoomInUp;
}
/* Zooming exits */
@-webkit-keyframes zoomOut {
  from {
    opacity: 1;
  }

  50% {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  to {
    opacity: 0;
  }
}
@keyframes zoomOut {
  from {
    opacity: 1;
  }

  50% {
    opacity: 0;
    -webkit-transform: scale3d(0.3, 0.3, 0.3);
    transform: scale3d(0.3, 0.3, 0.3);
  }

  to {
    opacity: 0;
  }
}
.animate__zoomOut {
  -webkit-animation-name: zoomOut;
  animation-name: zoomOut;
}
@-webkit-keyframes zoomOutDown {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomOutDown {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomOutDown {
  -webkit-animation-name: zoomOutDown;
  animation-name: zoomOutDown;
  -webkit-transform-origin: center bottom;
  transform-origin: center bottom;
}
@-webkit-keyframes zoomOutLeft {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0);
  }

  to {
    opacity: 0;
    -webkit-transform: scale(0.1) translate3d(-2000px, 0, 0);
    transform: scale(0.1) translate3d(-2000px, 0, 0);
  }
}
@keyframes zoomOutLeft {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0);
  }

  to {
    opacity: 0;
    -webkit-transform: scale(0.1) translate3d(-2000px, 0, 0);
    transform: scale(0.1) translate3d(-2000px, 0, 0);
  }
}
.animate__zoomOutLeft {
  -webkit-animation-name: zoomOutLeft;
  animation-name: zoomOutLeft;
  -webkit-transform-origin: left center;
  transform-origin: left center;
}
@-webkit-keyframes zoomOutRight {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0);
  }

  to {
    opacity: 0;
    -webkit-transform: scale(0.1) translate3d(2000px, 0, 0);
    transform: scale(0.1) translate3d(2000px, 0, 0);
  }
}
@keyframes zoomOutRight {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0);
  }

  to {
    opacity: 0;
    -webkit-transform: scale(0.1) translate3d(2000px, 0, 0);
    transform: scale(0.1) translate3d(2000px, 0, 0);
  }
}
.animate__zoomOutRight {
  -webkit-animation-name: zoomOutRight;
  animation-name: zoomOutRight;
  -webkit-transform-origin: right center;
  transform-origin: right center;
}
@-webkit-keyframes zoomOutUp {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
@keyframes zoomOutUp {
  40% {
    opacity: 1;
    -webkit-transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    transform: scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
    animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
  }

  to {
    opacity: 0;
    -webkit-transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0);
    transform: scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0);
    -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
    animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1);
  }
}
.animate__zoomOutUp {
  -webkit-animation-name: zoomOutUp;
  animation-name: zoomOutUp;
  -webkit-transform-origin: center bottom;
  transform-origin: center bottom;
}
/* Sliding entrances */
@-webkit-keyframes slideInDown {
  from {
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes slideInDown {
  from {
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__slideInDown {
  -webkit-animation-name: slideInDown;
  animation-name: slideInDown;
}
@-webkit-keyframes slideInLeft {
  from {
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes slideInLeft {
  from {
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__slideInLeft {
  -webkit-animation-name: slideInLeft;
  animation-name: slideInLeft;
}
@-webkit-keyframes slideInRight {
  from {
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes slideInRight {
  from {
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__slideInRight {
  -webkit-animation-name: slideInRight;
  animation-name: slideInRight;
}
@-webkit-keyframes slideInUp {
  from {
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
@keyframes slideInUp {
  from {
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
    visibility: visible;
  }

  to {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }
}
.animate__slideInUp {
  -webkit-animation-name: slideInUp;
  animation-name: slideInUp;
}
/* Sliding exits */
@-webkit-keyframes slideOutDown {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }
}
@keyframes slideOutDown {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(0, 100%, 0);
    transform: translate3d(0, 100%, 0);
  }
}
.animate__slideOutDown {
  -webkit-animation-name: slideOutDown;
  animation-name: slideOutDown;
}
@-webkit-keyframes slideOutLeft {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }
}
@keyframes slideOutLeft {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
  }
}
.animate__slideOutLeft {
  -webkit-animation-name: slideOutLeft;
  animation-name: slideOutLeft;
}
@-webkit-keyframes slideOutRight {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }
}
@keyframes slideOutRight {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
  }
}
.animate__slideOutRight {
  -webkit-animation-name: slideOutRight;
  animation-name: slideOutRight;
}
@-webkit-keyframes slideOutUp {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
}
@keyframes slideOutUp {
  from {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  to {
    visibility: hidden;
    -webkit-transform: translate3d(0, -100%, 0);
    transform: translate3d(0, -100%, 0);
  }
}
.animate__slideOutUp {
  -webkit-animation-name: slideOutUp;
  animation-name: slideOutUp;
}
/* twine-user-stylesheet #4: "battle animation.css" */
.actors.animationContainer {
  margin-top:20px;
  margin-bottom:20px;
  row-gap:20px;
  justify-content: space-evenly;
  order:2;
}

.dmgPopup {
	visibility:hidden;
	display:inline-block;
	font-size:28pt;
	font-weight:bold;
	color: black;
	position:absolute;
	right:10px;
	top:20px;
	padding: 5px;
	text-align: center;
	line-height: 1.1;
	border-radius: 25%;
	border: 1px solid black;
	background-color: white;
	max-width: 180px;
	overflow: hidden;
}

.dmgPopup.small {
	font-size:18pt;
}

.dmgPopup.big {
	font-size:32pt;
}

.dmgPopup.regen {
/*  text-shadow: 0 0 10px white;
  -webkit-text-stroke: 0.5px white;
  background: unset;
  padding: 0;
  border: unset;
*/  right: 20px;
  top: 15px;
}
/* twine-user-stylesheet #5: "battle grid.css" */
.actors.grid {
  display: grid;
  justify-items: center;
  align-items: center;
  row-gap: 1em;
  width: 100%;
  height: auto;
/*  grid-template-columns: repeat(auto-fit,1fr); */
  /*
  By default, this will result in rows of size 4.
  For shorter rows, put a defined number in place of auto-fit or the space specification.
  For longer rows, you must expand the width of #content and/or adjust the width of .actor.grid.
  */
}

.actors.grid.large {
	grid-template: repeat(2,1fr) / repeat(3,1fr);
}

#puppets .actors.grid {
  margin-top: 3em;
}

.actor.grid {
  position: relative;
  width: 140px; /* 4 per row at default #content width */
  min-height: 96px;
}

.actor.grid.large {
	grid-column: 1 / 4;
	grid-row: 1 / 3;
	width: 100%;
	height: 192px;	/* 2 actor boxes */
	padding: 0;
	display: flex;
	flex-direction: column;
	text-align: center;
	justify-content: center;
	align-items: center;
}

.actor.large .actorname {
	font-size: 24pt;
}

.actor.empty {
  border: dotted gray;
}
/* twine-user-stylesheet #6: "battle layout.css" */
.invisible {
	display: none;
}

.battlemsg {
  border-bottom: 2px solid;
  padding-bottom: 1em;
  margin-bottom: 1em;
  font-style: italic;
  text-align: center;
}

.actors.invisible {
	display: none;
}

.actors {
  position: relative;
  display: flex;
  flex-flow: row wrap;
  justify-content: space-evenly;
  align-items: flex-start;
  margin-bottom: 1em;
}

.actors.enemies {
  border-bottom: 2px solid;
  padding-bottom: 1em;
}

.actors.enemies.reverse {
  flex-flow: row-reverse wrap-reverse;
}

.actor {
	position: relative;
  min-width: 130px;
  font-weight: bold;
  display: inline-block;
  border: solid;
  border-width: 2px;
  border-radius: 4px;
  padding: 1em;
  margin-right: auto;
	margin-left: auto;
}

.actor.victory {
	font-weight: normal;
	margin-bottom: 1em;
	background-color:#fff;
	color:#111;
}

.actor.large {
  width: 100%;
  text-align: center;
}

.actor.inactive {
	opacity: 0.5;
}

.selected {
  /* background-color: cyan; */
  border-color: blue;
}

/*
.itemcontainer {
  display: flex;
  align-items: flex-start;
  border: solid blue;
}

.items {
  display: inline-block;
  border: solid;
  width: 45%;
}
*/

.commandcontainer {
  display: flex;
  flex-flow: row wrap;
  justify-content: space-evenly;
  align-items: space-evenly;
  min-height: 90px;
  margin-bottom: 10px;
}

.commands {
  min-width: 130px;
  display: inline-block;
  padding-right: 1em;
  padding-left: 1em;
  align-content: center;
  border: solid;
  border-width: 3px;
}

.noact {
  color: gray;
  font-weight: bold;
  text-align: center
}

.embargo {
  color: gray;
  font-weight: bold;
}

/*
button {
	text-transform: uppercase;
	background-color: red;
	border-radius: 2px;
}
*/

.btn {
  margin-left: 20px;
  background-color: red;
  padding: 2px;
  text-transform: uppercase;
  border-radius: 2px;
}

.btn.back {
  background-color: silver;
}

.formula {
  font-style: italic;
  text-align: center;
}

.right {
  float: right;
}

.center {
  text-align: center;
  display: inline-block;
}

.actorname {
  font-weight: bold;
}

.actorname .dead {
	color: gray;
}

.hotkey {

}

.statusbutton {
	float: right;
	margin-left: 0.5em;
}

.statusbutton.absolute {
	position:absolute;
	top:1em;
	right:1em;
}

.targetnumber {
	position: absolute;
	bottom: 1em;
	right: 1em;
	font-size: 9pt;
}

#quit {
	position: absolute;
	left: 1em;
	bottom: 0;
}

#roundCounter {
	font-weight: bold;
	position: absolute;
	right: 1em;
	bottom: 0;
}
/* twine-user-stylesheet #7: "custom animations.css" */
@-webkit-keyframes headShake {
  0% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }

  6.5% {
    -webkit-transform: translateX(-10px) rotateY(-9deg);
    transform: translateX(-10px) rotateY(-9deg);
  }

  18.5% {
    -webkit-transform: translateX(9px) rotateY(7deg);
    transform: translateX(9px) rotateY(7deg);
  }

  31.5% {
    -webkit-transform: translateX(-6px) rotateY(-5deg);
    transform: translateX(-6px) rotateY(-5deg);
  }

  43.5% {
    -webkit-transform: translateX(5px) rotateY(3deg);
    transform: translateX(5px) rotateY(3deg);
  }

  55.5% {
    -webkit-transform: translateX(-3px) rotateY(3deg);
    transform: translateX(-3px) rotateY(3deg);
  }

  66.5% {
    -webkit-transform: translateX(2px) rotateY(3deg);
    transform: translateX(2px) rotateY(3deg);
  }

  75% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }
}
@keyframes headShake {
  0% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }

  6.5% {
    -webkit-transform: translateX(-10px) rotateY(-9deg);
    transform: translateX(-10px) rotateY(-9deg);
  }

  18.5% {
    -webkit-transform: translateX(9px) rotateY(7deg);
    transform: translateX(9px) rotateY(7deg);
  }

  31.5% {
    -webkit-transform: translateX(-6px) rotateY(-5deg);
    transform: translateX(-6px) rotateY(-5deg);
  }

  43.5% {
    -webkit-transform: translateX(5px) rotateY(3deg);
    transform: translateX(5px) rotateY(3deg);
  }

  55.5% {
    -webkit-transform: translateX(-3px) rotateY(3deg);
    transform: translateX(-3px) rotateY(3deg);
  }

  66.5% {
    -webkit-transform: translateX(2px) rotateY(3deg);
    transform: translateX(2px) rotateY(3deg);
  }

  75% {
    -webkit-transform: translateX(0);
    transform: translateX(0);
  }
}
.animate__headShake {
  -webkit-animation-timing-function: ease-in-out;
  animation-timing-function: ease-in-out;
  -webkit-animation-name: headShake;
  animation-name: headShake;
}

@-webkit-keyframes slideOutUp {
  0% {
    visibility: visible;
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  80% {
    opacity: 1;
    -webkit-transform: translate3d(0, -120%, 0);
    transform: translate3d(0, -120%, 0);
  }

  100% {
    opacity: 0;
    visibility: hidden;
    -webkit-transform: translate3d(0, -120%, 0);
    transform: translate3d(0, -120%, 0);
  }
}
@keyframes slideOutUp {
  0% {
    visibility: visible;
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  80% {
    opacity: 1;
    -webkit-transform: translate3d(0, -120%, 0);
    transform: translate3d(0, -120%, 0);
  }

  100% {
    opacity: 0;
    visibility: hidden;
    -webkit-transform: translate3d(0, -120%, 0);
    transform: translate3d(0, -120%, 0);
  }
}
.animate__slideOutUp {
  -webkit-animation-name: slideOutUp;
  animation-name: slideOutUp;
}

@-webkit-keyframes slideOutDown {
  0% {
    visibility: visible;
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  80% {
    opacity: 1;
    -webkit-transform: translate3d(0, 120%, 0);
    transform: translate3d(0, 120%, 0);
  }

  100% {
    opacity: 0;
    visibility: hidden;
    -webkit-transform: translate3d(0, 120%, 0);
    transform: translate3d(0, 120%, 0);
  }
}
@keyframes slideOutDown {
  0% {
    visibility: visible;
    opacity: 1;
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
  }

  80% {
    opacity: 1;
    -webkit-transform: translate3d(0, 120%, 0);
    transform: translate3d(0, 200%, 0);
  }

  100% {
    opacity: 0;
    visibility: hidden;
    -webkit-transform: translate3d(0, 120%, 0);
    transform: translate3d(0, 200%, 0);
  }
}
.animate__slideOutDown {
  -webkit-animation-name: slideOutDown;
  animation-name: slideOutDown;
}
/* twine-user-stylesheet #8: "status-pane.css" */
.statusname {
  text-transform: uppercase;
  text-align: center;
}

.statname {
  display: inline-block;
  min-width: 6em;
  text-transform: uppercase;
}

.stat {
	display: inline-block;
	min-width: 4em;
	text-align: right;
}

.effectdesc {
  font-weight: normal;
}

.duration, .tolerance {
  color: gray;
  font-style: italic;
  float: right;
}
/* twine-user-stylesheet #9: "bleached style.css" */
body, tw-story
{
  background-color:#fff;
  color:#111;
}

a {
	color: #35c;
}

a:hover {
  color: #6691ff;
}

input, select, textarea {
  color: #444;
}

input:not(:disabled):focus, input:not(:disabled):hover, select:not(:disabled):focus, select:not(:disabled):hover, textarea:not(:disabled):focus, textarea:not(:disabled):hover {
    background-color: #fff;
    border-color: #444;
}

#title, #story-caption {
	color:#fff;
}

/* Default dialog styling */
#ui-overlay {
	background-color: #777;
}
#ui-dialog-titlebar {
	background-color: #ccc;
}
#ui-dialog-close:hover {
	background-color: #b44;
	border-color: #a33;
}
#ui-dialog-body {
	background-color: #fff;
	border-color: #ccc;
	color:#111;
}
#ui-dialog-body hr {
	background-color: #ccc;
}

/* List-based dialog styling */
#ui-dialog-body.list li:not(:first-child) {
	border-top-color: #ccc;
}
#ui-dialog-body.list li a {
	color: #111;
}
#ui-dialog-body.list li a:hover {
	background-color: #ddd;
	border-color: #111;
}

/* Saves dialog styling */
#ui-dialog-body.saves > *:not(:first-child),
#ui-dialog-body.saves tr:not(:first-child) {
	border-top-color: #ccc;
}
#ui-dialog-body.saves .empty {
	color: #777;
}

/* Settings dialog styling */
#ui-dialog-body.settings button[id|="setting-control"] {
	color: #111;
	border-color: #ccc;
}
#ui-dialog-body.settings button[id|="setting-control"]:hover {
	background-color: #ddd;
	border-color: #111;
}
#ui-dialog-body.settings button[id|="setting-control"].enabled {
	background-color: #9e9;
	border-color: #7c7;
}
#ui-dialog-body.settings button[id|="setting-control"].enabled:hover {
	background-color: #7c7;
	border-color: #5a5;
}
/* twine-user-stylesheet #10: "colors.css" */
.stat-raised, .blue {
	color: blue;
}

.stat-lowered, .red {
	color: red;
}

.green {
	color: lime;
}

.truegreen {
	color: green;
}

.gray {
  color: gray;
}

.maroon {
  color: maroon;
}

.gold {
  color: gold;
}

.orange {
  color: orange;
}
/* twine-user-stylesheet #11: "fonts.css" */
@font-face {
  font-family: 'OpenDyslexic';
  src: url("fonts/OpenDyslexic-Regular.otf") format("otf"),
  url("fonts/OpenDyslexic-Regular.woff") format("woff");
}

@font-face {
  font-family: 'OpenDyslexicMono';
  src: url("fonts/OpenDyslexicMono-Regular.otf") format("otf"),
  url("fonts/OpenDyslexicMono-Regular.woff") format("woff");
}
/* twine-user-stylesheet #12: "marquee.css" */
.marqueeWrapper {
    position: relative;
    display: flex;
}
.marqueeWrapper div {
    position: relative;
    box-sizing: border-box;
    padding: 0 0.2em;
    white-space: nowrap;
}
.marqueeWrapper div#marquee {
    flex-grow: 1;
    overflow: hidden;
}
.marqueeWrapper div#marquee span {
    position: relative;
    display: inline-block;
    animation: scroll 10s linear infinite;
}

@keyframes scroll {
    0%   {
        left: 100%;
    }
    100% {
        left: -100%;
    }
}
/* twine-user-stylesheet #13: "bestiary.css" */
.bestiary-header {
	font-size: 200%;
	font-weight: bold;
	border-bottom: 1px solid;
	line-height: 1;
	padding-bottom: 10px;
	margin-bottom: 10px;
}

.bestiary-grid {
	display: grid;
	width: 100%;
	grid-auto-rows: auto;
	grid-template-columns: 25px 1fr 25px 1fr;
	grid-column-gap: 20px;
	overflow-y: auto;
	padding-right: 1em;
	max-height: 60vh;
	font-weight: bold;
}

.bestiary-display {
    position: relative;
}

.bestiary-name {
    font-size: 200%;
    font-weight: bold;
    background-color: lightgray;
    border: 2px solid black;
    border-radius: 15px 15px 0 0;
    padding-left: 10px;
    border-bottom: 0;
}

.bestiary-detail {
    position: relative;
    border: 2px solid;
    border-radius: 0 0 15px 15px;
    padding: 1em;
    min-height: 70vh;
}

#bestiary-infoblock {
    grid-column: 1;
    padding: 0 1em 1em 1em;
		border: 1px solid;
		font-weight: bold;
}

.bestiary-desc {
	grid-column: 2;
	font-weight: normal;
	margin-left: 20px;
}

.bestiary-defeated-count {
    position: absolute;
    right: 1em;
    bottom: 1em;
		font-weight: bold;
}

.bestiary-display-numbering {
    float: right;
    text-align: right;
    font-size: 14pt;
    line-height: 1.2;
    margin: 10px;
}

.bestiary-form-container {
	font-weight:normal;
	text-transform:uppercase;
	margin-bottom:5px;
	position:relative;
	top:-5px;
}

.bestiary-form-entry {
	margin-right:15px;
}

.bestiary-detail-container {
	display: grid;
	grid-template-columns: 50% 50%;
	min-height: 250px;
}

.bestiary-numbering {
	text-align: right;
}

.bestiary-entry {
	border-bottom: 1px solid;
}
/* twine-user-stylesheet #14: "equipment.css" */
#equipment-list {
	overflow-y: auto;
	padding-right: 1em;
	max-height: 60vh;
}
.menuactor-equipment-slot {
	font-weight:bold;
	color:gray;
	line-height:1;
}

.menuactor-equipment-name {
	position:relative;
	left:1.5em;
	display:inline-block;
	margin-bottom:0.5em;
}

.unequip-button {
	float: right;
}

.item-equippable {
	font-style: italic;
	font-size: 12px;
}
/* twine-user-stylesheet #15: "formation.css" */
.actors.menu {
	grid-template-columns: auto 1fr 1fr 1fr;
}

.formation-label {
	padding-right: 1em;
	justify-self: start;
}

.leaderlabel {
	grid-column: 1;
	grid-row: 1;
	font-weight: bold;
}

.frontrowlabel {
	grid-column: 1;
	grid-row: 2;
	font-weight: bold;
}

.backrowlabel {
	grid-column: 1;
	grid-row: 3;
	font-weight: bold;
}

.front1.menu {
  grid-column: 2;
  grid-row: 1;
}

.front2.menu {
  grid-column: 3;
  grid-row: 1;
}

.front3.menu {
  grid-column: 4;
  grid-row: 1;
}

.mid1.menu {
  grid-column: 2;
  grid-row: 2;
}

.mid2.menu {
  grid-column: 3;
  grid-row: 2;
}

.mid3.menu {
  grid-column: 4;
  grid-row: 2;
}

.back1.menu {
  grid-column: 2;
  grid-row: 3;
}

.back2.menu {
  grid-column: 3;
  grid-row: 3;
}

.back3.menu {
  grid-column: 4;
  grid-row: 3;
}

.formation-labels {
	display: inline-grid;
	grid-template: repeat(3,1fr) / 1fr;
	row-gap: 1em;
	height: 100%;
}
/* twine-user-stylesheet #16: "inventory.css" */
.itemcontainer {
	display: grid;
	width: 100%;
	grid-auto-rows: auto;
	grid-template-columns: 1fr 2em 1fr;
	overflow-y: auto;
	padding-right: 1em;
	max-height: 60vh;
}
.item1 {
	grid-column: 1;
}

.item2 {
	grid-column: 3;
}

.itemstock {
	margin-left: 1em;
	margin-right: 1em;
	text-align: right;
	float: right;
}

.item-buttons {
	display: flex;
	justify-content: space-evenly;
	margin-top: 0.5em;
}
/* twine-user-stylesheet #17: "shared.css" */
#content.menu {
	padding-top: 0;
	border: none;
}

.menunav {
	display: inline-block;
	line-height: 1.2;
	float: right;
}

#menu-display {
	border: 2px solid;
	border-radius: 1em;
	height: 120px;
	padding: 1em;
	margin-bottom: 0.5em;
}

#display-content {
	height: 3.5em;
	overflow-Y: auto;
}

.elementdisplay {
	float: right;
	text-align: right;
}

.shop-button {
	display: inline-block;
	float: right;
}

.cyclebuttons {
	position:absolute;
	top:0;
	right:1em;
}

#button1 button {
	padding:0.1em;
	color: #35c;
	background-color:unset;
	border-width:medium;
}

#button2 button {
	padding:0.1em;
	color: #35c;
	background-color: unset;
	border-width: medium;
}

.GPdisplay {
	font-weight: bold;
	margin-top: 3em;
}

.itembox {
	background-color:#fff;
	color:#111;
	width: 50%;
	border: solid;
	border-radius: 8px;
	padding: 1em;
	margin-top: 1em;
	margin-bottom: 1em;
	text-align: left;
}

.infield #display-content {
	height: auto;
}

.smalltext {
	font-size:12px;
	font-weight:normal;
}

#notify.menu {
	font-weight: bold !important;
	background-color: lightgreen !important;
}
/* twine-user-stylesheet #18: "status.css" */
.menuactor {
  position: relative;
  min-height: 96px;
  border: 1px solid;
  line-height: 1.2;
  margin-bottom: 0;
}

.actor.menu {
	margin-bottom: 10px;
	min-width: 90%;
	border-radius: 0px;
	height: auto;
}

.menuactor.small-display {
	display: grid;
	grid-template-columns: 33% 1fr;
	margin-bottom: 0.5em;
}

.portrait {
	display: inline-block;
	text-align: center;
	height: 96px;
	width: 96px;
	border-right: 1px solid;
}

.menuactor-nameblock {
	position:absolute;
	margin-left: 14px;
	padding-top: 5px;
}

.menuactor-nameblock.small-display {
	position: static;
	padding-bottom: 0.5em;
	grid-row: 1;
	grid-column: 1;
	border-right: 1px solid;
}

.menuactor-name {
	font-weight:bold;
	font-size:20px;
}

.menuactor-level {
	font-weight:bold;
	font-size:16px;
	position:relative;
	top:0.7em;
}

.menuactor-hpmpblock {
	position:absolute;
	left:240px;
	top:0;
	width: 200px;
}

.menuactor-hpmpblock.small-display {
	top: 0.75em;
	width: 260px;
}

.hpmp {
	font-weight:bold;
	font-size:20px;
	font-family: monospace;
	display:inline-block;
	width:100%;
	position:relative;
	top:5px;
}

.hpmpvalue {
	display:inline-block;
	text-align:right;
	min-width:2.3em;
}

.menuactor-xpblock {
	position: absolute;
	left: 480px;
	top: 0.5em;
	min-width: 110px;
	line-height: 1.15;
}

.menuactor-detail {
	display: grid;
  grid-template-columns: 50% 50%;
  height:auto;
  border:1px solid;
}

.menuactor-stats {
	grid-row: 1;
  grid-column: 1;
  display: grid;
  font-weight: bold;
  font-size: 12pt;
  grid-auto-rows: max-content;
  grid-template-columns: 50% 6em 4em;
  border-right: 1px solid;
  padding-top: 1em;
  padding-bottom: 0.4em;
}

.menuactor-stats.small-display, .menuactor-stats.inventory-display {
	grid-row: unset;
	grid-column: unset;
	grid-template-columns: 40% 3em 4em;
	border-right: none;
}

.menuactor-statname {
	grid-column: 1;
    margin-left:1em;
    margin-bottom:0;
    font-weight:bold;
    text-transform:uppercase;
}

.menuactor-statvalue {
	grid-column: 2;
    text-align:right;
}

.menuactor-statmod {
	grid-column:3;
    margin-left:1em;
}

#menuactor-special {
	grid-row: 1;
    grid-column: 2;
    padding-bottom: 1em;
}

.menuactor-special-title {
	text-transform:uppercase;
	font-weight:bold;
	text-align:center;
	margin-bottom:0.5em;
}

.abilities-header {
	font-weight: bold;
	border-bottom: 1px solid;
	text-transform: uppercase;
	margin-bottom: 1em;
}

.menuactor-equipment.small-display, .menuactor-equipment.inventory-display {
	grid-row: 1;
	grid-column: 2;
	margin-left: 1em;
	margin-top: 0.5em;
	margin-bottom: 0.5em;
	margin-right: 1em;
}

#menu-display.action {
  height: auto;
}
/* twine-user-stylesheet #19: "tooltips.css" */
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted black;
}

.tooltip .tooltiptext {
  all: initial;
  visibility: hidden;
  width: 300px;
  background-color:white;
  text-align:center;
  border:1px solid;
  border-radius: 6px;
  padding: 5px;

  /* Position the tooltip */
  position: absolute;
  z-index: 1;
  top: 0;
  left: 110%;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
}

html.dyslexic .tooltiptext {
  font-family: 'OpenDyslexic';
}
/* twine-user-stylesheet #20: "miscellaneous.css" */
/* Styles relating to the display of the help file. You will likely wish to delete or override this for your own stories. */

blockquote a.link-external::after, a.noExternal.link-external::after {
  visibility: hidden;
  content: "";
}

body.text {
  background-color: tan;
}

.text .passage {
  line-height: 1.5;
}

h1, h2, h3, h4, h5 {
  margin: auto;
}

img {
  max-width: 100%;
}

pre {
	background-color: silver;
	padding: 0px 3px;
}
pre > code {
	padding: 0px;
}

#navbar, #navbar div {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-evenly;
}

#navbar span {
  margin-left: 1em;
  margin-right: 1em;
}
/* twine-user-stylesheet #21: "notify-custom.css" */
#notify {
  position:fixed;
  display:block;
  opacity: 0;
  width:26em;
  top: -1em;
  right: 530px;
  padding:1em;
  background-color:#fff;
  color:#000;
  font-size: 100%;
  border: 2px solid;
  border-radius: 1em;
  -webkit-transition: top .3s, opacity .3s;
  -moz-transition:top .3s, opacity .3s;
  -o-transition:top .3s, opacity .3s;
  transition:top .3s, opacity .3s;
}

#notify.open {
  opacity: 1;
  top: 4em;
}
/* twine-user-stylesheet #22: "saves desc.css" */
#ui-dialog-body.saves {
  min-width: 600px;
}

#ui-dialog-body.saves .datestamp {
	margin-left: 0.5em;
}

.save-desc {
	position: relative;
	margin-bottom: 5px;
	margin-top: 10px;
}

.save-area {
	display: block;
	font: 16px/1 Helmet,Freesans,sans-serif;
	font-weight: bold;
	font-size: 125%;
	margin-bottom: 10px;
}

.save-left {
	display: inline-block;
	max-width: 50%;
}

.save-extra {
	position: absolute;
	top: 2em;
}

.save-money {
}

.save-level {
	margin-right: 2em;
}

.save-party {
	float: right;
	position: relative;
	right: -5px;
}

.save-puppet {
	display: inline-block;
	padding-left: 5px;
	padding-right: 5px;
	border: 1px solid;
	text-align: center;
	text-transform: uppercase;
	font-weight: bold;
	overflow: hidden;
}
/* twine-user-stylesheet #23: "special formats.css" */
html.dark body, body.dark
{
  background-color:#111;
  color:#fff;
}
/* twine-user-stylesheet #24: "bundle.css" */
/* popover.min.css, by chapel; for use with popover.js; v1.0.0 */
#ui-dialog-body.popover{background:0 0;border:0;padding:0}.popover #ui-dialog-titlebar{background:0 0}.popover #ui-dialog-title{display:none}.popover #ui-dialog-close{position:fixed;display:block;top:0;right:0;height:3em}.popover #ui-dialog-close:hover{background-color:transparent;border-color:transparent;color:#c22}#ui-overlay.popover.opaque{opacity:1}#ui-overlay.popover.transparent{opacity:0}#ui-overlay.popover.invert{background-color:#f8f8f8}#ui-dialog-body.popover.invert{color:#111}
/* end popover.min.css */
/* speech.min.css, by chapel; for use with speech.js */
.say{border:1px solid #eee;overflow:auto}.say img{max-width:20%;float:left;margin-right:1em}.say p:first-of-type{font-weight:700;margin:.2em 0;border-bottom:1px solid #eee}.say p:last-of-type{padding:.5em;margin:0}
/* notify.min.css, by chapel; for use with notify.js; v1.0.0 */
/*
#notify {
  position:fixed;
  display:block;
  width:16em;
  right:-20em;
  top:2em;
  padding:.5em;
  background-color:#fff;
  color:#000;
  -webkit-transition:right .3s;
  -moz-transition:right .3s;
  -o-transition:right .3s;
  transition:right .3s
}
*/
/*
#notify.open {
  right:0
}
*/
/* end notify.min.css */
/* twine-user-stylesheet #25: "ctp.css" */
.macro-ctp-entry-t8n {
  opacity: 1;
  animation: macro-ctp-fade-in 0.25s ease;
}

@keyframes macro-ctp-fade-in {
  0% {
    opacity: 0;
  }
}
/* twine-user-stylesheet #26: "linkdropdown.css" */
/*
    Copyright Kronwiz.
    This file is part of https://github.com/kronwiz/twineworks repository.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

div.linkdropdown-dropdown {
  background: yellow;
  padding-left: 6px;
  padding-right: 6px;
  padding-top: 6px;
  border-top-right-radius: 4px;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
}

a.linkdropdown-anchor {
  background: transparent;
  padding-left: 6px;
  padding-right: 6px;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;  
}

a.linkdropdown-anchor.open {
  background: yellow;
}
/* twine-user-stylesheet #27: "numberpool-macro-set.css" */
/*! <<numberpool>> macro set for SugarCube v2 */
div[id|="numberinput-body"] {
	display: inline-block;
}
div[id|="numberinput-body"] input {
	min-width: 3em;
	width: 3em;
	text-align: center;
}
div[id|="numberinput-body"] button {
	font-family: "tme-fa-icons";
	font-style: normal;
	font-weight: normal;
	font-variant: normal;
	text-transform: none;
	line-height: normal;
	speak: none;
	padding: 0.4em 0.6em;
}
div[id|="numberinput-body"] button[id|="numberinput-minus"] {
	margin-right: 0.4em;
}
div[id|="numberinput-body"] button[id|="numberinput-plus"] {
	margin-left: 0.4em;
}

div[id|="numberslider-body"] {
	display: inline-block;
}
div[id|="numberslider-body"] span {
	display: inline-block;
	/*font-size: 1.25em;*/
	margin-left: 0.25em;
	min-width: 3em;
	text-align: center;
	vertical-align: middle;
}
div[id|="numberslider-body"] input {
	-webkit-appearance: none;
	cursor: pointer;
	height: 1.25em;
	min-width: 20em;
	vertical-align: middle;
}
div[id|="numberslider-body"] input:focus {
	outline: none;
}
div[id|="numberslider-body"] input::-webkit-slider-runnable-track {
	background: #222;
	border: 1px solid #444;
	border-radius: 0;
	cursor: pointer;
	height: 10px;
	width: 100%;
}
div[id|="numberslider-body"] input::-webkit-slider-thumb {
	-webkit-appearance: none;
	background: #35a;
	border: 1px solid #57c;
	border-radius: 0;
	cursor: pointer;
	height: 18px;
	margin-top: -5px;
	width: 33px;
}
div[id|="numberslider-body"] input:focus::-webkit-slider-runnable-track {
	background: #222;
}
div[id|="numberslider-body"] input::-moz-range-track {
	background: #222;
	border: 1px solid #444;
	border-radius: 0;
	cursor: pointer;
	height: 10px;
	width: 100%;
}
div[id|="numberslider-body"] input::-moz-range-thumb {
	background: #35a;
	border: 1px solid #57c;
	border-radius: 0;
	cursor: pointer;
	height: 18px;
	width: 33px;
}
div[id|="numberslider-body"] input::-ms-track {
	background: transparent;
	border-color: transparent;
	color: transparent;
	cursor: pointer;
	height: 10px;
	width: 99%; /* fallback for MS browsers without support for calc() */
	width: calc(100% - 1px);
}
div[id|="numberslider-body"] input::-ms-fill-lower {
	background: #222;
	border: 1px solid #444;
	border-radius: 0;
}
div[id|="numberslider-body"] input::-ms-fill-upper {
	background: #222;
	border: 1px solid #444;
	border-radius: 0;
}
div[id|="numberslider-body"] input::-ms-thumb {
	background: #35a;
	border: 1px solid #57c;
	border-radius: 0;
	cursor: pointer;
	height: 16px;
	width: 33px;
}
/* twine-user-stylesheet #28: "shake-macro-set.css" */
/*! <<shake>> macro set for SugarCube 2.x */
@-webkit-keyframes shakeanim {
	0% { -webkit-transform: translate(2px, 1px) rotate(0deg); }
	10% { -webkit-transform: translate(-1px, -2px) rotate(-1deg); }
	20% { -webkit-transform: translate(-3px, 0px) rotate(1deg); }
	30% { -webkit-transform: translate(0px, 2px) rotate(0deg); }
	40% { -webkit-transform: translate(1px, -1px) rotate(1deg); }
	50% { -webkit-transform: translate(-1px, 2px) rotate(-1deg); }
	60% { -webkit-transform: translate(-3px, 1px) rotate(0deg); }
	70% { -webkit-transform: translate(2px, 1px) rotate(-1deg); }
	80% { -webkit-transform: translate(-1px, -1px) rotate(1deg); }
	90% { -webkit-transform: translate(2px, 2px) rotate(0deg); }
	100% { -webkit-transform: translate(1px, -2px) rotate(-1deg); }
}
@-o-keyframes shakeanim {
	0% { -o-transform: translate(2px, 1px) rotate(0deg); }
	10% { -o-transform: translate(-1px, -2px) rotate(-1deg); }
	20% { -o-transform: translate(-3px, 0px) rotate(1deg); }
	30% { -o-transform: translate(0px, 2px) rotate(0deg); }
	40% { -o-transform: translate(1px, -1px) rotate(1deg); }
	50% { -o-transform: translate(-1px, 2px) rotate(-1deg); }
	60% { -o-transform: translate(-3px, 1px) rotate(0deg); }
	70% { -o-transform: translate(2px, 1px) rotate(-1deg); }
	80% { -o-transform: translate(-1px, -1px) rotate(1deg); }
	90% { -o-transform: translate(2px, 2px) rotate(0deg); }
	100% { -o-transform: translate(1px, -2px) rotate(-1deg); }
}
@keyframes shakeanim {
	0% { transform: translate(2px, 1px) rotate(0deg); }
	10% { transform: translate(-1px, -2px) rotate(-1deg); }
	20% { transform: translate(-3px, 0px) rotate(1deg); }
	30% { transform: translate(0px, 2px) rotate(0deg); }
	40% { transform: translate(1px, -1px) rotate(1deg); }
	50% { transform: translate(-1px, 2px) rotate(-1deg); }
	60% { transform: translate(-3px, 1px) rotate(0deg); }
	70% { transform: translate(2px, 1px) rotate(-1deg); }
	80% { transform: translate(-1px, -1px) rotate(1deg); }
	90% { transform: translate(2px, 2px) rotate(0deg); }
	100% { transform: translate(1px, -2px) rotate(-1deg); }
}
.shake-block,
.shake {
	-webkit-animation-duration: 0.8s;
	     -o-animation-duration: 0.8s;
	        animation-duration: 0.8s;
	-webkit-animation-iteration-count: infinite;
	     -o-animation-iteration-count: infinite;
	        animation-iteration-count: infinite;
	-webkit-animation-name: shakeanim;
	     -o-animation-name: shakeanim;
	        animation-name: shakeanim;
	-webkit-animation-timing-function: linear;
	     -o-animation-timing-function: linear;
	        animation-timing-function: linear;
	-webkit-transform-origin: 50% 50%;
	    -ms-transform-origin: 50% 50%;
	     -o-transform-origin: 50% 50%;
	        transform-origin: 50% 50%;
}
.shake-block {
	display: block;
}
.shake {
	display: inline-block;
}
</style><script role="script" id="twine-user-script" type="text/twine-javascript">/* twine-user-script #1: "1_support-functions.js" */
const V = variables; /* for convenience */

predisplay['set-return-variable'] = function () {
	// "Long return" functionality, for menus and other situations where the player may jump through multiple side-passages before returning to the main story. See the SugarCube documentation for more details.
	if (!tags().includes('noreturn')) {
		State.variables['return'] = passage();
	}
};

window.puppets = function puppets () {
	return V().puppets.filter(function(p) { return p !== null });
};

window.enemies = function enemies () {
	return V().enemies.filter(function(p) { return p !== null });
};

const target = function target () {return State.variables.target;}
const subject = function subject () {return State.variables.subject;}
const action = function action () {return State.variables.action;}
window.target = target; window.subject = subject; window.action = action;

window.getActor = function getActor(x) {
	var targets = [];
	var id;
	var actor;
	switch(x) {
		case "target": id = target() !== undefined ? target().id : undefined; break;
		case "subject": id = subject() !== undefined ? subject().id : undefined; break;
		case "actor": id = V().B.actor !== undefined ? V().B.actor.id : undefined; break;
		default: console.log("ERROR in getActor: invalid argument");
	}
	if (id !== undefined) {
		actor = getActorById(id);
		switch(x) {
			case "target": V().target = actor; break;
			case "subject": V().subject = actor; break;
			case "actor": V().B.actor = actor; break;
			default: console.log("ERROR in getActor: invalid argument");
		}
	}
	return;
};

const getActorById = function (id) {
	var targets = [];
	var actor;
	if (id !== undefined) {
		switch(id.charAt(0)) {
			case "p": targets = State.variables.puppets; break;
			case "e": targets = State.variables.enemies; break;
			default: console.log("ERROR: Target ID does not match any known party."); return;
		}
		actor = targets.find(function(t) { return t && t.id === id; });
	}
	return actor;
};
window.getActorById = getActorById;

const chainBattleGrid = function (grid) {
	console.assert(grid instanceof Array,`ERROR in chainBattleGrid: non-array passed`);
	for (let row of grid) {
		for (let cell of row) {
			if (cell.contents instanceof Actor) {
				cell.contents = getActorById(cell.contents.id);
			}
		}
	}
};
window.chainBattleGrid = chainBattleGrid;

window.encounters = function encounters () {
	return V().encounters;
};

const animationsOn = function () {
	return (setup.ANIMATIONS === true && temporary().queue instanceof Set);
};
window.animationsOn = animationsOn;

const StatName = function (statName) {
	if (typeof(statName) === "string") {
		switch (statName) {
			case 'def':
				statName = "Defense";
				break;
			case 'atk':
				statName = "Attack";
				break;
			case 'spc':
				statName = "Special";
				break;
			case 'spd':
				statName = "Speed";
				break;
			case 'intv':
				statName = "Initiative";
				break;
		}
		return setup.STAT_NAMES[statName];
	} else {
		return setup.STAT_NAMES;
	}
}
window.StatName = StatName;

const StatMin = function (statName) {
	if (typeof(statName) === "string") {
		switch (statName) {
			case 'def':
				statName = "Defense";
				break;
			case 'atk':
				statName = "Attack";
				break;
			case 'spc':
				statName = "Special";
				break;
			case 'spd':
				statName = "Speed";
				break;
			case 'intv':
				statName = "Initiative";
				break;
		}
		return setup.STAT_MIN[StatName(statName)];
	} else {
		return setup.STAT_MIN;
	}
}
window.StatMin = StatName;

const StatMax = function (statName) {
	if (typeof(statName) === "string") {
		switch (statName) {
			case 'def':
				statName = "Defense";
				break;
			case 'atk':
				statName = "Attack";
				break;
			case 'spc':
				statName = "Special";
				break;
			case 'spd':
				statName = "Speed";
				break;
		}
		return setup.STAT_MAX[StatName(statName)];
	} else {
		return setup.STAT_MAX;
	}
}
window.StatMax = StatMax;

Map.prototype.inc = function (key,amt) {
	this.set(key,this.get(key)+amt);
	return;
};

window.deadCount = function deadCount (party = puppets()) {
	let count = 0;
	party.forEach(function(actor) {
		if (actor.dead) {
			count++;
		}
	});
	return count;
};

function convertFunction (v) {
	return (v instanceof Function) ? v() : v;
}

/*
	Number-To-Words module
	Converts a number, which must be a safe integer, into its short scale word equivalent.

	USAGE:
		numberToWords(4269)   →  four thousand two hundred sixty-nine
		numberToWords(-4269)  →  negative four thousand two hundred sixty-nine
*/
!function(){"use strict";function isTruthy(number){return!!number}function chunk(number){for(var thousands=[];number>0;)thousands.push(number%1e3),number=Math.floor(number/1e3);return thousands}function toEnglish(number){if(number<20)return UNDER_TWENTY[number-1];var hundreds,tens,ones,words=[];return number<100?(ones=number%10,tens=number/10|0,words.push(TENS[tens-1]),words.push(toEnglish(ones)),words.filter(isTruthy).join("-")):(hundreds=number/100|0,words.push(toEnglish(hundreds)),words.push(HUNDRED),words.push(toEnglish(number%100)),words.filter(isTruthy).join(" "))}function appendScale(chunk,i){if(chunk)return[chunk,SCALES[i-1]].filter(isTruthy).join(" ")}function numberToWords(number){if(!Number.isSafeInteger(number))throw new Error("numberToWords number parameter must be a safe integer");return 0===number?ZERO:(number<0?NEGATIVE+" ":"")+chunk(Math.abs(number)).map(toEnglish).map(appendScale).filter(isTruthy).reverse().join(" ")}var NEGATIVE="negative",ZERO="zero",UNDER_TWENTY=["one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"],TENS=["ten","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"],HUNDRED="hundred",SCALES=["thousand","million","billion","trillion","quadrillion"];window.numberToWords=numberToWords}();

// Controlled axis fixed element hack by Richard Harrison
// @Note: not sure e.pageX will work in IE8
(function(window){
  if (true) {
		// A full compatability script from MDN:
		var supportPageOffset = window.pageXOffset !== undefined;
		var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");

		// Set up some variables
		var statusbar;
		var noHorizontal;
		var noVertical;
		// Add an event to the window.onscroll event
		window.addEventListener("scroll", function() {

		statusbar = document.getElementById("status");
		noHorizontal = document.getElementById("noHorizontal");
		noVertical = document.getElementById("noVertical");

		// A full compatability script from MDN for gathering the x and y values of scroll:
		var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
		var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

		if (noHorizontal) {
			noHorizontal.style.left = -x + 1250 + "px";
		}
		if (statusbar) {
			statusbar.style.left = -x + 1020 + "px";
		}
		if (noVertical) {
			noVertical.style.top = -y + 50 + "px";
		}
	});
  }
})(window);

(function(window){
  if (true) {

		// Set up some variables
		var popup;
		var actionList;
		// Add an event to the window.mousemove event
		window.addEventListener("mousemove", function(e) {

			popup = document.getElementById("actionBox");

			if (popup) {
				popup.style.left = e.clientX - $("#content").position().left + 10 + "px";
				popup.style.top = e.clientY + (popup.offsetHeight/2) > window.innerHeight ?
					window.innerHeight - popup.offsetHeight - 1 + "px" : e.clientY - (popup.offsetHeight/2) + "px"
				actionList = document.getElementById("actionList");
				if (actionList) {
					actionList.addEventListener("scroll", function() {
						popup.style.visibility = "hidden";
					});
				}
			}
		});
	}
})(window);

/* Shorthand notation for player inventory. Set this to return whatever you want to call your inventory variable in-game, and it will work without needing to edit any of the code. */
/* By default, the inventory variable is the story variable "$inventory" and is defined in StoryInit. To give characters unique inventories, you could define inventories as attributes of the Actor class and set this to return "this.inventory". */
var inv = function inv () {return V().inventory;}
window.inv = inv;

window.reverseChildren = function reverseChildren(parent) {
// Code by Ayman Abdel-Rahman
    for (var i = 1; i < parent.childNodes.length; i++){
        parent.insertBefore(parent.childNodes[i], parent.firstChild);
    }
};

window.guardCheck = function guardCheck (index) {
	if (index < 0 || index >= V().enemies.length) {
		console.log("ERROR in guardCheck: index out of bounds");
		index = Math.clamp(index,0,V().enemies.length-1);
	}
	if (setup.BATTLE_GRID != true) {
		return true;
	}
	else if (index >= setup.ROW_SIZE && V().enemies[index-setup.ROW_SIZE] !== null && !V().enemies[index-setup.ROW_SIZE].dead) {
		// Guarded by character in next row up, cannot be targeted
		return false;
	}
	else if (index >= setup.ROW_SIZE * 2) {
		// No immediate guard (previous check failed), but not in front two rows, so another guard is possible. Move up a row and check again.
		return guardCheck(index-setup.ROW_SIZE);
	}
	else {
		return true;
	}
};

// textWidth function
setup.textWidth = function(text, bold, size) {
    /* create the <span> to measure the text width */
	if (bold === undefined) {
		bold = "normal";
	}
	else if (bold === true) {
		bold = "bold";
	}
	if (size === undefined || typeof(size) != 'number') {
		size = "12pt";
	} else {
		size = Number.toString(size) + "px";
	}
    var tElement = jQuery(`<span style="font-weight: ${bold}">` + String(text) + "</span>");
    /* add it (hidden) to the end of the document's body so that
       the browser updates its width and we can save it */
    tElement.hide().appendTo(document.body);
    var width = tElement.width();
    /* clean up */
    tElement.remove();
    return width;
};

setup.scaledTextDiv = function(text, width, mods = {}, print) {
  var tWidth = setup.textWidth(text, mods.bold, mods.size);
	if (print !== undefined) {
		text = print;
	}
    if (temporary().enemy !== undefined && temporary().enemy.large) {
		return `<div>${text}</div>`;
	} else if(tWidth < width) {
        return `<div style="width: ${width}px; overflow: hidden;"><span style="display: inline-block; white-space: nowrap;">${text}</span></div>`;
    } else {
        return `<div style="width: ${width}px; overflow: hidden;"><span style="display: inline-block; white-space: nowrap; transform: translate(-50%, 0) scaleX(${width / tWidth}) translate(50%, 0);">${text}</span></div>`;
    }
};

setup.NAME_LENGTH = 120;	// length of the actor name in actor block, in px


/*! <<numberboxplus>> and <<textboxplus>> macros for SugarCube v2 */
!function(){
	"use strict";
	var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};
	if("undefined"==typeof version||void 0===version.title||"SugarCube"!==version.title||void 0===version.major||version.major<2||void 0===version.minor||version.minor<32)throw new Error("<<numberboxplus>> macro requires SugarCube 2.32.0 or greater, aborting load");

	Macro.add(['numberboxplus', 'textboxplus'], {
		isAsync : true,
		tags		: null,

		handler	:	function() {
			var _this = this;
			if (this.args.length < 2) {
				const errors = [];
				if (this.args.length < 1) { errors.push('variable name'); }
				if (this.args.length < 2) { errors.push('default value'); }
				return this.error(`no ${errors.join(' or ')} specified`);
			}

			// Ensure that the variable name argument is a string.
			if (typeof this.args[0] !== 'string') {
				return this.error('variable name argument is not a string');
			}

			var varName = this.args[0].trim();

			// Try to ensure that we receive the variable's name (incl. sigil), not its value.
			if (varName[0] !== '$' && varName[0] !== '_') {
				return this.error(`variable name "${this.args[0]}" is missing its sigil ($ or _)`);
			}

			// Custom debug view setup.
			if (Config.debug) {
				this.debugView.modes({ block : true });
			}

			var asNumber     = this.name === 'numberboxplus';
			var defaultValue = asNumber ? Number(this.args[1]) : this.args[1];

			if (asNumber && Number.isNaN(defaultValue)) {
				return this.error(`default value "${this.args[1]}" is neither a number nor can it be parsed into a number`);
			}

			var varId = Util.slugify(varName);
			var el    = document.createElement('input');
			let autofocus = false;
			let passage;

			if (this.args.length > 3) {
				passage   = this.args[2];
				autofocus = this.args[3] === 'autofocus';
			}
			else if (this.args.length > 2) {
				if (this.args[2] === 'autofocus') {
					autofocus = true;
				}
				else {
					passage = this.args[2];
				}
			}

			if (typeof passage === 'object') {
				// Argument was in wiki link syntax.
				passage = passage.link;
			}

			// Set up and append the input element to the output buffer.
			jQuery(el)
				.attr({
					id       : `${this.name}-${varId}`,
					name     : `${this.name}-${varId}`,
					type     : asNumber ? 'number' : 'text',
					tabindex : 0 // for accessiblity
				})
				.addClass(`macro-${this.name}`)
				.on('change.macros', this.createShadowWrapper(function () {
					State.setVar(varName, asNumber ? Number(this.value) : this.value);
				}))
				.on('keypress.macros', this.createShadowWrapper(function () {
					// If Return/Enter is pressed, set the variable, execute contents and, optionally, forward to another passage.
					var contents=_this.payload[0].contents.trim();
					return function (ev) {
						if (ev.which === 13) { // 13 is Return/Enter
							ev.preventDefault();
							State.setVar(varName, asNumber ? Number(this.value) : this.value);

							if (contents !== "") {
								Wikifier.wikifyEval(contents);
							}

							if (passage != null) { // lazy equality for null
								Engine.play(passage);
							}
						}
					}
				}()))
				.appendTo(this.output);

			// Set the variable and input element to the default value.
			State.setVar(varName, defaultValue);
			el.value = defaultValue;

			// Autofocus the input element, if requested.
			if (autofocus) {
				// Set the element's "autofocus" attribute.
				el.setAttribute('autofocus', 'autofocus');

				// Set up a single-use post-display task to autofocus the element.
				postdisplay[`#autofocus:${el.id}`] = task => {
					delete postdisplay[task]; // single-use task
					setTimeout( function () {
						return el.focus();
					}, Engine.minDomActionDelay);
				};
			}
		}
	});
}();

$(document).on(":all-animations-done", function () {
	if (V().inbattle) {
		temporary().showDead = true;
		$.wiki('<<update>>');
		temporary().queue.forEach(function (actor) {
			delete actor._displayHP;
		})
	}
});

// animateCSS function, by animate.style team
const animateCSS = (element, animation, time, prefix = 'animate__') =>
  // We create a Promise and return it
  new Promise((resolve, reject) => {
    const animationName = `${prefix}${animation}`;
    const node = document.querySelector(element);
		const duration = typeof(time) == "string" ? time : node.style.getPropertyValue('--animate-duration');

		node.style.setProperty('--animate-duration', duration);
    node.classList.add(`${prefix}animated`, animationName);

    // When the animation ends, we clean the classes and resolve the Promise
    function handleAnimationEnd() {
      node.classList.remove(`${prefix}animated`, animationName);
			if (typeof(temporary().animationsComplete) == "number") {temporary().animationsComplete++;}
			if ($('#continue') !== undefined && temporary().animationsComplete >= temporary().animationsToComplete) {
					$("#continue .macro-button").each((index, element) => {
						element.disabled = false;
					});
					$.event.trigger(":all-animations-done");
			}
      resolve('Animation ended');
    }

    node.addEventListener('animationend', handleAnimationEnd, {once: true});
  });
window.animateCSS = animateCSS;

const resetAnimation = (element, animation) => {
	const animationName = "animate__"+animation;
	const node = document.querySelector(element);
	node.classList.remove(animationName);
	setTimeout(function () {
		node.classList.add(animationName);
	},10);
}
window.resetAnimation = resetAnimation;
/* twine-user-script #2: "2_action-functions.js" */
// Common action types to make assignments quicker. These are also saved to Twine variables so they can be used in the enemy actions passage.

// Most actions have an "extension" variable that allows for greater modularity. Anything passed into the extension variable is appended to the normal result, and can incorporate any text or SugarCube code, including the result of other action functions. You can use extensions to "chain" the effects of multiple action types in this way.
// Extensions can also be passed as a function; the function will be called and converted into its return string. This is to enable chaining of action functions that return a function, which is necessary for those that use findTarget.

function findTarget (selector) {
//	Targeting code: Actions target character specified by the target variable by default, but you can make this explicit with a 't' argument. To target self, pass 's'. To target opposing party (enemies if used by a puppet, puppets if used by an enemy), pass 'mass', 'e', or 'enemies'. To target allied party, pass 'a' or 'allies'.
//	Returns three variables, target, party, and mass. This means you must assign the variables the same way, through a two-element array.
//	IMPORTANT: Any action that uses this must RETURN A FUNCTION rather than calculating its results immediately. This is because the result will change depending on the active target and subject, so the function call itself must be renewed.

//	console.log("findTarget called, selector = "+selector);
	var targetName;
	var party;
	var mass = false;
	if (selector == 'mass' || selector == 'e' || selector == 'enemies'){
		if (subject() instanceof Puppet) {
			party = "$enemies";
		} else if (subject() instanceof Enemy) {
			party = "$puppets";
		}
		targetName = "$target";
		mass = true;
	} else if (selector == 'a' || selector == 'allies') {
		if (subject() instanceof Puppet) {
			party = "$puppets";
		} else if (subject() instanceof Enemy) {
			party = "$enemies";
		}
		targetName = "$target";
		mass = true;
	} else if (selector == 'all') {
		party = "$B.actors"
		targetName = "$target";
		mass = true;
	} else if (selector == 's'){
		targetName = "$subject";
		if (State.getVar(targetName) !== null) {
			switch (State.getVar(targetName).id.charAt(0)) {
				case 'p':
					party = "$puppets";
					break;
				case 'e':
					party = "$enemies";
					break;
			}
		}
	} else if (selector === undefined || selector == 't'){
		targetName = "$target";
		if (State.getVar(targetName) !== null) {
			switch (State.getVar(targetName).id.charAt(0)) {
				case 'p':
					party = "$puppets";
					break;
				case 'e':
					party = "$enemies";
					break;
			}
		}
	} else {
		console.log("ERROR in findTarget: invalid selector");
	}
	return [targetName,party,mass];
}


const justdmg = function justdmg (extension = "",mods = {}) {
	var result = `<<echoDamage>>`;
	if (mods.counter === true) {
		result = `<<set _counterActive = true>>`+result;
	}
	return function () {
		if (extension instanceof Function) {
			result += extension();
		} else {
			result += extension;
		}
		return result;
	}
};

const heal = function heal (test,extension = "") {
//	test = Boolean; set true to have the function return only the healing value. Useful if you just want to quickly calculate the result of the healing formula.

	return function () {
		if (extension instanceof Function){
			extension = "<br/>" + extension();
		}
		if (target().healBlock) {
			return `${target().name} cannot be healed!`;
		} else {
			return `<<healCalc>>\
			<<if setup.ANIMATIONS === true && _queue instanceof Set>>\
				<<set _queue.add(target())>>\
				<<set target().battleMsg.push({type: "healing", content: $heal})>>\
			<</if>>\
			<<run target().hp += $heal>>\
			${target().name} recovers $heal HP!`+extension;
		}
	}
};

const manaBurn = function (args = {target: 't'},extension = "") {
	//	Function for abilities that damage mana/energy/whatever.
	//	Works with the manaBurn widget; see Damage and Formulas for details.

	//args = object with the following properties:
	//	target = string. Defaults to 't'. See findTarget for details.
	//	dmg = Boolean. If true, echoDamage will be appended to result.

	if (args.target === undefined) {
		args.target = 't';
	}

	return function () {

		var [targetName,party] = findTarget(args.target);
		content = "<<manaBurn>>";
		var targ = State.getVar(targetName);
		if (extension instanceof Function){
			extension = extension();
		}

		if (args.dmg === true) {
			return `<<echoDamage>>`+content+extension;
		} else {
			return content+extension;
		}
	}

};

const applyEffect = function applyEffect (effects, args = {}, extension = "") {
//	Function for abilities that apply status effects.

//	effects is a string or array of strings corresponding to the effects to apply. Duration, power, and target will be the defaults. For more complex behavior, use Actor.addEffect directly.

//args is object with following properties:
//	dmg = Boolean. If true, echoDamage widget prepended to result.
//	self = Boolean. If true, effect is applied to subject instead of target.

//	extension = string. Additional SugarCube code appended to the end of the result. For AoE attacks, this is only appended once, after the entire loop.

	return function () {

	effects = (effects || action().effects);
	console.assert(effects instanceof Array || typeof(effects) == 'string',"ERROR in applyEffect: invalid effects argument");
	if (typeof(effects) == 'string') {
		effects = [effects];
	}
	if (extension instanceof Function){
		extension = extension();
	}

	var effectTarget;
	effectTarget = args.self === true ? "$subject" : "$target";
	var content = "";

	effects.forEach(function (effect) {
		console.assert(typeof(effect) == "string","ERROR in applyEffect: effect undefined or non-string");
		content += `<<print ${effectTarget}.addEffect("${effect}")>>`;
	});

	if (args.dmg === true) {
		return `<<echoDamage>>`+content+extension;
	} else {
		return content+extension;
	}

	}
};

const removeEffect = function (args = {target: 't'}, extension = "") {
//	Function for removal of specific status effects, e.g. through the status cure items.
//	By default, removes both buffs AND ailments if type is "all".

//args = object with the following properties:
//	effects = array. Name of effect(s) to remove.
//		Include "all" to remove all effects; "buffs" to remove all buffs; "ailments" to remove all ailments; "conditional" to remove buffs if used on enemy and ailments if used on ally
//		defaults to the action's "effects" property, or "all" if that is undefined
//	target = string. Defaults to target if unset. See findTarget for details.
//	removeStack = Boolean. Set true to remove all instances of a stackable effect.
//	unsticky = Boolean. Allows cure to remove sticky effects (but not ULTIMATESTICKY)
//	pierce = Boolean. Allows effect removal through Stasis.
//	perExtension = string. Extension to be added within each iteration of a mass targeting loop.

	if (typeof(args.effects) === "string") {
		args.effects = [args.effects];
	}

	if (args.target === undefined) {
		args.target = 't';
	}

	return function () {
		args.effects = (args.effects || action().effects || ["all"]);
		var condition = `true`;	//filter for effects, by default selects all effects
		var perExtension = args.perExtension;
		temporary().mods = args;	//will be passed to removeEffect execution in SugarCube

		var [targetName,party,mass] = findTarget(args.target);

		if (args.effects.includes("conditional")) {
			condition = `($subject.id.charAt(0) === ${targetName}.id.charAt(0) && !_effect.buff) || ($subject.id.charAt(0) !== ${targetName}.id.charAt(0) && _effect.buff)`;
		} else if (args.effects.includes("ailments")) {
			condition = `!_effect.buff`;
		} else if (args.effects.includes("buffs")) {
			condition = `_effect.buff`;
		} else if (!args.effects.includes("all")) {
			temporary().removedEffects = args.effects;
			condition = `_removedEffects.includes(_effect.name)`;
		}

		if (extension instanceof Function) {
			extension = extension();
		}

		if (perExtension === undefined) {
			perExtension = "";
		}
		if (args.perExtension instanceof Function) {
			perExtension = args.perExtension();
		}

		var content = "";

		content += `<<for _effect range ${targetName}.effects>>\
		<<if ${condition}>>\
			<<print ${targetName}.removeEffect(_effect,_mods)>>\
		<</if>>\
		<</for>>`;

		if (mass === true) {
			return `<<for _a range ${party}>>\
				<<set $target = _a>>`+
					content+perExtension+
			`<</for>>`+extension;
		} else {
			return content+extension;
		}
	}
};

const massAttack = function massAttack (args = {target: 'enemies', content: `<<echoDamage>>`},extension = "") {
//	Function for attacks that target an entire party. By default, characters with the "guarded" flag are immune to this ability.
//	The extension for this function is executed only once, after the loop.

//args = object with the following properties:
//	target = string. Defaults to 'enemies'. See findTarget for details.
//	content = string. Code to be executed on each character of the party. Defaults to echoDamage.
//	cut = Boolean. Set to true to divide damage by the number of living characters. This will automatically add an instance of damage before each set of content.
//	type = string. Used to denote special AoE attacks if the battle grid is active. Can be row, column, adjacent (+ shape), or all.

	return function () {

	//	console.log("massAttack after inner function call, arguments:"); console.log(args);
	if (args.target === undefined) {
		args.target = "enemies";
	}
	if (args.type === undefined) {
		args.type = action().area;
	}
	var content = args.content;
	if (args.content === undefined) {
		content = `<<echoDamage>>`;
	} else if (args.content instanceof Function){
//		console.log("content is a function");
		content = args.content();
	}
	if (extension instanceof Function){
		extension = extension();
	}

	var result = `<<set _AoE = true>>`;

	var [targetName,partyName] = findTarget(args.target);
	var party = State.getVar(partyName);
	party = party.filter(function (a) { return a && !a.areaImmune });
	if (args.cut === true) {
		var count = 0;
		party.forEach(function(actor) {
				count++;
		});
		var prepend = `<<damageCalc>>\
		<<set $dmg = Math.round($dmg/${count})>>\
		<<echoDamage "nocalc">>`;
		content = prepend+content;
	}
	if (typeof(args.type) == 'string') {
		if (V().B.override_AoE) {
			result += content;
		}
		switch (args.type.toLowerCase()) {
			case 'row':
				temporary().party = party.filter(function (a) { return a && a.row === target().row });
				result += `<<for _actor range _party>>\
							<<set $target = _actor>>\
							${content}\
					<</for>>`;
				break;
			case 'col':
			case 'column':
				temporary().party = party.filter(function (a) { return a && a.col === target().col });
				result += `<<for _actor range _party>>\
							<<set $target = _actor>>\
							${content}\
					<</for>>`;
				break;
			case 'adjacent':
			case '+':
				temporary().party = party.filter(function (a) { return a && (
					(a.id === target().id) ||
					(a.col === target().col && (a.row === target().row + 1 || a.row === target().row - 1)) ||
					(a.row === target().row && (a.col === target().col + 1 || a.col === target().col - 1))
					)})
				result += `<<for _actor range _party>>\
							<<set $target = _actor>>\
							${content}\
					<</for>>`;
				break;
			default:
				result += `<<for _actor range ${partyName}>>\
						<<set $target = _actor>>\
						${content}\
				<</for>>`;
				break;
		}
	}
	else {
		result += `<<for _actor range ${partyName}>>\
				<<set $target = _actor>>\
				${content}\
		<</for>>`;
	}
	return result+extension;

	}
};

const splashDamage = function splashDamage (args = {target: 't', cut: 1}, extension) {
//	Function for "splash damage" attacks that inflict less damage to indirect targets, e.g. Grenade items.

//args = object with the following properties:
//	target = string. Defaults to 't'. See findTarget for details.
//	cut = number, damage against other targets is divided by this number.

	return function () {

	if (args.target === undefined) {
		args.target = 't';
	}
	console.assert(Number.isFinite(args.cut),"ERROR in splashDamage: cut value undefined or nonnumber");

	var [targetName,party] = findTarget(args.target);

	if (extension === undefined) {
		extension = "";
	} else if (extension instanceof Function){
		extension = extension();
	}

	return `<<echoDamage>>\
	<<set _temp = $target">\
	<<for _actor range ${party}>>\
	<<if !_actor.dead && _actor.id != _temp.id && !_actor.areaImmune>>\
	<<set $target = _actor>>\
	<<damageCalc>>\
	<<set $dmg = Math.round($dmg/${args.cut})>>\
	<<echoDamage "nocalc">>\
	<</if>>\
	<</for>>`+extension;

	}
};

const removeLastEffect = function removeLastEffect (args) {
//	Removes the last buff of the target. For e.g. Off Your High Horse

	return function () {
		if (!target().dead && !target().stasis) {
			temporary().effect = target().effects.filter(function (eff) { return eff && eff.buff && !eff.sticky }).last();
			if (temporary().effect instanceof Effect) {
				return `<<print target().removeEffect(_effect)>>`;
			}
		}
	}
};

window.dispelCalc = function dispelCalc () {
//	Calculates how many effects to remove with dispel abilities. Run automatically during the dispel function.

	if (target().stasis != true) {
		// Stasis blocks any effect changes, so it blocks this too.
		var effects = target().effects;
		// This is done just so you don't have to write out the longer name
		var e = V().effects_to_remove;
		for (var i = effects.length-1; i >= 0; i--) {
			if (e <= 0) {
				break;
				// The number of effects removed by Neutralize/Restoration varies depending on energy invested. If there are more effects than the spell can remove, we end the function here. Otherwise the spell would clear all effects regardless of strength!
			}
			if (target() instanceof Puppet) {
				if (!effects[i].buff && !effects[i].sticky) {
					// Because there are fewer buffs than debuffs, a single "buff" flag is used to distinguish them. We only want Restoration to remove debuffs, so it will only trigger the removal code if the effect's buff flag is NOT true.
					// You may also want some effects to be irremovable. This is the purpose of the "sticky" flag, which is set in the effects database.
					V().removed_effects.push(effects[i]);
					e--;
				}
			} else if (target() instanceof Enemy) {
				if (effects[i].buff && !effects[i].sticky) {
					// Because there are fewer buffs than debuffs, a single "buff" flag is used to distinguish them. We only want Restoration to remove debuffs, so it will only trigger the removal code if the effect's buff flag is NOT true.
					// You may also want some effects to be irremovable. This is the purpose of the "sticky" flag, which is set in the effects database.
					V().removed_effects.push(effects[i]);
					e--;
				}
			}
		}
	}
};

const dispel = function () {
	dispelCalc();
	if ((target() instanceof Puppet) && (subject() instanceof Puppet)) {
		V().B.heal_used = true;
	}
	return `<<for _effect range $removed_effects>>`+
	`<<print target().removeEffect(_effect)>>`+
	`<</for>>`+
	`<<set $removed_effects = []>>`;
};

const pushAttack = function pushAttack (args = {target: 't'},extension = "") {
//	Function for abilities that move characters in the battle grid. Only works if BATTLE_GRID is enabled. Will only move characters if the target square is unoccupied (null or dead).
//	NOTE: BATTLE_GRID is set in StoryInit, which is excuted after this file. This means this function can only be called within a function if assigned as a property of an action.

//args = object with the following properties:
//	target = string. Defaults to 't'. See findTarget for details.
//	direction = strings "forward", "up", "pull", "back", "down", "push", "left", or "right". Moves target in the stated direction.
//		-direction can also be a 2-element array corresponding to grid coordinate; if so, target will be moved to that coordinate.
//	offset = integer. Number of tiles to move. Defaults to 1.

	console.assert(typeof(args.direction) == 'string' || args.direction instanceof Array,`ERROR in pushAttack: invalid direction`);

	if (args.target === undefined) {
		args.target = 't';
	}

	return function () {

		var [targetName,party] = findTarget(args.target);
		result = "";
		var targ = State.getVar(targetName);
		if (extension instanceof Function){
			extension = extension();
		}
		if (target.unmovable) {
			return `${targ.name} can't be moved!<br/>${extension}`;
		}

		var offset = args.offset;
		if (Number.isInteger(args.offset) && args.offset > 0) {
			offset = args.offset;
		} else {
			offset = 1;
		}
		if (typeof(args.direction) == 'string') {
			switch (args.direction.toLowerCase()) {
				case "forward":
				case "up":
				case "pull":
					for (let i = 1; i <= offset; i++) {
						try {
							targ.pos = [targ.row-1][targ.col];
						} catch (e) {
							result = `${targ.name} couldn't be moved!`;
							break;
						}
					}
					break;
				case "back":
				case "down":
				case "push":
				for (let i = 1; i <= offset; i++) {
					try {
						targ.pos = [targ.row+1][targ.col];
					} catch (e) {
						result = `${targ.name} couldn't be moved!`;
						break;
					}
				}
					break;
				case "left":
				for (let i = 1; i <= offset; i++) {
					try {
						targ.pos = [targ.row][targ.col-1];
					} catch (e) {
						result = `${targ.name} couldn't be moved!`;
						break;
					}
				}
					break;
				case "right":
				for (let i = 1; i <= offset; i++) {
					try {
						targ.pos = [targ.row][targ.col+1];
					} catch (e) {
						result = `${targ.name} couldn't be moved!`;
						break;
					}
				}
					break;
				default:
					return "ERROR invalid direction in pushAttack";
			}
		}
		if (result.length === 0) {
			result = `${target().name} moved!`;
		}

		return result+"<br/>"+extension;
	}
};

const cancelAction = function cancelAction (extension = "",mods = {}) {
	var result = "";

	return function () {
		if (target().setupAction instanceof Action) {
			if (target().interruptGuard) {
				result = `${target().name}'s held ${target().their} concentration!`;
			} else {
				target().setupAction = null;
				result = `${target().name}'s concentration was broken!`;
			}
		} else {
			result = `${target().name} didn't have a prepared action!`
		}
		if (extension instanceof Function) {
			result += extension();
		} else {
			result += extension;
		}
		return result;
	}
};

// PREVIEW FUNCTIONS

const Prev = {
	dmg: `<<damageCalc>>This attack will inflict $dmg damage.`,
	heal: function (args) {
		return function() {
			if (typeof(args) !== 'object') {
				args = {};
			}
			var gain = heal(true);
			if (args.revive) {
				if (target().dead) {
					gain = Math.round(target().maxHP * action().special);
					return `$target.name will revive with ${gain} HP.`;
				} else {
					return `${target().name} isn't defeated, so this won't do anything.`;
				}
			}
			else if (args.mass) {
				return `All allies will recover ${gain} HP.`;
			}
			else {
				return `${target().name} will recover ${gain} HP.`;
			}
		}
	},
	effect: function (type,extension) {
		return function () {
			var str;
			if (extension === undefined){
				str = "This";
			} else if (extension === 'dmg') {
				str = `<<damageCalc>>This will inflict $dmg damage and`;
			} else {
				str = extension;
			}
			var end = '.';
			var time = "";
			var phrase;
			var article;
			var E = new Effect(type);
			if (E.buff == true){
				phrase = " provide";
			} else {
				phrase = " inflict";
			}
			var tol = target().getTol(type);
			if (tol !== undefined && tol == 'immune') {
				str += " would";
				end = ", but <b>the target is immune</b>.";
			} else if (E.unblockable == false && target().stasis){
				str += " would";
				end = ", but <b>the target's effects are in Stasis</b>.";
			} else if (E.unblockable == false && E.buff != true && target().chi){
				str += " would";
				end = ", but <b>the target's Chi Shield will block it</b>.";
			} else if (type == "Stunned" && target().alert) {
				str += " would";
				end = `...but <b>the target is Alert, so ${target().they} won't fall for it</b>.`;
			} else {
				str += " will";
			}
			switch (type){
				case "ATK Boost":
				case "Injury":
					article = " an";
					break;
				case "DEF Boost":
				case "SPC Boost":
				case "Blessing":
				case "Headache":
				case "Curse":
					article = " a";
					break;
				default:
					article = "";
			}
			if (action().dur > 1){
				time = ` for ${action().dur} rounds`;
			}
		return str+phrase+article+` ${type}`+time+end;
		}
	},
	stance: function () {
		if (subject().stasis){
			return `$subject.name is in Stasis, so this won't do anything.`;
		}
		else {return "";}
	},
	multihit: function (hits,extension) {
		if (extension === undefined){
			extension = '.';
		}
		return `<<damageCalc>>This will inflict $dmg x ${hits} damage`+extension;
	},
	cleanse: function () {
		var str;
		dispelCalc();
		if (V().removed_effects.length > 0) {
			str = "This will remove ";
			V().removed_effects.forEach(function(effect,i){
				str += effect.name;
				if (i == (V().removed_effects.length-1)){
					str += '.';
				} else if (i == (V().removed_effects.length-2)){
					if (V().removed_effects.length == 2){
						str += ' and ';
					} else {
						str += ', and ';
					}
				} else {
					str += ', ';
				}
			});
		} else {
			str = "...This won't remove any effects! You can still cast it if you really want to, but it'll be a waste of a turn.";
		}
		V().removed_effects = [];
		// This is necessary for the actual action to work as intended; because it also draws on this variable, when dispelCalc() is called again it would double the array and cause the action to remove the effects twice.
		return str;
	},
	grenade: `<<damageCalc>>This will inflict $dmg damage to $target.name and half damage to other enemies.`,
	cure: function (type = "") {
		return function () {
			var str = `This will cure ${target().name} of ${type}`;
			if (type == "all") {
				str += " ailments.";
			} else {
				str += ".";
			}
			var found = false;
			target().effects.forEach(function(eff){
				if (eff.name == type){
					found = true;
				} else if (type == "all" && !eff.buff){
					found = true;
				}
			});
			if (!found){
				var t;
				if (type == "all"){
					t = 'any';
				} else {
					t = 'that ailment';
				}
				str += ` ...or it would, if they had ${t}! You can still use it, but it'll be a waste.`;
			} else if (target().stasis && (type != "Knocked Down")){
				str += ` ...but ${target().their} effects are held in Stasis, so nothing will happen.`;
			}
			return str;
		}
	},
	massAttack: function (type = "") {
		switch (type.toLowerCase()) {
			case 'row':
				return `<<for _i = (target().row - 1) * setup.ROW_SIZE; _i < (target().row * setup.ROW_SIZE); _i++>>\
						<<if $enemies[_i] !== null && !$enemies[_i].dead && !$enemies[_i].areaImmune>>\
							<<damageCalc $enemies[_i]>>\
							$enemies[_i].name will take <b>$dmg</b> damage<br/>\
						<</if>>\
					<</for>>`;
			case 'col':
			case 'column':
				return `<<for _i = (target().col - 1); _i < (setup.COLUMN_SIZE * setup.ROW_SIZE); _i += setup.ROW_SIZE>>\
						<<if $enemies[_i] !== null && !$enemies[_i].dead && !$enemies[_i].areaImmune>>\
							<<damageCalc $enemies[_i]>>\
							$enemies[_i].name will take <b>$dmg</b> damage<br/>\
						<</if>>\
					<</for>>`
			case 'adjacent':
			case '+':
				var hitlist = [V().enemies.indexOf(target()),			// center
					V().enemies.indexOf(target())-setup.ROW_SIZE,		// above
					V().enemies.indexOf(target())-1,					// left
					V().enemies.indexOf(target())+1,					// right
					V().enemies.indexOf(target())+setup.ROW_SIZE];		// below
				hitlist.deleteWith(function (targIdx,i) {
					// This will remove targets that are out of index bounds and left/right entries that jump rows
					return (targIdx < 0 || targIdx >= V().enemies.length || (i == 2 && target().col == 1) || (i == 3 && target().col == setup.ROW_SIZE));
				});
				State.temporary.hitlist = hitlist;
				return `<<for _t range _hitlist>>\
						<<if $enemies[_t] !== null && !$enemies[_t].dead && !$enemies[_t].areaImmune>>\
							<<damageCalc $enemies[_t]>>\
							$enemies[_t].name will take <b>$dmg</b> damage<br/>\
						<</if>>\
					<</for>>`;
			default:
				return `<<for _enemy range enemies()>>\
							<<if !_enemy.dead>>\
								<<damageCalc _enemy>>\
								_enemy.name will take <b>$dmg</b> damage<br/>\
							<</if>>\
						<</for>>`;
		}
	},
	cutAttack: function (type) {
		return function () {
			return `<<set _d = (setup.base + $subject.get(StatName("spc")))*$action.weight>>\
			This will inflict _d base damage and ${type} status, divided across the current number of enemies.`;
		}
	}
};


// DEPRECIATED as of version 1.11. Use the dmg flag in applyEffect instead.
const dmgandeffect = function dmgandeffect (target,type,dur) {

			if (dur === undefined){
				dur = "$action.dur";
			}
			if (target == 's'){
				target = "$subject";
			} else if (target == 't'){
				target = "$target";
			}
			return `<<echoDamage>><<addEffect ${target} "${type}" ${dur} $subject>>`;
};

// DEPRECIATED as of version 4.00. Multiple hit functionality now incorporated through action's "hits" property.
const multihit = function multihit (args = {},extension = "") {
//	Function for simple multi-hit abilities that only inflict damage, e.g. Rogue's Knife. For more complex abilities, use multihitCustom.

//Args = object with following properties:
//	hits = int. Number of attacks. If undefined or noninteger, will attempt to read the active action's hits property. If that fails, the function will return an error message.

//	Note that extension is applied only after ALL hits are done.

	return function () {
		var final = "<<echoDamage>>";
		if (!Number.isInteger(args.hits) && V().action !== null){
			args.hits = action().hits;
		}
		console.assert(Number.isInteger(args.hits),"ERROR in multihit: hits must be an integer");

		if (extension instanceof Function){
			extension = extension();
		}
		for (let h = 1; h < args.hits; h++) {
			final += "<<echoDamage>>";
		}
		return final+extension;
	}
};

// DEPRECIATED as of version 4.00. Functionality handled by Battle Phases and the spread and noRedundant Action properties.
const multihitCustom = function multihitCustom (args = {content: `<<echoDamage>>`},finalExtension = "") {
//	Function for more complex multi-hit abilities.

//args = object with following properties:
//	hits = int. Number of hits/applications of the content. If undefined or noninteger, will attempt to read the active action for a "_hits" property. If that fails, the function will return an error message.
//	content = string. Full content of actions to occur with each hit. Defaults to echoDamage.
//	spread = Boolean. If true, a new target will be chosen after each hit.
//	noRedundant = Boolean. If true, spread attacks will be unable to hit the same character multiple times. Spread behavior will be applied automatically even if spread parameter is not true.
//	finalExtension = string. SugarCube code to execute after ALL hits are completed. Only executes once.

	return function () {
		var content;
		if (args.content === undefined){
			content = `<<echoDamage>>`;
		} else if (args.content instanceof Function){
			content = content();
		}
		if (!Number.isInteger(args.hits) && V().action !== null){
			args.hits = action().hits;
		}
		console.assert(Number.isInteger(args.hits),"ERROR in multihitCustom: hits must be an integer");
		if (finalExtension instanceof Function){
			finalExtension = finalExtension();
		}
		var str = "";
		if (args.noRedundant === true) {
			if ((puppets().length - deadCount()) < args.hits) {
				args.hits = puppets().length - deadCount();
			}
			State.temporary.list = [];
			temporary().list.push(target().name);
			str += content;
			var subloop;
			for (let i = 1; i < args.hits; i++){
				subloop = `<<set _keepGoing = true>>\
						<<for _keepGoing>>\
							<<set $target = Hitlist.targetEnemy($action.targetMod)>>\
							<<if _list.includes(target().name)>>\
								<<set _keepGoing = true>>\
							<<else>>\
								<<set _keepGoing = false; _list.push(target().name)>>`+
								content+
							`<</if>>\
						<</for>>`;
				str += subloop;
			}
		} else {
			str += content;
			for (let i = 1; i < args.hits; i++){
				if (args.spread === true) {
					str += `<<set $target = Hitlist.targetEnemy($action.targetMod)>>`;
				}
				str += content;
			}
		}
		return str+finalExtension;
	}
};
/* twine-user-script #3: "class-action.js" */
window.Action = class Action {
	constructor(name){
	if (typeof(name) == 'object') {
		Object.keys(name).forEach(prop => this[prop] = clone(name[prop]));
	} else {
		this.name = name;
		if (Number.isInteger(this.actionData.uses)) { this._uses = new FillStat(this.actionData.uses); }
		if (Number.isInteger(this.actionData.cooldown)) { this._cd = new FillStat(this.actionData.cooldown); }
		if (Number.isInteger(this.actionData.warmup) && this.cd !== undefined) { this.cd = this.actionData.warmup; }

		if (this.name !== this.displayname) {
			for (let [pn,v] of Object.entries(this.actionData)) {
				this["_"+pn] = v;
			}
			this.name = this.displayname;
		}
	}
	}

	get actionData () {
		return (setup.actionData[this.name] || {});
	}

	get displayname () {
		//	Name of the action displayed in the player menu. This may be different from the action's name in the code.
		//	Useful for related families of actions that are very similar but require different names in the database (such as upgraded abilities).

		var val = this._displayname;
		if (val === undefined && setup.actionData[this.name] !== undefined) {
			val = setup.actionData[this.name].displayname;
		}
		if (val === undefined) {
			val = this.name;
		}
		return val;
	}

	set displayname (val) {
		console.assert(typeof(val) == "string",`ERROR: displayname is not string`);
		this._displayname = val;
	}

	get formula () {
		//	Function. Special damage formula, if divergence from the default is desired. If unset, will default to the normal damage formula.

		var val = this._formula;
		if (val === undefined) {
			val = this.actionData.formula;
		}
		if (val === undefined) {
			val = null;
		}
		return val;
	}

	set formula (val) {
		console.assert(val instanceof Function,`ERROR: formula is not function`);
		this._formula = val;
	}

	get info() {
		//	Gameplay information on the action's function, displayed to the player during action selection.

		var val = this._info;
		if (val === undefined) {
			val = this.actionData.info;
		}
		if (val === undefined) {
			val = "Info pending.";
		}
		return (val instanceof Function) ? val(this) : val;
  }

	set info (val) {
		this._info = val;
	}

  get desc() {
		//	Flavor text displayed below action info in smaller text.

		var val = this._desc;
		if (val === undefined) {
			val = this.actionData.desc;
		}
		if (val === undefined) {
			val = "Description pending.";
		}
		return val;
  }

	set desc (val) {
		this._desc = val;
	}

	get preview() {
		//	Function. Pre-calculates the effect of the action and provides the result to the player in the Confirm Phase.

    var val = this._preview;
		if (val === undefined) {
			val = this.actionData.preview;
		}
		if (val === null || val instanceof Function) {
			return val;
		} else if (typeof(val) === "string") {
			val = [val];
		} else if (!(val instanceof Array)) {
			val = [];
		}
		var result = "";
		var initialLength = 0;
		if (val.includes("spread")) {
			if (this.weight > 0) {
				return `Will hit <b>${this.hits}</b> targets randomly`;
			}
		} else if (target() instanceof Actor) {
			var hits = 0;
			var party = [target()];
			if (val.includes("mass") || val.includes("all")) {
				party = target().ownParty.filter(function (a) { return a && !a.areaImmune });
			} else if (val.includes("row")) {
				party = target().ownParty
								.filter(function (a) { return a && !a.areaImmune && a.row === target().row });
			} else if (val.includes("col") || val.includes("column")) {
				party = target().ownParty
								.filter(function (a) { return a && !a.areaImmune && a.col === target().col });
			} else if (val.includes("adjacent") || val.includes("+")) {
				party = target().ownParty
								.filter(function (a) { return a && !a.areaImmune && (
												a.id === target().id ||
												a.col === target().col && (a.row === target().row + 1 || a.row === target().row - 1) ||
											 	a.row === target().row && (a.col === target().col + 1 || a.row === target().col - 1)
												) });
			}
			if (!this.canTargetDead) {
				party = party.filter(function (a) { return !a.dead });
			}
			for (let actor of party) {
				initialLength = result.length;
				hits = this.hits - actor.shieldHits;
				if (val.includes("multihit")) {
					if (this.weight > 0) {
						if (hits > 0) {
							result += `<<damageCalc>><b>${actor.name}</b> will take <b>$dmg x ${hits}</b> damage`;
						} else {
							result += `<b>${actor.name}</b> <b>will block all ${this.hits} hits</b>`;
						}
					}
		 		} else if (val.includes("splash") && target().id !== actor.id) {
					if (this.weight > 0) {
						if (hits > 0) {
							temporary().temp = actor;
							$.wiki('<<damageCalc _temp>>');
							result += `<b>${actor.name}</b> will take <b>${V().dmg}</b> damage`;
						} else {
							result += `<b>${actor.name}</b> <b>will block the hit</b>`;
						}
					}
				} else if (val.includes("heal")) {
					result += `<<healCalc>><b>${target().name}</b> will recover <b>$heal</b> health`;
				} else {
					if (this.weight > 0) {
						if (hits < 1) {
							result += `<b>${target().name}</b> <b>will block the hit</b>`;
						} else {
							result += `<<damageCalc>><b>${target().name}</b> will take <b>$dmg</b> damage`;
						}
					}
				}

				if (result.length > initialLength) {
					result += `<br/>`;
				}

				if (val.includes("lastEffect")) this.removedEffects = 1;

				if (val.includes("cleanse") && Number.isInteger(this.removedEffects)) {
					this.effects = [];
					let e = clone(this.removedEffects);
					let effects = actor.effects;
					for (let i = effects.length-1; i >= 0; i--) {
						if (e <= 0) {
							break;
							// The number of effects removed by Neutralize/Restoration varies depending on energy invested. If there are more effects than the spell can remove, we end the function here. Otherwise the spell would clear all effects regardless of strength!
						}
						if (subject().ownParty === actor.ownParty && !effects[i].buff) {
							// If using this on ally, only remove ailments
							this.effects.push(effects[i].name);
							e--;
						} else if (effects[i].buff) {
							this.effects.push(effects[i].name);
							e--;
						}
					}
					val.pushUnique("removeEffect");
				}
				if (this.effects instanceof Array) {
					if (val.includes("removeEffect")) {
						if (actor.testRemoval(this.effects[0],{unsticky: val.includes("unsticky")}) === "none") {
							result += `<b>${actor.name} doesn't have any effects to remove!</b><br/>`;
						} else {
							let effects = clone(this.effects);
							if (effects.includes("all")) {
								effects = actor.effects.map(function (e) { return e.name });
							} else if (effects.includes("ailments")) {
								effects = actor.effects.filter(function(e) { return e && !e.buff }).map(function (e) { return e.name });
							} else if (effects.includes("buffs")) {
								effects = actor.effects.filter(function(e) { return e && e.buff }).map(function (e) { return e.name });
							}
							console.log(effects);
							for (let effect of effects) {
								let testResult = actor.testRemoval(effect,{unsticky: val.includes("unsticky")});
								switch (testResult) {
									case "block":
										result += `<b>${actor.name}'s effects are sealed</b>`;
										break;
									case "none":
										result += `<b>${actor.name} doesn't have any effects to remove!</b>`;
										break;
									case "absent":
										result += `<b>${actor.name}</b> <b>does not have ${effect}</b>`;
										break;
									case "sticky":
										result += `<b>${effect} can't be removed!</b>`;
										break;
									default:
										result += `<b>${actor.name}</b> will lose <b>${effect}</b>`;
								}
								result += `<br/>`;
							}
						}
					} else {
						for (let effect of this.effects) {
							switch (actor.testEffect(effect)) {
								case "immune":
									result += `<b>${actor.name}</b> <b>is immune to ${effect}</b>`;
									break;
								case "block":
									result += `<b>${actor.name}</b> <b>is protected from ${effect}</b>`;
									break;
								case "tolerance":
									result += `<b>${actor.name}</b> will lose <b>${this.toleranceDamage} ${effect} tolerance</b>`;
									break;
								default:
									result += `<b>${actor.name}</b> will gain <b>${effect}</b>`;
									if (this.dur > 1) result += ` for <b>${this.dur}</b> rounds`;
							}
							result += `<br/>`;
						}
					}
				}
			}
		} else {
			return null;
		}
		return result;
  }

	set preview (val) {
		console.assert(typeof(val) === "string" || val instanceof Function,`ERROR: preview must be string or function`);
		this._preview = val;
	}

	get useText() {
		//	Text to be displayed above actText. Usually provides the name of the action.
		//	Set to null to remove this section from the action display entirely.

		var val = this._useText;
		if (val === undefined) {
			val = this.actionData.useText;
		}
		if (val === undefined) {
			val = `$subject.name uses "${this.displayname}".`;
		}
		return val;
  }

	set useText (val) {
		this._useText = val;
	}

	get actText() {
		//	Text to be displayed in actFlavor when the action is executed.

    var val = this._actText;
		if (val === undefined) {
			val = this.actionData.actText;
		}
		if (val === undefined) {
			val = null;
		}
		return val;
  }

	set actText (val) {
		this._actText = val;
	}

	get act() {
		//	Gameplay effect of the action. Usually a string of SugarCube code.
		//	Results of this call are printed in the actEffects textbox. Note that JavaScript code cannot print to a passage.

		var val = this._act;
		if (val === undefined) {
			val = this.actionData.act;
		}
		if (val === undefined) {
			val = `This action doesn't do anything!`;
		}
		return val;
  }

	set act (val) {
		this._act = val;
	}

	get finisher() {
		//	Function. Effect ocurring on the final hit of the action only. Optional.
		//	Note that ONLY the finisher is triggered on the final hit.

		var val = this._finisher;
		if (val === undefined) {
			val = this.actionData.finisher;
		}
		return val;
  }

	set finisher (val) {
		console.assert(val instanceof Function,`ERROR in finisher setter: must be function`);
		this._finisher = val;
	}

	get onMiss() {
		//	Function. Executes if the action misses (but not if blocked by a shield effect). Optional.

		var val = this._onMiss;
		if (val === undefined) {
			val = this.actionData.onMiss;
		}
		return val;
  }

	set onMiss (val) {
		console.assert(val instanceof Function,`ERROR in onMiss setter: must be function`);
		this._onMiss = val;
	}

	get spellMod() {
		//	Function. Called in the Spell Phase to modify the action if the action's spell attribute is true.

    return (this._spellMod || this.actionData.spellMod || "ERROR SPELLMOD UNDEFINED");
  }

	get phase () {
		//	String. Phase that the player will be forwarded to when the action is selected.
		//	Must match one of the phase passage names EXACTLY.

		return (this._phase || this.actionData.phase || "Targeting Phase");
	}

	get target () {
		//	String. Specifies what party or parties can be targeted by the action.
		//	Can take value of "enemy", "ally", or "all".
		//	See noself for additional modifier on targeting properties.

		return (this._target || this.actionData.target || "enemy");
	}

	set target (val) {
		this._target = val;
	}

	get cost () {
		//	Number. Value subtracted from user EN on use.

		var val = this._cost;
		if (val === undefined) {
			val = this.actionData.cost;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set cost (val) {
		this._cost = val;
	}

	get hpcost () {
		//	Number. Value subtracted from user HP on use.

		var val = this._hpcost;
		if (val === undefined) {
			val = this.actionData.hpcost;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set hpcost (val) {
		this._hpcost = val;
	}

	get weight () {
		//	Number. Attack damage is weighted by this number according to damage formula.

		var val = this._weight;
		if (val === undefined) {
			val = this.actionData.weight;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set weight (val) {
		console.assert(typeof(val) === "number" && val >= 0,`ERROR in action weight setter: value was non-number or less than 0`)
		this._weight = val;
	}

	get base () {
		//	Integer. Flat bonus added to attack damage.

		var val = this._base;
		if (val === undefined) {
			val = this.actionData.base;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set base (val) {
		console.assert(Number.IsInteger(val) && val >= 0,`ERROR in action base setter: value was non-integer or less than 0`)
		this._base = val;
	}

	get effweight () {
		//	Number. Weights the effect of numerical status effects according to the effect formula.

		var val = this._effweight;
		if (val === undefined) {
			val = this.actionData.effweight;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set effweight (val) {
		this._effweight = val;
	}

	get dur () {
		//	Number. Duration of an applied effect.

		var val = this._dur;
		if (val === undefined) {
			val = this.actionData.dur;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set dur (val) {
		this._dur = val;
	}

	get threat () {
		//	Number. Additional flat threat value incurred to the user when action used.
		//	Stacks with standard threat gain from damage formula.

		var val = this._threat;
		if (val === undefined) {
			val = this.actionData.threat;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set threat (val) {
		this._threat = val;
	}

	get special () {
		//	Value used for miscellaneous purposes, e.g. the EN gain from Focus.

		return (this._special || this.actionData.special || "ERROR SPECIAL UNDEFINED");
	}

	set special (val) {
		this._special = val;
	}

	get basic () {
		//	If true, can be used even while Dizzy.

		var val = this._basic;
		if (val === undefined) {
			val = this.actionData.basic;
		}
		if (val === undefined) {
			val = this instanceof ItemAction ? true : false;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set basic (val) {
		this._basic = val;
	}

	get instant () {
		//	If true, does not end the user's turn.

		var val = this._instant;
		if (val === undefined) {
			val = this.actionData.instant;
		}
		if (val === undefined) {
			val = false;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set instant (val) {
		this._instant = val;
	}

	get pierce () {
		//	If true, attack ignores enemy defense.

		var val = this._pierce;
		if (val === undefined) {
			val = this.actionData.pierce;
		}
		if (val === undefined) {
			val = false;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set pierce (val) {
		this._pierce = val;
	}

	get noself () {
		//	If true, the user cannot target themself with this action.

		var val = this._noself;
		if (val === undefined) {
			val = this.actionData.noself;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get counter () {
		//	If true, this is considered a counter action

		var val = this._counter;
		if (val === undefined) {
			val = this.actionData.counter;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get item () {
		//	If true, the item entry in the player's inventory that matches the action's name will be decremented after action is used.

		var val = this._item;
		if (val === undefined) {
			val = this.actionData.item;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get passive () {
		//	If true, action will not be displayed or selectable during battle.

		var val = this._passive;
		if (val === undefined) {
			val = this.actionData.passive;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get nosave () {
		//	If true, action will not be saved to lastAction.

		var val = this._nosave;
		if (val === undefined) {
			val = this.actionData.nosave;
		}
		if (this.crisis || this instanceof ItemAction) {
			val = true;
		} else if (val === undefined) {
			val = false;
		}
		return val;
	}

	get saveMod () {
		//	String. User's last action will be saved as this name. Defaults to the action's regular name.

		return (this._saveMod || this.actionData.saveMod || this.name);
	}

	get passagejump () {
		//	String. If filled, action will forward the player to the passage with the same name as this property's value.
		//	Value must match the desired passage name EXACTLY.

		var val = this._passagejump;
		if (val === undefined) {
			val = this.actionData.passagejump;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get accuracy () {
		// 	Nonnegative number, percentile value of chance to hit. Reduced by enemy evasion stat if it exists.
		//	Set to Boolean true for an always-accurate attack (bypasses accuracy and evasion checks).
		//	By default, magical attacks (denoted by useSpecial of 1) have perfect accuracy.

		var val = this._accuracy;
		if (val === undefined) {
			val = this.actionData.accuracy;
		}
		if (val === undefined) {
			this.useSpecial == 1 ? val = true : val = setup.ACCURACY_RATE;		/* magic cannot miss */
		}
		if (val === true) {
			return true;
		} else if (isNaN(val)) {
			console.log(`ERROR: accuracy rate of ${this.name} is not a number`);
			return 0;
		}
		return Math.abs(val);
	}

	set accuracy (val) {
		this._accuracy = val;
	}

	get critRate () {
		//	Nonnegative number, percentile value of chance of landing a critical hit.
		//	By default, magical attacks (denoted by useSpecial of 1) always have 0% crit rate.

		var val = this._critRate;
		if (val === undefined) {
			val = this.actionData.critRate;
		}
		if (val === undefined) {
			this.useSpecial == 1 ? val = 0 : val = setup.CRITICAL_RATE;		/* magic cannot crit */
		}
		if (isNaN(val)) {
			console.log(`ERROR: critical rate of ${this.name} is not a number`);
			return 0;
		}
		return Math.abs(val);
	}

	set critRate (val) {
		this._critRate = val;
	}

	get critMultiplier () {
		//	Nonnegative number, multiplier for damage on a critical hit. Defaults to critical multiplier value defined in setup.

		var val = this._critMultiplier;
		if (val === undefined) {
			val = this.actionData.critMultiplier;
		}
		if (val === undefined) {
			val = setup.CRITICAL_MULTIPLIER;
		}
		if (isNaN(val)) {
			console.log(`ERROR: crit multiplier of ${this.name} is not a number`);
			return 0;
		}
		return Math.abs(val);
	}

	set critMultiplier (val) {
		this._critMultiplier = val;
	}

	get trigger () {
		//	For counterattacks. Function or Boolean. If result is true, counter will trigger.

		var val = this._trigger;
		if (val === undefined) {
			val = this.actionData.trigger;
		}
		if (val === undefined) {
			val = true;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	get fullround () {
		//	If true, action will use up all enemy actions.

		var val = this._fullround;
		if (val === undefined) {
			val = this.actionData.fullround;
		}
		if (val === undefined) {
			val = false;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	get element () {
		//	String or Array. Elemental affinity of the action. See damage formula for details.

		var val = this._element;
		if (val === undefined) {
			val = this.actionData.element;
		}
		if (val === undefined) {
			val = null;
		} else if (val instanceof Function) {
			val = val();
		}
		if (typeof(val) == "string") {
			console.assert(setup.ELEMENT_LIST.includes(val),`ERROR: ${this.name} has illegal element`);
			return val.toLowerCase();
		} else if (val instanceof Array) {
			for (let elm of val) {
				console.assert((typeof(elm) == "string" && setup.ELEMENT_LIST.includes(elm)),`ERROR: ${this.name} has illegal element`);
			}
			return val;
		} else if (val !== null) {
			console.log(`ERROR: ${this.name} has non-string element value`);
			return null;
		}
		return val;
	}

	get crisis () {
		//	Determines if this is a crisis action.

		var val = this._crisis;
		if (val === undefined) {
			val = this.actionData.crisis;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get silent () {
		//	If true, action will not display any text during the Action Phase. Effects will still trigger, but the player will be auto-forwarded to the next phase.

		var val = this._silent;
		if (val === undefined) {
			val = this.actionData.silent;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get oncePerTurn () {
		//	If true, action can only be used once per turn, even if it is instant.

		var val = this._oncePerTurn;
		if (val === undefined) {
			val = this.actionData.oncePerTurn;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get ranged () {
		//	If true, action can target anyone on the battlefield regardless of configuration. See the battle grid for details.

		var val = this._ranged;
		if (val === undefined) {
			val = this.actionData.ranged;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	set ranged (val) {
		this._ranged = val;
	}

	get noDefault () {
		// if true, action cannot be set as a default

		var val = this._noDefault;
		if (val === undefined) {
			val = this.actionData.noDefault;
		}
		if (val === undefined) {
			this.passive || this.crisis || this.weight === 0 ? val = true : val = false;
		}
		return val;
	}

	get noShock () {
		// if true, action cannot cure "shock" effects on direct damage

		var val = this._noShock;
		if (val === undefined) {
			val = this.actionData.noShock;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get needsPriorElement () {
		//	If true, action will require an element in the user's lastUsed property.

		var val = this._needsPriorElement;
		if (val === undefined) {
			val = this.actionData.needsPriorElement;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get truce () {
		//	If true, action will not violate an enemy's truce

		var val = this._truce;
		if (val === undefined) {
			val = this.actionData.truce;
		}
		if (val === undefined) {
			val = this.silent ? true : false;
		}
		return val;
	}

	get useSpecial () {
		// Number between 0 and 1, determines proportion of base damage dependent on Special. Attack dependence is automatically calculated as the inverse, so e.g. a 75% Special dependence results in a 25% Attack dependence.

		var val = this._useSpecial;
		if (val === undefined) {
			val = this.actionData.useSpecial;
		}
		if (val === undefined) {
			this instanceof ItemAction? val = 1 : val = 0;
		}
		return Math.clamp(val,0,1);
	}

	set useSpecial (val) {
		this._useSpecial = val;
	}

	get uses () {
		// Assumes _uses is a FillStat
		return this._uses === undefined ? undefined : this._uses.currentVal;
	}

	set uses (amt) {
		if (this.uses !== undefined) { this._uses.currentVal = Math.clamp(amt,0,this._uses.current); }
	}

	get maxUses () {
		return this._uses === undefined ? undefined : this._uses.current;
	}

	set maxUses (amt) {
		if (this.uses !== undefined) { this._uses.base = amt; }
	}

	refill () {
		if (this.uses !== undefined) { this._uses.refill(); }
	}

	get cd () {
		// Assumes _cd is a FillStat
		return this._cd === undefined ? undefined : this._cd.currentVal;
	}

	set cd (amt) {
		if (this.cd !== undefined) { this._cd.currentVal = Math.max(amt,0); }
	}

	get maxCD () {
		return this._cd === undefined ? undefined : this._cd.current;
	}

	set maxCD (amt) {
		if (this.cd !== undefined) { this._cd.base = amt; }
	}

	resetCD () {
		if (this.cd !== undefined) { this._cd.refill(); }
	}

	get warmup () {
		var val = this._warmup;
		if (val === undefined) {
			val = this.actionData.warmup;
		}
		if (val === undefined) {
			val = 0;
		}
		return val;
	}

	get enemyCD () {
		var val = this._enemyCD;
		if (val === undefined) {
			val = this.actionData.enemyCD;
		}
		if (val === undefined) {
			val = this.actionData.cooldown;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get nameCD () {
		return (this._nameCD || this.actionData.nameCD || this.name);
	}

	get setupAction () {
		//	String. Name of action that will be performed after this action following a delay specified by setupDelay.
		return (this._setupAction || this.actionData.setupAction || null);
	}

	set setupAction (val) {
		this._setupAction = val;
	}

	get setupDelay () {
		//	Positive integer. Number of turns that must elapse before a delayed action is performed.
		//	Assumes setupAction is defined; if not, will not be read.
		//	Defaults to 1 (action performed on next turn)
		var val = this._setupDelay;
		if (val === undefined) {
			val = this.actionData.setupDelay;
		}
		if (val === undefined || (!Number.isInteger(val) || val < 0)) {
			val = 1;
		}
		return val;
	}

	set setupDelay (val) {
		this._setupDelay = val;
	}

	get delayPersist () {
		//	Boolean. If true and this is a delayed action, the action will occur even if the user is dead or under a hold effect.
		var val = this._delayPersist;
		if (val === undefined) {
			val = this.actionData.delayPersist;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	get delayHold () {
		//	Boolean. If true and this is a delayed action, the user will not be able to act for the duration of the action's delay time.
		var val = this._delayHold;
		if (val === undefined) {
			val = this.actionData.delayHold;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	get delayMessage () {
		//	Function. Message printed at top of round when character is charging a delayed action.
		//	Must be attached to the delayed action, not the setup action.
		//	Set to null to display no message.

		var val = this._delayMessage;
		if (val === undefined) {
			val = this.actionData.delayMessage;
		}
		if (val === undefined) {
			val = function () {
				return `${subject().name} is preparing to use ${this.displayname}!`;
			};
		}
		return val;
	}

	get waitTime () {
		//	Whole integer. Number of ticks between selection and action execution.
		//	For use with the timeline system.

		var val = this._waitTime;
		if (val === undefined) {
			val = this.actionData.waitTime;
		}
		if (val === undefined) {
			val = 0;
		}
		return val;
	}

	set waitTime (val) {
		console.assert(Number.isInteger(val) && val >= 0,`ERROR: waitTime must be whole integer`);
		this._waitTime = val;
	}

	set recoveryTime (val) {
		console.assert(Number.isInteger(val) && val >= 0,`ERROR: recoveryTime must be whole integer`);
		this._recoveryTime = val;
	}

	get recoveryTime () {
		//	Whole integer. Number of ticks between action's execution and the user's next turn.
		//	For use with the timeline system.

		var val = this._recoveryTime;
		if (val === undefined) {
			val = this.actionData.recoveryTime;
		}
		if (val === undefined) {
			val = 0;
		}
		return (val instanceof Function) ? val(this) : val;
	}


	get targetMethod () {
		//	Function. Determines targeting logic for actions that must choose their own target, e.g. enemy and delayed actions.
		//	Return value is the target object.
		//	Defaults to targetEnemy, or targetAlly if the action's target property is "ally".

		var val = (this._targetMethod || this.actionData.targetMethod)
		if (!(val instanceof Function)) {
			if (this.target === "ally") {
				val = function () {
					return Hitlist.targetAlly(this.targetMod);
				};
			} else {
				val = function () {
					return Hitlist.targetEnemy(this.targetMod);
				};
			}
		}
		return val;
	}

	set targetMethod (val) {
		console.assert(val instanceof Function,`ERROR: targetMethod is not function`);
		this._targetMethod = val;
	}

	get targetMod () {
		//	Array of strings. Passed to targetMethod to customize targeting logic.

		var val = (this._targetMod || this.actionData.targetMod || []);
		if (!(val.includes("custom") || val.includes("random"))) {
			// add standard mods relevant to action unless bypassed with the "custom" mod
			// the "random" mod will also bypass this since it makes mods meaningless
			if (this.pierce === true) {
				val.pushUnique("pierce");
			}
			if (this.effweight > 0) {
				val.pushUnique("effect");
			}
			if (this.weight === 0) {
				val.pushUnique("ignore downed","ignore vulnerable");
			}
			if (this.noself === true) {
				val.pushUnique("noself");
			}
		}
		return val;
	}

	set invisible (val) {
		console.assert(typeof(val) === "boolean",`ERROR: invisible must be Boolean`);
		this._invisible = val;
	}

	get invisible () {
		//	Boolean. If true, action will not be displayed in the action list.
		//	By default, passive abilities are invisible if displayed in-battle, but not if viewed from the menu.

		var val = this._invisible;
		if (val === undefined) {
			val = this.actionData.invisible;
		}
		if (val === undefined) {
			val = V().inbattle && this.passive ? true : false;
		}
		return val;
	}

	set canTargetDead (val) {
		console.assert(typeof(val) === "boolean",`ERROR: canTargetDead must be Boolean`);
		this._canTargetDead = val;
	}

	get canTargetDead () {
		//	Boolean. If true, action can target dead actors in the Targeting Phase.
		//	(By default, dead characters cannot be targeted.)

		var val = this._canTargetDead;
		if (val === undefined) {
			val = this.actionData.canTargetDead;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	set noReflection (val) {
		console.assert(typeof(val) === "boolean",`ERROR: noReflection must be Boolean`);
		this._noReflection = val;
	}

	get noReflection () {
		//	Boolean. If true, action will not trigger damage reflection.
		//	(Unless the target has the "absreflect" property.)

		var val = this._noReflection;
		if (val === undefined) {
			val = this.actionData.noReflection;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	set spread (val) {
		console.assert(typeof(val) === "boolean",`ERROR: spread must be Boolean`);
		this._spread = val;
	}

	get spread () {
		//	Boolean. If true and this action has multiple hits, a new target will be chosen every hit.

		var val = this._spread;
		if (val === undefined) {
			val = this.actionData.spread;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	set noRedundant (val) {
		console.assert(typeof(val) === "boolean",`ERROR: noRedundant must be Boolean`);
		this._noRedundant = val;
	}

	get noRedundant () {
		//	Boolean. If true and this action has multiple hits and this action is a spread action, this action may not target the same actor twice.

		var val = this._noRedundant;
		if (val === undefined) {
			val = this.actionData.noRedundant;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	set area (val) {
		console.assert(typeof(val) === "string",`ERROR: area must be string`);
		this._area = val;
	}

	get area () {
		//	String. Denotes class of AoE, if the action contains an area of effect.

		return (this._area || this.actionData.area || "enemies");
	}

	set onApply (val) {
		console.assert(val instanceof Function,`ERROR: onApply is not function`);
		this._onApply = val;
	}

	get onApply () {
		return (this._onApply || this.actionData.onApply || function () { return; });
	}

	set onRemove (val) {
		console.assert(val instanceof Function,`ERROR: onRemove is not function`);
		this._onRemove = val;
	}

	get onRemove () {
		return (this._onRemove || this.actionData.onRemove || function () { return; });
	}

	set onUse (val) {
		console.assert(val instanceof Function,`ERROR: onUse is not function`);
		this._onUse = val;
	}

	get onUse() {
		//	Determines the effect abilities will have when used from the menu outside of battle. Optional.

    return (this._onUse || this.actionData.onUse || undefined);
  }

	set instantUse (val) {
		console.assert(typeof(val) === "boolean",`ERROR: instantUse must be Boolean`);
		this._instantUse = val;
	}

	get instantUse() {
		//	Boolean. If true, the action's onUse will be executed immediately, instead of requiring a target.
		//	This is useful for e.g. action that affect the whole party or call up another passage for more detailed interaction.

		return (this._instantUse || this.actionData.instantUse || false);
	}

	set toleranceDamage (val) {
		console.assert(Number.isInteger(val) && val > 0,`ERROR: toleranceDamage must be positive integer`);
		this._toleranceDamage = val;
	}

	get toleranceDamage() {
		//	Positive integer. If action inflicts an effect, it will reduce tolerance by this number.
		//	Defaults to 1.

		var val = this._toleranceDamage;
		if (val === undefined) {
			val = this.actionData.toleranceDamage;
		}
		if (val === undefined) {
			val = 1;
		}
		return val;
	}

	set hits (val) {
		console.assert(Number.isInteger(val) && val > 0,`ERROR: hits must be positive integer`);
		this._hits = val;
	}

	get hits() {
		//	Positive integer. Determines number of hits if attack hits multiple times.
		//	Defaults to 1.

		var val = this._hits;
		if (val === undefined) {
			val = this.actionData.hits;
		}
		if (val === undefined) {
			val = 1;
		}
		return (val instanceof Function) ? val(this) : val;
	}

	set effects (val) {
		console.assert(val instanceof Array,`ERROR: effects must be array`);
		this._effects = val;
	}

	get effects () {
		//	Array of strings. Name of effects that will be applied by the action.
		//		if single string is passed, it will be converted into a 1-element array
		//	Used in previews and as defaults for applyEffect.

		var result = (this._effects || this.actionData.effects || null);
		if (typeof(result) == "string") result = [result];
		return result;
	}

	//	Checks for action availability. Separate ones needed to customize UI feedback.
	//	A true return means the action FAILED the check and will be unavailable.

	standardCheck (actor) {
		//	Checks for EN cost, uses, cooldown, and crisis points.
		let subj = subject() || actor;
		return (subj.en < this.cost)
		|| (typeof(this.uses) == "number" && this.uses < 1)
		|| (typeof(this.cd) == "number" && this.cd !== 0)
		|| (this.used === true)
		|| (this.crisis && subject().crisisPoints < 100);
	}

	lockCheck (actor) {
		//	Checks if character is under a skill lock.
		let subj = subject() || actor;
		return (subj.skillLock && !this.basic);
	}

	HPCheck (actor) {
		//	Checks if character cannot pay the HP cost.
		let subj = subject() || actor;
		return (this.hpcost && subj.hp <= this.hpcost);
	}

	elementCheck (actor) {
		//	Checks that a character has a prior element stored for actions that need a prior element.
		let subj = subject() || actor;
		return (this.needsPriorElement && typeof(subj.lastUsed) !== "string");
	}

	check (actor) {
		return (this.standardCheck(actor) || this.lockCheck(actor) || this.HPCheck(actor) || this.elementCheck(actor));
	}

	toString () {
		//	Determines the default way actions are displayed in-game. Used with actionList.
	  var subj = subject() || temporary().display;

	  var cRef = `<img src="${setup.ImagePath}/ui/waittime.png" />`;
	  var rRef = `<img src="${setup.ImagePath}/ui/recovertime.png" />`;
	  var eRef = `<img src="${setup.ImagePath}/ui/energy.png" />`;

	  var text = `<span class="action-name">${this.name}</span>`;
	  if (typeof(this.cd) === "number" && this.cd !== 0) text += ` <span class="action-cooldown">[CD ${this.cd}]</span>`
	  if (this.uses !== undefined) text += ` <span class="action-uses">(Uses: ${this.uses}/${this.maxUses})</span>`;
	  var tags = "";
	  var cost = "";
	  if (this.crisis) tags += `<span class="crisis-tag">Crisis</span>`;
	  if (this.basic) tags += `<span>Basic</span>`;
	  if (this.instant) tags += `<span>Instant</span>`;
	  if (this.passive) tags += `<span>Passive</span>`;
	  if (!V().inbattle && subj.defaultAction === this.name) tags += `<span><b>Default</b></span>`;
	  text += `<div class="action-tags">${tags}</div>`;
	  if (!this.passive && Number.isInteger(this.cost) && this.cost > 0) {
	    cost += `${eRef} `;
	    cost += this.cost;
	    if (this.phase === "Spell Phase") cost += `+`;
	    cost = `<div>${cost}</div>`;
	  } else {
	    cost = `<div><br/></div>`;
	  }
	  if (Number.isInteger(this.waitTime) && this.waitTime > 0) {
	    cost += `<div>${cRef} ${this.waitTime}s</div>`;
	  }
	  if (Number.isInteger(this.recoveryTime) && this.recoveryTime > 0) {
	    cost += `<div>${rRef} ${this.recoveryTime}s</div>`;
	  }
	  text += `<div class="action-cost">${cost}</div>`
	  var data = this;
	  text += `<div class="action-info">${data.info}</div>`;
	  if (data.desc !== null) text += `<div class="action-desc">${data.desc}</div>`;
	  return text;
  }

	printCompressed () {
		//	Determines the display for compressed actions.
		//	By default, this strips tags, info, and description.

		var eRef = `<img src="${setup.ImagePath}/ui/energy.png" />`;

	  var text = `<span class="action-name">${this.name}</span>`;
	  var cost = "";
	  if (this instanceof ItemAction && !this.crisis) {
	    cost += `x${inv().get(this.name).stock}`;
	  } else if (!this.passive && Number.isInteger(this.cost) && this.cost > 0) {
	    cost += `${eRef} `;
	    cost += this.cost;
	    if (this.phase === "Spell Phase") cost += `+`;
	    cost = `<div>${cost}</div>`;
	  } else {
	    cost = `<div><br/></div>`;
	  }
	  text += `<span class="action-cost">${cost}</span>`;
	  return text;
	}

	clone () {
		// Return a new instance containing our current data.
		return new Action(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Action($ReviveData$)', data);
	}
};

window.ItemAction = class ItemAction extends Action {
	constructor(name){
		super(name);
		if (typeof(name) === 'string') {
			this._item = true;
		}
	}

	get useText() {
      return (this._useText || this.actionData.useText || null);
  }

	get actText() {
    return (this._actText || this.actionData.actText ||
			function () {
				var article;
				if (this.name) {
					switch (this.name.charAt(0).toLowerCase()){
						case 'i':
						case 'e':
						case 'o':
						case 'u':
						case 'a':
							article = 'an';
							break;
						default:
							article = 'a';
					}
				return `$subject.name uses ${article} ${this.name}.`;
				}
			}
			|| null);
  }

	get source() {
		//	The item from which the ItemAction comes. Defaults to the action's name.

		return (this.actionData.source || this.name);
	}

	standardCheck (i) {
		var inventory = (i || inv());
		return (inventory.get(this.source).stock < 1);
	}

	toString () {
		//	Determines the default way actions are displayed in-game. Used with actionList.
		var subj = subject() || temporary().display;

    var text = `<span class="action-name">${this.name}</span>`;
		var tags = "";
    if (!this.crisis) {
      tags += `x${inv().get(this.source).stock}`;
    }
    text += `<span class="action-tags">${tags}</span>`;
    var data = new Item(this.source);
    text += `<div class="action-info">${data.info}</div>`;
    if (data.desc !== null) text += `<div class="action-desc">${data.desc}</div>`;
    return text;
  }

	printCompressed () {
		//	Determines the display for compressed actions.
		//	By default, this strips tags, info, and description.

		var text = `<span class="action-name">${this.name}</span>`;
		var tags = "";
    if (!this.crisis) {
      tags += `x${inv().get(this.source).stock}`;
    }
    text += `<span class="action-tags">${tags}</span>`;
		return text;
	}

	clone () {
		// Return a new instance containing our current data.
		return new ItemAction(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new ItemAction($ReviveData$)', data);
	}
};
/* twine-user-script #4: "class-actor.js" */
window.Actor = class Actor {
	constructor(name,pos){
	if (typeof(name) == 'object'){
		Object.keys(name).forEach(prop => this[prop] = clone(name[prop]));
	}
	else {
		if (this instanceof Puppet) {
			this.id = "p";
		} else if (this instanceof Enemy) {
			this.id = "e";
		} else {
			this.id = "_";
		}
		this.id += (new Date().getTime() + Math.random() * 0x10000000000).toString(16);

		this.name = name;

		if (this.data) {
			this._HPregen = {
				"flat": new Stat(0),
				"percent": new Stat(0)
			}
			this.elements = new Map();
			if (setup.ELEMENT_LIST !== undefined){
				setup.ELEMENT_LIST.forEach(function(x) {
					this.elements.set(x,{"percent": new Stat(1), "flat": new Stat(0)});
				}, this);
			}
			this.tolerances = new Map();
			if (setup.effectData !== undefined){
				Object.keys(setup.effectData).forEach(function(x) {
					this.tolerances.set(x,new Tolerance(0));
				}, this);
			}

			this._maxHP = new Stat(this.data.hp);
			this._hp = this.data.hp;
			if (Number.isInteger(this.data.en)) {
				this._maxEN = new Stat(this.data.en);
				this._en = this.data.en;
			} else if (Number.isInteger(setup.MAX_EN)) {
				this._maxEN = new Stat(setup.MAX_EN);
				this._en = setup.MAX_EN;
			}
			this._ENregen = new Stat(0);
			if (Number.isInteger(this.data.ENregen)) {
				this._ENregen = new Stat(this.data.ENregen);
			} else if (Number.isInteger(setup.EN_REGEN)) {
				this._ENregen = new Stat(setup.EN_REGEN);
			}
			this.stats = {};
			for (let [pn,v] of Object.entries(this.data.stats)) {
				this.stats[pn] = new Stat(v);
			}
			if (this.data.elements) { this.setElements(Object.entries(this.data.elements),"percent"); }
			if (this.data.tolerances) { this.setTol(Object.entries(this.data.tolerances)); }
			Number.isInteger(this.data.retaliations) ?
				this._retaliations = new FillStat(this.data.retaliations) : this._retaliations = new FillStat(0);
			Number.isInteger(this.data.respawn) ?
				this._respawn = new FillStat(this.data.respawn) : this._respawn = new FillStat(0);
			if (typeof(this.data.respawnHP) === "number") { this._respawnHP = this.data.respawnHP; }

			this.battleMsg = [];	// container for popups that will appear during actions

			this.active = true;
			this.isDone = false;
			this.dead = false;
			this.protectedBy = null;
			this.effects = [];
			this.onHit = [];
			this.lastDmg = 0;
			this.noMinimum = [];	// stats that do not have minimums for this character; used by some effects
			this.delayCounter = 0;

			this.equipment = new Map();
			var equipData;
			equipData = (typeof(this.equipSlots) == "object")
				? equipData = this.equipSlots
				: equipData = setup.DEFAULT_EQUIP_SLOTS;

			for (let [pn,v] of Object.entries(equipData)) {
				this.equipment.set(pn,new Array(v).fill(null));
			}

			if (pos instanceof Array) {
				console.assert(pos.length == 2 && Number.isInteger(pos[0]),`ERROR in Actor constructor: invalid position array passed`);
				this.position = pos;
			}
		}
		else if (name !== "Dummy") {
			console.log("ERROR: Actor "+name+" is not in database");
			this.name = "INVALID ACTOR";
			this._hp = 1;
			this._maxHP = new Stat(1);
		}
	}
	}

	// GETTERS/SETTERS

	get idname () {
		return (this._idname || this.name);
	}

	get data () {
		if (this instanceof Puppet) {
			return (setup.puppetData[this.idname] || false);
		}
		else if (this instanceof Enemy) {
			return (setup.enemyData[this.idname] || false);
		}
		else {
			return undefined;
		}
	}

	get ownParty () {
		switch (this.id.charAt(0)) {
			case 'p':
				return V().puppets;
			case 'e':
				return V().enemies;
			default:
				console.log("ERROR in ownParty: invalid ID type");
				return V().B.actors;
		}
	}

	get otherParty () {
		switch (this.id.charAt(0)) {
			case 'p':
				return V().enemies;
			case 'e':
				return V().puppets;
			default:
				console.log("ERROR in otherParty: invalid ID type");
				return V().B.actors;
		}
	}

	get fullname () {
		return (this._fullname || this.data.fullname || this.name || false);
	}

	get equipSlots () {
		return (this._equipSlots || this.data.equipSlots || undefined);
	}

	get dead () {
		return this._dead;
	}

	set dead (flag) {
		if (typeof(flag) == 'boolean') {
			this._dead = flag;
			// reset respawn if it exists (happens on both defeat and revival)
			if (this.respawn !== undefined) {
				this._respawn.refill();
			}
			// erase delayed action on death UNLESS the action persists past user death
			if (!this.actionReady) {
				this.delayedAction = null;
			}
			// reset threat (if using threat targeting)
			if (setup.THREAT_TARGETING === true && this instanceof Puppet && V().inbattle) {
				if (flag === true) {
					enemies().forEach(function(enemy) {
						enemy.threat.forEach(function(v,k) {
							if (k == this.name) {
								enemy.threat.set(k,0);
							}
						}, this);
					}, this);
				} else if (flag === false) {
					enemies().forEach(function(enemy) {
						enemy.threat.forEach(function(v,k) {
							if (k == this.name) {
								enemy.threat.set(k,this.initialThreat());
							}
						}, this);
					}, this);
				}
			}
		}
		else {
			console.log("ERROR: death flag setter passed non-Boolean value");
		}
	}

	get noact () {
		//	Checks if the Actor is under a hold effect.
		//	If hold effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.hold });
	}

	get untargetable () {
		//	Checks if the Actor is under an untargetable effect.
		//	If untargetable effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.untargetable });
	}

	get uncontrollable () {
		//	Checks if the Actor is under a loss-of-control effect.
		//	If uncontrollable effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.uncontrollable });
	}

	get skillLock () {
		//	Checks if the Actor is under a skill-locking effect (e.g. Dizzy)
		//	If skillLock effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.skillLock });
	}

	get healBlock () {
		//	Checks if the Actor is under an effect that prevents healing
		//	If healBlock effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.healBlock });
	}

	get interruptGuard () {
		//	Checks if the Actor is under an effect that prevents action interruption
		//	If interruptGuard effect found, will return a truthy value, else will return a falsy value.

		return this.effects.find(function(eff) { return eff && eff.interruptGuard });
	}

	get noENregen () {
		//	Checks if the Actor is under an effect that prevents EN regen
		//	If noENregen effect found, will return a truthy value, else will return a falsy value.

		return (typeof(this.en) === "number") && (this.dead || this.effects.find(function(eff) { return eff && eff.noENregen }));
	}

	get shieldHits () {
		//	Returns the number of blocks from shield effects on this character, if they have any

		var hits = 0;
		this.effects.filter(function (eff) {return eff && eff.shield }).forEach(function (shield) {
			hits += shield.uses;
		});
		return hits;
	}

	get hp () {
		return this._hp;
	}

	set hp (amt) {
		console.assert(Number.isInteger(amt),`ERROR in HP setter: HP must be integer`);
		if (setup.ANIMATIONS && V().inbattle && this.displayHP === this.hp) {
			this.displayHP = this.hp;
		}
		this._hp = Math.clamp(amt,0,this.maxHP);
	}

	get maxHP () {
		return this._maxHP.current;
	}

	set maxHP (amt) {
		console.assert(Number.isInteger(amt),`ERROR in max HP setter: max HP must be integer`);
		this._maxHP.base = amt;
	}

	updateHP () {
		// used for matching current HP to changes in max HP, e.g. HP-boosting equipment
		if (!(this instanceof Puppet && V().lastingDamage)) {
			this.hp = this.maxHP;
		}
	}

	get HPregen () {
		return this._HPregen;
	}

	get HPregenFlat () {
		return this._HPregen.flat.current;
	}

	set HPregenFlat (amt) {
		this._HPregen.flat.base = amt;
	}

	get HPregenPercent () {
		return this._HPregen.percent.current;
	}

	set HPregenPercent (amt) {
		this._HPregen.percent.base = amt;
	}

	get displayHP () {
		return (this._displayHP || this.hp);
	}

	set displayHP (amt) {
		this._displayHP = Math.clamp(amt,0,this.maxHP);
	}

	//  en: number; Energy points spent to use actions
	get en () {
		return this._en;
	}

	set en (amt) {
		console.assert(Number.isInteger(amt),`ERROR in EN setter: EN must be integer`);
		this._en = Math.clamp(amt,0,this.maxEN);
	}

	//  maxEN: number; maximum Energy points Puppet can hold
	get maxEN () {
		return this._maxEN.current;
	}

	set maxEN (amt) {
		console.assert(Number.isInteger(amt),`ERROR in max en setter: max en must be integer`);
		this._maxEN.base = amt;
	}

	//  ENregen: number; determines EN gain per turn
	get ENregen () {
		return this._ENregen.current;
	}

	set ENregen (amt) {
		console.assert(Number.isInteger(amt),`ERROR in EN regen setter: EN regen must be integer`);
		this._ENregen.base = amt;
	}

	get lastDmg () {
		return this._lastDmg;
	}

	set lastDmg (val) {
		console.assert(typeof(val) == "number",`ERROR: lastDmg must be number`);
		this._lastDmg = val;
	}

	// Respawn functions. These assume respawn time is a FillStat.

	get maxRespawn () {
		if (this._respawn === undefined) {
			return undefined;
		} else {
			return this._respawn.current;
		}
	}

	set maxRespawn (amt) {
		if (this._respawn === undefined) {
			this._respawn = new FillStat(amt);
		} else {
			this._respawn.base = amt;
		}
	}

	get respawn () {
		if (this._respawn === undefined) {
			return undefined;
		} else {
			return this._respawn.currentVal;
		}
	}

	set respawn (amt) {
		this._respawn.currentVal = Math.clamp(amt,0,this.maxRespawn);
	}

	get respawnHP () {
		// Number between 0 and 1. Proportion of max HP restored on a respawn.

		var val = (this._respawnHP || setup.RESPAWN_HP);
		return Math.clamp(val,0,1);
	}

	get respawnMessage () {
		return (this._respawnMessage || this.data.respawnMessage || `${this.name} respawns!`)
	}

	resetRespawn () {
		if (this.respawn !== undefined) {
			this._respawn.refill();
		}
	}

	setHP (amt) {
		// Relative setter: keeps HP within bounds on damage or heal
		// DEPRECIATED as of version 1.12; use the hp setter instead.
		this._hp = Math.clamp(this.hp + amt,0,this.maxHP);
	}

	setMaxHP (amt) {
		// Absolute setter: for when both HP and max HP need to be set simultaneously, e.g. form changes.
		this.maxHP = amt;
		this.hp = amt;
	}

	get (key) {
		// calculates effective stats
		key = key.toUpperFirst();
		if (this.stats[key]) {
			let v = this.stats[key];
			let n = Math.round(v.current);
			let max = setup.STAT_MAX[key];
			let min = setup.STAT_MIN[key];
			return this.noMinimum.includes(key)
				? Math.min(n,max)
				: Math.clamp(n,min,max);
		} else {
			console.log("ERROR in stat getter, target does not have requested stat");
			return 0;
		}
	}

	getBase (key) {
		key = key.toUpperFirst();
		return this.stats[key].base;
	}

	getBonus (key) {
		key = key.toUpperFirst();
		return this.stats[key].bonus;
	}

	getEquipBonus (key) {
		key = key.toUpperFirst();
		return this.stats[key].equipBonus;
	}

	statRaised (key) {
		key = key.toUpperFirst();
		return (this.get(key) > this.getBase(key));
	}

	statLowered (key) {
		key = key.toUpperFirst();
		return (this.get(key) < this.getBase(key));
	}

	setBase (k,v){
		this.stats[k].base = v;
	}

	addMod (key, id, mod, equipment) {
		return this.stats[key].addMod(id,mod,equipment);
	}

	removeMod (key, id, index) {
		this.stats[key].removeMod(id, index);
	}

	setTemp (k,v,abs){
		// DEPRECIATED as of version 1.08. Use addMod instead.
		if (abs !== undefined && (abs.toLowerCase() == 'abs' || abs.toLowerCase() == 'absolute')){
			this.stats.get(k).Temp = v;
		} else {
			this.stats.get(k).Temp += v;
		}
	}

	getElement (needle,type) {
		if (type === undefined) {
			return this.elements.get(needle);
		} else {
			return this.elements.get(needle)[type].current
		}
	}

	setElements (array,type) {
		// Easy way to set base elemental affinities. Takes an array of arrays that each contain two elements, the name of the effect and the base value. Pass the second argument to denote if you are setting flat or percent rates.
		if (type === undefined || typeof(type) !== 'string') {
			console.log("ERROR in setElements: no type defined");
		} else {
			array.forEach(function(data) {
				if (this.elements.has(data[0])) {
					this.elements.get(data[0])[type].base = data[1];
				}
			}, this);
		}
	}

	get retaliations () {
		if (this._retaliations) { return this._retaliations.currentVal; } else { return undefined; }
	}

	set retaliations (amt) {
		if (this._retaliations) {
			this._retaliations.base = amt;
		} else {
			this._retaliations = new FillStat(amt);
		}
	}

	get dmgreflection () {
		if (this._dmgreflection) { return this._dmgreflection.current; } else { return undefined; }
	}

	set dmgreflection (amt) {
		if (this._dmgreflection) {
			this._dmgreflection.base = amt;
		} else {
			this._dmgreflection = new Stat(amt);
		}
	}

	// gender and pronouns

	get gender () {
		return (this._gender || this.data.gender || 'x');
	}

	getPronouns (type) {
		if (typeof(type) == 'string') {
			var pr;
			switch(this.gender.toLowerCase()) {
				case 'f':
				case 'female':
					pr = {obj: "her", subj: "she", pos: "her"};
					break;
				case 'm':
				case 'male':
					pr = {obj: "him", subj: "he", pos: "his"};
					break;
				case 'n':
				case 'neuter':
				case 'neutral':
				case 'agender':
					pr = {obj: "them", subj: "they", pos: "their"};
					break;
				default:
					pr = {obj: "it", subj: "it", pos: "its"};
			}
			var result = pr[type];
			if (result === undefined) { console.log("ERROR in getPronouns: invalid pronoun type"); }
			return result;
		}
		else {
			console.log("ERROR in getPronouns: no pronoun type passed");
			return undefined;
		}
	}

	get them () {
		return this.getPronouns("obj");
	}

	get themself () {
		return this.getPronouns("obj")+"self";
	}

	get they () {
		return this.getPronouns("subj");
	}

	get their () {
		return this.getPronouns("pos");
	}

	get theyare () {
		switch (this.they) {
			case "they":
				return "they are";
			default:
				return (this.they + " is");
		}
	}

	get theyre () {
		switch (this.they) {
			case "they":
				return "they're";
			default:
				return (this.they + "'s");
		}
	}

	get deathMessage () {
		var base = (this._deathMessage || this.data.deathMessage || `${this.name} is defeated!`);
		if (base instanceof Function) base = base(this);
		return base+"<br/>";
	}

	// EQUIPMENT FUNCTIONS

	unequip (slot,index = 0,mods = {}) {
		console.assert(typeof(slot) == "string",`ERROR in unequip: slot must be string`);
		console.assert(Number.isInteger(index) && index >= 0,"ERROR in unequip: index must be whole integer");
		console.assert(this.equipment.has(slot),`ERROR in unequip: attempted to unequip nonexistent slot`);

		var item = this.equipment.get(slot)[index];
		if (item instanceof Filler) {
			console.log(this.equipment.values());
			var multislot = Array.from(this.equipment.values()).flat().find(function (i) { return (i instanceof Item) && i.id === item.id });
			this.unequip(Array.from(multislot.equippable.slot)[0]);
		}
		else if (item !== null && (!item.sticky || mods.unsticky === true)){
			if (item.default === undefined && mods.destroy !== true) {
				inv().addItem(item.id);
			}
			if (item.onRemove !== undefined) {
				item.onRemove(this);
			}
			this.equipment.get(slot)[index] = null;

			// If your system always has to read something in an equipment slot, such as if you wish to calculate equipment effects through a call function or iterator, define default item names in DEFAULT_EQUIPMENT. Remember to define default equipment in the items database.
			if (typeof(setup.DEFAULT_EQUIPMENT) === "object") {
				console.assert(typeof(setup.DEFAULT_EQUIPMENT[slot]) === "string","ERROR in unequip: no default equipment specified for "+slot);
				this.equipment.get(slot)[index] = new Item(setup.DEFAULT_EQUIPMENT[slot]);
			}

			if (item.equippable.slot instanceof Set) {
				// If item was equipped to multiple slots, we have to clear all the other slots it covered.
				for (let slotName of item.equippable.slot) {
					var pos = this.equipment.get(slotName);
					for (let i = 0; i < pos.length; i++) {
						pos[i] = null;
					}
				}
			}
		}
	}

	unequipAll (mods) {
		this.equipment.forEach(function (slot,name) {
			slot.forEach(function(subslot,index) {
				this.unequip(name,index,mods);
			}, this);
		}, this);
	}

	equip (item) {
		// To equip an item, we also have to de-equip the existing item and return it to the inventory (unless you want players to lose replaced equipment). This function checks that the equipment slot exists and that it's filled by something. If it is, the current equipment is extracted and added to the inventory before we set the new equipment.
		// If the item has any special equipment functionality, such as modifying stats, its onEquip function is passed the actor to modify.
		console.assert(typeof(item.equippable) == "object","ERROR in equip: Item has no equippable property");
		if (item.equippable.slot instanceof Set) {
			var slotList = item.equippable.slot;
			for (let slot of slotList) {
				console.assert(this.equipment.has(slot),"ERROR in equip: Equipment type not recognized");
			}
			for (let [s,slot] of Array.from(slotList).entries()) {
				var pos = this.equipment.get(slot);
				for (let i = 0; i < pos.length; i++) {
					this.unequip(slot,i);
					pos[i] = (s > 0 || i > 0) ? new Filler(item.id) : item;
				}
			}
		} else {
			console.assert(this.equipment.has(item.equippable.slot),"ERROR in equip: Equipment type not recognized");
			var slot = this.equipment.get(item.equippable.slot);
			var existing = null;
			var subslot = -1;
			// Run over the equipment subslots and find the first one that is empty (contains null)
			for (let i = 0; i < slot.length; i++) {
				if (slot[i] === null) {
					subslot = i;
					break;
				}
			}
			// If no empty subslot found (still -1), all subslots are occupied. Grab the item in the last subslot so we can unequip it.
			if (subslot === -1) {
				subslot = slot.length-1;
				existing = slot[subslot];
			}
			// If an item is already equipped in this slot, unequip it.
			if (existing !== null) this.unequip(item.equippable.slot,subslot);

			// Assign the item to the slot.
			slot[subslot] = item;
		}

		if (item.onEquip !== undefined){
			item.onEquip(this);
		}
		if (inv() instanceof Inventory && inv().has(item.id)){
			inv().decItem(item.id);
		}
	}

	hasEquipped (name) {
		var result = false;
		for (let [slot,item] of this.equipment) {
			for (let subitem of item) {
				if (subitem !== null && subitem.id == name) {
					return true;
				}
			}
		}
		return result;
	}

	hasCursedItem () {
		var result = false;
		this.equipment.forEach(function (slot,name) {
			slot.forEach(function (subitem) {
				if (subitem !== null && subitem.sticky === true) {
					result = true;
				}
			});
		});
		return result;
	}

	checkRestriction (item) {
		// Shorthand for checking equipment restrictions. Returns true if puppet's name is in the restricted listing.
		return (item.equippable.restrictedTo instanceof Array)
			? (item.equippable.restrictedTo.includes(this.name))
			: true
	}

	// TOLERANCE FUNCTIONS

	getTol (key) {
		// This is for evaluating tolerance in-battle, and therefore only returns the current value. DON'T use it to access the whole tolerance object, because that's not what it returns.
		if (!this.tolerances.has(key)){
			return undefined;
		} else {
			return this.tolerances.get(key).currentVal;
		}
	}

	decTol (key, amt = 1) {
		this.tolerances.get(key).currentVal -= amt;
	}

	resetTol (key) {
		this.tolerances.get(key).refill();
	}

	setTol (array) {
		// Easy way to set base tolerances. Takes an array of arrays that each contain two elements, the name of the effect and the base value.
		array.forEach(function(data) {
			if (this.tolerances.has(data[0])) {
				this.tolerances.get(data[0]).base = data[1];
			}
		}, this);
	}

	// GRID FUNCTIONS

	set row (num) {
		console.assert(Number.isInteger(num),`ERROR in row setter: row must be integer`);
		console.assert(num > 0,`ERROR in row setter: row must be positive`);
		console.assert(num <= setup.COLUMN_SIZE,`ERROR in row setter: row cannot be greater than column size`);
		this._row = num;
	}

	get row () {
		return (this._row || 1);
	}

	set col (num) {
		console.assert(Number.isInteger(num),`ERROR in column setter: column must be integer`);
		console.assert(num > 0,`ERROR in column setter: column must be positive`);
		console.assert(num <= setup.ROW_SIZE,`ERROR in column setter: column cannot be greater than row size`);
		this._col = num;
	}

	get col () {
		return (this._col || this.ownParty.indexOf(this) + 1);
	}

	get gridArea () {
		//	For use with CSS styling.
		if (this instanceof Enemy) {
			return `grid-area: ${setup.COLUMN_SIZE - this.row + 1} / ${this.col}`;
		} else {
			return `grid-area: ${this.row} / ${this.col}`;
		}
	}

	get position () {
		//	Returns this character's cell in the grid object.
		//	Note this does NOT return the cell's contents, but the cell itself.
		var grid;
		if (V().inbattle === true) {
			switch (this.id.charAt(0)) {
				case 'p':
					grid = V().puppetGrid;
					break;
				case 'e':
					grid = V().enemyGrid;
					break;
			}
		} else {
			grid = V().grid;
		}
		console.assert(grid instanceof Array,`ERROR in position getter: grid does not exist or is not array`);
		return grid[this.row-1][this.col-1];
	}

	set position (pos) {
		//	Adjusts row and column simultaneously and automatically swaps with the contents of the new cell.
		//	pos = array of 2 positive integers, [row,col]
		console.assert(pos instanceof Array && pos.length >= 2,`ERROR in position setter: pos must be array with 2 elements`);
		console.assert(pos[0] > 0 && pos[1] > 0,`ERROR in position setter: pos must be positive`);
		console.assert(pos[0] <= setup.COLUMN_SIZE,`ERROR in position setter: row cannot be greater than column size`);
		console.assert(pos[1] <= setup.ROW_SIZE,`ERROR in position setter: column cannot be greater than row size`);
		var org;
		try {
			org = this.position;
		} catch (e) {
			org = this.ownParty.find(function (a) { return a && a.row === pos[0] && a.col === pos[1] });
		}
		var row = this.row;
		var col = this.col;
		this.row = pos[0];
		this.col = pos[1];
		// hold the contents of the cell that will be at the actor's new position
		var holder;
		try {
			holder = this.position.contents;
		} catch (e) {
			holder = org;
		}
		if (holder instanceof Actor) {
			holder.row = row;
			holder.col = col;
		}
		try {
			// populate the new cell with this character
			this.position.contents = this;
			// move the held contents to the original position
			org.contents = holder;
		} catch (e) {
			// if no grid defined, further adjustments unnecessary; end here
		}
	}

	get guardBreak () {
		//	Boolean. If true, this character will not guard characters behind them.
		//	By default, dead characters will automatically return true.

		return (this.dead || this.effects.find(function(eff) { return eff && eff.guardBreak }));
	}

	get guarded () {
		//	Boolean. Returns true if guardCheck returns a different target, and false otherwise.

		var newTarget = Hitlist.guardCheck(this);
		return newTarget === this ? false : true;
	}

	numAdjacent (area) {
		//	Integer. Returns the number of OTHER characters in the group specified; does not include calling character
		//	area: string; corresponds to one of the AoE types
		console.assert(typeof(area) === "string",`ERROR in numAdjacent: area must be string`);

		switch (area) {
			case 'col':
			case 'column':
				return this.ownParty.filter(function (a) { return a && a.id !== this.id && a.col === this.col }).length;
			case 'row':
				return this.ownParty.filter(function (a) { return a && a.id !== this.id && a.row === this.row }).length;
			case '+':
			case 'adjacent':
				return this.ownParty.filter(function (a) { return a && a.id === target().id && (
					(a.col === target().col && (a.row === target().row + 1 || a.row === target().row - 1)) ||
					(a.row === target().row && (a.col === target().col + 1 || a.col === target().col - 1))
				)}).length;
			default:
				return 0;
		}
	}

	// TIMELINE FUNCTIONS

	get ticks () {
		return this._ticks;
	}

	set ticks (num) {
		console.assert(Number.isInteger(num),`ERROR in tick setter: non-integer passed`);
		this._ticks = Math.max(0,num);
	}

	// BOOLEAN FLAGS

	get immortal () {
		var val = this._immortal;
		if (val === undefined) {
			val = this.data.immortal;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	set immortal (flag) {
		console.assert(typeof(flag) === "boolean",`ERROR in immortal setter: non-Boolean passed`);
		this._immortal = flag;
	}

	get large () {
		var val = this._large;
		if (val === undefined) {
			val = this.data.large;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	set large (flag) {
		console.assert(typeof(flag) === "boolean",`ERROR in large setter: non-Boolean passed`);
		this._large = flag;
	}

	get maskhp () {
		var val = this._maskhp;
		if (val === undefined) {
			val = this.data.maskhp;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	set maskhp (flag) {
		console.assert(typeof(flag) === "boolean",`ERROR in maskhp setter: non-Boolean passed`);
		this._maskhp = flag;
	}

	get loadBearing () {
		//	Boolean. If true, defeating this character will instantly end the encounter.

		var val = this._loadBearing;
		if (val === undefined) {
			val = this.data.loadBearing;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	set loadBearing (flag) {
		console.assert(typeof(flag) === "boolean",`ERROR in loadBearing setter: non-Boolean passed`);
		this._loadBearing = flag;
	}

	get uncounted () {
		//	Boolean. If true, this character does not need to be defeated to end an encounter.

		var val = this._uncounted;
		if (val === undefined) {
			val = this.data.uncounted;
		}
		if (val === undefined) {
			val = false
		}
		return val;
	}

	set uncounted (flag) {
		console.assert(typeof(flag) === "boolean",`ERROR in uncounted setter: non-Boolean passed`);
		this._uncounted = flag;
	}

	// MISCELLANEOUS

	regenHP () {
		var gain = 0;
		var mod;
		gain += this.maxHP * this.HPregenPercent;
		gain += this.HPregenFlat;
		if (gain === 0) {
			return;
		}
		this.hp = Math.max(this.hp + gain,1);		//	HP degen cannot take HP below 1
		if (gain > 0) {
			mod = "truegreen";
			gain = "+"+gain;
		}
		this.addPopup({type: "regen", content: gain, mod: mod});
	}

	addPopup (popup) {
		console.assert(typeof(popup) === "object" && popup.content !== undefined,`ERROR in addPopup for ${this.name}: invalid popup object`);
		if (setup.ANIMATIONS === true && this.battleMsg instanceof Array) {
			if (temporary().queue instanceof Set) {	temporary().queue.add(this) }
			this.battleMsg.push(popup);
		}
		return;
	}

	hasEffect (name) {
		//	name = string or array, name of effect to check

		return this.effects.map(function (e) { return e.name }).includesAny(name);
	}

	get actionReady () {
		//	Returns true if actor has a valid delayed action stored,
		//	and they can perform it (not dead/held/uncontrollable, or delayPersist)

		return (this.delayedAction instanceof Action && this.delayCounter <= 0 &&
			(this.delayedAction.delayPersist ||
				!(this.dead || this.fakedeath || this.noact || this.uncontrollable)));
	}

	effectCount (type,mods) {
		//	Returns the number of instances of the named effect currently posessed by this actor.
		//	Can search for specific effects or classes of effect: buffs, ailments, DoTs, holds, blocks, shields, or all.
		//	Note that unlike for other effect functions, you must specify if you do NOT want stickies counted.
		//	mods is an array of strings.
		//		"nosticky": effects will not count if they are sticky

		console.assert(typeof(type) == "string",`ERROR in effectCount: non-string passed`);
		mods = (mods || []);
		let count = 0;
		this.effects.forEach(function (effect) {
				if (!(effect.sticky && mods.includes("nosticky")) &&
						effect.name == type ||
						type == "all" ||
						type == "buff" && effect.buff ||
						type == "ailment" && !effect.buff ||
						type == "dot" && effect.dot ||
						type == "hold" && effect.hold ||
						type == "block" && effect.block ||
						type == "shield" && effect.shield) {
							if (mods.includes("threat")) {
								count += effect.threat;
							} else {
								count++;
							}
				}
			});

		return count;
	}

	replenishUses (name) {
		//	name = string
		//	Refills the uses of all actions matching the passed name.

		console.assert(typeof(name) == "string",`ERROR in replenishUses: action name must be string`);
		this.actions.forEach(function (action) {
			if (action.name === name) action.refill();
		});
		return;
	}

	clone () {
		// Return a new instance containing our current data.
		return new Actor(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Actor($ReviveData$)', data);
	}
};
/* twine-user-script #5: "class-bestiary.js" */
window.BestiaryEntry = class BestiaryEntry {
	constructor(name,enemy){
	//	name: String, name of database entry
	//	enemy: Object, associated data from enemy database

	if (typeof(name) === "string"){
		this.name = name;
		this.encountered = false;
		this.defeated = 0;
		this.statsKnown = {
			"hp": false,
			"gp": false,
			"xp": false
		};
		this.tolerancesKnown = {};

		if (enemy.stats !== undefined) {
			for (let stat in enemy.stats) {
				this.statsKnown[stat] = false;
			}
		}
		if (setup.ELEMENT_LIST !== undefined) {
			setup.ELEMENT_LIST.forEach(function (elmn) {
				this.statsKnown[elmn] = false;
			},this);
			this.elementData = this.access().elements;
		}
		if (enemy.tolerances !== undefined) {
			for (let tolerance in enemy.tolerances) {
				this.tolerancesKnown[tolerance] = false;
			}
		}

		if (enemy.alts !== undefined) {
			this.altSkin = null;
			this.altsKnown = {};
			enemy.alts.forEach(function (alt) {
				this.altsKnown[alt] = false;
			},this);
		}
	}
	else {
		Object.keys(name).forEach(prop => this[prop] = clone(name[prop]));
	}

	}

	get data () {
		return (setup.enemyData[this.altSkin] || setup.enemyData[this.name]);
	}

	get baseData () {
		return setup.enemyData[this.name];
	}

	get bestiaryNo () {
		return setup.enemyData[this.name].bestiaryNo;
	}

	get desc () {
		return (this.data.desc || this.access().desc);
	}

	get abilityInfo () {
		return (this.data.abilityInfo || this.baseData.abilityInfo || "Pending.");
	}

	get itemDrops () {
		return (this.data.itemDrops || {});
	}

	get (stat) {
		//	stat = String, assumes valid match for entry in statsKnown

		console.assert(typeof(stat) == "string","ERROR in BestiaryEntry.get(): stat argument "+stat+" is not a string");
		if (this.statsKnown[stat] === true) {
			let s = stat.toLowerCase();
			if (s == 'hp' || s == 'gp' || s == 'xp') {
				return (this.data[s] || this.baseData[s] || 0);
			} else if (setup.ELEMENT_LIST.includes(s)) {
				return this.elementData[s];
			} else {
				let statData = (this.data.stats || this.baseData.stats);
				if (typeof(statData) == 'object') {
					return (statData[stat] || this.baseData.stats[stat]);
				} else {
					console.log("ERROR in BestiaryEntry.get(): database entry has no stat object");
					return;
				}
			}
		} else {
			return "???";
		}
	}

	revealAll () {
		//	Sets all data flags to true, allowing all information to be displayed to the player

		this.encountered = true;
		for (let pn in this.statsKnown) {
			this.statsKnown[pn] = true;
		}
		if (Object.keys(this.tolerancesKnown).length > 0) {
			for (let pn in this.tolerancesKnown) {
				this.tolerancesKnown[pn] = true;
			}
		}
	}

	access () {
		//	Creates an Enemy object with the same name as the BestiaryEntry.
		//	Use to access specific Enemy functions needed for displaying data.

		return new Enemy(this.name);
	}

	clone () {
		// Return a new instance containing our current data.
		return new BestiaryEntry(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new BestiaryEntry($ReviveData$)', data);
	}
}

window.Bestiary = class Bestiary extends Array {
	constructor(foo) {
	if (typeof(foo) == 'object'){
		super(0);
		Object.keys(foo).forEach(prop => this[prop] = clone(foo[prop]));
	}
	else {
		super(0);
		for (let [name,enemy] of Object.entries(setup.enemyData)) {
			if (typeof(enemy.bestiaryNo) == "number") {
				this.push(new BestiaryEntry(name,enemy));
			}
		}
		this.sort(function (a,b) { return a.bestiaryNo - b.bestiaryNo});
	}
	}

	fetch (name) {
		//	name = String, assumes Bestiary contains matching name

		console.assert(typeof(name) == "string","ERROR in Bestiary.fetch(): non-string argument passed");

		return this.find(function (e){ return e.name === name; });
	}

	encountered () {
		//	Returns array of only encountered enemies

		return this.filter(function (e) { return e.encountered === true; });
	}

	nextEntry (index) {
		//	index = nonnegative integer
		//	finds the next entry in the Bestiary that has been encountered

		if (index+1 >= this.length) {
			//	If out of bounds, loop around, start from beginning
			index = -1;
		}
		for (let i = index+1; i < this.length; i++) {
			if (this[i].encountered === true) {
				return this[i];
			}
		}
		return this[index];
	}

	lastEntry (index) {
		//	index = nonnegative integer
		//	finds the previous entry in the Bestiary that has been encountered

		if (index-1 < 0) {
			//	If out of bounds, loop around, start at end
			index = this.length;
		}
		for (let i = index-1; i >= 0; i--) {
			if (this[i].encountered === true) {
				return this[i];
			}
		}
		return this[index];
	}

	clone () {
		// Return a new instance containing our current data.
		return new Bestiary(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Bestiary($ReviveData$)', data);
	}
};
/* twine-user-script #6: "class-effect.js" */
window.Effect = class Effect {
	constructor(name,time,power,special){
		if (typeof(name) == 'object'){
			Object.keys(name).forEach(prop => this[prop] = clone(name[prop]));
		}
		else {
			special = (special || {});
			this.name = name;
			this.duration = Number.isInteger(time) ? time : 1;
			this.power = typeof(power) == 'number' ? power : 0;
			if (Number.isInteger(this.effectData.uses)) {
				this.uses = this.effectData.uses;
			}
			if (special.weight) {
				this.weight = special.weight;
			}
			if (special.target instanceof Actor) {
				this.target = special.target;
			}
		}
	}

	get effectData () {
		return (setup.effectData[this.name] || {});
	}

	get duration () {
		return this._duration;
	}

	set duration (amt) {
		this._duration = Math.min(amt,setup.DURATION_MAX);
	}

	get info () {
		return (this._info || this.effectData.info || function () { return "Unknown."; });
	}

	get addText () {
		return (this._addText || this.effectData.addText || function (target) { return `${target} is afflicted with <b>${this.name}</b>!`; });
	}

	get removeText () {
		return (this._removeText || this.effectData.removeText || function (target) { return `${target} is cured of ${this.name}.`; });
	}

	get onApply () {
		return (this._onApply || this.effectData.onApply || function () { return; });
	}

	get onRemove () {
		return (this._onRemove || this.effectData.onRemove || function () { return; });
	}

	get dmgtype () {
		return (this._dmgtype || this.effectData.dmgtype || function () { return 0; });
	}

	get msg () {
		return (this._msg || this.effectData.msg || function () { return null; });
	}

	get buff () {
		var val = this._buff;
		if (val === undefined) {
			val = this.effectData.buff;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get stackable () {
		var val = this._stackable;
		if (val === undefined) {
			val = this.effectData.stackable;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get exclusive () {
		var val = this._exclusive;
		if (val === undefined) {
			val = this.effectData.exclusive;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get statmod () {
		var val = this._statmod;
		if (val === undefined) {
			val = this.effectData.statmod;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get dot () {
		var val = this._dot;
		if (val === undefined) {
			val = this.effectData.dot;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get shield () {
		var val = this._shield;
		if (val === undefined) {
			val = this.effectData.shield;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get hold () {
		var val = this._hold;
		if (val === undefined) {
			val = this.effectData.hold;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get untargetable () {
		var val = this._untargetable;
		if (val === undefined) {
			val = this.effectData.untargetable;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get uncontrollable () {
		var val = this._uncontrollable;
		if (val === undefined) {
			val = this.effectData.uncontrollable;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get healBlock () {
		var val = this._healBlock;
		if (val === undefined) {
			val = this.effectData.healBlock;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get noENregen () {
		var val = this._noENregen;
		if (val === undefined) {
			val = this.effectData.noENregen;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get interruptGuard () {
		var val = this._interruptGuard;
		if (val === undefined) {
			val = this.effectData.interruptGuard;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get block () {
		var val = this._block;
		if (val === undefined) {
			val = this.effectData.block;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get blockCondition () {
		return (this._blockCondition || this.effectData.blockCondition || function () { return false });
	}

	get blockText () {
		return (this._blockText || this.effectData.blockText || function () { return `BLOCK TEXT FOR ${this.name} UNSET` });
	}

	get topDec () {
		var val = this._topDec;
		if (val === undefined) {
			val = this.effectData.topDec;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get sticky () {
		var val = this._sticky;
		if (val === undefined) {
			val = this.effectData.sticky;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get ULTIMATESTICKY () {
		var val = this._ULTIMATESTICKY;
		if (val === undefined) {
			val = this.effectData.ULTIMATESTICKY;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get unblockable () {
		var val = this._unblockable;
		if (val === undefined) {
			val = this.effectData.unblockable;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get persistAfterDeath () {
		var val = this._persistAfterDeath;
		if (val === undefined) {
			val = this.effectData.persistAfterDeath;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get persistAfterBattle () {
		var val = this._persistAfterBattle;
		if (val === undefined) {
			val = this.effectData.persistAfterBattle;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get weight () {
		return (this._weight || this.effectData.weight || 0);
	}

	set weight (amt) {
		this._weight = amt;
	}

	get shock () {
		// integer between 1 and 100, equal to chance of being cured by direct damage from attacks.
		// value of true is equivalent to 100% chance.
		// if noninteger, will default to Boolean false
		var result = (this._shock || this.effectData.shock || false);
		if (Number.isInteger(result)) {
			return Math.clamp(result,1,100);
		}
		else if (result === true) {
			return 100;
		}
		else {
			return false;
		}
	}

	get holdAction () {
		return (this._holdAction || this.effectData.holdAction || null);
	}

	get priority () {
		//	Integer. Order for which hold effects get resolved first. Lower numbers are resolved earlier.
		//	Defaults to 0.

		var val = this._priority;
		if (!Number.isInteger(val)) {
			val = this.effectData.priority;
		}
		if (!Number.isInteger(val)) {
			val = 0;
		}
		return val;
	}

	get onHit () {
		return (this._onHit || this.effectData.onHit || null);
	}

	get uses () {
		return this._uses;
	}

	set uses (amt) {
		//	Tracks uses for shield effects. Each use will block/interact with one attack. When uses are exhausted, the effect is removed.
		//	Currently there is no easy way to track the character an effect is attached to from within the effect, so this always removes the effect from the target, as this should only be changing when a character is the target of an attack.

		this._uses = amt;
		if (this.uses <= 0) {
			console.log("uses dropped to 0, should remove effect");
			target().removeEffect(this.name,{unsticky: true, pierce: true, noPopup: true});
		}
	}

	get synonym () {
		//	String. If defined, effect will be blocked by the tolerance matching this name rather than its own.
		//	Must match an extant tolerance value EXACTLY.

		return (this._synonym || this.effectData.synonym || false);
	}

	get threat () {
		//	Number. Added to weighting when selecting targets for dispelling.
		//	Defaults to 1.

		var val = this._threat;
		if (typeof(val) !== "number") {
			val = this.effectData.threat;
		}
		if (typeof(val) !== "number") {
			val = 1;
		}
		if (this.duration < 0) {
			val *= setup.INDEFINITE_EFFECT_MULTIPLIER;
		} else {
			val += ((this.duration-1)/setup.EFFECT_THREAT_CUT);
		}
		return val;
	}

	get unique () {
		//	Boolean. If true, only one instance of this effect can exist per party.

		var val = this._unique;
		if (val === undefined) {
			val = this.effectData.unique;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get guardBreak () {
		//	Boolean. If true, characters with this effect cannot guard characters behind them in the battle map.

		var val = this._guardBreak;
		if (val === undefined) {
			val = this.effectData.guardBreak;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get skillLock () {
		//	Boolean. If true, this effect will prevent the victim from using non-basic actions.

		var val = this._skillLock;
		if (val === undefined) {
			val = this.effectData.skillLock;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	get guard () {
		//	Boolean. If true, this effect causes the subject to guard another character.

		var val = this._guard;
		if (val === undefined) {
			val = this.effectData.guard;
		}
		if (val === undefined) {
			val = false;
		}
		return val;
	}

	damage (actor) {
		console.assert(this.dot,`ERROR in effect ${this.name}: damage function called on non-DoT`);
		var dmg = Math.round(this.dmgtype(actor));
		if (dmg < setup.min_DoT){
			dmg = setup.min_DoT;
		}
		return dmg;
	}

	decay (actor) {
		if (this.duration >= 1 && !(actor.stasis && this.name != "Stasis")) {
      this.duration -= 1;
		}
		if (this.duration == 0) {
      var m = actor.removeEffect(this,{pierce: true, unsticky: "ultimate", noPopup: true});
			if (m.length > 1) {
				State.temporary.message = true;
			}
			return m;
		} else {
			return "";
		}
	}
}

Effect.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new Effect(this);
};

Effect.prototype.toJSON = function () {
	// Return a code string that will create a new instance
	// containing our current data.
	const data = {};
	Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
	return JSON.reviveWrapper('new Effect($ReviveData$)', data);
};
/* twine-user-script #7: "class-enemy.js" */
window.Enemy = class Enemy extends Actor {
	constructor(name,pos){
	if (typeof(name) == 'object'){
		super(name,pos);
	}
	else {
		super(name,pos);

		if (this.data.cooldown) { this.cd = new Map(Object.entries(this.data.cooldown)); }
		this._noAttacks = Number.isInteger(this.data.noAttacks) && this.data.noAttacks > 0
			? new FillStat(this.data.noAttacks)
			: new FillStat(1);
		if (this.data.specialInit) { this.data.specialInit(this); }

		if (setup.THREAT_TARGETING === true) {
			this.threat = new Map();
			puppets().forEach(function(puppet) {
				this.threat.set(puppet.name,puppet.initialThreat());
			}, this);
		}

		if (this.boss === undefined) { this.boss = false; }
		if (this.aggro === undefined) { this.aggro = false; }
	}
	}

	decCD () {
		if (this.cd !== undefined){
			this.cd.forEach(function(v,k){
				this.cd.inc(k,-1);
			}, this);
		}
	}

	CDcheck (key) {
		return (this.cd.get(key) <= 0);
	}

	get actions () {
		return (this._actions || this.data.actions || null);
	}

	get priority () {
		var r;
		if (this._priority !== undefined) {
			r = this._priority;
		} else if (this.data.priority !== undefined) {
			r = this.data.priority;
		}
		return Number.isInteger(r) ? r : enemies().indexOf(this);
	}

	set xp (num) {
		console.assert(Number.isInteger(num) && num > 0,`ERROR in xp setter: must be positive integer`);
		this._xp = num;
	}

	get xp () {
		var r;
		if (this._xp !== undefined) {
			r = this._xp;
		} else if (this.data.xp !== undefined) {
			r = this.data.xp;
		}
		return Number.isInteger(r) ? r : 0;
	}

	get XP () {
		return this.xp;
	}

	set gp (num) {
		console.assert(Number.isInteger(num) && num > 0,`ERROR in gp setter: must be positive integer`);
		this._gp = num;
	}

	get gp () {
		var r;
		if (this._gp !== undefined) {
			r = this._gp;
		} else if (this.data.gp !== undefined) {
			r = this.data.gp;
		}
		return Number.isInteger(r) ? r : 0;
	}

	get GP () {
		return this.gp;
	}

	get itemDrops () {
		//	Item drop table. Drop tables should be in the format of objects, with the item names as properties and their drop rate in integer percentage as values.

		return (this._itemDrops || this.data.itemDrops || {});
	}

	get mercy () {
		if (this._mercy !== undefined) {
			return this._mercy;
		} else if (this.data.mercy !== undefined) {
			return this.data.mercy;
		} else {
			return 3;
		}
	}

	get noAttacks () {
		return this._noAttacks.currentVal;
	}

	set noAttacks (amt) {
		this._noAttacks.currentVal = amt;
	}

	get isFirstAction () {
		//	Boolean, for enemies that take multiple actions per round; returns true if enemy has not yet performed any action this round

		return (!this.dead && V().B.actionsThisTurn[this.id] instanceof Array && V().B.actionsThisTurn[this.id].length == 0);
	}

	get surrender () {
		//	function, determines behavior if spared

		return (this._surrender || this.data.surrender || false);
	}

	get surrenderFail () {
		//	function, determines behavior if surrender violated

		return (this._surrenderFail || this.data.surrenderFail || false);
	}

	get noBestiary () {
		//	if true, enemy will not have a bestiary entry
		//	useful for abstract database entries e.g. form changes

		return (this.data.noBestiary || false);
	}

	get desc () {
		//	String, description to be displayed in the bestiary entry.

		return (this.data.desc || "Description goes here. Lorem ipsum dolor sit amen. This is a sentence. Filler text.");
	}

	get actionsThisTurn () {
		try {
			return V().B.actionsThisTurn[this.id];
		} catch (e) {
			return [];
		}
	}

	changeInto (name) {
		// Alters character attributes for mid-battle changes. By default, checks for HP, stat, and action changes.

		if (setup.enemyData[name].hp) {
			this.setMaxHP(setup.enemyData[name].hp);
		}
		if (setup.enemyData[name].stats) {
			for (let [pn,v] of Object.entries(setup.enemyData[name].stats)) {
				this.setBase(pn,v);
			}
		}
		if (setup.enemyData[name].actions) {
			this._actions = setup.enemyData[name].actions;
		}

		if (setup.enemyData[name].special) {
			// for any miscellaneous changes, specify them in a "special" function
			setup.enemyData[name].special(this);
		}
	}

	surrenderCheck () {
		if (this.surrenderFail() !== undefined && !action().truce) {
			return "\n" + this.surrenderFail();
		}
		return;
	}

	validTarget () {
		//	Returns Boolean. Determination for if character can be selected by the player in Targeting Phase.
		//	To customize, use Object.defineProperty.

		if (!(V().B.targeting === "all" || V().B.targeting === "enemy")) {
			//	If not targeting enemies, invalid target
			return false;
		} else if (this.dead && !action().canTargetDead) {
			//	If this actor is dead, invalid target UNLESS action canTargetDead
			return false;
		} else if (this.martyr) {
			//	If martyr, valid target
			return true;
		}
		let martyr = this.ownParty.find(function (a) { return a && a.martyr === true });
		if (martyr) {
			//	If a martyr exists and they're not this, invalid target
			return false;
		} else if (this.untargetable) {
			//	If untargetable, invalid target
			return false;
		} else if (Hitlist.guardCheck(this).id !== this.id) {
			//	For battle map: If guardCheck returns this (not guarded by anyone), valid target
			//	Bypassed if using a ranged action, which can hit anyone
			return false;
		} else {
			return true;
		}
	}

	clone () {
		// Return a new instance containing our current data.
		return new Enemy(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Enemy($ReviveData$)', data);
	}
};
/* twine-user-script #8: "class-item.js" */
/*
Customizable equipment:
	If like FFX, equipment has N number of slots that can be filled by traits. Each trait is a distinct item with a specific name and property, e.g. Strength +5% always boosts physical attacks by 5%.

	This could be handled with a trait database, with every trait having a unique description and onEquip functions.

	So for instance...

	"Red Ward": {
		"augment": 0.5,
		"desc": "Red resistance +"+this.augment*100+"%",	\\ no object so this won't work
		"onApply": function (puppet) {
			this.modID.blue = puppet.elements.addMod("red","Red Ward",this.augment,true,"flat");
		}
	}
*/


window.Item = class Item {
/*
Due to the way the Inventory class works (see below), subclass inheritance is not recommended for specialized items. Property flags are used instead.

equippable -> object, must have a "slot" attribute; can also add data for restrictions or special categories (e.g., tag "heavy" then exclude mages from wearing heavy armor, or make an array of characters who can wear it)
*/
	constructor(name,stock = 0){
	if (typeof(name) == 'object') {
		Object.keys(name).forEach(prop => this[prop] = clone(name[prop]));
	} else {
		this._name = name;
		if (this.usable.includes("inmenu") && this.onUse === undefined) {
			console.log(`WARNING: item ${name} does not have an onUse`);
		}
		if (this.equippable && this.onEquip === undefined) {
			console.log(`WARNING: item ${name} does not have an onEquip`);
		}
		if (this.equippable && this.onRemove === undefined) {
			console.log(`WARNING: item ${name} does not have an onRemove`);
		}
		this.stock = stock;
		this.maxstock = stock;

		if (this.equippable !== undefined) {
			this.modID = {};
		}
	}

	}

	get id() {
		//	Returns the item's hardcoded name for referencing the database. Use this for accessing data & etc.

		return this._name;
	}

	get name() {
		//	Returns the name that is displayed to the player in user interfaces & etc.
		//	If the item has a fakeName and does not have the "known" property, displays fakeName; otherwise, displays database name.

		return (this.fakeName && !this.known) ? this.fakeName : this._name;
	}

	get itemData () {
		return (setup.itemData[this.id] || {});
	}

	get info() {
      var val = (this.itemData.info || "Info pending.");
			return (val instanceof Function) ? val(this) : val;
  }

  get desc() {
      var val = (this.itemData.desc || "Description pending.");
			return (val instanceof Function) ? val(this) : val;
  }

	get special() {
    return (this.itemData.special || 0);
  }

	get value() {
		let r = (this.itemData.value || 0);
		r = (r instanceof Function) ? r(this) : r;
		console.assert(Number.isInteger(r),`ERROR in value getter for ${this.name}: non-integer value`);

    return r;
  }

  get usable() {
    return (this.itemData.usable || []);
  }

	get onUse() {
    return (this.itemData.onUse || undefined);
  }

	get instantUse() {
		//	Boolean. If true, the item's onUse will be executed immediately, instead of requiring a target.
		//	This is useful for e.g. items that affect the whole party or call up another passage for more detailed interaction.

		return (this.itemData.instantUse || false);
	}

	get equippable() {
      return (this.itemData.equippable || undefined);
  }

	get onEquip() {
      return (this.itemData.onEquip || undefined);
  }

	get onRemove() {
      return (this.itemData.onRemove || undefined);
  }

	get action() {
		console.assert(this.usable.includes("inbattle"),`ERROR in action getter for ${this.name}: item is not usable inbattle`);
		var name = this.itemData.action || this.name;
		if (this.usable.includes("inbattle")) {
			var action = new ItemAction(name);
			return action;
		} else {
			return undefined;
		}
	}

	get sticky() {
		//	If true, item cannot be unequipped through normal means.

		return (this.itemData.sticky || false);
	}

	get fakeName() {
		//	If defined, the item will display this name on the inventory screen unless its "known" property is true.
		//	Useful for cursed items, or other items you wish to make ambiguous to the player.

		return (this.itemData.fakeName || false);
	}

	get stackSize() {
		//	Integer. Maximum number of copies that can exist in an inventory.
		//	Defaults to ITEM_MAX.

		return (this.itemData.stackSize || setup.ITEM_MAX);
	}

	get restrictedTo () {
		//	Shorthand for getting the restrictedTo property of the equippable object.
		return (typeof(this.equippable) == "object")
			? this.equippable.restrictedTo
			: undefined;
	}

	checkRestriction (puppet) {
		//	DEPRECIATED as of v1.18. Use the Actor version instead.
		// Shorthand for checking equipment restrictions. Returns true if puppet's name is in the restricted listing or if the restricted listing is empty.
		return (this.restrictedTo instanceof Array)
			? (this.restrictedTo.includes(puppet.name))
			: true
	}

	toString () {
		var text = `<span class="item-name">${this.name}</span>`;
		text += `<span class="action-tags">x${this.stock}</span>`;
		if (this.equippable) {
			if (this.equippable.slot instanceof Set) {
				text += `<div class="item-equippable">`;
				var array = Array.from(this.equippable.slot).entries();
				for (let [s,slot] of array) {
					text += slot;
					if (s < this.equippable.slot.size-1) text += " + ";
				}
				text += `</div>`;
			} else {
				text += `<div class="item-equippable">${this.equippable.slot}</div>`;
			}
			if (this.restrictedTo instanceof Array && this.restrictedTo.length > 0) {
				text += `<div class="item-equippable">Restriction:`
				for (let [n,name] of this.restrictedTo) {
					text += ` ${name}`;
					if (n < this.restrictedTo.length-1) text += ",";
				}
				text += `</div>`;
			}
		}
		text += `<div id="display-content">`;
		text += `<div class="action-info">${this.info}</div>`;
		if (this.desc !== null) text += `<div class="action-desc">${this.desc}</div>`;
		text += `</div>`;
		return text;
	}

	clone () {
		// Return a new instance containing our current data.
		return new Item(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Item($ReviveData$)', data);
	}
};

window.Filler = class Filler {
	constructor(name) {
		this.id = name;
	}

	toString () {
		return "&mdash;&mdash;";
	}

	clone () {
		// Return a new instance containing our current data.
		return new Filler(this.id);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		let data = this.id;
		return JSON.reviveWrapper('new Filler($ReviveData$)', data);
	}
};

window.Inventory = class Inventory extends Map {
	constructor(ItemArray){
		var m = [];
		ItemArray.forEach(function(item){
			m.push([item.id,item]);
		});
		super(m);
	}

	clone () {
		// Return a new instance containing our current data.
		return new Inventory(Array.from(this.values()));
	}

	toJSON() {
		// Return a code string that will create a new instance
		// containing our current data.
		let data = Array.from(this.values());
		return JSON.reviveWrapper('new Inventory($ReviveData$)', data);
	}

	addItem (name,amt) {
		if (amt === undefined){
			amt = 1;
		}
		if (this.has(name)){
			var item = new Item(name);
			if (this.get(name).stock + amt > item.stackSize) {
				let s = 1;
				while (((this.get(name).stock + 1) < item.stackSize) && s < amt) {
					this.get(name).stock += 1;
					s++;
				}
				return false;
			} else {
				this.get(name).stock += amt;
				return true;
			}
		} else {
			this.set(name,new Item(name,amt));
			return true;
		}
	}

	decItem (name,amt) {
		if (this.has(name)){
			if (amt === undefined){
				amt = 1;
			}
			var v = this.get(name);
			v.stock -= amt;
			if (v.stock <= 0){
				//this.delete(name);
			}
			return;
		} else {
			return "ERROR in decItem: item name not found in inventory\n";
		}
	}
};
/* twine-user-script #9: "class-music.js" */
window.Music = class Music {
	constructor (name) {
		this.title = name;
	}

	get musicData () {
		return (setup.musicData[this.title] || {});
	}

	get author () {
		return this.musicData.author;
	}

	get license () {
		return this.musicData.license;
	}

	get distributor () {
		return this.musicData.distributor;
	}

	clone () {
		// Return a new instance containing our current data.
		return new Music(this.title);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		return JSON.reviveWrapper('new Music($ReviveData$)', this.title);
	}
};
/* twine-user-script #10: "class-puppets.js" */
window.Puppet = class Puppet extends Actor{
	constructor(name,pos){
	if (typeof(name) == 'object'){
		super(name,pos);
	}
	else {
		super(name,pos);
		if (this.data) {
			this.actions = [];
			for (let n of this.data.actions) {
				this.actions.push(new Action(n));
			}
			this.defaultAction = this.data.defaultAction;
			this.crisis = [];
			if (this.data.crisis instanceof Array) {
				for (let n of this.data.crisis) {
					this.crisis.push(new Action(n));
				}
			} else if (typeof(this.data.crisis) == "string") {
				this.crisis.push(new Action(this.data.crisis));
			}
			if (this.data.specialInit) { this.data.specialInit(this); }

			this.lastAction = null;

			this.defeats = 0;
			this.kills = 0;

// Features used for level ups, explained further in the "Widgets: Leveling Up" passage. You (probably) want growth rates to be unique for every character, so they are blank Maps in the general constructor. Set them when creating a character via Call widget, or make a switch statement with a case for every character to define them here. The labels must match the stat labels exactly.
// By default, these attributes are for Puppets only. If you want to let Enemy objects level up, just move the code into the "Actor" class and they'll apply to both.

			this.level = 1;
			this.xp = 0;
		}

	}
	}

	get xp () {
		return this._xp;
	}

	get XP () {
		return this.xp;
	}

	set xp (num) {
		console.assert(Number.isInteger(num) && num > 0,`ERROR in xp setter: must be positive integer`);
		this._xp = num;
	}

	get levelRate () {
		return (this._levelRate || this.data.levelRate || 'medium');
	}

	get growthRates () {
		return (this.data.growthRates || {});
	}

	get StatTable () {
		return (this.data.StatTable || function () { console.log("ERROR in StatTable: no stat table for "+this.name); return; });
	}

	get portrait () {
		return (this.data.portrait || this.name.substring(0,5));
	}

	hasAction (name) {
		return this.actions.map(function (a) { return a.name; }).includes(name);
	}

	validTarget () {
		//	Returns Boolean. Determination for if character can be selected by the player in Targeting Phase.
		//	To customize, use Object.defineProperty.

		if (!(V().B.targeting === "all" || V().B.targeting === "ally")) {
			//	If not targeting allies, invalid target
			return false;
		} else if (action().noself === true && subject().id === this.id) {
			//	If action has noself enabled and this is the action user, invalid target
			return false;
		} else if (this.dead && !action().canTargetDead) {
			//	If this actor is dead, invalid target UNLESS action canTargetDead
			return false;
		} else {
			return true;
		}
	}

	clone () {
		// Return a new instance containing our current data.
		return new Puppet(this);
	}

	toJSON () {
		// Return a code string that will create a new instance
		// containing our current data.
		const data = {};
		Object.keys(this).forEach(pn => data[pn] = clone(this[pn]));
		return JSON.reviveWrapper('new Puppet($ReviveData$)', data);
	}
};
/* twine-user-script #11: "class-stat.js" */
window.Stat = class Stat {
// Designed by Akjosch

	constructor (base) {
		this._base = base;
		this._mods = {};
		this._current = undefined;
	}

	clearCache () {
		this._current = undefined;
	}

	addMod (id, mod, equipment) {
		id = String(id);
		var mods = this._mods[id] = this._mods[id] || [];
		if(Number.isFinite(mod)) {
			mod = { add: mod };
			if (equipment === true) {
				mod.equipment = true;
			}
		}
		if(typeof mod === "object") {
			var idx = 0;
			mods.forEach(function(mod) { idx = Math.max(idx, mod.idx); });
			mod.idx = (++ idx);
			mods.push(mod);
			this.clearCache();
			return mod.idx;
		}
	}

	removeMod (id, index) {
		id = String(id);
		if (Number.isFinite(index)) {
			this._mods[id].deleteWith(function(mod) { return (mod.idx === index); })
		} else {
			delete this._mods[id];
		}
		this.clearCache();
	}

	clearMods () {
		this._mods = {};
		this.clearCache();
	}

	get base () {
		return this._base;
	}

	set base (newBase) {
		newBase = Number(newBase);
		/* alternative: newBase = setup.roll(newBase) for "3d6" as inputs */
		if(!Number.isFinite(newBase)) {
			newBase = 0;
		}
		if (this._base !== newBase) {
			this._base = newBase;
			this.clearCache();
		}
	}

	get current () {
		if (this._current === undefined) {
			/* gather multipliers */
			var mult = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			/* gather sums */
			var add = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			this._current = this.base * (mult + 1) + add;
		}
			return this._current;
	}

	get bonus () {
		return this.current - this.base;
	}

	get equipBonus () {
		var mult = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return m.equipment === true ? m : {}; })
				.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		var add = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return m.equipment === true ? m : {}; })
				.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		return this.base * (mult + 1) + add - this.base;
	}

	toString () {
		var mult = Object.values(this._mods)
			.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
			.reduce(function(sum, add) { return sum + add; }, 0);
		var add = Object.values(this._mods)
			.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
			.reduce(function(sum, add) { return sum + add; }, 0);
		return this.current.toFixed(2)
			+ " [" + this.base.toFixed(2)
			+ " x " + (mult + 1).toFixed(2)
			+ (add >= 0 ? " + " + add.toFixed(2) : " - " + (-add).toFixed(2))
			+ "]";
	}

	/* SugarCube support */
	clone () {
		return Stat.create(this);
	}

	toJSON () {
		return JSON.reviveWrapper('Stat.create($ReviveData$)', Object.assign({}, clone(this)));
	}
};

Stat.create = function(vals) {
	vals = vals || {};
	var result = new Stat();
	result._base = vals._base;
	result._mods = clone(vals._mods);
	result._current = vals._current;
	return result;
};

window.FillStat = class FillStat extends Stat {
	// Stat that contains both a current and maximum value, such as tolerances or retaliations.
	// Due to inheritance, the "current" and "base" attributes actually refers to the maximum value. "currentVal" refers to the actual current value. Apologies for confusion.
	constructor (base) {
		super(base);
		this.currentVal = base;
	}

	clearCache () {
		this._current = undefined;
		this.refill();
	}

	refill () {
		this.currentVal = this.current;
	}

	get isFull () {
		return this.currentVal == this.current;
	}

	get base () {
		return this._base;
	}

	get current () {
		if (this._current === undefined) {
			/* gather multipliers */
			var mult = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			/* gather sums */
			var add = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			this._current = this.base * (mult + 1) + add;
		}
			return this._current;
	}

	set base (newBase) {
		newBase = Number(newBase);
		if(!Number.isFinite(newBase)) {
			newBase = 0;
		}
		if (this._base !== newBase) {
			this._base = newBase;
			this.clearCache();
		}
	}

	clone () {
		return FillStat.create(this);
	}

	toJSON () {
		return JSON.reviveWrapper('FillStat.create($ReviveData$)', Object.assign({}, clone(this)));
	}
}

FillStat.create = function(vals) {
	vals = vals || {};
	var result = new FillStat();
	result._base = vals._base;
	result._mods = clone(vals._mods);
	result._current = vals._current;
	result.currentVal = vals.currentVal;
	return result;
};

window.Tolerance = class Tolerance extends FillStat {
	constructor (base) {
		super(base);
	}

	get current () {
		if (this._current === undefined) {
			// check for immunity
			let immunity = false;
			if (this.base >= 0) {
				Object.values(this._mods)	// returns array of arrays
					.forEach(function(modArray) {
						modArray.forEach(function(mod) { if (mod.immune === true) {immunity = true;} });
					});
			} else {
				immunity = true;
			}
			if (immunity === true) {
				this._current = -1;
			} else {
				// gather tolerance
				var tol = Object.values(this._mods)
					.reduce(function(bigSum, entry) { return bigSum + entry
						.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
						.reduce(function(sum, add) { return sum + add; }, 0);
					}, 0);
				this._current = this.base + tol;
			}
		}
			return this._current;
	}

	clone () {
		return Tolerance.create(this);
	}

	toJSON () {
		return JSON.reviveWrapper('Tolerance.create($ReviveData$)', Object.assign({}, clone(this)));
	}
};

Tolerance.create = function(vals) {
	vals = vals || {};
	var result = new Tolerance();
	result._base = vals._base;
	result._mods = clone(vals._mods);
	result._current = vals._current;
	result.currentVal = vals.currentVal;
	return result;
};

Map.prototype.addMod = function (key, id, mod, equipment, type) {
	if (type !== undefined && typeof(type) == 'string') {
		return this.get(key)[type].addMod(id,mod,equipment);
	} else {
		return this.get(key).addMod(id,mod,equipment);
	}
};

Map.prototype.removeMod = function (key, id, index, type) {
	if (type !== undefined && typeof(type) == 'string') {
		this.get(key)[type].removeMod(id, index);
	} else {
		this.get(key).removeMod(id, index);
	}
};
/* twine-user-script #12: "core-actions.js" */
/* common variables */
setup.knife_weight = 0.6; /* weight for all basic multi-hit attacks; localized here for easy testing */
setup.pierce_weight = 0.95; /* weight for all basic piercing attacks; localized here for easy testing */
setup.boost_time = 3;
setup.HUNTER_WEIGHT = 0.8;
setup.STD_DEBUFF = 0.6;
setup.STD_BUFF = (20/45);

setup.actionData = {

	"Heal": {
		"cost": 1,
		"special": 50,
		"target": "ally",
		"info": function (action) { return `Heals ${action.special} HP.`},
		"desc": "Art heals.",
		"onUse": function (puppet) {
			temporary().targ = puppet;
			$.wiki('<<healCalc _targ>>');
			puppet.hp += V().heal;
			subject().en -= this.cost;
			return `${puppet.name} recovers <<print $heal>> HP!`;
		},
		"act": heal(),
		"preview": "heal"
	},

	// MISC

	"rest": {
		"silent": true,
		"cost": 0,
		"act": function () {
			subject().removeEffect("Winded",{pierce: true, noPopup: true});
			return;
		},
		"preview": null
	},

	"struggle": {
		"silent": true,
		"cost": function () { return setup.STRUGGLE_COST; },
		"act": function () {
			subject().removeEffect("Knocked Down",{pierce: true, noPopup: true});
			return;
		},
		"preview": null
	},

	"Thorn Counterattack": {
		//Currently only used for immediate damage following Rose's thorn bubble.
		"weight": 1.5,
		"useSpecial": 1
	},

	"kill": {
	// Debug action used to quickly test death effects.
		"cost": 0,
		"act": function () {
			return `<<set $target.hp to 0>>`+
		`<<deathcheck>>`;
		}
	},

	"Wait": {
		"cost": 0,
		"fullround": true,
		"useText": null,
		"actText": function () {
			return `${subject().name} waits for a better time to act.<<set $target.isDone = false; $B.enemyTurns++>>`;
		},
		"act": null
	},

	// Passive skills

	"Firefly": {
		"passive": true,
		"onApply": function (actor) {
			actor.firefly = true;
		},
		"onRemove": function (actor) {
			actor.firefly = false;
		},
		"info": function (action) {return `Enemies are twice as likely to target this character.`},
		"desc": null
	},

	"Crafty": {
		"passive": true,
		"onApply": function (actor) {
			actor.crafty = true;
		},
		"onRemove": function (actor) {
			actor.crafty = false;
		},
		"info": function (action) {return `Items cost half as much Energy to use.`},
		"desc": null
	},

	// FIGHTER

	"Sword": {
		"cost": 2,
		"weight": 1,
		"basic": true,
		"info": function (action) {return `Attack with a weight of ${action.weight}.`},
		"desc": `Ah, the sword: favored weapon of heroes everywhere. In reality they're pretty impractical and hard to use, but they just look so cool!`,
		"useText": null,
		"actText": function () {
			return `${subject().name} swings ${subject().their} sword with perfect form.`;
		},
		"act": justdmg()
	},

	"Punch": {
		"cost": 1,
		"weight": 0.75,
		"basic": true,
		"info": function (action) {return `Attack with a weight of ${action.weight}.`},
		"desc": `A quick jab with the off-hand. Weaker than using a weapon, but less tiring.`,
		"useText": null,
		"actText": function () {
			return `${subject().name}'s fist slams into the enemy.`;
		},
		"act": justdmg()
	},

	"Hammer": {
		"cost": 3,
		"weight": 0.95,
		"basic": true,
		"pierce": true,
		"info": function (action) {return `Attack with a weight of ${action.weight} and ignore enemy defense.`},
		"desc": `Fighter's heavy warhammer concentrates all the force of their swing onto a single point, piercing through even the toughest of armor.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} draws ${subject().their} warhammer from ${subject().their} back and brings it down on the enemy in a crushing blow.`;
		},
		"act": justdmg()
	},

	"Bull Rush": {
		"cost": 4,
		"weight": 1.1,
		"dur": 1,
		"effects": ["Off-Balance"],
		"info": function (action) {return `Inflicts damage with an attack weight of ${action.weight} and knocks the enemy <b>Off-Balance</b>, but knocks Fighter Off-Balance too.`},
		"desc": `A reckless charge that attempts to overpower the enemy with sheer force. Fighter can put a lot of strength behind this attack, but it'll leave them overbalanced and open to a counterattack.`,
		"actText": function () {
			return `${subject().name} rushes up to the enemy and puts all ${subject().their} weight into the attack! In the process ${subject().they} overextend ${subject().themself}, and start to wobble a little.`;
		},
		"act": function () {
			return `<<echoDamage>>\
							<<print target().addEffect("Off-Balance")>>\
							<<print subject().addEffect("Off-Balance")>>`;
		}
	},

	"Assault": {
		"cost": 4,
		"weight": 1.4,
		"dur": 3,
		"info": function (action) {return `Inflicts damage with an attack weight of ${action.weight}, but makes Fighter <b>Winded</b>.`},
		"desc": `Rush the enemy with an all-out attack!`,
		"actText": function () {
			return `${subject().name} lets out a primal roar before descending on $target.name, swinging ${subject().their} weapon in a series of heavy, brutal swings. At the end, ${subject().theyare} left panting.`;
		},
		"act": function () {
			return `<<echoDamage>>\
							<<print subject().addEffect("Winded")>>`;
		}
	},

	"Berserker": {
		"cost": 0,
		"instant": true,
		"phase": "Confirm Phase",
		"effects": ["Berserker"],
		"info": function (action) {return `Increase damage dealt and received by ${setup.BERSERK_FACTOR*100}%.`},
		"desc": `Fighter will throw down their shield and fight with reckless abandon, hitting harder but hurting harder, too.`,
		"actText": function () {
			return `${subject().name}'s shield drops to the ground with a <i>clang</i>, and ${subject().they} grip ${subject().their} weapon with fiery determination. No holding back, now!`;
		},
		"act": applyEffect("Berserker",{self:true})
	},

	"Defender": {
		"cost": 0,
		"instant": true,
		"phase": "Confirm Phase",
		"effects": ["Defender"],
		"info": function (action) {return `Reduce damage dealt and received by ${setup.DEFEND_FACTOR*100}%.`},
		"desc": `Fighter will hunker behind their shield, blocking oncoming blows but making it harder for them to attack.`,
		"actText": function () {
			return `An expression of cool stillness passes over ${subject().name}'s face as they hunker behind ${subject().their} shield, eyes peeled for all incoming attacks.`;
		},
		"act": applyEffect("Defender",{self:true})
	},

	"Meditate": {
		"cost": 5,
		"basic": true,
		"dur": 4,
		"phase": "Confirm Phase",
		"effects": ["ailments"],
		"info": function (action) {return `Cure user of all negative ailments and bestow <b>Chi Shield</b>, protecting them from future ailments for ${action.dur} turns.`},
		"actText": function () {
			return `${subject().name} stops, and closes ${subject().their} eyes. ${subject().their.toUpperFirst()} sudden tranquility is discordant with the chaos of the battle. ${subject().they.toUpperFirst()} take a deep breath, and when ${subject().they} let it out you swear you can see a physical presence leave ${subject().them}. ${subject().they.toUpperFirst()} stand up straighter, positively glowing.`;
		},
		"act": removeEffect({target:'s'},
						applyEffect("Chi Shield",{self:true},
						`<<set $B.heal_used = true>>`)),
		"preview": function () {
			if (subject().stasis) {
				return `$subject.name <b>is in Stasis, so this won't do anything.</b>`;
			}
			else {
				return `$subject.name will be cured of all ailments and gain <b>Chi Shield</b>.`;
			}
		},
		"desc": `The indignities of the world quail before Fighter's indomitable spirit. When that spirit is focused, all their troubles will fade away like dust in the wind.`
	},

	"Protector": {
		"cost":		2,
		"effweight":	0.25,
		"dur":		3,
		"target":	"ally",
		"noself":	true,
		"effects": ["Protector"],
		"info":	function (action) {return 	`Take hits for an ally and gain a Defense bonus for ${action.dur} rounds.`},
		"actText": function () {
			return `Without hesitation ${subject().name} jumps in front of ${subject().their} charge, shielding them from all harm.`;
		},
		"act": applyEffect("Protector",{self:true}),
		"preview": `$subject.name will protect $target.name and gain a bonus to Defense.`,
		"desc":		`Leap to another puppet's defense! Fighter will put themselves in the way of any attack, deflecting it with their mighty shield. But they can't be everywhere at once, so beware of area attacks...`
	},

	"Martyr": {
		"cost":		2,
		"phase":	"Confirm Phase",
		"effects": ["Martyr"],
		"info":	function (action) {return 	`Draw all direct attacks for this round.`},
		"actText": null,
		"act": applyEffect("Martyr",{self:true}),
		"desc":		`The blinding intensity of Fighter's spirit can warp perception itself. Through sheer will they can become so overpoweringly <b>real</b> that enemies become unable to see anything else, compelling them to send all attacks Fighter's way. Unfortunately, the technique requires too much concentration for Fighter to raise their shield.`
	},

	// ROGUE

	"Knife": {
		"cost":		2,
		"weight":	setup.knife_weight,
		"basic":	true,
		"hits": 2,
		"info":	function (action) {return 	`Attack twice with a weight of ${action.weight.toFixed(2)}.`},
		"desc":		`It's not as strong as Fighter's big sword, but Rogue is fast enough to get two licks before their victim knows what's hit them. This is most effective against enemies with poor defense.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} draws two knives and rushes in, slashing with one hand and stabbing with the other.`;
		},
		"act": justdmg(),
		"preview": "multihit"
	},

	"Crossbow": {
		"cost":		0,
		"weight":	1,
		"basic":	true,
		"pierce":	true,
		"noDefault": true,
		"saveMod": "Reload",
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and ignore defense. Needs reloading after use.`},
		"desc":		`Ah, the marvel of modern technology: while other fools tire themselves out swinging those heavy weapons, Rogue can send death flying through the air with just a twitch of the finger.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} fires ${subject().their} crossbow with a <i>twang</i>.`;
		},
		"act": function () {
			var x = subject().actions.find(function(a) { return a && a.name == "Crossbow" });
			subject().actions[subject().actions.indexOf(x)] = new Action("Reload");
			return `<<echoDamage>>`;
		},
	},

	"Reload": {
		"cost":		2,
		"phase":	"Confirm Phase",
		"basic":	true,
		"silent": true,
		"noDefault": true,
		"saveMod": "Crossbow",
		"info":	function (action) {return 	`Reload crossbow.`},
		"desc":		`...Of course, crossbows also take an age and a half to reload.`,
		"preview": null,
		"act": function () {
			var x = subject().actions.find(function(a) { return a && a.name == "Reload" });
			subject().actions[subject().actions.indexOf(x)] = new Action("Crossbow");
		}
	},

	"Something in your eye": {
		"cost":		2,
		"effects": ["Stunned"],
		"info":	function (action) {return 	`Stun an enemy.`},
		"desc":		`It's amazing how if you say something ridiculous, people will hold still long enough for you to make it true. It's like they want it to happen, really.`,
		"actText": function () {
			return `"Hey," you say. "Something in your eye."
			'Something' turns out to be a fistful of dirt.`;
		},
		"act": applyEffect("Stunned")
	},

	"Poison Prick": {
		"cost":		3,
		"weight":	0.5,
		"effweight":	0.6,
		"dur":		3,
		"effects": ["Poisoned"],
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and inflict Poisoned for ${action.dur} rounds.`},
		"desc":		`The tiny knife may barely break the skin, but the poison it's coated in ensures they'll be feeling it for a while to come.`,
		"actText": function () {
			return `$subject.name feints to the side, then with blinding speed draws a tiny concealed knife, stabbing it into the enemy like a needle. The skin around it breaks into welts and sickly purple splotches.`;
		},
		"act": applyEffect("Poisoned",{dmg: true})
	},

	"Off Your High Horse": {
		"cost":		4,
		"weight":	1,
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and remove the target's most recent buff.`},
		"desc":		`A special technique that cuts through flesh and magic alike, bringing those haughty enchanted foes back down to earth.`,
		"actText": function () {
			return `$subject.name leaps forward, twirling ${subject().their} knife in a strange pattern before slicing it across the enemy. Glimmering lines of energy trail after it like strands of cobweb, then wink out of existence.`;
		},
		"act": justdmg(removeLastEffect()),
		"preview": ["cleanse","lastEffect"]
	},

	"A Farewell to Arms": {
		"cost":		4,
		"weight":	1,
		"effweight":	setup.STD_DEBUFF,
		"dur":		3,
		"effects": ["Injury"],
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and inflict Injury for ${action.dur} rounds.`},
		"desc":		`A savage laceration of the arm muscles that leaves the enemy crippled.`,
		"actText": function () {
			return `$subject.name pauses, their eyes flicking over their opponent. They raise their knife level with their eyes, and the next instant lunge forward with a crippling stab to the arm joints.`;
		},
		"act": applyEffect("Injury", {dmg: true})
	},

	"Below the Belt": {
		"cost":		4,
		"weight":	1,
		"effweight":	setup.STD_DEBUFF,
		"dur":		3,
		"effects": ["Pain"],
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and inflict Pain for ${action.dur} rounds.`},
		"desc":		`A nasty kick to the joints and other painful regions that leaves the enemy too distracted by pain to defend themselves.`,
		"actText": function () {
			return `$subject.name pauses, their eyes flicking over their opponent. Suddenly they strike out like a viper, ramming a sharp kick into an exposed weak point.`;
		},
		"act": applyEffect("Pain", {dmg: true})
	},

	"Dead Ringer": {
		"cost":		4,
		"weight":	1,
		"effweight":	setup.STD_DEBUFF,
		"dur":		3,
		"effects": ["Headache"],
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and inflict Headache for ${action.dur} rounds.`},
		"desc":		`An unsporting blow to the temple that leaves the enemy's head ringing.`,
		"actText": function () {
			return `$subject.name kicks dust into their opponent's eyes, disorienting ${target().them} just long enough for them to ram their dagger's pommel straight into ${target().their} temple.`;
		},
		"act": applyEffect("Headache", {dmg: true})
	},

	"Flurry": {
		"cost":		5,
		"weight":	0.55,
		"hits": 4,
		"dur":	1,
		"effects": ["Off-Balance"],
		"info":	function (action) {return 	`Attack thrice with a weight of ${action.weight} and inflict Off-Balance.`},
		"desc":		`Descend on the enemy in a whirlwind of strikes! The sudden ferocity will make them lose their footing, leaving them open to another puppet's attack.`,
		"actText": function () {
			return `With uncharacteristic unsubtlety, $subject.name charges forward, swinging their blades in a whirlwind of flashing steel. Not every swing connects, but it doesn't need to. The enemy stumbles and sways from the pressing assault, looking like they could be knocked over by a light breeze. $subject.name grins and leaps away, their job done.`;
		},
		"act": justdmg(),
		"finisher": applyEffect("Off-Balance"),
		"preview": "multihit"
	},

	"Sneak": {
		"cost":		2,
		"phase":	"Confirm Phase",
		"dur":		3,
		"effects": ["Hidden"],
		"info":	function (action) {return 	`Become untargetable for ${action.dur} rounds.`},
		"desc":		`Become one with the shadows.`,
		"actText": function () {
			return `The arena should be well-lit, but as $subject.name presses themselves against the wall, their surroundings suddenly become dimmer. You blink, and suddenly you can't tell where they end and the shadows begin.`;
		},
		"act": applyEffect("Hidden",{self:true})
	},

	"Procure": {
		"phase":	"procure",
		"target": null,
		"noDefault": true,
		"info":	function (action) {return 	`Add an item to party stock. Cost varies.`},
		"desc":		`Even you don't know where they get it from.`
	},

	// MAGE

	"Focus": {
		"cost":		2,
		"special": 	4,
		"noDefault": false,
		"phase":	"Confirm Phase",
		"info":	function (action) {return 	`Gain ${action.special} Energy (net ${action.special - action.cost}).`},
		"desc":		`Magic is everywhere if you know where to look. A skilled mage can, with concentration, read the currents that flow through the world and pluck power from them like notes from a harp.`,
		"actText": function () {
			return `${subject().name} holds out a hand. The motion is calm and easy, like trailing a hand through a forest stream. Glimmering motes of multicolored light settle on it like dew, trickling into the center of ${subject().their} palm before vanishing with a soft glow.`;
		},
		"act": function () {
			return `<<set $subject.en += action().special>>\
			$subject.name gains ${action().special} Energy!`;
		},
		"preview": `$subject.name will gain <<print $action.special - $action.cost>> net Energy.`
	},

	"Sacrifice": {
		"cost":		0,
		"special":	2,
		"phase":	"Confirm Phase",
		"basic":	true,
		"instant":	true,
		"oncePerTurn": true,
		"hpcost": 	50,
		"info":	function (action) {return 	`Sacrifice ${action.hpcost} HP to generate ${action.special} Energy.`},
		"desc":		`Magic is born from a desire to impose morality on a cruel and uncaring world. If we suffer, should good things not happen to balance it out? Only wishful thinking when done by humans, of course -- but Mage makes it a reality.`,
		"actText": function () {
			return `${subject().name} presses ${subject().their} hand into a fist so tight it draws blood. As you watch, ${subject().their} blood changes from a thick red into an inky black that streams away as if you are underwater. In an instant it is gone, leaving ${subject().name} with only a faint scar.`;
		},
		"act": function () {
			return `Mage loses $action.hpcost HP.
			Mage gains $action.special Energy!\
			<<set $subject.en += $action.special>>`;
		},
		"preview": `$subject.name will lose $action.hpcost HP and gain $action.special Energy.`
	},

	"Blast": {
		"cost":		3,
		"weight":	1,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Indignant Variati");
					break;
				default:
					console.log("default active");
					action()._weight = action().weight + 0.25*(action().cost - V().B.mincost);
			}
		},
		"basic":	true,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} + 0.25 per Energy invested.`},
		"desc":		`Use the beautiful, wonderous, and infinite power of magic to blow something up.`,
		"actText": function () {
			switch (V().action.cost) {
				case 3:
					return `$subject.name raises a hand, and an orb of glowing blue-white energy shoots out of ${subject().their} palm.`;
				case 4:
					return `$subject.name raises a hand, and a missile of glowing blue-white energy shoots out of ${subject().their} palm, showering shimmering motes like snow.`;
				case 5:
				case 6:
					return `$subject.name raises a hand, and blue-white energy erupts from it like a geyser, blasting into the enemy.`;
				case 7:
				case 8:
					return `$subject.name raises both of ${subject().their} hands, and blue-white energy erupts in front of ${subject().them} in a chaotic blast, glowing tendrils arcing against the air and ground as the enemy is eveloped in waves of destruction.`;
				case 9:
					return `$subject.name raises both of ${subject().their} hands, glowing with power. Countless rays of blue-white energy spread out in all directions before curving in and condensing into a huge, powerful beam.`;
			}
		},
		"act": justdmg()
	},

	"Indignant Variati": {
		"cost":		10,
		"weight":	3,
		"saveMod": "Blast",
		"effects": ["Knocked Down"],
		"actText": function () {
			return `$subject.name calmly steps forward, and raises a hand to the heavens. In an instant, the sky is suddenly ablaze with wrathful fire. Fire and lightning rain down from the inferno to strike the earth, blasting the enemy in a terrifying and beautiful display of utter destruction.`;
		},
		"act": function () {
			return `<<echoDamage>>\
							<<print target().addEffect("Knocked Down",{time: -1})>>\
							<<print subject().addEffect("Winded",{time: 3})>>`;
		},
		"preview": `<<damageCalc>>\
			The wrath of the gods. This attack will inflict $dmg damage and <b>knock the enemy off their feet</b>, but the exertion will leave Mage <b>Winded</b>.`
	},

	"Fireball": {
		"cost":		4,
		"weight":	1,
		"effweight":	0.6,
		"effects": ["Burning"],
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Perdition");
					break;
				default:
					action()._effweight = 0.6+0.1*(action().cost-V().B.mincost);
			}
		},
		"dur":		3,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} and inflict Burning status with greater severity per Energy invested.`},
		"desc":		`Since the beginning of humanity, fire has had a hallowed place in the halls of myth and magic. One moment, there is nothing but dead wood and still air -- the next, a wild, flickering shape that banishes the cold and dark, changes objects irrevocably, purges evil and disease. What could be more magical than that? Of course, you don't care about any of that. You just want to burn stuff.`,
		"actText": function () {
			switch (action().cost) {
				case 4:
					return `$subject.name waves a hand, and a ball of orange flame bursts into existence to fly towards the enemy, igniting in an impressive display of fire that clings to the enemy's skin.`;
				case 5:
					return `$subject.name waves a hand, and a ball of yellow flame bursts into existence to fly towards the enemy, igniting in a magnificent display of fire that clings to the enemy's skin.`;
				case 6:
				case 7:
				case 8:
					return `$subject.name throws out their hand as if throwing a punch. A jet of flame shoots out like a comet, swallowing the enemy in fire.`;
				case 9:
					return `$subject.name points a finger at the enemy, and a perfect sphere of orange-red flame shoots out like a missile. When it connects it lights up like a firework, exploding in a brilliant inferno.`;
			}
		},
		"act": applyEffect("Burning", {dmg: true})
	},

	"Perdition": {
		"cost":		10,
		"weight":	1,
		"effweight":	0.4,
		"effects": ["Perdition"],
		"saveMod": "Fireball",
		"actText": function () {
			return `$subject.name raises their palms as if lifting a great weight, and $target.name is suddenly enveloped in a pillar of screaming white fire. The ember, lodged in $target.their heart, is unquenchable.`;
		},
		"act": applyEffect("Perdition", {dmg: true}),
		"preview": `<<damageCalc>>\
			The flames of eternal torment. This attack will inflict $dmg damage and <b>Perdition</b> status, which will remain for the duration of the battle.`
	},

	"Favor": {
		"cost":		1,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Inspiration");
					break;
				default:
			}
		},
		"target":	"ally",
		"noself":	true,
		"info":	function (action) {return 	`Lend Energy to an ally.`},
		"desc":		`Magic blurs the boundaries of the natural world, and the boundaries between individuals. Mage can allow another to use their energy as if it was their own.`,
		"actText": function () {
			return `$subject.name clasps one hand over their heart, and extends another towards $target.name. Glowing blue energy flows between them.`;
		},
		"act": function () {
			return `$target.name gains $action.cost Energy!`+
			`<<set $target.en += $action.cost>>`;
		},
		"preview": function () {
			var note = "";
			if ((target().en + V().action.cost) > target().maxEN) {
				note = ` ...but they already have $target.en Energy, so some of it will be wasted.`;
			}
			return `$subject.name will transfer $action.cost Energy to $target.name.`+note;
		}
	},

	"Inspiration": {
		"cost":		10,
		"target": 	"ally",
		"noself":	true,
		"saveMod": "Favor",
		"actText": function () {
			return `$subject.name places their palm flat below their mouth. They close their eyes, and blow out a breath towards $target.name. It glows with a strange energy, wrapping around $target.name. They look ready for anything.`;
		},
		"act": function () {
			target().en += action().cost;
			if (target().active == false){
				target().active = true;
			} else {
				target().inspired = true;
			}
			return `$target.name gains $action.cost Energy and an additional action!`;
		},
		"preview": `The breath of life. Mage will transfer $action.cost Energy to $target.name and grant them an additional action.`
	},

	"Restoration": {
		"cost":		3,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost) {
				case 10:
					V().action = new Action("Salvation"),
					V().target = null;
					break;
				default:
					this.removedEffects = 1+(action().cost-V().B.mincost);
			}
		},
		"effects": "ailments",
		"target":	"ally",
		"info":	function (action) {return 	`Cure an ally of their most recent status ailment, plus one ailment per Energy invested.`},
		"desc":		`People have always turned to mystics for cures to the world's ills and pains. To be blighted by an enemy you cannot see is terrifying and transcendent -- so surely, one must seek out a person that is the same. And so Mage gained the power of healing.`,
		"actText": function () {
			return `$subject.name waves their hands in smooth, wide motions, as if polishing a surface. When they're finished they stretch their hands out imperiously, and positive energy washes over $target.name in a bright burst.`;
		},
		"act": removeEffect(),
		"preview": "cleanse"
	},

	"Salvation": {
		"cost":		10,
		"dur": 		3,
		"phase":	"Confirm Phase",
		"saveMod": "Restoration",
		"actText": function () {
			return `$subject.name spreads their hands wide, exultant. The curses afflicting your puppets condense into balls of dark energy before bursting in brilliant showers of light. The glow swirls around them, enveloping them in protective energy.`;
		},
		"act": removeEffect(
			{target: "allies", type: "all", cure: true, unsticky: true,
			perExtension: `<<print _puppet.addEffect("Chi Shield")>>`}
		),
		"preview": function () {
			return `A miracle to turn the tide of battle. This will cure your puppets of all ailments and bestow each with Chi Shield for ${action().dur} rounds.`;
		}
	},

	"Neutralize": {
		"cost":		3,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost) {
				case 10:
					V().action = new Action("Annulment");
					V().target = null;
					break;
				default:
					this.removedEffects = 1+(action().cost-V().B.mincost);
			}
		},
		"effects": "buffs",
		"info":	function (action) {return 	`Strip an enemy of their most recent buff, plus one buff per Energy invested.`},
		"desc": 	`To make magic, one must first know how to break it. Your enemies think themselves safe, shining and untouchable with all those enchantments? With a whisper, Mage can remind them just how mortal they really are.`,
		"actText": function () {
			return `$subject.name waves their hands in contracted, sprialling motions, as if gathering up dust. When they're finished, they swipe a hand sharply to the side as if in dismissal. You see $target.name's magic flash and sputter, fading away like mist.`;
		},
		"act": removeEffect(),
		"preview": "cleanse"
	},

	"Annulment": {
		"cost":		10,
		"weight": 	1,
		"phase":	"Confirm Phase",
		"saveMod": "Neutralize",
		"actText": function () {
			return `$subject.name places their hand out, palm up. With violent suddenness they close it into a fist. You suddenly see the enchantments aiding the enemy clear as day, little balls of energy orbiting them like little planets -- before they all shatter at once like a galaxy of dying stars.`;
		},
		"act": function () {
			var cut = 0;
			enemies().forEach(function(enemy) {
				if (!enemy.dead && !enemy.areaImmune) {
					cut++;
				}
			});
			return `<<for _enemy range $enemies>>\
								<<if !_enemy.dead && !_enemy.areaImmune>>\
									<<set $target = _enemy>>\
									<<damageCalc>>\
									<<set $dmg = Math.round($dmg/${cut})>>\
									<<echoDamage "nocalc">>\
									<<for _k, _effect range _enemy.effects>>\
										<<if _effect.buff>>\
											<<print _enemy.removeEffect(_effect)>>\
										<</if>>\
									<</for>>\
								<</if>>\
			<</for>>`;
		},
		"preview": `<<set _d = (setup.base + $subject.get(StatName("atk")))*$action.weight>>\
			A judgment upon those who would defy you. This will inflict _d base damage and strip all buffs from every enemy.`
	},

	"Blessing": {
		"cost":		5,
		"effweight":	(10/45),
		"effects": ["Blessing"],
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Ascension"),
					V().target = null;
					break;
				default:
					// duration
					switch (action().cost){
						case 6:
						case 7:
							action()._dur = 4;
							break;
						case 8:
						case 9:
							action()._dur = 5;
							break;
						default:
					}
					// effect
					switch (action().cost){
						case 7:
						case 8:
							action()._effweight = (15/45);
							break;
						case 9:
							action()._effweight = (20/45);
							break;
						default:
					}
				}
		},
		"dur":		3,
		"target":	"ally",
		"info":	function (action) {return 	`Bestow a Blessing, which will boost all stats for ${action.dur} rounds. Additional Energy points will alternate improvements in duration and effect.`},
		"desc": 	`Grant us strength that we may strike true. Grant us protection that we may endure. Grant us wisdom that we may see the way through the darkness.`,
		"actText": function () {
			return `$subject.name raises their arms skyward, then clasps their hands together as if in prayer. They suddenly let go, and wave their hands over $target.name with a flourish. Motes of light fall over ${target().them}, making ${target().them} glow with a strange aura.`;
		},
		"act": applyEffect("Blessing")
	},

	"Ascension": {
		"cost":		10,
		"effweight":	(10/45),
		"dur":		5,
		"phase":	"Confirm Phase",
		"saveMod": "Blessing",
		"actText": function () {
			return `$subject.name raises their arms skyward. Their muscles strain and their fists suddenly clench, as if they are trying to grasp the Sun itself. Perhaps they succeed: their hands are suddenly effulgent with light, which they push down into the earth. The ground glows and your puppets are bathed in geysers of light, exultant.`;
		},
		"act": massAttack({target: "allies", content: applyEffect("Blessing")}),
		"preview": function () {
			return `Become something greater. This will endow a Blessing to all puppets for ${action().dur} rounds.`;
		}
	},

	"Curse": {
		"cost":		5,
		"effweight":	(1/3),
		"effects": ["Curse"],
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Forsaken");
					break;
				default:
					// duration
					switch (action().cost){
						case 6:
						case 7:
							action()._dur = 4;
							break;
						case 8:
						case 9:
							action()._dur = 5;
							break;
						default:
					}
					// effect
					switch (action().cost){
						case 7:
						case 8:
							action()._effweight = (15/30);
							break;
						case 9:
							action()._effweight = (2/3);
							break;
						default:
					}
			}
		},
		"dur":		3,
		"info":	function (action) {return 	`Inflict a Curse, which will weaken all stats for ${action.dur} rounds. Additional Energy points will alternate improvements in duration and effect.`},
		"desc":		`May their flesh sag and rot. May their bones crumble like parchment. May their thoughts slow like treacle.`,
		"actText": function () {
			return `$subject.name stares intently, then calmly points a single finger at the enemy. $target.name sways, and the air around $target.them suddenly looks dingier.`;
		},
		"act": applyEffect("Curse")
	},

	"Forsaken": {
		"cost":		10,
		"effweight":	1,
		"dur":		5,
		"effects": ["Forsaken"],
		"saveMod": "Curse",
		"actText": function () {
			return `$subject.name does not even move. They only spare $target.name a look, and <<print target().theyare>> suddenly drowned in darkness.`;
		},
		"act": applyEffect("Forsaken"),
		"preview": `A terrible judgment that denies all mercy. This will inflict <b>Forsaken</b> status, which will sharply reduce Defense, even into the negatives.`
	},

	// BARD

	"Rapier": {
		"cost": 2,
		"weight": 1,
		"basic": true,
		"info": function (action) {return `Inflicts damage with an attack weight of ${action.weight}.`},
		"desc": `A flashy, elegant weapon for sophisticated duelists, specialized for thrusts and precise cuts. Its usefulness in a real brawl is questionable, but if you can't fight in style, what's even the point?`,
		"useText": null,
		"actText": function () {
			return `${subject().name} elegantly stabs the foe with ${subject().their} rapier.`;
		},
		"act": justdmg()
	},

	"Dagger": {
		"cost":		2,
		"weight":	setup.knife_weight,
		"hits": 2,
		"basic":	true,
		"info": function (action) {return 	`Attack twice with a weight of ${action.weight.toFixed(2)}.`},
		"desc":		`A real dagger, not the shoddy knife you'd find in the hands of a thug! Longer than a knife and shorter than a sword, the dagger is an elegant weapon combining strength and concealment. It's favored by assassins and scheming nobles.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} draws an ornate dagger and slashes it twice across the enemy.`;
		},
		"act": justdmg()
	},

	"Shout": {
		"cost":		3,
		"weight":	1,
		"phase":	"Spell Phase",
		"spellMod": function () {
			action()._weight = action().weight + 0.25*(action().cost - V().B.mincost);
		},
		"basic":	true,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} + 0.25 per Energy invested.`},
		"desc":		`Bard knows all about the destructive power of words, though it's a bit more literal than usual in this case. With a little magic, boosted by their own mythological resonance with the domain of sound, Bard can turn their voice into an oddly melodic sonic attack.`,
		"actText": function () {
			return `$subject.name projects ${subject().their} voice into a wave of crushing force.`;
		},
		"act": justdmg()
	},

	"Non-Sequitor": {
		"cost":		4,
		"weight":	0.9,
		"dur": 1,
		"effects": ["Off-Balance"],
		"info":	function (action) {return 	`Attack with a weight of ${action.weight} and inflict Off-Balance.`},
		"desc":		`"This statement is false!" Sometimes you need to do the thing they least expect. It'll throw them off-kilter, especially after you follow it with a sucker punch.`,
		"useText": null,
		"actText": function () {
			return `$subject.name says something so random the enemy has to stop to process it. While they're doing that, $subject.name socks them in the face.`;
		},
		"act": applyEffect("Off-Balance",{dmg: true})
	},

	"Insult": {
		"cost":		2,
		"effweight":	0.4,
		"dur":		3,
		"effects": ["Injury"],
		"info":	function (action) {return 	`Inflict an Injury for ${action.dur} rounds.`},
		"desc":		`"You fight like a cow!" Any bard worth their salt knows exactly what wicked wordplay will leave their victims a laughingstock. The injury inflicted is only emotional, but really, isn't that worse?`,
		"useText": null,
		"actText": function () {
			return `$subject.name insults the opponent's fighting style so wickedly they are crushed by despair.`;
		},
		"act": applyEffect("Injury")
	},

	"Joke": {
		"cost":		2,
		"effweight":	0.4,
		"dur":		3,
		"effects": ["Pain"],
		"info":	function (action) {return 	`Inflict Pain for ${action.dur} rounds.`},
		"desc":		`Bard can make jokes so bad they cause physical pain. Bard assures us they're doing it ironically. You think that makes worse.`,
		"useText": null,
		"actText": function () {
			return `$subject.name makes a painfully bad joke.`;
		},
		"act": applyEffect("Pain")
	},

	"Equivocate": {
		"cost":		2,
		"effweight":	0.4,
		"dur":		3,
		"effects": ["Headache"],
		"info":	function (action) {return 	`Inflict Headache for ${action.dur} rounds.`},
		"desc":		`"Oh, I believe that <b>you</b> believe, but have you considered..." Also known as "playing devil's advocate" or, more colloquially, "trolling". Bard is a master.`,
		"useText": null,
		"actText": function () {
			return `$subject.name leads the enemy on a meandering and nonsensical argument. It's irritating to everyone, but $target.name gets the worst of it.`;
		},
		"act": applyEffect("Headache")
	},

	"Rewrite": {
		"cost":		4,
		"target":	"all",
		"effects": ["all"],
		"info":	function (action) {return 	`Remove all effects (positive and negative) from a target.`},
		"desc":		`Don't like the story? Then change it! It's the tales that are remembered, and in a way isn't that more real than what actually happened?`,
		"actText": function () {
			return `$subject.name crafts a personal narrative so compelling it overwrites $target.name's state of being. All the forces acting upon ${target().them} vanish like they were never even there.`;
		},
		"act": removeEffect({target:'t'},`<<set $B.heal_used = true>>`)
	},

	"Provoke": {
		"cost":		2,
		"dur":		1,
		"effects": ["Martyr"],
		"phase":	"Confirm Phase",
		"info":	function (action) {return 	`Draw all direct attacks for this round.`},
		"desc":		`A bard thrives in the spotlight. This one knows just how to get it.`,
		"actText": function () {
			return `$subject.name runs around like a headless chicken while insulting everyone's parentage.`;
		},
		"act": function () {
			return `<<print subject().addEffect("Martyr")>>`;
		}
	},

	// ARCHER

	"Shot": {
		"cost":		1,
		"weight":	0.45,
		"phase":	"Spell Phase",
		"spellMod": function () {
			if (action().cost > 1) {
				action().hits = action().cost;
			}
		},
		"basic":	true,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} once per Energy point invested.`},
		"desc":		`Ranged weapons are where the real power's at. With sharp eyes, you can strike down an entire battalion of soldiers before they can land even single blow. Of course, in this arena, everyone is always within melee range of each other, so it's a bit less useful. Archer has to make up for it by firing multiple arrows at once -- they can draw on their mythological resonance to create them out of Energy points, so you'll never run out.`,
		"useText": null,
		"actText": function () {
			var str;
			if (V().action.cost == 1) {
				str = "an arrow";
			} else if (V().action.cost == 10) {
				return `Were there a sun here, ${subject().name}'s arrows would blot it out.`;
			} else {
				str = "a volley of arrows";
			}
			return `${subject().name} fires ${str}.`;
		},
		"act": justdmg()
	},

	"Soulshot": {
		"cost":		2,
		"weight":	1,
		"phase":	"Spell Phase",
		"spellMod": function () {
			action()._weight = action().weight + 0.25*(action().cost - V().B.mincost);
		},
		"basic":	true,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} + 0.25 per Energy invested.`},
		"desc":		`The <b>idea</b> of an arrow, shot from the heart -- and ideally, into someone else's. The more Archer focuses, the more they feel the thrill of the hunt, the stronger it will become.`,
		"useText": null,
		"actText": function () {
			if (V().action.cost == 10) {
				return `${V().subject.name} nocks what looks to be the Platonic ideal of an arrow. The shaft is perfectly balanced, the point, so razor-sharp you cannot even see the edge. This is the arrow that always finds its mark, the weapon from which there is no refuge.

				${V().subject.name} lets it fly.`;
			} else {
				return `${subject().name} fires the ghost of an arrow.`;
			}
		},
		"act": justdmg()
	},

	"SoulshotOLD": {
		"cost":		3,
		"weight":	0.8,
		"phase":	"Spell Phase",
		"spellMod": function () {
			action()._weight = action().weight + 0.1*(action().cost - V().B.mincost);
		},
		"pierce":	true,
		"info":	function (action) {return 	`Inflict damage with an attack weight of ${action.weight} + 0.1 per Energy invested and ignore enemy defense.`},
		"desc":		`Arrows made of pure ether. Their insubstantial nature makes them weaker than real weapons, but they'll glide straight through any armor to pierce the heart.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} fires the ghost of an arrow.`;
		},
		"act": justdmg
	},

	"Mark Shot": {
		"cost":		1,
		"weight":	0.75,
		"useText": null,
		"actText": function () {
			return `${subject().name} follows up the attack with a shot at all ${subject().their} marks.`
		},
		"act": function () {
			return `<<set _markActive = true>>\
			<<for _enemy range enemies().filter(function (e) { return e.marked && !e.dead })>>\
				<<set $target = _enemy>>\
				<<echoDamage "nocounter">>\
				<<set subject().en -= $action.cost>>\
				<<if subject().en <= 0>>\
					${subject().name} has run out of arrows!
					<<addEffect $subject "Winded" 3>>\
					<<for _enemy range enemies()>>\
						<<run _enemy.removeEffect("Marked",{pierce: true})>>\
					<</for>>\
					All Marks vanish!\
					<<break>>\
				<</if>>\
			<</for>>\
			<<set _markActive = false>>`;
		}
	},

	"Hunter Counter": {
		"cost":		0,
		"weight":	0.75,
		"counter": true,
		"useText": null,
		"actText": function () {
			return `${target().name} should've known better than to attract ${subject().name}'s attention. ${subject().name} counterattacks!`;
		},
		"act": justdmg("",{counter: true})
	},

	"Exacerbate": {
		"cost":		3,
		"weight":	function () {
			var w = 1;
			if (target() == true) {
				target().effects.forEach(function (eff) {
					if (!eff.buff) {
						w += action().special;
					}
				});
			}
			return w;
		},
		"special":  0.35,
		"info":	function (action) {return 	`Inflict damage with a weight of ${action.weight} + ${action.special} for every ailment afflicting the enemy.`},
		"desc":		`A cruel attack targeted at existing wounds and injuries. Go on. Twist the knife.`,
		"actText": function () {
			return `${subject().name} pulls out a massive, wicked thing with a head of twisted, barbed metal, it looks more like a harpoon than an arrow. ${subject().they.toUpperFirst()} draw ${subject().their} bowstring to the limit, quivering with tension, and as ${subject().they} do so ${subject().their} eyes flick over ${subject().their} opponent, scanning for the slightest weakness. Then, with a suddenness that makes you jump, ${subject().they} let the arrow fly.`;
		},
		"act": justdmg()
	},

	"Explosive Bolt": {
		"cost":		4,
		"weight":	1,
		"area": "all",
		"info":	function (action) {return 	`Inflict damage with a weight of ${action.weight} to target and half damage to all other enemies.`},
		"desc":		`The famous "bomb arrow" technique popularized by a certain green-capped troublemaker. It consists of strapping a bomb to an arrow and shooting it away from you very fast. It's totally absurd, but then, what isn't?`,
		"useText": null,
		"actText": function () {
			return `${subject().name} straps a sizzling bomb to an arrow and lets it fly.`;
		},
		"act": splashDamage({target:'t', cut:2}),
		"preview": ["splash","mass"]
	},

	"Mark": {
		"cost":		0,
		"dur":		3,
		"effects": ["Marked"],
		"basic":	true,
		"info":	function (action) {return 	`Paint a target on an enemy. Every time another puppet attacks, Archer will follow up with a 1-point Shot on every Marked enemy. (Archer will become Winded if their Energy is exhausted in this manner.)`},
		"desc":		`Archer never lets up once an enemy is in their sights.`,
		"actText": function () {
			return `$subject.name stares with burning intensity, and if you squint, you think you can see a target over $target.name.`;
		},
		"act": applyEffect("Marked")
	},

	"Mercy": {
		"cost":		0,
		"effects": ["Marked"],
		"basic":	true,
		"instant":	true,
		"info":	function (action) {return 	`Remove a Mark from an enemy.`},
		"desc":		`Archer wants you to know they're letting you live because they feel like it, and not because they're too tired to keep going. They never let up, remember!`,
		"actText": null,
		"act": removeEffect({target:'t'}),
		"preview": "removeEffect"
	},

	"Hunter": {
		"cost":		2,
		"effects": ["Hunter"],
		"phase":	"Confirm Phase",
		"info":	function (action) {return 	`Counterattack every enemy that attacks this round at a weight of ${setup.HUNTER_WEIGHT}.`},
		"desc":		`Archer can forgo an attack to hone their senses to the peak of human perfection, straining their ears and eyes for the slightest movement. Any enemy that dares to come close will know their swift and vengeful wrath.`,
		"actText": null,
		"act": applyEffect("Hunter",{self:true})
	},

	"Call to Arms": {
		"cost":		7,
		"effweight":	(1/2),
		"target": "ally",
		"dur":		3,
		"effects": ["ATK Boost"],
		"info":	function (action) {return 	`Bestow an ATK Boost to all puppets for ${action.dur} rounds.`},
		"desc":		`Let slip the dogs of war.`,
		"actText": null,
		"act": massAttack({target: "allies", content: applyEffect("ATK Boost")}),
		"preview": "mass"
	},

	// CLERIC

	"Club": {
		"cost":		2,
		"weight":	(2/3),
		"basic":	true,
		"pierce":	true,
		"info":	function (action) {return 	`Attack with a weight of ${action.weight.toFixed(2)} and ignore defense.`},
		"desc":		`Priests are prohibited from shedding blood. Violence against one's fellow man is a sin, after all! Fortunately, bludgeoning weapons, though capable of causing horrific internal injuries, don't spill blood, so it's all kosher.`,
		"useText": null,
		"actText": function () {
			return `${subject().name} nonviolently clubs the enemy over the head.`;
		},
		"act": justdmg()
	},

	"Meditate_Cleric": {
		"displayname": "Meditate",
		"desc": `Cleric's optimism is so strong it becomes a physical force. They believe they will be alright, and so they will be.`
	},

	"Protector_Cleric": {
		"displayname": "Protector",
		"desc":	`Cleric never hesitates to defend the weak. They will stand like a mighty titan before their charge, protecting them from all harm. But they can't be everywhere at once, so beware of area attacks...`
	},

	"Martyr_Cleric": {
		"displayname": "Martyr",
		"desc":		`The light of Cleric's spirit is blinding. Even under normal circumstances, people can't help but be drawn to them; when that spirit is focused, they will see nothing else. Cleric will gladly take all their pain and violence onto themselves.`
	},

	"Helping Hand": {
		"cost": 2,
		"effects": ["Knocked Down"],
		"target": "ally",
		"noself": true,
		"info": function (action) {return `Right an ally who has been Knocked Down.`},
		"desc": `Being knocked prone is a terrible thing to happen during a battle. Normally a person can only be righted with magic or personal struggle, but you can also just... pull them back up. Cleric is the only puppet who'd bother.`,
		"actText": function () {
			return `$subject.name helps $target.name back to $target.their feet.`;
		},
		"act": removeEffect({pierce: true}),
		"preview": "removeEffect"
	},

	"Assured Aegis": {
		"cost":		3,
		"dur":		4,
		"effects": ["Shield"],
		"target":	"ally",
		"info":	function (action) {return 	`Bestows a Shield to a puppet for ${action.dur} rounds, reducing incoming damage by ${setup.SHIELD_FACTOR*100}%.`},
		"desc":		`Don't worry. You're safe now.`,
		"actText": function () {
			return `$subject.name places a hand over $target.name like a benediction.`;
		},
		"act": applyEffect("Shield")
	},

	"Lifegiver": {
		"cost":		1,
		"hpcost":	250,
		"basic":	true,
		"target":	"ally",
		"noself":	true,
		"info":	function (action) {return 	`Give ${action.hpcost} HP to another puppet.`},
		"desc": 	`Life is a limited resource. We have only what we were given. But, if our life is ours, is it not up to us what we do with it?`,
		"actText": function () {
			return `$subject.name cradles $target.name in a comforting embrace. Vibrant green energy flows into ${target().their} wounds, and the broken flesh knits back together.`;
		},
		"act": function () {
			return `$subject.name gives ${action().hpcost} HP to $target.name!\
							<<if $ANIMATIONS === true && _queue instanceof Set>>\
								<<run target().addPopup({type: "healing", content: action().hpcost})>>\
							<<else>>\
								<<set target().hp += action().hpcost>>\
							<</if>>`
		},
		"preview": function () {
			var str = `$subject.name will give action().hpcost HP to $target.name.`;
			if ((target().hp + action().hpcost) > target().maxHP){
				str += " ...but some of it will be wasted.";
			}
			return str;
		}
	},

	"Downfall": {
		"cost":		6,
		"weight":	function () {
			var w = 1;
			if (target() == true) {
				target().effects.forEach(function (eff) {
					if (eff.buff) {
						w += action().special;
					}
				});
			}
			return w;
		},
		"special":  0.25,
		"effects": ["buffs"],
		"info":	function (action) {return 	`Inflict damage with a weight of ${action.weight} + ${action.special} for every buff empowering the enemy, removing them in the process.`},
		"desc":		`Pride goeth before a fall. Cleric can turn the enemy's hubris against them, reminding them that even the strongest warrior can be brought low by the smallest among us.`,
		"actText": function () {
			return `$subject.name plants their feet firmly. They swing their staff around in wide, twirling motions, building up momentum before charging $target.name head-on and bringing it down like a judgment from the heavens.`;
		},
		"act": function () {
			return `<<echoDamage>>\
			<<for _effect range target().effects>>`+
			`<<if _effect.buff && !_effect.sticky>>`+
			`<<print target().removeEffect(_effect)>>`+
			`<</if>>`+
			`<</for>>`+
			`<<set $removed_effects = []>>`;
		},
		"preview": "removeEffect"
	},

	"Walled City": {
		"cost":		7,
		"effweight":	(1/2),
		"target": "ally",
		"dur":		3,
		"effects": ["DEF Boost"],
		"info":	function (action) {return 	`Bestow a DEF Boost to all puppets for ${action.dur} rounds.`},
		"desc":		`A line, to separate us from them. A shield to repel all.`,
		"actText": null,
		"act": massAttack({target: "allies", content: applyEffect("DEF Boost")}),
		"preview": "mass"
	},

	// WITCH

	"Pox": {
		"cost":		2,
		"weight":	0.75,
		"effweight":	0.5,
		"effects": ["Pain"],
		"phase":		"Targeting Phase",
		"dur":		2,
		"info":		function (action) {return `Inflict damage with a weight of ${action.weight} and inflict Pain for ${action.dur} rounds.`},
		"desc":		`Witches are feared for their power over the unseen and unknowable. Cross them and they will strike you with an attack you can't even see: a terrible sickness of sores and blisters, unbearable in their pain.`,
		"actText": function () {
			return `$subject.name points a finger at ${target().name}, and ${target().their} skin instantly breaks out in boils that swell and burst. It looks pretty painful.`;
		},
		"act": applyEffect("Pain", {dmg: true})
	},

	"Gift": {
		"cost":		1,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost) {
				case 10:
					V().action = new Action("Miracle");
					V().target = null;
					break;
				default:
			}
		},
		"basic":	true,
		"target":	"ally",
		"noself":	true,
		"info":		`Lend Energy to an ally.`,
		"desc":		`The mages may speak of "equivalent exchange", of sacrifice. Witch understands the world is not so simple. Our lives are a renewable resource, a rich pattern of ups and downs, flourishing anew every day with new choices and ideas. So this is a gift, freely given: do with it what you will.`,
		"actText": function () {
			return `$subject.name exchanges a meaningful look with $target.name, and gives them a slight nod.`;
		},
		"act": function () {
			return `$target.name gains $action.cost Energy!`+
			`<<set $target.en += $action.cost>>`;
		},
		"preview": function () {
			var note = "";
			if ((target().en + V().action.cost) > 10) {
				note = ` ...but they already have $target.en Energy, so some of it will be wasted.`;
			}
			return `$subject.name will transfer $action.cost Energy to $target.name.`+note;
		}
	},

	"Miracle": {
		"cost": 10,
		"special": 4,
		"phase": "Confirm Phase",
		"saveMod": "Gift",
		"actText": function () {
			return `$subject.name kneels down, spreading their hand over the earth, and whispers something you can't hear. There is a pause, and then shoots of green break through the ground. They grow and grow, joined by more and more as you watch. They burst into beautiful blooms of every possible color, vines and branches stretching out to gently rest against your puppets' shoulders like a motherly hand. Something in your vision shifts and the image suddenly disappears -- but the vibrancy of life remains. Your puppets are glowing with energy.`;
		},
		"act": function () {
			return `<<for _puppet range puppets()>>\
								<<set _puppet.en += ${this["special"]}>>\
								<<print "_puppet.name gains ${this["special"]} Energy!">>`+"\r\n"+
							`<</for>>`;
		},
		"preview": `It's a sad truth that one often gains a lesser reward than the sacrifice one gave up to achieve it. But if that's true, could it mean that sometimes, one can gain something for nothing? This spell will take 10 Energy to call to the Earth for supplication, but it will give 12 Energy in return, spread evenly across your puppets.`
	},

	"Cleanse": {
		"cost":		2,
		"phase":	"Spell Phase",
		"spellMod": function () {
			switch (action().cost){
				case 10:
					V().action = new Action("Renewal"),
					V().target = null;
					break;
				default:
					this.removedEffects = 1+(action().cost-V().B.mincost);
			}
		},
		"basic":	true,
		"target":	"all",
		"effects": "conditional",
		"info":		`Removes the most recent ailment from an ally or the most recent buff from an enemy, plus 1 effect for every Energy point invested.`,
		"desc":		`Wizards heal by forcing their will upon the world, demanding that it change for them. But there is an easier way, if you are willing to work with the currents of the world instead of against them. <b>Let</b> the magic depart, like water flowing downhill.`,
		"actText": function () {
			return `$subject.name calmly waves a hand, and the magic passes like a dream.`;
		},
		"act": removeEffect(),
		"preview": "cleanse"
	},

	"Renewal": {
		"cost": 10,
		"phase": "Confirm Phase",
		"saveMod": "Cleanse",
		"actText": function () {
			return `$subject.name lifts their hands to the sky, palms up. There is an expectant, yearning silence in the air, and then you hear it: the crashing of waves. From out of nowhere comes an unstoppable tide of crystal-clear water, flowing over the whole arena. With every fighter it passes, you see motes of glowing magic dissolve into it, until the world before you looks like the clear night sky, bedazzled with lights. Then the flood passes, and the arena is back to normal. Everyone is completely dry.`;
		},
		"act": function () {
			return `<<for _enemy range $enemies>>\
								<<if !_enemy.dead>>\
									<<for _k, _effect range _enemy.effects>>\
										<<if _effect.buff>>\
											<<print _enemy.removeEffect(_effect,{pierce: true, unsticky: true})>>\
										<</if>>\
									<</for>>\
								<</if>>\
							<</for>>\
							<<for _puppet range puppets()>>\
								<<if _puppet.dead isnot true>>\
									<<for _k, _effect range _puppet.effects>>\
										<<if !_effect.buff>>\
											<<print _puppet.removeEffect(_effect,{pierce: true, unsticky: true})>>\
										<</if>>\
									<</for>>\
								<</if>>\
			<</for>>`;
		},
		"preview": `By accepting the flow of nature, all your troubles can be washed away. This miracle will remove all buffs from enemies and all ailments from allies, even through Stasis and Chi Shield.`
	},

	"Forgetfulness": {
		"cost":		2,
		"dur":		1,
		"effects": ["Stunned"],
		"info":		`Stun an enemy.`,
		"desc":		`There's no need to go through your opponent when you can go around them instead. A simple touch on the mind, and they'll lose all memory of what they were doing.`,
		"actText": function () {
			return `$subject.name slowly waves a hand over $target.name's eyes.`;
		},
		"act": applyEffect("Stunned")
	},

	"Frenzy": {
		"cost":		4,
		"effweight":	(40/55),
		"dur":		3,
		"effects": ["Frenzy"],
		"target":	"ally",
		"info":		function (action) {return `Greatly boost Attack, but cut Defense by half the amount. Lasts ${action.dur} rounds.`},
		"desc":		`Power like no other, at the expense of all else. Witch can give it to you, if you are prepared to accept it.`,
		"actText": function () {
			return `$subject.name bites their thumb, and smears the blood over $target.name's face in a strange pattern. Their eyes narrow into slits.`;
		},
		"act": applyEffect("Frenzy")
	},

	"Thaumastasis": {
		"cost":		5,
		"phase":	"Targeting Phase",
		"dur":		7,
		"effects": ["Stasis"],
		"target":	"ally",
		"info":		function (action) {return `Place a puppet in Stasis, preventing any change to their effects for ${action.dur} rounds.`},
		"desc":		`Being one with nature sounds all well and good right up until you're getting chased by a bear while suffering from some new and exciting disease and starving from the recent drought. Sometimes, nature needs a kick in the teeth. Witch can forcefully stop the flow of magic completely, forcing every one of an individual's effects to stay exactly as they are.`,
		"actText": function () {
			return `$subject.name snaps their fingers. The air around $target.name seems to freeze for a moment, then returns to normal.`;
		},
		"act": applyEffect("Stasis")
	},

	"Age of Enlightenment": {
		"cost":		7,
		"effweight":	(1/2),
		"effects": ["SPC Boost"],
		"target": "ally",
		"dur":		3,
		"info":		function (action) {return `Bestow a SPC Boost to all puppets for ${action.dur} rounds.`},
		"desc":		`To hoard one's knowledge is inevitably to lose it. Let it free, so that it can live.`,
		"actText": null,
		"act": massAttack({target: "allies", content: applyEffect("SPC Boost")}),
		"preview": "mass"
	},

	// ARTIST

	"Crimson Flames": {
		"basic": true,
		"cost": 2,
		"weight": 1,
		"element": "red",
		"info":	function (action) {return 	`Inflicts Red damage with a weight of ${action.weight}.`},
		"desc":		`Red is the color of anger, passion, and hunger. The consuming power of fire is often used as its conduit, even though real flames can be almost any color.`,
		"actText": function () {
			return `${subject().name} paints a pure red flame to consume the foe.`;
		},
		"act": justdmg()
	},

	"Azure Frost": {
		"basic": true,
		"cost": 2,
		"weight": 1,
		"element": "blue",
		"info":	function (action) {return 	`Inflicts Blue damage with a weight of ${action.weight}.`},
		"desc":		`Blue is the color of sadness, stillness, and emptiness. The stilling power of ice is often used as its conduit, even though real ice is colorless in all but the largest quantities.`,
		"actText": function () {
			return `${subject().name} paints crystals of stark blue ice to freeze the foe.`;
		},
		"act": justdmg()
	},

	"Gold Sparks": {
		"basic": true,
		"cost": 2,
		"weight": 1,
		"element": "yellow",
		"info":	function (action) {return 	`Inflicts Yellow damage with a weight of ${action.weight}.`},
		"desc":		`Yellow is the color of joy, energy, and movement. The velocitous power of electricity is often used as its conduit, even though real arcs are so bright and ephemeral none can truly claim to know their color.`,
		"actText": function () {
			return `${subject().name} paints dazzling gold arcs of electricity to shock the foe.`;
		},
		"act": justdmg()
	},

	"White Light": {
		"basic": true,
		"cost": 2,
		"weight": 1,
		"element": "white",
		"info":	function (action) {return 	`Inflicts ${action.element.toUpperFirst()} damage with a weight of ${action.weight}.`},
		"desc":		`White is the color of everything or the color of nothing, depending on how you look at it. Blessed light or blank canvas, purity or pollution? But no matter your perspective, none can deny its power. White is attributed to the arcane, the spiritual, the transcendent. Let the enemy witness it, and weep.`,
		"actText": function () {
			return `${subject().name} paints a sunburst of purest white.`;
		},
		"act": justdmg()
	},

	"Black Night": {
		"basic": true,
		"cost": 2,
		"weight": 1,
		"element": "black",
		"info":	function (action) {return 	`Inflicts ${action.element.toUpperFirst()} damage with a weight of ${action.weight}.`},
		"desc":		`Black is the color of nothing or the color of everything, depending on how you look at it. Empty void or rich soil, death or life? But no matter your perspective, none can deny its power. Black is attributed to the dark, the physical, the unknown. Let the enemy witness it, and weep.`,
		"actText": function () {
			return `${subject().name} paints a night of purest black.`;
		},
		"act": justdmg()
	},

	"Red Tide": {
		"cost": 6,
		"weight": 0.8,
		"element": "red",
		"area": "all",
		"info":	function (action) {return 	`Inflicts Red damage to all enemies with a weight of ${action.weight}.`},
		"desc":		`Remember that it is the color that matters, not the medium. Though we often associate water with the color blue, in truth it is a blank palette, clear but for the impurities it has consumed and scattered throughout its body. With this in mind, it is surprisingly easy to tint it with the consuming power of the Red.`,
		"actText": function () {
			return `${subject().name} paints a wave of blood-red water that washes away the enemies.`;
		},
		"act": massAttack(),
		"preview": "mass"
	},

	"Blue Lightning": {
		"cost": 6,
		"weight": 0.8,
		"element": "blue",
		"area": "all",
		"info":	function (action) {return 	`Inflicts Blue damage to all enemies with a weight of ${action.weight}.`},
		"desc":		`Remember that it is the color that matters, not the medium. We often associate lightning with the color yellow, but why? It exists only for but a blinding instant; can you be sure your eyes do not play tricks on you? Some say it looks closer to a blue tinge, and sure enough it can channel the awful majesty of the Blue as well.`,
		"actText": function () {
			return `${subject().name} paints a storm of sky-blue lightning to devastate the enemies.`;
		},
		"act": massAttack(),
		"preview": "mass"
	},

	"Yellow Scorch": {
		"cost": 6,
		"weight": 0.8,
		"element": "yellow",
		"area": "all",
		"info":	function (action) {return 	`Inflicts Yellow damage to all enemies with a weight of ${action.weight}.`},
		"desc":		`Remember that it is the color that matters, not the medium. Though we often associate fire with the color red, that is only actually true for the coldest flames. A hotter flame can hold the manic energy of the Yellow just fine.`,
		"actText": function () {
			return `${subject().name} paints a scorching blaze of star-yellow fire that sweeps over the enemies.`;
		},
		"act": massAttack(),
		"preview": "mass"
	},

	"Violet Bloom": {
		"cost": 2,
		"weight": 1,
		"element": ["red","blue"],
		"info":	function (action) {return 	`Inflicts Red/Blue damage with a weight of ${action.weight}.`},
		"desc":		`Red and blue combined makes violet. Flowers can be used as its conduit, combining the hypnotic beauty of the Blue with the hungry consumption of the Red.`,
		"actText": function () {
			return `${subject().name} paints the enemy wrapped in a violet wreath of beautiful, hungry flowers.`;
		},
		"act": justdmg()
	},

	"Orange Blaze": {
		"cost": 2,
		"weight": 1,
		"element": ["red","yellow"],
		"info":	function (action) {return 	`Inflicts Red/Yellow damage with a weight of ${action.weight}.`},
		"desc":		`Red and yellow combined makes orange. Fury and ecstasy together create a wild, uncontrollable flame that consumes all in its path.`,
		"actText": function () {
			return `${subject().name} splatters ${subject().their} canvas with a wild blaze of orange, consuming the foe utterly.`;
		},
		"act": justdmg()
	},

	"Green Toxin": {
		"cost": 2,
		"weight": 1,
		"element": ["blue","yellow"],
		"info":	function (action) {return 	`Inflicts Blue/Yellow damage with a weight of ${action.weight}.`},
		"desc":		`Blue and yellow combined makes green. Despair and mania both, a seeming impossibility, can be channeled through the power of poisons that overstimulate the body unto exhaustion.`,
		"actText": function () {
			return `${subject().name} paints tendrils of toxic green curling into the enemy's veins.`;
		},
		"act": justdmg()
	},

	"Prismatic Spray": {
		"cost": 3,
		"weight": 1,
		"element": ["red","blue","yellow","white","black"],
		"info":	function (action) {return 	`Inflicts omni-elemental damage with a weight of ${action.weight}.`},
		"desc":		`Light contains all colors, if one knows how to reveal their secrets.`,
		"actText": function () {
			return `${subject().name} refracts a beam of light through ${subject().their} canvas, creating a kaleidescopic spray of color.`;
		},
		"act": justdmg()
	},

	"Sacrament": {
		"cost": 4,
		"weight": 2,
		"element": function () {
			return subject().lastUsed;
		},
		"dur": 4,
		"effects": ["Consecrated"],
		"special": 0.5,
		"noDefault": true,
		"needsPriorElement": true,
		"info":	function (action) {return 	`Inflicts damage of the last element used with a weight of ${action.weight}, and increases the enemy's resistance to that element by ${action.special*100}% for ${action.dur} turns.`},
		"desc": `Bless an enemy with the purest hue of an element's color. It will overwhelm their uninitiated senses in an orgy of agony and ecstasy, but afterwards they will be inoculated, resisting further manifestations of the element.`,
		"actText": function () {
			return `${subject().name} consecrates the enemy in the holy power of the ${subject().lastUsed.toUpperFirst()}, searing its color into ${target().their} soul.`;
		},
		"act": function () {
			return `<<set $action._element = subject().lastUsed>>\
							<<echoDamage>>\
							<<print target().addEffect("Consecrated")>>`;
		},
	},

	"Blasphemy": {
		"cost": 4,
		"weight": 0.75,
		"element": function () {
			return subject().lastUsed;
		},
		"dur": 4,
		"effects": ["Desecrated"],
		"special": 0.5,
		"noDefault": true,
		"needsPriorElement": true,
		"info":	function (action) {return 	`Inflicts damage of the last element used with a weight of ${action.weight}, and reduces the enemy's resistance to that element by ${action.special*100}% for ${action.dur} turns.`},
		"desc": `Desecrate an element that lies within an enemy. Such an irreverent technique can inflict only superficial damage, but it will leave a scar.`,
		"actText": function () {
			return `${subject().name} desecrates the ${subject().lastUsed.toUpperFirst()} before the enemy, opening ${target().their} soul to its wrath.`;
		},
		"act": function () {
			return `<<set $action._element = subject().lastUsed>>\
							<<echoDamage>>\
							<<print target().addEffect("Desecrated")>>`;
		},
	},

	// CRISIS

	"Desperate Attack": {
		"crisis": true,
		"weight": 3.5,
		"act": justdmg(),
		"actText": null,
		"info": function (action) {return `Inflicts damage with a weight of ${action.weight}.`;},
		"desc": null
	},

	"Perfect Defense": {
		"crisis": true,
		"dur": 3,
		"effects": ["Invincible"],
		"phase": "Confirm Phase",
		"act": applyEffect("Invincible",{self:true}),
		"actText": null,
		"info": function (action) {return `User becomes immune to all damage for ${action.dur} rounds.`;},
		"desc": null
	},

	"Divine Protection": {
		"crisis": true,
		"dur": -1,
		"act": massAttack({target: "allies", content: applyEffect("Divine Protection")}),
		"target": "ally",
		"actText": null,
		"info": function (action) {return `All allies will gain complete protection from the next two attacks.`;},
		"desc": null
	},

	"Bloody Rain": {
		"crisis": true,
		"weight": 1.5,
		"area": "all",
		"act": massAttack(),
		"actText": function () {
			return `${subject().name} rains death from the sky.`;
		},
		"info": function (action) {return `Attack all enemies with a weight of ${action.weight}.`;},
		"desc": null,
		"preview": "mass"
	},

	"Stash": {
		"crisis": true,
		"phase": "Stash Phase",
		"info": `Use an item for free.`,
		"desc": `Rogue may have kept a few of the party's items tucked away for themselves. But now that the chips are down, they've got to use everything at their disposal!`,
		"preview": null
	},

	// ITEMS

	"Salve": {
		"target": "ally",
		"special": 250,
		"act": heal,
		"actText": function () {
			var text;
			target() == subject() ? text = subject().their : text = target().name+"'s";
			return `${subject().name} pours MegaCorp's healing salve into ${text}'s wounds.`
		},
		"preview": Prev.heal()
	},

	"Antidote": {
		"target": "ally",
		"effects": ["Poisoned"],
		"act": removeEffect(),
		"preview": "removeEffect"
	},

	"Fire Extinguisher": {
		"target": "ally",
		"effects": ["Burning"],
		"act": removeEffect(),
		"preview": "removeEffect"
	},

	"Healing Crystal": {
		"target": "ally",
		"effects": ["Dizzy"],
		"act": removeEffect(),
		"preview": "removeEffect"
	},

	"Nanites": {
		"target": "ally",
		"effects": ["Injury"],
		"act": removeEffect({removeStack: true}),
		"preview": "removeEffect"
	},

	"Painkiller": {
		"target": "ally",
		"effects": ["Pain"],
		"act": removeEffect({removeStack: true}),
		"preview": "removeEffect"
	},

	"Asprin": {
		"target": "ally",
		"effects": ["Headache"],
		"act": removeEffect({removeStack: true}),
		"preview": "removeEffect"
	},

	"Canned Air": {
		"target": "ally",
		"effects": ["Winded"],
		"act": removeEffect({type: "Winded"},`<<set $target.en += 1>>`),
		"preview": "removeEffect"
	},

	"Smelling Salts": {
		"target": "ally",
		"effects": ["Asleep"],
		"act": removeEffect(),
		"preview": "removeEffect"
	},

	"Anti-Mineral Water": {
		"target": "ally",
		"effects": ["Petrified"],
		"act": removeEffect(),
		"preview": "removeEffect"
	},

	"Panacea": {
		"target": "ally",
		"effects": ["all"],
		"act": removeEffect({unsticky: true}),
		"preview": "removeEffect"
	},

	"Bottled Chi": {
		"target": "ally",
		"dur": 3,
		"effects": ["Chi Shield"],
		"act": applyEffect("Chi Shield")
	},

	"Adrenaline": {
		"effweight": setup.STD_BUFF,
		"dur": 4,
		"effects": ["ATK Boost"],
		"target": "ally",
		"actText": `$subject.name injects a shot of adrenaline.`,
		"act": applyEffect("ATK Boost")
	},

	"Stoneskin": {
		"effweight": setup.STD_BUFF,
		"dur": 4,
		"effects": ["DEF Boost"],
		"target": "ally",
		"actText": `$subject.name uses some Stoneskin formula.`,
		"act": applyEffect("DEF Boost")
	},

	"Nootropic": {
		"effweight": setup.STD_BUFF,
		"dur": 4,
		"effects": ["SPC Boost"],
		"target": "ally",
		"act": applyEffect("SPC Boost")
	},

	"Stimulant": {
		"target": "ally",
		"act": function () {
			return 		 `<<set $target.en += 5>>\
			$target.name gains 5 Energy!`;
		},
		"preview": function () {
			var note = "";
			if ((target().en + 5) > 10) {
				note = ` ...but they already have $target.en Energy, so some of it will be wasted.`;
			}
			return `$target.name will gain 5 Energy.`+note;
		}
	},

	"Throwing Knife": {
		"weight": 1.25,
		"act": justdmg()
	},

	"Powdered Glass": {
		"weight": 1,
		"dur":	1,
		"effects": ["Stunned"],
		"actText": `$subject.name throws powdered glass in your enemy's eyes. Ouch!`,
		"act": applyEffect("Stunned",{dmg: true})
	},

	"Grenade": {
		"weight": 1.5,
		"area": "all",
		"actText": `$subject.name chucks a grenade.`,
		"act": splashDamage({target:'t',cut:2}),
		"preview": ["splash","mass"]
	},

	"Flamethrower": {
		"weight": 1,
		"effweight": 0.6,
		"dur": 5,
		"area": "all",
		"actText": `$subject.name bathes your enemies in flame.`,
		"act": massAttack({target:'enemies', cut:true, content: applyEffect("Burning")}),
		"preview": Prev.cutAttack("Burning")
	},

	"Gas Bomb": {
		"weight": 1,
		"effweight": 0.6,
		"dur": 5,
		"area": "all",
		"actText": `$subject.name throws a bomb filled with noxious gas.`,
		"act": massAttack({target:'enemies', cut:true, content: applyEffect("Poisoned")}),
		"preview": Prev.cutAttack("Poisoned")
	},

	"Flashbang": {
		"effects": "Stunned",
		"area": "all",
		"act": massAttack({target: "enemies", content: applyEffect("Stunned")}),
		"preview": "mass"
	},

	"Calamity Bomb": {
		"weight": 1,
		"effweight": 0.6,
		"dur": 3,
		"effects": ["Injury","Pain","Headache"],
		"actText": `$subject.name throws a calamity bomb.`,
		"act": applyEffect(["Injury","Pain","Headache"],{dmg: true})
	}

};
/* twine-user-script #13: "core-effects.js" */
setup.effectFunctions = {

	add: function (actor) {
		return `${actor.name} is <b>${this.name}</b>!`;
	},
	rem: function (actor) {
		return `${actor.name} is no longer ${this.name}.`;
	},
	stance: function (actor) {
		return `${actor.name} adopts the stance of a <b>${this.name}</b>.`;
	},
	remDebuff: function (actor) {
		return `${actor.name}'s ${this.name} is cured.`;
	},
	remBuff: function (actor) {
		var article;
		switch (this.name.charAt(0).toLowerCase()){
			case "a":
			case "i":
			case "o":
			case "u":
			case "e":
				article = 'an';
				break;
			default:
				article = 'a';
		}
		return `${actor.name} loses ${article} ${this.name}.`;
	},
	invisible: function () {return "";},

	physical: function (puppet) {
		return this.weight*(setup.base + (setup.damper * (this.power - puppet.get(StatName("def")))));
	},
	special: function (puppet) {
		return this.weight*(setup.base + (setup.damper * (this.power - puppet.get(StatName("spc")))));
	},
	piercing: function (puppet) {
		return this.weight*(setup.base + (setup.damper * this.power));
	},
	proportional: function (puppet) {
		return this.weight * puppet.maxHP;
	},
	fixed: function (puppet) {
		return this.power;
	}

};

setup.effectData = {

  "Injury": {
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("atk")].addMod("Injury",-this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("atk")].removeMod("Injury",this.id);
    },
    "info": function (effect) {
      return `Attack reduced by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} suffers an <b>Injury</b>!`;
    },
    "removeText": setup.effectFunctions.remDebuff
  },
  "Pain": {
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("def")].addMod("Pain",-this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("def")].removeMod("Pain",this.id);
    },
    "info": function (effect) {
      return `Defense reduced by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} is struck with <b>Pain</b>!`;
    },
    "removeText": setup.effectFunctions.remDebuff
  },
  "Headache": {
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("spc")].addMod("Headache",-this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("spc")].removeMod("Headache",this.id);
    },
    "info": function (effect) {
      return `Special reduced by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} gets a <b>Headache</b>!`;
    },
    "removeText": setup.effectFunctions.remDebuff
  },
  "ATK Boost": {
    "buff": true,
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("atk")].addMod("ATK Boost",this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("atk")].removeMod("ATK Boost",this.id);
    },
    "info": function (effect) {
      return `Attack boosted by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} is surging with strength!`;
    },
    "removeText": setup.effectFunctions.remBuff
  },
  "DEF Boost": {
    "buff": true,
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("def")].addMod("DEF Boost",this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("def")].removeMod("DEF Boost",this.id);
    },
    "info": function (effect) {
      return `Defense boosted by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} feels tougher.`;
    },
    "removeText": setup.effectFunctions.remBuff
  },
  "SPC Boost": {
    "buff": true,
    "stackable": true,
    "statmod": true,
    "onApply": function (puppet) {
      this.id = puppet.stats[StatName("spc")].addMod("SPC Boost",this.power);
    },
    "onRemove": function (puppet) {
      puppet.stats[StatName("spc")].removeMod("SPC Boost",this.id);
    },
    "info": function (effect) {
      return `Special boosted by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name}'s mind is racing.`;
    },
    "removeText": setup.effectFunctions.remBuff
  },
  "Burning": {
    "dot": true,
    "dmgtype": setup.effectFunctions.physical,
    "msg": function (actor) {return `${actor.name} is burning!`},
    "onApply": function (puppet) {
      puppet.burning = true;
    },
    "onRemove": function (puppet) {
      puppet.burning = false;
    },
    "info": function (effect) {
      return `Inflicts <<print _effect.damage($B.actor)>> physical damage per round.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Perdition": {
    "dot": true,
    "dmgtype": setup.effectFunctions.piercing,
    "msg": function (actor) {return `The fires of perdition burn in ${actor.name}'s soul.`},
    "sticky": true,
    "synonym": "Burning",
    "onApply": function (puppet) {
      puppet.perdition = true;
    },
    "onRemove": function (puppet) {
      puppet.perdition = false;
    },
    "info": function (effect) {
      return `Inflicts <<print _effect.damage($B.actor)>> magical damage per round.`;
    },
    "addText": function (actor) {
      return `${actor.name} feels the fires of <b>Perdition</b>.`;
    },
    "removeText": function (actor) {
      return `${actor.name} is freed from the fires of Perdition.`;
    }
  },
  "Poisoned": {
    "dot": true,
    "dmgtype": setup.effectFunctions.special,
    "msg": function (actor) {return `${actor.name} writhes in agony as poison courses through ${actor.their} veins.`},
    "onApply": function (puppet) {
      puppet.poisoned = true;
    },
    "onRemove": function (puppet) {
      puppet.poisoned = false;
    },
    "info": function (effect) {
      return `Inflicts <<print _effect.damage($B.actor)>> special damage per round.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Dizzy": {
		"skillLock": true,
    "onApply": function (puppet) {
      puppet.dizzy = true;
    },
    "onRemove": function (puppet) {
      puppet.dizzy = false;
    },
    "info": function (effect) {
      return `Can only use basic skills.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Winded": {
		"noENregen": true,
    "onApply": function (puppet) {

    },
    "onRemove": function (puppet) {

    },
    "info": function (effect) {
      return `No Energy regen.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Stunned": {
    "hold": true,
    "onApply": function (puppet) {
      puppet.stunned = true;
    },
    "onRemove": function (puppet) {
      puppet.stunned = false;
      if (V().inbattle){
        var d;
        if (puppet.boss){
          d = 7;
        } else {
          d = 3;
        }
        puppet.addEffect("Alert",{time: d, noPopup: true});
      }
    },
    "info": function (effect) {
      return `Cannot act.`;
    },
    "holdAction": function () {
      temporary().enemy.decCD();
      return {useText: null,
        actText: "_enemy.name is stunned!",
        act: null};
    },
    "priority": 1,
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Off-Balance": {
    "topDec": true,
    "onApply": function (puppet) {
      puppet.offbalance = true;
    },
    "onRemove": function (puppet) {
      puppet.offbalance = false;
    },
    "info": function (effect) {
      return `Direct damage will inflict Knocked Down.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Knocked Down": {
    "hold": true,
    "onApply": function (puppet) {
      puppet.down = true;
      puppet.stats[StatName("def")].addMod("Knocked Down",{mult: -0.5});
    },
    "onRemove": function (puppet) {
      puppet.down = false;
      puppet.stats[StatName("def")].removeMod("Knocked Down");
    },
    "info": function (effect) {
      return `Cannot act until righted. Defense halved.`;
    },
    "holdAction": function () {
      temporary().enemy.removeEffect("Knocked Down",{pierce: true, noPopup: true});
      return {useText: null,
        actText: "_enemy.name struggles back to _enemy.their feet.",
        act: null};
    },
    "priority": 2,
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Curse": {
    "statmod": true,
    "threat": 3,
    "onApply": function (puppet) {
      puppet.curse = true;
      puppet.stats[StatName("atk")].addMod("Curse",-this.power);
      puppet.stats[StatName("def")].addMod("Curse",-this.power);
      puppet.stats[StatName("spc")].addMod("Curse",-this.power);
    },
    "onRemove": function (puppet) {
      puppet.curse = false;
      puppet.stats[StatName("atk")].removeMod("Curse"),
      puppet.stats[StatName("def")].removeMod("Curse"),
      puppet.stats[StatName("spc")].removeMod("Curse");
    },
    "info": function (effect) {
      return `All stats reduced by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} can't seem to do anything right.`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s ${this.name} is lifted.`;
    }
  },
  "Forsaken": {
    "statmod": true,
    "synonym": "Curse",
    "onApply": function (puppet) {
      puppet.noMinimum.push(StatName("def"));
      puppet.stats[StatName("def")].addMod("Forsaken",-this.power);
    },
    "onRemove": function (puppet) {
      puppet.noMinimum.deleteAt(puppet.noMinimum.indexOf(StatName("def")));
      puppet.stats[StatName("def")].removeMod("Forsaken");
    },
    "info": function (effect) {
      return `Defense reduced by ${this.power}. Defense can be negative.`;
    },
    "addText": function (actor) {
      return `${actor.name} is <b>Forsaken</b>.`;
    },
    "removeText": setup.effectFunctions.rem
  },
  "Blessing": {
    "buff": true,
    "statmod": true,
    "threat": 3,
    "onApply": function (puppet) {
      puppet.blessing = true;
      puppet.stats[StatName("atk")].addMod("Blessing",this.power);
      puppet.stats[StatName("def")].addMod("Blessing",this.power);
      puppet.stats[StatName("spc")].addMod("Blessing",this.power);
    },
    "onRemove": function (puppet) {
      puppet.blessing = false;
      puppet.stats[StatName("atk")].removeMod("Blessing");
      puppet.stats[StatName("def")].removeMod("Blessing");
      puppet.stats[StatName("spc")].removeMod("Blessing");
    },
    "info": function (effect) {
      return `All stats boosted by ${this.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} feels a sense of grace.`;
    },
    "removeText": setup.effectFunctions.remBuff
  },
  "Alert": {
    "buff": true,
    "sticky": true,
    "unblockable": true,
    "block": true,
    "priority": 3,
    "blockCondition": function (effect) {
      return effect.name === "Stunned";
    },
    "blockText": function (actor) {
      return `${actor.name} saw it coming and wasn't stunned!`;
    },
    "onApply": function (puppet) {
      puppet.alert = true;
    },
    "onRemove": function (puppet) {
      puppet.alert = false;
    },
    "info": function (effect) {
      return `Can't be stunned.`;
    },
    "addText": setup.effectFunctions.invisible,
    "removeText": setup.effectFunctions.rem
  },
  "Chi Shield": {
    "buff": true,
    "sticky": true,
    "block": true,
    "priority": 2,
    "blockCondition": function (effect) {
      return !(effect.buff || target().id === subject().id);
    },
    "blockText": function (actor) {
      return `${actor.name}'s Chi Shield protected ${actor.them} from the ailment.`;
    },
    "onApply": function (puppet) {
      puppet.chi = true;
    },
    "onRemove": function (puppet) {
      puppet.chi = false;
    },
    "info": function (effect) {
      return `Protected from ailments.`;
    },
    "addText": function (actor) {
      return `${actor.name} has a tangible aura.`;
    },
    "removeText": function (actor) {
      return `${actor.name} is no longer protected by ${this.name}.`;
    }
  },
  "Protector": {
    "topDec": true,
    "buff": true,
    "statmod": true,
    "exclusive": true,
    "unblockable": true,
		"guard": true,
    "onApply": function (puppet) {
      puppet.protector = true;
      puppet.stats[StatName("def")].addMod("Protector",this.power);
    },
    "onRemove": function (puppet) {
      puppet.protector = false;
      puppet.stats[StatName("def")].removeMod("Protector");
      var targets = [];
      switch(this.target.id.charAt(0)) {
        case "p": targets = State.variables.puppets; break;
        case "e": targets = State.variables.enemies; break;
        default: console.log("ERROR: Target ID does not match any known party.");
      }
      var id = this.target.id;
      var actor = targets.find(function(t) { return t && t.id === id; });
      actor.protectedBy = null;
    },
    "info": function (effect) {
      return `Taking hits for ${effect.target.name}. Defense boosted by ${effect.power}.`;
    },
    "addText": function (actor) {
      return `${actor.name} is protecting $target.name.`;
    },
    "removeText": function (actor) {
      return `${actor.name} is no longer protecting anyone.`;
    }
  },
  "Martyr": {
    "buff": true,
    "exclusive": true,
		"unique": true,
    "topDec": true,
    "threat": 0,
    "onApply": function (puppet) {
      puppet.martyr = true;
    },
    "onRemove": function (puppet) {
      puppet.martyr = false;
    },
    "info": function (effect) {
      return `Will be targeted by all direct attacks.`;
    },
    "addText": function (actor) {
      return `All eyes are on ${actor.name}.`;
    },
    "removeText": setup.effectFunctions.invisible
  },
  "Hunter": {
    "buff": true,
    "exclusive": true,
    "topDec": true,
    "onApply": function (puppet) {
      puppet.hunter = true;
    },
    "onRemove": function (puppet) {
      puppet.hunter = false;
    },
    "info": function (effect) {
      return `Counterattacking.`;
    },
    "addText": setup.effectFunctions.stance,
    "removeText": setup.effectFunctions.invisible
  },
  "Hidden": {
    "untargetable": true,
    "buff": true,
    "exclusive": true,
    "onApply": function (puppet) {
      return;
    },
    "onRemove": function (puppet) {
      return;
    },
    "info": function (effect) {
      return `Can't be targeted by direct attacks.`;
    },
    "addText": function (actor) {
      return `${actor.name} is evading attacks.`;
    },
    "removeText": function (actor) {
      return `${actor.name} is no longer hidden.`;
    }
  },
  "Berserker": {
    "buff": true,
    "exclusive": true,
    "topDec": true,
    "onApply": function (puppet) {
      puppet.berserker = true;
    },
    "onRemove": function (puppet) {
      puppet.berserker = false;
    },
    "info": function (effect) {
      return `Damage dealt and received up by <<print setup.BERSERK_FACTOR*100>>%.`;
    },
    "addText": setup.effectFunctions.stance,
    "removeText": setup.effectFunctions.invisible
  },
  "Defender": {
    "buff": true,
    "exclusive": true,
    "topDec": true,
    "threat": 0,
    "onApply": function (puppet) {
      puppet.defender = true;
    },
    "onRemove": function (puppet) {
      puppet.defender = false;
    },
    "info": function (effect) {
      return `Damage dealt and received down by <<print setup.DEFEND_FACTOR*100>>%.`;
    },
    "addText": setup.effectFunctions.stance,
    "removeText": setup.effectFunctions.invisible
  },
  "Shield": {
    "buff": true,
    "onApply": function (puppet) {
      puppet.shield = true;
    },
    "onRemove": function (puppet) {
      puppet.shield = false;
    },
    "info": function (effect) {
      return `Incoming damage reduced by <<print setup.SHIELD_FACTOR*100>>%.`;
    },
    "addText": function (actor) {
      return `The air before ${actor.name} glimmers with a magical <b>Shield</b>.`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s Shield is gone.`;
    }
  },
  "Frenzy": {
    "statmod": true,
    "buff": true,
    "onApply": function (puppet) {
      puppet.frenzy = true;
      puppet.stats[StatName("atk")].addMod("Frenzy",this.power);
      puppet.stats[StatName("def")].addMod("Frenzy",-this.power/2);
    },
    "onRemove": function (puppet) {
      puppet.frenzy = false;
      puppet.stats[StatName("atk")].removeMod("Frenzy");
      puppet.stats[StatName("def")].removeMod("Frenzy");
    },
    "info": function (effect) {
      return `Attack boosted by ${this.power}; Defense reduced by ${Math.round(this.power/2)}.`;
    },
    "addText": function (actor) {
      return `${actor.name} feels the <b>Frenzy</b>!`;
    },
    "removeText": function (actor) {
      return `${actor.name} is no longer in a Frenzy.`;
    }
  },
  "Stasis": {
    "unblockable": true,
    "sticky": true,
    "block": true,
    "priority": 1,
    "blockCondition": function (effect) {
      return true;
    },
    "blockText": function (actor) {
      return `${actor.name}'s effects are in Stasis.`;
    },
    "onApply": function (puppet) {
      puppet.stasis = true;
    },
    "onRemove": function (puppet) {
      puppet.stasis = false;
    },
    "info": function (effect) {
      return `Effects will not decay. Effects cannot be added or removed.`;
    },
    "addText": function (actor) {
      return `${actor.name}'s effects are placed in <b>Stasis</b>.`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s effects are no longer in Stasis.`;
    }
  },
  "Marked": {
    "onApply": function (puppet) {
      puppet.marked = true;
    },
    "onRemove": function (puppet) {
      puppet.marked = false;
    },
    "info": function (effect) {
      return `Will be shot every time someone attacks.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Guarded": {
    // Note that this functions uniquely. The AoE protection is automatic, but everyone else taking hits for Steven is hard-coded into the "battle interruptions" passage. You may want to generalize it, but you will need to add your own code for that.
    "buff": true,
    "sticky": true,
    "ULTIMATESTICKY": true,
    "onApply": function (puppet) {
      puppet.areaImmune = true;
    },
    "onRemove": function (puppet) {
      puppet.areaImmune = false;
    },
    "info": function (effect) {
      return `Protected from direct attacks; out of reach of area attacks.`;
    },
    "removeText": setup.effectFunctions.invisible
  },
  "Bubble": {
    "buff": true,
    "shield": true,
    "uses": 1,
    "onApply": function (puppet) {
      puppet.bubbled = true;
    },
    "onRemove": function (puppet) {
      puppet.bubbled = false;
    },
    "onHit": function (puppet) {
      return `${puppet.name}'s bubble pops like a balloon under the attack, leaving ${puppet.them} unharmed!<br/>`;
    },
    "info": function (effect) {
      return `Protects against one attack.`;
    },
    "addText": function (actor) {
      return `Translucent pink petals rise from the ground to wrap ${actor.name} in a protective bubble.`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s bubble shield dissipates.`;
    }
  },
  "Doom": {
    "dot": true,
    "dmgtype": setup.effectFunctions.piercing,
    "msg": function (actor) {return `${actor.name}'s doom ticks closer.`},
    "onApply": function (puppet) {
      puppet.doom = true;
    },
    "onRemove": function (puppet) {
      puppet.doom = false;
    },
    "info": function (effect) {
      return `Inflicts <<print _effect.damage($B.actor)>> magical damage per round.`;
    },
    "addText": function (actor) {
      return `${actor.name} is cursed with <b>Doom</b>! Their life ticks away...`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s ${this.name} is dispelled.`;
    }
  },
  "Asleep": {
    "hold": true,
    "onApply": function (puppet) {
      puppet.asleep = true;
    },
    "onRemove": function (puppet) {
      puppet.asleep = false;
    },
    "info": function (effect) {
      return `Cannot act.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": function (actor) {
      return `${actor.name} wakes up!`;
    }
  },
  "Petrified": {
    "hold": true,
		"noENregen": true,
    "onApply": function (puppet) {
      puppet.petrified = true;
    },
    "onRemove": function (puppet) {
      puppet.petrified = false;
    },
    "info": function (effect) {
      return `Cannot act.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Thorns": {
    "buff": true,
    "shield": true,
    "uses": 1,
    "onApply": function (puppet) {
      puppet.thorns = true;
    },
    "onRemove": function (puppet) {
      puppet.thorns = false;
    },
    "onHit": function (puppet) {
      return `${puppet.name}'s bubble pops like a balloon under the attack, and ${subject().name} is pricked by the thorns!
      <<if target() !== subject()>>\
        <<set _OG = {subject: $subject, target: $target, action: $action}>>\
        <<set $action = new Action("Thorn Counterattack"); $subject = _OG.target; $target = _OG.subject>>\
        <<echoDamage "nocounter">>\
        <<set $action = _OG.action; $subject = _OG.subject; $target = _OG.target>>\
        <<unset _OG>>\
      <</if>>`;
    },
    "info": function (effect) {
      return `Protects and counterattacks against one attack.`;
    },
    "addText": function (actor) {
      return `Translucent pink petals rise from the ground to wrap ${actor.name} in a protective bubble that grows menacing, spiky thorns all around.`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s spiky bubble dissipates.`;
    }
  },
  "Consecrated": {
    "buff": true,
    "onApply": function (puppet) {
      this.power = V().action.special;
      this.type = V().action.element;
      puppet.elements.addMod(this.type,"Consecrated",-this.power,false,"percent");
    },
    "onRemove": function (puppet) {
      puppet.elements.removeMod(this.type,"Consecrated",null,"percent");
    },
    "info": function (effect) {
      return `${this.type.toUpperFirst()} resistance increased by ${this.power*100}%.`;
    },
    "addText": function (actor) {
      return `${actor.name} is <b>Consecrated</b> in the power of the <<print $action.element.toUpperFirst()>>.`;
    },
    "removeText": setup.effectFunctions.rem
  },
  "Desecrated": {
    "onApply": function (puppet) {
      this.power = V().action.special;
      this.type = V().action.element;
      puppet.elements.addMod(this.type,"Desecrated",this.power,false,"percent");
    },
    "onRemove": function (puppet) {
      puppet.elements.removeMod(this.type,"Desecrated",null,"percent");
    },
    "info": function (effect) {
      return `${this.type.toUpperFirst()} resistance decreased by ${this.power*100}%.`;
    },
    "addText": function (actor) {
      return `${actor.name} is <b>Desecrated</b> in the power of the <<print $action.element.toUpperFirst()>>.`;
    },
    "removeText": setup.effectFunctions.rem
  },
  "Hatred": {
    "uncontrollable": true,
    "topDec": true,
    "onApply": function (puppet) {
      puppet.hatred = true;
    },
    "onRemove": function (puppet) {
      puppet.hatred = false;
    },
    "info": function (effect) {
      return `Compelled to attack enemies.`;
    },
    "addText": function (actor) {
      return `${actor.name} is filled with a blinding <b>Hatred</b>!`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s unnatural hatred has passed.`;
    }
  },
  "Confusion": {
    "uncontrollable": true,
    "topDec": true,
    "onApply": function (puppet) {
      puppet.confusion = true;
    },
    "onRemove": function (puppet) {
      puppet.confusion = false;
    },
    "info": function (effect) {
      return `Compelled to attack at random.`;
    },
    "addText": function (actor) {
      return `${actor.name} cannot tell friend from foe!`;
    },
    "removeText": function (actor) {
      return `${actor.name}'s head clears.`;
    }
  },
  "Charmed": {
    "uncontrollable": true,
    "topDec": true,
    "onApply": function (puppet) {
      puppet.charmed = true;
    },
    "onRemove": function (puppet) {
      puppet.charmed = false;
    },
    "info": function (effect) {
      return `Compelled to attack allies.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Invincible": {
    "buff": true,
    "sticky": true,
    "unblockable": true,
    "onApply": function (puppet) {
      puppet.invincible = true;
    },
    "onRemove": function (puppet) {
      puppet.invincible = false;
    },
    "info": function (effect) {
      return `Takes no damage from attacks.`;
    },
    "addText": setup.effectFunctions.add,
    "removeText": setup.effectFunctions.rem
  },
  "Divine Protection": {
    "buff": true,
    "shield": true,
    "unblockable": true,
    "uses": 2,
    "onApply": function (puppet) {
      puppet.shielded = true;
      puppet.divineProt = true;
    },
    "onRemove": function (puppet) {
      puppet.shielded = false;
      puppet.divineProt = false;
    },
    "onHit": function (puppet) {
      return `Divine intervention shields ${puppet.name} from harm!<br/>`;
    },
    "info": function (effect) {
      return `Protects against two attacks. (Remaining: ${effect.uses})`;
    },
    "addText": function (actor) {
      return `${actor.name} gains <b>${this.name}!</b>`;
    },
    "removeText": function (actor) {
      return `${actor.name} loses ${this.name}.`;
    }
  }

};
/* twine-user-script #14: "core-enemies.js" */
setup.enemyData = {

	// GRAVITY FALLS 1

	"Dipper": {
		"bestiaryNo": 0,
		"alts": ["Big Dipper"],
		"gender": 'M',
		"hp": 1000,
		"stats": {
			"Attack"	: 25,
			"Defense"	: 30,
			"Special"	: 35
		},
		"elements": {
			"black"	: 0.8,
			"white"	: 1.2,
			"blue"	: 0,
			"yellow": -0.1
		},
		"cooldown": {
			"Dispel Magick": 0
		},
		"actions": function () {
			while (V().action === null) {
				console.log("Dipper actions rolling");
				var act = random(1,100);
				console.log("act = "+act);

			// Dipper is a support caster. Half the time, he will enter support mode. If he is able, he will prioritize Dispel Magick, which will remove all buffs from one target. This is pretty powerful, so for balance it has a long cooldown (4 rounds) and a threshold of 2 buffs. If dispelTarget fails the threshold or Dispel is still on cooldown, he will use Recovery. Since there's no healing, I will instead interpret this as a buff spell, but it can also provide the ailment reduction like Bonfire Monk's Heal. Because he's selfless, he will prioritize Mabel if she has the same number of ailments as him; otherwise he will pick the person with more ailments, or choose randomly if no one has any ailments. The buff is chosen completely randomly because I don't want to try to make logic for that. (Patron maps onto the specializations for the basic three classes, so Chattur'gha = DEF, Ulayoth = ATK, Xel'lotath = SPC.)

			// Half the time, he will enter attack mode. 25% of the time, he will use Damage Field, which I am interpreting as damage + debuff because Mabel already has DoT and there are no multi-turn stuns. Debuff is again chosen randomly. The other 25% of the time, he will use Bind Creature, which does weak damage + stun. All of his attack weights are below 1, so he cannot deal significant damage on his own.

			if (this.CDcheck("Dispel Magick") && act <= 50) {
				console.log("Dispel Magick selected");
				if (dispelCheck() > 2) {
					V().action = new Action("Dispel Magick");
					return;
				}
			}
			if (act <= 50) {
				console.log("Healing selected");
				V().action = new Action("Recovery");
			}
			else if (act <= 75 && act > 50) {
				console.log("Debuff selected");
				V().action = new Action("Damage Field");
			}
			else if (act <= 100 && act > 75) {
				console.log("Bind Creature selected");
				V().action = new Action("Bind Creature");
			}

			} // end loop
			return;
		}
	},

	"Big Dipper": {
		"noBestiary": true,
		"special": function (actor) {
			actor._idname = "Dipper";
			actor.name = "Big Dipper";
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Big Dipper gains stronger offense to make up for the loss of Mabel, but still focuses on debuffs and ailments, making him a sort of balanced mage. His Damage Field and Bind Creature go up to weight 1, making them fairly potent attacks, and he gains a full-party damage + Winded spell.

//			20%: Empowered Dispel Magick
//			20%: Empowered Recovery (Mantorok), which grants Blessing
//			20%: Empowered Damage Field (Mantorok), which inflicts Curse
//			20%: Empowered Bind Creature
//			20%: Empowered Magickal Attack

			if (this.CDcheck("Dispel Magick") && act <= 20) {
				if (dispelCheck(["mass"]) > 4) {
					V().action = new Action("Empowered Dispel Magick");
					return;
				}
			}
			else if (this.blessing == false && act <= 40 && act > 20) {
				V().action = new Action("Empowered Recovery");
			}
			else if (act <= 60 && act > 40) {
				V().action = new Action("Empowered Damage Field");
			}
			else if (act <= 80 && act > 60) {
				V().action = new Action("Empowered Bind Creature");
			}
			else if (act <= 100 && act > 80) {
				V().action = new Action("Empowered Magickal Attack");
			}

			}
			return;
		}
	},

	"Mabel": {
		"bestiaryNo": 0,
		"alts": ["Mega Mabel"],
		"gender": 'F',
		"hp": 1000,
		"stats": {
			"Attack"	: 40,
			"Defense"	: 25,
			"Special"	: 25
		},
		"elements": {
			"white": 0,
			"red"	: 0.5,
			"blue"	: 2,
			"yellow": -2
		},
		"cooldown": {
			"Glitter Bomb": 0
		},
		"actions": function () {
			while (V().action === null){
				console.log("Mabel actions rolling");
				var act = random(1,100);
				console.log("act = "+act);

			// Mabel is a simple soul, so she just picks from five attacks randomly with even chances.

			// Mabel is blaster caster. She has two DoT attacks, one for Poison and one for Burning. Due to the imbalance between her ATK and SPC, they are designed to be mainly heavy initial hits with minor DoT, to ease players into the concept before the fight with Bill, who will invert the dynamic. She also has a Dizzy attack, just because I loved the idea of a "Glitter Bomb" attack and that was the logical ailment for it. Since this is a hold effect, it has a one-turn cooldown to prevent her from incapacitating the whole party with lucky rolls. For pure damage, she has a 3-hit spread attack as well as a regular attack that actually functions effectively as more of a breather, as it's not significantly stronger than her DoT attacks.

			if (act <= 20){
				console.log("Cuteness Poisoning selected");
				V().action = new Action("Cuteness Poisoning");
			}
			else if (act <= 40 && act > 20) {
				console.log("Galacta Burning selected");
				V().action = new Action("Galacta Burning");
			}
			else if (this.CDcheck("Glitter Bomb") && act <= 60 && act > 40) {
				console.log("Glitter Bomb selected");
				V().action = new Action("Glitter Bomb");
			}
			else if (act <= 80 && act > 60) {
				console.log("Chaos Blaster selected");
				V().action = new Action("Chaos Blaster");
			}
			else if (act > 80) {
				console.log("Kitty Cannon selected");
				V().action = new Action("Kitty Cannon");
			}

			} //end loop
			return;
		}
	},

	"Mega Mabel": {
		"noBestiary": true,
		"special": function (actor) {
			actor._idname = "Mabel";
			actor.name = "Mega Mabel";
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

			//The idea behind Mega Mabel is a "sprint to the finish" kind of boss. Her attacks don't get stronger, but they now strike the whole party, making them much harder to defend against and encouraging the player to just rush her before she overwhelms you. Chaos Blaster is also upgraded to a true single-target nuke, meaning it is still possible for her to pick off individuals.

			if (act <= 20){
				V().action = new Action("Cuteness Overload");
			}
			else if (act <= 40 && act > 20) {
				V().action = new Action("Galacta Blazing");
			}
			else if (this.CDcheck("Glitter Bomb") && act <= 60 && act > 40) {
				V().action = new Action("Anarchy Rave");
			}
			else if (act <= 80 && act > 60) {
				V().action = new Action("Chaos Thunder");
			}
			else if (act > 80) {
				V().action = new Action("Kitty Cannon");
			}

			} //end loop
			return;
		}
	},

	// ADVENTURE TIME 1

	"Finn": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 500,
		"stats": {
			"Attack"	: 60,
			"Defense"	: 20,
			"Special"	: 10
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,2);

			// Finn smash. Half the time he will do a regular attack, and half the time he will mimic Fighter's Assault. No further logic, because he is a doofus with no concern for his own safety.

			if (act == 1) {

				V().action = new Action("Sword");
				V().action.actText = "Finn swings his sword wildly!";
				V().action.useText = null;
			} else if (act == 2) {
				V().action = new Action("Assault");
				V().action.actText = "Finn charges in recklessly!";
				V().action.useText = null;
				V().action.dur = 1;
				V().action.act = applyEffect("Off-Balance",{self: true, dmg: true});
			}

			} //end loop
			return;
		}
	},

	"Jake": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 500,
		"stats": {
			"Attack"	: 20,
			"Defense"	: 40,
			"Special"	: 30
		},
		"cooldown": {
			"Below the Belt": 0,
			"Dead Ringer": 0,
			"Trip": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);
				console.log(`Jake act = ${act}`);

//			Jake is a dual-class Fighter/Rogue. He always protects someone if they're at less than half health (but prioritizes Finn because he cares about him more). From there his breakdown is:
//			25%: Martyr (if viable)
//			10%: stun
//			20%: Below the Belt
//			20%: Dead Ringer
//			10%: AoE Off-Balance
//			15%: regular attack

//			He therefore has a higher chance of tanking than any other individual action, but will use debuff attacks most of the time. However, his attacks have long cooldowns, so on any given turn his chances might break down differently.

			if (V().enemies[2].hp < (V().enemies[2].maxHP / 2) && !V().enemies[2].dead && !this.protector && act <= 30){ //If Finn is below 50% HP
				V().target = V().enemies[2];
				V().action = new Action("Protector");
				V().action._actText = `Jake wraps himself around $target.name like a suit of armor.`;
			}
			else if (V().enemies[1].hp < (V().enemies[1].maxHP / 2) && !V().enemies[1].dead && !this.protector && act <= 30){ //If Bubblegum is below 50% HP
				V().target = V().enemies[1];
				V().action = new Action("Protector");
				V().action._actText = `Jake wraps himself around $target.name like a suit of armor.`;
			}
			else if (!V().enemies[1].dead && !V().enemies[2].dead && act <= 25){
				console.log("Martyr branch")
				V().action = new Action("Martyr");
				V().action._actText = `Jake stretches himself into a huge wall of flesh, covering the others from your attacks!`;
			}
			else if (act <= 40 && act > 30){
				console.log("Stun branch")
				if (!target().alert && !target().chi && !target().stasis){ //Unlike most enemies, Jake is a hardened criminal and smart enough not to try to stun an alert character.
					console.log("Target valid");
					V().action = new Action("Something in your eye");
					action()._targetMod = ["ignore downed"];
					action()._useText = null;
					action()._actText = `Jake stretches out towards $target.name and wraps around and around until they can't move!`;
				}
			}
			else if (this.CDcheck("Below the Belt") && act <= 60 && act > 40){
				console.log("Below the Belt branch")
				V().action = new Action("Below the Belt");
				action()._targetMod = ["debuff"];
				action()._actText = `Jake raises his fists as if to punch $target.name, but instead his legs snap out to hit them right in the knees.`;
				this.cd.set("Below the Belt",3);
			}
			else if (this.CDcheck("Dead Ringer") && act <= 80 && act > 60){
				console.log("Dead Ringer branch")
				V().action = new Action("Dead Ringer");
				action()._targetMod = ["debuff"];
				action()._actText = `Jake stretches around behind $target.name before they can react, and whacks them hard on the back of the head.`;
				this.cd.set("Dead Ringer",3);
			}
			else if (this.CDcheck("Trip") && act <= 90 && act > 80){
				console.log("Trip branch")
				V().action = new Action("Trip");
				V().action._useText = null;
				V().action._actText = `Jake stretches his arms into whips and trips everyone up!`;
				V().action._act = function () {return ``+
				`<<for _puppet range puppets()>>`+
					`<<addEffect _puppet "Off-Balance" 1>>`+
				`<</for>>`;}
				this.cd.set("Trip",3);
			}
			else {
				console.log("Default attack branch")
				V().action = new Action();
				V().action._weight = 1;
				V().action._useText = null;
				V().action._actText = `Jake attacks!`;
				V().action._act = justdmg("",{enemy:true});
			}

			if (V().action === null) {
				console.log("Action null, should reroll");
			} else {
				console.log("At loop end, action = "+V().action.name);
			}

			} //end loop
			return;
		}
	},

	"Princess Bubblegum": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 1000,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 40,
			"Special"	: 40
		},
		"cooldown": {
			"mass buff": 0,
			"Chi Shield": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Bubblegum delegates to her subordinates instead of doing stuff directly. She will always use a mass buff ability if she is able, but must wait for the buffs to expire before she can use one again, so she can't just stack buffs until the enemies are unstoppable. On her off-turns, she can freely use single-target buff drugs (weaker than the player's for balance purposes) and bestow Chi Shield (with a cooldown since it's so hard to remove). Rarely, she will attack by throwing bombs, but must spend a turn to make one first. (Bombs get second priority after mass buffs if she has one ready.)

//			50%: use drugs
//			25%: Chi Shield
//			25%: ready a bomb

			if (this.CDcheck("mass buff")) {
				act = random(1,3)
				switch (act) {
					case 1:
						V().action = new Action("Call to Arms");
						V().action.effweight = (1/3);
						break;
					case 2:
						V().action = new Action("Walled City");
						V().action.effweight = (1/3);
						break;
					case 3:
						V().action = new Action("Age of Enlightenment");
						V().action.effweight = (1/3);
						break;
				}
				this.cd.set("mass buff",3);
			}
			else if (this.ready) {
				act = random(1,2)
				if (act == 1) {
					V().action = new ItemAction("Grenade");
					V().action.weight = 1;
					V().action.useText = null;
					V().action.actText = `Princess Bubblegum throws what appears to be a giant peppermint, but as soon as it hits the ground it explodes with the force of a grenade, spreading hard candy shrapnel everywhere.`;
				}
				else if (act == 2) {
					V().action = new Action();
					V().action.effweight = 0.75;
					V().action.dur = 4;
					V().action.useText = null;
					V().action.actText = `Princess Bubblegum douses $target.name in a stinging, sticky syrup. They cough and stagger as their skin breaks out in welts.`;
					V().action._act = applyEffect("Poisoned");
				}
				this.ready = false;
			}
			else if (act <= 50) {
				var hitlist = [];
				if (!V().enemies[0].dead && !V().enemies[0].stasis){
					hitlist.push(V().enemies[0]);
				} else if (!V().enemies[2].dead && !V().enemies[2].stasis){
					hitlist.push(V().enemies[2]);
				}
				if (hitlist.length > 0) {
					var t = random(0,hitlist.length-1);
					V().target = hitlist[t];
					act = random(1,3)
					switch (act) {
						case 1:
							V().action = new ItemAction("Adrenaline");
							V().action._dur = 2;
							break;
						case 2:
							V().action = new ItemAction("Stoneskin");
							V().action._dur = 2;
							break;
						case 3:
							V().action = new ItemAction("Nootropic");
							V().action._dur = 2;
							break;
					}
				}
			}
			else if (this.CDcheck("Chi Shield") && act <= 75 && act > 50) {
				if (target() !== null){
					V().action = new Action("");
					V().action.dur = 2;
					V().action.useText = null;
					V().action.actText = function () {
						var str;
						if (V().target == subject()){
							str = "her becomes";
						} else {
							str = "$target.name is";
						}
						return `$subject.name presses a button, the air around ${str} surrounded by a force field.`
					}
					V().action._act = applyEffect("Chi Shield");
					this.cd.set("Chi Shield",2);
				}
			}
			else {
				V().action = new Action();
				V().action.useText = null;
				V().action.actText = `Princess Bubblegum pulls something out of her pack.`;
				V().action.act = `Something has changed...`;
				this.ready = true;
			}

			} //end loop
			return;
		}
	},

	"PB alone": {
		"noBestiary": true,
		"special": function (actor) {
			actor.cd.set("mass buff",0);
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			PB switches to an offensive role when Jake and Finn are down. Her mass buff is changed to a Blessing, and she is now much more likely to make a bomb. She may also attack regularly, but this is more of a breather due to her low Attack.

//			25%: attack
//			75%: make bomb

			if (this.CDcheck("mass buff")) {
				V().action = new Action("Mandate of Heaven");
				V().action._effweight = 0.2;
				V().action._dur = 4;
				action()._actText = null;
				V().action._act = applyEffect("Blessing",{self:true});
				this.cd.set("mass buff",4);
			}
			else if (this.ready) {
				act = random(1,2)
				if (act == 1) {

					V().action = new ItemAction("Grenade");
					V().action._weight = 1;
					V().action._useText = null;
					V().action._actText = `Princess Bubblegum throws what appears to be a giant peppermint, but as soon as it hits the ground it explodes with the force of a grenade, spreading hard candy shrapnel everywhere.`;
				}
				else if (act == 2) {
					V().action = new Action();
					V().action._effweight = 0.75;
					V().action._dur = 4;
					V().action._useText = null;
					V().action._actText = `Princess Bubblegum douses $target.name in a stinging, sticky syrup. They cough and stagger as their skin breaks out in welts.`;
					V().action._act = applyEffect("Poisoned");
				}
				this.ready = false;
			}
			else if (act <= 25) {

				V().action = new Action();
				V().action._weight = 1;
				V().action._useText = null;
				V().action._actText = `Princess Bubblegum blasts $target.name with her ray gun.`;
				V().action._act = justdmg();
			}
			else {
				V().action = new Action();
				V().action._useText = null;
				V().action._actText = `Princess Bubblegum pulls something out of her pack.`;
				V().action._act = `Something has changed...`;
				this.ready = true;
			}

			} //end loop
		}
	},

	// GUMBALL 1

	"Gumball": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 666,
		"stats": {
			"Attack"	: 15,
			"Defense"	: 50,
			"Special"	: 25
		},
		"surrender": function () {
			V().action = {
				useText: null,
				actText: ``+
`Gumball laughs so hard he cries. "Wow! Wow, I really don't have to..." His expression snaps to suspicion with unsettling speed, and his head darts from side to side like a bird's. "This isn't a trick, is it? You're not gonna stab me in the back? I'm not gonna trip and break my neck? An anvil's not gonna fall from the sky?"

He cowers for several seconds, but nothing happens. After a few more moments, he gingerly cracks an eye open. A heartbeat later, he's suddenly jumping wildly up and down, cackling frenziedly. "Ahahaha! Yes! <i>Yes!</i>" He raises his fist in triumph. "Guess who didn't get beaten to a pulp today? That's right, ME! Suck on that, Universe! SUCK! ON! TH--"

Gumball slips on a stray pebble, falls back, hits his head, and is instantly knocked unconscious.`,
			act: null};
			V().enemies[0].dead = true;
			V().B.kills.push("Gumball");
			V().B.surrender = false;
		},
		"surrenderFail": function () {
			V().B.surrender = false;
			return `Gumball sighs. "Well, it was worth a shot." He raises his fists, but halfheartedly. "Hey, you never know. Maybe I'll get lucky for once. Stranger things have happened!"`;
		},
		"actions": function () {
			console.log("Gumball actions called");
			if (V().B.surrender){
				V().action = {useText: null, act: null, actText: `Gumball is watching you expectantly.`};
			}
			else {

			while (V().action === null){
				console.log("Action loop triggered");
				var act = random(1,100);

//			Gumball is intended to be a wild card. His behavior is highly random and his actions vary wildly in usefulness, from knocking himself down to an AoE nuke. Most of his attacks are rogueish, because he is a bratty troublemaker. However, unlike most enemies he does not use smart targeting for his debuffs, because he is also an idiot.

//			5%: self-inflict Knocked Down
//			5%: skip turn
//			10%: hide
//			10%: stun all except himself
//			10%: stun
//			10%: gimped Below the Belt
//			10%: damage + Winded
//			40%: use item
//			-5%: skip turn
//			-20%: attack
//			-20%: SPC Boost
//			-20%: DEF Boost
//			-15%: hit all, including allies
//			-5%: hit all, high damage

			if (act <= 5) {
				console.log("Action: do nothing");
				V().action = new Action();
				V().action._useText = null;
				V().action._actText = `Gumball doesn't feel like doing anything this turn.`;
				V().action._act = `$subject.name does nothing!`;
			}
			else if (act <= 10 && act > 5) {
				console.log("Action: trip");
				V().action = new Action();
				V().action._useText = null;
				V().action._actText = `Gumball trips over his own feet!`;
				action()._dur = -1;
				V().action._act = applyEffect("Knocked Down",{self:true});
			}
			else if (!V().enemies[1].dead && !V().enemies[2].dead && !this.untargetable && act <= 20 && act > 10) {
				console.log("Action: sneak");
				V().action = new Action("Sneak");
				V().action._useText = null;
				V().action._actText = `Gumball's eyes flick from side to side. When he thinks no one is watching him, he slinks away from the fight.`;
			}
			else if (act <= 30 && act > 20) {
				console.log("Action: screech");
				V().action = new Action("screech");
				V().action._useText = null;
				V().action._actText = `Gumball lets out an ear-splitting screech! Everyone has to stop what they're doing to clamp their hands over their ears.`;
				V().action._act = `<<for _t = 1; _t < $enemies.length; _t++>>`+
									`<<addEffect $enemies[_t] "Stunned" 1>>`+
								`<</for>>`+
								`<<for _puppet range puppets()>>`+
									`<<addEffect _puppet "Stunned" 1>>`+
								`<</for>>`;
			}
			else if (act <= 40 && act > 30) {
				console.log("Action: stun");
				V().action = new Action("Something in your eye");
				action()._targetMod = ["ignore downed"];
				V().action._useText = null;
				V().action._actText = `Gumball spits in $target.name's eyes!`;
			}
			else if (act <= 50 && act > 40) {

				V().action = new Action("Below the Belt");
				V().action._weight = 0.9;
				V().action._useText - null;
				V().action._actText = `Gumball kicks $target.name in the shins!`;
			}
			else if (act <= 60 && act > 50) {

				V().action = new Action();
				V().action._weight = 0.9;
				V().action._dur = 3;
				V().action._useText = null;
				V().action._actText = `Gumball rushes forward and punches $target.name hard in the gut, leaving them gasping.`;
				V().action._act = dmgandeffect('t',"Winded");
			}
			else {
				console.log("Action: item");
				V().action = new ItemAction("placeholder");
				V().action._useText = `Gumball rummages through his pockets...`;
				act = random(1,20); //rolling a d20, as is custom
				if (act == 1) {
					// critical fail: gumball
					V().action._actText = `...and only finds a gumball. He giggles to himself and sticks it to the arena wall with a mischevious grin. In the process, he seems to have forgotten about attacking you.`;
					V().action._act = null;
				}
				else if (act > 1 && act <= 6) {
					// 5 in 20: rubber band (effectively a weaker Throwing Knife)

					V().action._weight = 1;
					V().action._actText = `...and retrieves a thick rubber band. "Oh, cool!" He looks at you with a predatory glint in his eyes. "Hey," he says with a smirk, stretching the band between his fingers like a slingshot. "Wanna see a trick?"`;
					V().action._act = justdmg();
				}
				else if (act > 6 && act <= 11) {
					// 5 in 20: candy bar
					V().action._effweight = setup.STD_BUFF;
					V().action._dur = 3;
					V().action._actText = `...and retrieves a brightly-wrapped candy bar. "Oh, awesome! I forgot I had this!" He downs the whole thing in a few bites. You dread the sugar high he's going to get...`;
					V().action._act = applyEffect("SPC Boost",{self:true});
				}
				else if (act > 11 && act <= 16) {
					// 5 in 20: protein bar
					V().action._effweight = setup.STD_BUFF;
					V().action._dur = 3;
					V().action._actText = `...and pulls out a protein bar. He glares at it as if its existence offends him, then nonchalantly shrugs and takes a bite. "Food's food," he says.`;
					V().action._act = applyEffect("DEF Boost",{self:true});
				}
				else if (act > 16 && act <= 19) {
					// 3 in 20: angry cat
					V().action._weight = 0.8;
					V().action._actText = `...and pulls out a thin, mangy cat.

He screams and drops it, much to the cat's displeasure. "How did that even fit in there?! No -- wait -- good kitty -- AAAAHHHH!"`;
					V().action._act = `<<for _enemy range enemies()>>`+
										`<<set $target = _enemy>>`+
										`<<echoDamage>>`+
									`<</for>>`+
									`<<for _puppet range puppets()>>`+
										`<<set $target = _puppet>>`+
										`<<echoDamage>>`+
									`<</for>>`;
				}
				else if (act == 20) {
					// critical success: neutrino bomb
					V().action._weight = 1.5;
					V().action._actText = `...and pulls out a neutrino bomb?!

He yelps and throws the beeping thing up into the air, but catches it before it hits the ground. "Why do I even have this?!" he yells, then shakes his head. "Whatever, don't look a gift horse in the mouth! CATCH!"

<i>BOOM.</i>`
					V().action._act = `<<for _puppet range puppets()>>`+
										`<<set $target = _puppet>>`+
										`<<echoDamage>>`+
									`<</for>>`;
				}
			}

			} //end loop

			} //end surrender if
			return;
		}
	},

	"Anais": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 666,
		"stats": {
			"Attack"	: 25,
			"Defense"	: 5,
			"Special"	: 60
		},
		"cooldown": {
			"Flamethrower": 0,
			"Gas Bomb": 0,
			"Chaff": 0,
			"Calamity Bomb": 0
		},
		"specialInit": function(actor) {
			actor.ready = false;
		},
		"surrender": function () {
			V().action = {
				useText: null,
				actText: ``+
`You order $subject.name forward. They grasp Anais' hand, bending down to do so, and she shakes it firmly.

"That's it," Anais says. "I'm glad we could resolve this like civilized -- PSYCHE!!"

Before you can react, Anais pulls out a comically large syringe and stabs it into $subject.name, cackling maniacally. She leaps away as they stagger back.

"Did you REALLY think I'd just let you win after what you did to my brothers?!" she screams. "Wattersons never give up! And now, that poison will give you a heart attack in three... two... one!"

Without fanfare, $subject.name falls to the ground like a puppet with its stings cut. Which, you suppose, is pretty accurate.`,
				act: `<<set $subject.hp to 0>><<deathcheck $subject>><<set $anais_trap = true>>`
			}
			V().B.surrender = false;
		},
		"surrenderFail": function () {
			V().B.surrender = false;
			return `"Eh, it was worth a shot." Anais steps back. "Alrighty then. Let's finish this your way, you barbarian."`;
		},
		"actions": function () {
			if (V().B.surrender) {
				V().action = {useText: null, act: null, actText: `Anais is waiting for your decision.`};
			}
			else {

			while (V().action === null){
				var act = random(1,3);

//			Anais is the squishy wizard and the opposite of Gumball: her behavior is extremely predictable and consistent. She spends one turn making a bomb, then uses it the next turn. Rarely, she will use a regular attack instead; this is intended as a breather due to her low Attack.

//			1/3: attack
//			2/3: make bomb
//			-20%: grenade
//			-20%: flamethrower
//			-20%: gas bomb
//			-20%: calamity bomb
//			-20%: chaff grenade (Dizzy mass attack)

			if (this.ready) {
				act = random(1,5);

				if (act == 1){

					V().action = new ItemAction("Grenade");
					V().action._actText = `Anais lobs a grenade at you!`;
					V().action._act = splashDamage('enemies',2);
				}
				else if (this.CDcheck("Flamethrower") && act == 2){
					V().action = new ItemAction("Flamethrower");
					V().action._actText = `Anais pulls out a flamethrower! You barely have time to wonder how she got it before she starts shooting fire in all directions.`;
					this.cd.set("Flamethrower",4);
				}
				else if (this.CDcheck("Gas Bomb") && act == 3){
					V().action = new ItemAction("Gas Bomb");
					V().action._actText = `Anais pulls a gas mask over her face. You barely have time to wonder where she got it from before she throws something that bursts into a cloud of stinging green gas.`;
					this.cd.set("Gas Bomb",4);
				}
				else if (this.CDcheck("Calamity Bomb") && act == 4){
					V().action = new ItemAction("Calamity Bomb");
					action()._targetMod = ["debuff"];
					V().action._actText = `Anais pulls out a scroll that pulses with dark runes. She throws it at $target.name, where it explodes in a cloud of cursed magic.`;
					this.cd.set("Calamity Bomb",4);
				}
				else if (this.CDcheck("Chaff") && act == 5){
					V().action = new ItemAction("Chaff Grenade");
					V().action._weight = 1;
					V().action._dur = 3;
					V().action._actText = `Anais lobs a grenade at you -- but to your surprise, when it explodes it leaves a massive cloud of shiny metal flakes. It just looks like silly confetti to you, but your puppets stutter and freeze up trying to see through all the flashing lights!`;
					V().action._act = massAttack({content: applyEffect("Dizzy"), cut:true});
					this.cd.set("Chaff",4);
				}
				this.ready = false;
			}
			else if (act <= 2){
				V().action = new Action();
				V().action._useText = null;
				V().action._actText = `Anais turns around and builds something you can't see.`;
				V().action._act = `Something has changed...`;
				this.ready = true;
			}
			else {

				V().action = new Action();
				V().action._weight = 1;
				V().action._useText = null;
				V().action._actText = `Anais slaps $target.name.`;
				V().action._act = justdmg();
			}

			} //end loop

			} //end surrender if
			return;
		}
	},

	"Darwin": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 666,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 30,
			"Special"	: 30
		},
		"cooldown": {
			"Dance": 0,
			"Dizzy": 0,
			"Moralize": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Darwin is a dual-class Rogue/Fighter, with more emphasis on Rogue. He uses a regular attack most of the time, but has access to several debuffs Gumball lacks.

//			30%: regular attack
//			30%: Protector
//			10%: Off Your High Horse
//			10%: piercing attack
//			10%: Dizzy attack
//			10%: mass Injury

			if (act <= 30){

				V().action = new Action();
				V().action._weight = 1;
				V().action._useText = null;
				V().action._actText = `Darwin punches $target.name!`; //This is a purposeful contrast with Gumball's low kick
				V().action._act = justdmg();
			}
			else if (!this.protector && !(V().enemies[0].dead && V().enemies[1].dead) && act <= 60 && act > 30){ //disqualified if Darwin is only one left
				var t = null;
				while (t === null){
					t = random(0,1);
					if (V().enemies[t].dead) {
						t = null;
					}
				}
				V().target = V().enemies[t];
				V().action = new Action("Protector");
				V().action._actText = `Darwin heroically leaps in front of $target.name, protecting $target.them from attacks.`;
			}
			else if (act <= 70 && act > 60){
				$.wiki('<<dispelTarget 1>>');
				if (State.temporary.go){
					V().action = new Action("Off Your High Horse");
					V().action._actText = `Darwin leaps and attacks with a roundhouse kick that knocks off $target.name's magic!`;
				}
			}
			else if (this.CDcheck("Dance") && act <= 80 && act > 70){

				V().action = new Action("Dance Attack");
				V().action._weight = setup.pierce_weight;
				V().action._pierce = true;
				V().action._useText = null;
				V().action._actText = `Darwin leaps and twirls in a spectacular dance, the sun shining dazzlingly off his golden scales. It's so captivating, you don't even think to tell your puppet to defend until he's already kicked them in the face.`;
				V().action._act = justdmg();
				this.cd.set("Dance",2);
			}
			else if (this.CDcheck("Dizzy") && act <= 90 && act > 80){

				V().action = new Action("Dancing Strikes");
				V().action._weight = setup.knife_weight;
				V().action._dur = 3;
				V().action._actText = `Darwin leaps into the fray with graceful, dancing blows, striking, retreating, and leaping over your puppet to strike again. Not every attack connects, but by the end $target.name has had to spin around so much they can't tell which way is up.`;
				V().action._act = `<<multihit 2>><<addEffect $target "Dizzy" $action.dur>>`;
				this.cd.set("Dizzy",2);
			}
			else if (this.CDcheck("Moralize") && act > 90){
				V().action = new Action("Moralize");
				V().action._effweight = 0.4;
				V().action._dur = 3;
				V().action._actText = `Darwin puts on irresistible puppy eyes and makes a seemingly-heartfelt speech about how mean you are for beating him up. You feel uncomfortable, and your puppets hesitate before attacking again.`;
				V().action._act = massAttack({target: "enemies", content: applyEffect("Injury")}),
				this.cd.set("Moralize",3);
			}

			} //end loop
			return;
		}
	},

	// STEVEN UNIVERSE 1

	"Pearl": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 700,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 30,
			"Special"	: 50
		},
		"cooldown": {
			"Fireball": 0,
			"pierce": 0
		},
		"specialInit": function (actor) {
			actor._deathMessage = `${actor.name} poofs!`;
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Pearl uses her abilities from Attack the Light: normal damage, stun, DoT, and bit hit. Since the engine is not as well-suited to multi-hit abilities as Attack the Light, these are adjusted: Holo-Pearl is only a 1-turn stun but also inflicts Off-Balance; her spear throw is changed to a piercing attack; and her regular attack is split into a single hit and double hit skill.

//			10%: attack
//			20%: Holo-Pearl
//			25%: Fireball (CD 1)
//			25%: pierce (CD 1)
//			20%: 2 hits spread

			if (act <= 10) {

				V().action = new Action("Sword");
				V().action._actText = `Pearl advances with graceful steps, and thrusts her spear with perfect precision.`;
			}
			else if (act <= 30 && act > 10) {
				if (!target().alert && !target().chi && !target().stasis){
					V().action = new Action("Holo-Pearl");
					action()._targetMod = ["ignore downed"];
					action()._dur = 1;
					V().action._actText = `Pearl twirls and dips, projecting a holographic copy of herself from the gem on her forehead. It rushes at $target.name, pushing them away from the battle and locking them in combat.`;
					V().action._act = applyEffect(["Stunned","Off-Balance"]);
				}
			}
			else if (this.CDcheck("Fireball") && act <= 55 && act > 30) {

				V().action = new Action("Fireball");
				V().action._weight = 0.8;
				V().action._effweight = 0.7;
				V().action._dur = 3;
				V().action._actText = `Pearl levels her spear like a rifle as white energy swirls around the blade. Pearl fires, and the projectile bursts into searing white flames!`;
				this.cd.set("Fireball",2);
			}
			else if (this.CDcheck("pierce") && act <= 80 && act > 55) {

				V().action = new Action("Comet Strike"); //Last Scenario reference!
				V().action._weight = setup.pierce_weight;
				V().action._pierce = true;
				V().action._actText = `Pearl stands as still as a statue, staring at $target.name with robotic intensity. Then, in the span of an eyeblink, she hurls her spear with so much force the air ignites. It sails through the air with perfect accuracy, and hits $target.name right through a chink in their armor.`;
				V().action._act = justdmg();
				this.cd.set("pierce",2);
			}
			else if (act > 80) {

				V().action = new Action("Shooting Stars");
				V().action._weight = setup.knife_weight;
				V().action._actText = `Pearl summons a second, identical spear from her forehead, then, with the grace of a dancer, leaps high into the air. She spins, and rains down her spears like thunderbolts from Heaven.`;
				V().action._act = `<<multihit 2 "spread">>`;
			}

			} //end loop
			return;
		}
	},

	"Garnet": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 700,
		"stats": {
			"Attack"	: 40,
			"Defense"	: 40,
			"Special"	: 10
		},
		"tolerances": {
			"Stunned"	: 1
		},
		"cooldown": {
			"grenade": 0,
			"combo": 0
		},
		"specialInit": function (actor) {
			actor._deathMessage = `${actor.name} poofs!`;
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Garnet has all of her abilities from Attack the Light, with the 6-hit-combo obviously downgraded.

//			30%: attack
//			20%: attack + Pain (high damage, low effect)
//			25%: grenade (CD 1)
//			25%: 2 hit, higher weight than normal (CD 1)

			if (act <= 30){

				V().action = new Action("Sword");
				V().action._actText = `Garnet rushes forward and slams her gauntlet into $target.name!`;
			}
			else if (act <= 50 && act > 30){
				V().action = new Action("Below the Belt");
				action()._targetMod = ["debuff"];
				V().action._weight = 0.9;
				V().action._dur = 3;
				V().action._useText = null;
				V().action._actText = `Garnet raises her fists above her head, and her gauntlets grow to twice their size. Without missing a beat, she swings forward and crushes $target.name under their weight.`;
			}
			else if (this.CDcheck("grenade") && act <= 75 && act > 50){

				V().action = new Action("Explosive Bolt");
				V().action._weight = 1;
				V().action._useText = null;
				V().action._actText = `Garnet sticks her arm straight out, and her gauntlet detaches from her arm, rocketing towards you like a missile! It slams into $target.name before exploding in a wide burst.`;
				this.cd.set("grenade",3);
			}
			else if (this.CDcheck("combo") && act > 75){

				V().action = new Action("Two-hit Combo");
				V().action._weight = 0.75;
				V().action._useText = null;
				V().action._actText = `Garnet rushes $target.name with a two-hit combo!`;
				V().action._act = `<<multihit 2>>`;
				this.cd.set("combo",2);
			}

			} //end loop
			return;
		}
	},

	"Amethyst": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 700,
		"stats": {
			"Attack"	: 50,
			"Defense"	: 20,
			"Special"	: 20
		},
		"cooldown": {
			"debuff": 0,
			"spin": 0
		},
		"specialInit": function (actor) {
			actor._deathMessage = `${actor.name} poofs!`;
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Amethyst is tricky to adapt, because her "lots of tiny hits" skill can't feasibly be adapted at all. I've replaced it with a poisoning attack. Her other abilities work fine, however.

//			25%: hit all (weak)
//			25%: damage + Injury, on par with Rogue's (CD 1)
//			25%: damage + Poisoned (more direct dmg than Pearl's Fireball but weaker DoT)
//			25%: high damage + Knocked Down (CD 3)

			if (act <= 25){
				V().action = new Action("whip");
				V().action._weight = 0.6;
				V().action._useText = null;
				V().action._actText = `Amethyst lashes her whip in a wide arc, striking all your puppets!`;
				V().action._act = `<<for _puppet range puppets()>><<set $target = _puppet>><<echoDamage>><</for>>`;
			}
			else if (this.CDcheck("debuff") && act <= 50 && act > 25){
				V().action = new Action("A Farewell to Arms");
				action()._targetMod = ["debuff"];
				action()._useText = null;
				action()._actText = `Amethyst shapeshifts into a huge, muscled wrestler. She roars and beats her chest, then slams violently into $target.name!`;
				this.cd.set("debuff",2);
			}
			else if (act <= 75 && act > 50){

				V().action = new Action();
				V().action._weight = 0.9;
				V().action._effweight = 0.6;
				V().action._dur = 3;
				action()._useText = null;
				action()._actText = `Amethyst's gem flashes, and her whip suddenly gains a strange, oily sheen. She spins it around and around and then, with a smirk, snaps it out at $target.name like a hornet's sting.`;
				V().action._act = dmgandeffect('t',"Poisoned");
			}
			else if (this.CDcheck("spin") && act > 75){
				V().action = new Action("spin ball");
				action()._targetMod = ["ignore downed"];
				action()._weight = 1.2;
				action()._useText = null;
				action()._actText = `Amethyst curls up against the ground, and spins her whole body like a wheel. Sparks fly as she builds up speed, then without warning, she rockets straight into $target.name, sending them flying!`;
				V().action._act = dmgandeffect('t',"Knocked Down");
				this.cd.set("spin",4);
			}

			} //end loop
			return;
		}
	},

	"Steven": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 300,
		"stats": {
			"Attack"	: 0,
			"Defense"	: 10,
			"Special"	: 0
		},
		"specialInit": function (actor) {
			actor.addEffect("Guarded",{time: -1, noPopup: true, bypass: true});
			actor._deathMessage = `${actor.name} is knocked unconscious!`;
		},
		"surrender": function () {
			V().action = {
				useText: null,
				act: null,
				actText: `You let Steven scuttle away with the gems in tow.`
			}
			V().B.surrender = false;
			V().enemies[3].dead = true;
		},
		"surrenderFail": function () {
			if (target() !== undefined && target() !== null && target().name == "Steven" && !target().dead){
				var m = random(1,4);
				switch (m){
					case 1:
						return `"Owwww! That hurts!"`;
					case 2:
						return `"Please stop! I don't want to fight!"`;
					case 3:
						return `"Wh-why are you doing this?"`;
					case 4:
						return `Steven starts crying harder.`;
				}
				return;
			}
		},
		"actions": function () {
			var act;
			if (V().B.surrender){
				act = random(1,3)

			if (act == 1) {
				V().action = new Action("Bubble");
				V().action._dur = 3;
				V().action._useText = null;
				V().action._actText = `Steven wails, and his gem flashes a bright pink.`;
				V().action._act = applyEffect("Bubble",{self:true});
			}
			else {
				V().action = {useText: null, act: null, actText: `Steven clutches the gems to his chest and blubbers.`};
			}

			} else {

			while (V().action === null){
				act = random(1,3);

			//Steven is pure support. He provides weak buffs and occasionally bubble shields.

			if (act <= 2) {
				console.log("Encouragement selected");
				V().action = new Action("Encouragement");
				V().action._effweight = (1/3);
				V().action._dur = 3;
				$.wiki('<<allytarget "noself">>');
				switch (target().name){
					case "Pearl":
						V().action._actText = `"Pearl, you got this!" cries Steven. Pearl stands up straighter, and clutches her spear with newfound resolve.`;
						V().action._act = applyEffect("ATK Boost");
						break;
					case "Garnet":
						V().action._actText = `"Garnet, you're amazing!" cries Steven. Garnet's mask of stoicism cracks just long enough for her to curl a smile.`;
						V().action._act = applyEffect("SPC Boost");
						break;
					case "Amethyst":
						V().action._actText = `"Amethyst, keep it up!" cries Steven. Amethyst whoops and flexes her muscles.`;
						V().action._act = applyEffect("DEF Boost");
						break;
					default:
						console.log("No target found");
						V().action = null;
				}
			}
			else if (act == 3) {
				console.log("Bubble selected");
				var hitlist = [];
				enemies().forEach(function(enemy,i){
					console.log(i);
					if (!enemy.dead && enemy.name != "Steven") {
						hitlist.push(enemy);
						console.log(enemy.name+" added to hitlist");
					}
				});
				hitlist.forEach(function(enemy,i){
					console.log(enemy.name);
					if (i == 0){
						V().target = enemy;
						console.log(V().target.name);
					} else if (enemy.name == "Steven") {
						//do nothing
					} else {
						console.log("Current subject HP: "+enemy.hp);
						console.log("Previous subject HP: "+hitlist[i-1].hp);
						if (enemy.hp < hitlist[i-1].hp) { //target gem with lowest health
							V().target = enemy;
							console.log(V().target.name);
						}
					}
				});
				V().action = new Action("Bubble");
				V().action._dur = 3;
				V().action._useText = null;
				V().action._actText = `"A bubble for your trouble?" Steven lifts his shirt, and you see his gem flash with a pink light.`;
				V().action._act = applyEffect("Bubble");
			}

			} //end loop

			} //end surrender if
			return;
		}
	},

	// GUMBALL 2

	"Nicole": {
		"fullname": "Nicole Watterson",
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 3000,
		"stats": {
			"Attack"	: 100,
			"Defense"	: 30,
			"Special"	: 20
		},
		"tolerances": {
			"Injury": 1,
			"Off-Balance": 1
		},
		"mercy": 4,
		"specialInit": function(actor) {
			actor.boss = true;
			actor.specialdeath = "Nicole Defeat";
		},
		"cooldown": {
			"Meditate": 0,
			"stun": 0,
			"pierce": 0,
			"multihit": 2
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);
				var count = 0;

//			Nicole is a "rush boss" -- she can dish it out but she can't take it, so one way or another the battle will be over fast. All of her actions revolve around dealing damage: she has a regular attack, a multi-hit attack, a piercing attack, and a damage + winded + prone attack that will make characters more vulnerable. As a monk type, she also has Fighter's Meditate skill to prevent you from exploiting her low Special *too* much.

//			She uses a separate check for using Meditate. The longer she has to wait for her current effects to expire, the more likely she'll use it. If there are a total of 5 rounds of duration, she will always use it; at 4 rounds, she has an 80% chance of using it; and so on until 20% at 1 round. If Meditate is chosen, the return statement in the if closes the actions function immediately and Meditate is selected as the action. If not, we reroll the act variable to determine her attack.

//			25%: winded + prone + damage at 1 (CD 1)
//			45%: 3 hits at 0.7 (CD 4 because multihit is RIDICULOUSLY powerful with her Attack)
//			15%: pierce at 0.9
//			15%: regular attack

			count = meditateLogic();

			if (this.CDcheck("Meditate") && ((count >= 10) || (act <= (count*10)))) {
				V().action = new Action("Meditate");
				V().action._actText = `This whole time, Nicole has been quivering with intensity, but now she goes as still as a stone. She places her hand in front of her like a prayer, and closes her eyes.

				Her aura flares so brightly you have to shield your eyes. When you look at her again she is staring straight at you, literally glowing with health.`;
				this.cd.set("Meditate",5);
				return;
			}

				act = random(1,100);

			if (this.CDcheck("stun") && act <= 25) {
				V().action = new Action("Sweep the Leg");
				action()._targetMod = ["ignore downed"];
				V().action._weight = 1;
				V().action._actText = `Nicole leaps with a flying kick, slamming her heel into $target.name's knee with crushing force. It strikes the perfect point to twist the joint with a sickening <i>snap</i>, sweeping their legs clean out and throwing them flat on their back with such force it knocks the breath out of them.`;
				V().action._act = function () {
					return `<<echoDamage>>\
						<<print target().addEffect("Knocked Down",{dur: -1})>>\
						<<print target().addEffect("Winded",{dur: 3})>>`
				};
				this.cd.set("stun",2);
			}
			else if (this.CDcheck("multihit") && act <= 70 && act > 25) {
				V().action = new Action("Camilla Petals Dancing");
				action()._targetMod = ["smart"];
				V().action._weight = 0.7;
				V().action._actText = `Nicole leans back slightly, and eyes $target.name with a predatory intensity. In the next instant she springs forward like lighting, descending on them with a graceful yet unstoppable flurry of fists.`;
				V().action._act = `<<multihit 3>>`;
				this.cd.set("multihit",4);
			}
			else if (this.CDcheck("pierce") && act <= 85 && act > 70) {
				V().action = new Action("Steel Dragon Breaker");
				action()._targetMod = ["pierce", "ignore downed"];
				V().action._weight = 0.95;
				V().action._pierce = true;
				V().action._actText = `Nicole bends her knees slightly, and eyes $target.name with a predatory intensity. In the next instant she leaps high into the air, and as she gathers speed you think you see her catch fire like a meteorite. She slams her entire arm down on $target.name with a force to shatter steel.`;
				V().action._act = justdmg();
				// this.cd.set("pierce",1);
			}
			else {

				V().action = new Action("Lotus Strike");
				V().action._weight = 1.15;
				V().action._actText = `Nicole's palm snaps out like a spring.`;
				V().action._act = justdmg();
			}

			} //end loop
			return;
		}
	},

	// STEVEN UNIVERSE 2

	"Rose": {
		"fullname": "Rose Quartz",
		"bestiaryNo": 0,
		"bestiaryName": "Stage 1",
		"alts": ["Rose 2","Rose 3"],
		"gender": 'F',
		"hp": 1000,
		"stats": {
			"Attack"	: 65,
			"Defense"	: 45,
			"Special"	: 40
		},
		"tolerances": {
			"Pain": 1,
			"Curse": 1,
			"Poisoned": 1,
			"Burning": 1,
			"Off-Balance": 1
		},
		"mercy": 4,
		"specialInit": function(actor) {
			actor.boss = true;
			actor.specialdeath = "Rose stage 2";
		},
		"cooldown": {
			"Starlight Flurry": 2,
			"Supernova": 3
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Rose is a multistage boss. This is her first form, offense. Based on Flynn 1 (Last Scenario): has a strong one-hit, a slightly weaker 2-hit spread, and a 4-hit supermove. She additionally has a hit-all that she will always use every 3 turns. Otherwise her behavior is:

//			50%: 2 hit spread, x0.8
//			30%: 4 hit spread, x0.7
//			20% [50% when SF on cooldown]: hit one x1.15

			if (this.CDcheck("Supernova")) {
				V().action = new Action("Supernova");
				V().action._weight = 1;
				V().action._actText = `Rose grasps her sword firmly in both hands. Her gem glows with a soft pink light that suddenly flashes with blinding intensity as she sweeps her sword out in a wide cleave. The arc extends to an impossible length, whipping out a blast of destructive energy that makes the arena shake.`;
				V().action._act = `<<for _puppet range puppets()>><<echoDamage _puppet>><</for>>`;
				this.cd.set("Supernova",4);
				return;
			}

			if (act <= 50) {

				V().action = new Action("Shooting Stars");
				V().action._weight = 0.8;
				V().action._actText = `Rose jumps high into the air, seemingly weightless. She shoots down like a lightning bolt, sword extended, then uses her momentum to sweep around for another strike. She lands perfectly in her original position, as if she hadn't ever moved.`;
				V().action._act = `<<multihit 2 "spread">>`;
			}
			else if (this.CDcheck("Starlight Flurry") && (act <= 80 && act > 50)) {

				V().action = new Action("Starlight Flurry"); //Last Scenario reference!
				V().action._weight = 0.65;
				V().action._actText = `Rose grasps her sword with both hands, and leans forward slightly. With shocking speed for her size she charges forward, striking before gracefully spinning around to another puppet like a dancer. She brings the sword down again and again in a dazzling flurry of slashes, never allowing your puppets a single opening.`;
				V().action._act = `<<multihit 4 "spread">>`;
				this.cd.set("Starlight Flurry",3);
			}
			else {

				V().action = new Action("Meteor Strike");
				action()._weight = 1.1;
				action()._actText = `Rose holds her sword like a lance and charges forward with lightning speed, skewering her target.`;
				action()._act = justdmg();
			}

			} //end loop
			return;
		}
	},

	"Rose 2": {
		"noBestiary": true,
		"bestiaryName": "Stage 2",
		"hp": 2000,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 80
		},
		"special": function (actor) {
			actor._deathMessage = "Rose stage 3";
			actor.cd = new Map([
				["Meditate",0],
				["Revolution",0],
				["injury",0],
				["Downfall",0],
				["knockdown",2],
				["winded",0]
			]);
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);
				var count = 0;

//			Rose's main form: endurance match. Loses her strong multi-hit attacks but gains utility and disabling moves.

//			Meditate
//			Thorns
//			-spontaneously: 5% (with other moves)
//			-if Attack or Defense lowered: 30%
//			-if Attack AND Defense lowered: 50%
//			-if Marked: 90%
//			25%: dispel
//			-50%: Revolution
//			-50%: Downfall
//			20%: poison all (but no damage)
//			10%: Shield Bash: hit one x? + Knocked Down
//			10%: Guerilla Warfare: Winded all
//			10%: A Farewell to Arms: hit all x? + Injury
//			20%: attack + ATK Boost

			count = meditateLogic();

			if (this.CDcheck("Meditate") && ((count >= 10) || (act <= (count*10)))) {
				V().action = new Action("Meditate");
				V().action._actText = `Rose closes her eyes and takes a moment to catch her breath. You think you see her glowing slightly.`;
				this.cd.set("Meditate",5);
				return;
			}

				act = random(1,100);

			if ( !this.thorns && ( ( ((this.get(StatName("def")) < this.getBase(StatName("def"))) || (this.get(StatName("atk")) < this.getBase(StatName("atk")))) && act <= 30) || ((this.get(StatName("def")) < this.getBase(StatName("def"))) && (this.get(StatName("atk")) < this.getBase(StatName("atk"))) && act <= 50) || (this.marked && act <= 90) ) ) {
				V().action = new Action("Thorns");
				action()._useText = null;
				action()._actText = `Rose grins from ear to ear as her gem flashes a bright pink.`;
				action()._act = applyEffect("Thorns",{self:true});
				return;
			}

				act = random(1,100);

			if (act <= 5 && !this.thorns) {
				V().action = new Action("Thorns");
				action()._useText = null;
				action()._actText = `Rose grins from ear to ear as her gem flashes a bright pink.`;
				action()._act = applyEffect("Thorns",{self:true});
			}
			else if (act <= 30 && act > 5) {
				act = random(1,100);
				if (this.CDcheck("Revolution") && act <= 50) {
					$.wiki('<<dispelTarget 3 "mass">>');
					if (State.temporary.go){
						V().action = new Action("Revolution");
						V().action._weight = 1;
						V().action._actText = `Rose grasps her sword firmly and crouches down, she and the sword glowing pink. Suddenly she rushes forward in a dazzling twirl, sweeping the blade across all your puppets in a wide cleave.`;
						V().action._act = `<<for _puppet range puppets()>><<echoDamage _puppet>>`+
						`<<if !_puppet.dead && !_puppet.stasis>>`+
							`<<for _i = _puppet.effects.length-1; _i >= 0; _i-->>`+
								`<<set _effect = _puppet.effects[_i]>>`+
								`<<if _effect.buff && !_effect.sticky>>`+
									`<<print _puppet.removeEffect(_effect)+"\n">>`+
									`<<break>>`+
								`<</if>>`+
							`<</for>>`+
						`<</if>>`+
						`<</for>>`;
						this.cd.set("Revolution",3);
					}
				}
				else if (this.CDcheck("Downfall")) {
					$.wiki('<<dispelTarget 1>>');
					if (State.temporary.go) {
						V().action = new Action("Downfall");
						action()._weight = 1;
						action()._actText = `Rose gets a glint in her eye, then starts whirling her sword around like a pinwheel. She charges forward, then chains her final spin into a massive overhead cleave, bringing it crashing down on $target.name.`;
						this.cd.set("Downfall",2);
					}
				}
			}
			else if (act <= 40 && act > 30) {
				if (!target().chi) {
					V().action = new Action("Shield Bash");
					action()._targetMod = ["ignore downed"];
					V().action._weight = 1.15;
					V().action._actText = `Rose rushes forward, but instead of striking with her sword, she slams her shield into $target.name like a battering ram.`;
					V().action._act = dmgandeffect('t',"Knocked Down",-1);
					this.cd.set("knockdown",2);
				}
			}
			else if (act <= 50 && act > 40) {
				effectCheck();
				if (count < 3) {
					V().action = new Action("Guerilla Warfare");
					V().action._weight = 0.9;
					V().action._dur = 3;
					V().action._actText = `Rose leads your puppets along an infuriating series of feints, dodges, and near-misses. Only the lightest of her attacks actually land -- you swear she's toying with you -- but by the end your puppets have been run ragged. She just grins at you, as hale and hearty as ever.`;
					V().action._act = `<<for _a range puppets()>>`+
					`<<set $target = _a>>`+
					`<<echoDamage>>`+
					`<<addEffect _a "Winded" $action.dur $subject>>`+
					`<</for>>`;
				}
			}
			else if (this.CDcheck("injury") && act <= 60 && act > 50) {
				effectCheck();
				if (count < 3) {
					V().action = new Action("A Farewell to Arms");
					V().action._weight = 1;
					V().action._actText = `Rose hurls her shield like a discus. It flies unerringly to hit every one of your puppets in just the right spot to make them drop their weapons, bouncing off them like they're targets in a pinball machine. When it returns to her, she catches it perfectly.`;
					V().action._act = `<<for _a range puppets()>>`+
					`<<set $target = _a>>`+
					`<<echoDamage>>`+
					`<<addEffect _a "Injury" $action.dur $subject>>`+
					`<</for>>`
					this.cd.set("injury",2);
				}
			}
			else if (act <= 80 && act > 60) {
				effectCheck();
				if (count < 2) {
					V().action = new Action("Poison Powder");
					V().action._effweight = 0.6;
					V().action._dur = 4;
					V().action._actText = `Rose strikes her sword along the ground, exposing a single crack. Rose closes her eyes, focusing, and a dark green vine suddenly sprouts from the earth. It grows towards your puppets like it has a will of its own, and instantly blooms into dark indigo blossoms just beneath each of your puppets' faces. With a light <i>puff</i>, they let out a strange purple powder that your puppets don't seem to like at all.`;
					V().action._act = massAttack({target: "enemies", content: applyEffect("Poisoned")});
				}
			}
			else if (act > 80) {

				V().action = new Action("Crescendo");
				action()._weight = 1.25;
				action()._effweight = (20/50);
				action()._dur = 3;
				action()._actText = `Rose brings her sword down in an overhead strike, but at the last second, swings it around to strike against the ground instead, hitting $target.name on the upswing. The blade vibrates with a strange, alien song, and gleams with sharpness.`;
				action()._act = dmgandeffect('s',"ATK Boost");
			}

			} //end loop
		}
	},

	"Rose 3": {
		"noBestiary": true,
		"bestiaryName": "Stage 3",
		"hp": 300,
		"stats": {
			"Defense"	: 70,
			"Special"	: 50
		},
		"special": function (actor) {
			actor._deathMessage = "Rose poofs!";
			actor.showMaxHP = true;
			actor.specialdeath = false;
		},
		"actions": function () {

//	Final form. After defeat of second form she will stick the party with incurable DoT, giving you a time limit to finish her off in this form. Has a permanent shield that reduces all damage by 60%, and all she does is heal herself very slightly.

			V().action = new Action("Defiance");
			V().action._special = 10;
			V().action._actText = `Rose pants heavily, visibly sweating. She doesn't take her eyes off you.`;
			V().action._act = function () {
				subject().hp += action()._special;
				return `Rose regains $action.special HP.`;
			}
		}
	},

	// GRAVITY FALLS 2

	"Bill": {
		"fullname": "Bill Cipher",
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 3000,
		"stats": {
			"Attack"	: 40,
			"Defense"	: 40,
			"Special"	: 70
		},
		"tolerances": {
			"Headache": 1,
			"Curse": 1,
			"Off-Balance": -1
		},
		"mercy": 0,
		"specialInit": function(actor) {
			actor.boss = true;
		},
		"cooldown": {
			"Wild Magic": 0,
			"Rain of Fire": 0,
			"Stone Gaze": 0
		},
		"actions": function () {
			while (V().action === null){
				console.log("Bill actions");
				var act = random(1,100);
				var count = 0;

//			Bill is a bad day. He slowly grinds you down with damage-over-time and hold effects.

//			Bill's AI is heavy on special clauses.

//			1) If an item was used on him in the previous turn, lock items for 4 rounds.

//			2) Count the total number of effects on the puppets. If >= 2, (20 + (effects-2)*20)% chance of using Wild Magic, which damages everyone once for every effect on them. CD 2 because this could get nasty if he does it continuously.
//			-100% at 6 effects, is that too few?

//			3) Check if anyone has protection effects. If yes, Shatter (damage + protection strip on everyone who has it). This is second priority after Wild Magic, so he will ALWAYS do this if you have such an effect active. No cooldown, effectively preventing you from using these effects at all. Should be impossible to trick him into doing this constantly because Chi Shield and Stasis have such high EN costs that you cannot make him do this every turn.

//			4) Check how many puppets are asleep. (30 * sleepers)% chance of using Nightmare, 1.25 damage on all sleepers. 100% chance if everyone is asleep.

//			Only then does he enter normal behavior:

//			40%: hit all (0.6) + Burning (0.4) (CD 3)
//			30%: single target stun
//			-80%: petrify (can only be active on one person at a time for balance purposes)
//			-sleep + poison
//			-sleep + winded
//			-sleep + curse
//			-sleep two
//			10%: stun all
//			15%: doom (0.5 = 75 dmg/round)
//			5%: regular attack (0.9 + reduce buff durations by 1)

			if (V().B.item_used) {
				console.log("Item lock selected");
				V().action = new Action("Embargo");
				action()._dur = 5;
				V().action._useText = null;
				V().action._actText = `Bill stares lazily at something to your side. You trace his gaze just in time to see your pack grow wings and fly away!`;
				V().action._act = `<<set $B.embargo = $action.dur>>Can't use items for $action.dur turns!`;
				return;
			}

			puppets().forEach(function(puppet){
				count += puppet.effects.length;
			});

				var t = 20 + (count-2)*20;

			if (this.CDcheck("Wild Magic") && count >= 2 && act <= t){
				console.log("Wild Magic selected");
				V().action = new Action("Wild Magic");
				V().action._weight = 0.65;
				V().action._actText = `Bill cackles maniacally as your magic goes haywire! Every effect on your puppets bursts with unstable energy.`;
				V().action._act = `<<for _puppet range puppets()>><<set $target = _puppet>><<for _effect range _puppet.effects>><<echoDamage>><</for>><</for>>`;
				this.cd.set("Wild Magic",2);
				return;
			}

				count = 0;
				act = random(1,100);

				var shatter = false;
				State.temporary.hitlist = [];

			puppets().forEach(function(puppet){
				puppet.effects.forEach(function(effect){
					if (effect.name == "Chi Shield" || effect.name == "Stasis"){
						shatter = true;
						State.temporary.hitlist.push(puppet);
					}
				});
			});

			if (shatter){
				console.log("Shatter selected");
				V().action = new Action("Shatter");
				V().action._weight = 0.65;
				V().action._actText = `Bill raises a gloved hand, and snaps his fingers. The noise splits through your skull like a gunshot, forcing you to clamp your hands over your ears as the air itself seems to shatter like glass. When you look up, your puppets' protections are gone.`;
				V().action._act = `<<for _puppet range _hitlist>>`+
				`<<set $target = _puppet>><<echoDamage>>`+
				`<<for _k, _effect range _puppet.effects>>`+
				`<<if _effect.name == "Chi Shield" || _effect.name == "Stasis">>`+
				`<<print _puppet.removeEffect(_effect,{pierce: true})>>`+
				`<</if>><</for>><</for>>`;
				return;
			}

			puppets().forEach(function(puppet){
				if (puppet.asleep){
					count++;
				}
			});

			if ((count == 3) || (count == 2 && act <= 60) || (count == 1 && act <= 30)){
				console.log("Nightmare selected");
				V().action = new Action("Nightmare");
				V().action._weight = 1.3;
				V().action._actText = `Bill closes his eye and raises his hands to... where his temples would be, you think. He glows with a dark, menacing aura, and all your sleeping puppets start writhing in pain, savaged by psychic phantoms.`;
				V().action._act = `<<for _puppet range puppets()>>`+
				`<<if _puppet.asleep>><<echoDamage _puppet>><</if>>`+
				`<</for>>`;
				return;
			}

			count = 0;
			puppets().forEach(function(puppet){
				if (puppet.asleep || puppet.petrified){
					count++;
				}
			});

				act = random(1,100);
				var go;

			if (!V().B.fireRainUsed || (this.CDcheck("Rain of Fire") && act <= 40)){
				console.log("Rain of Fire selected");
				V().action = new Action("Rain of Fire");
				V().action._weight = 0.55;
				V().action._effweight = 0.5;
				V().action._dur = 3;
				V().action._actText = `Bill raises his arms skyward and cackles. Flaming rocks fall from the sky like infernal hail, spreading like wildfire where they hit.`;
				V().action._act = `<<for _puppet range puppets()>><<echoDamage _puppet>><<addEffect _puppet "Burning" $action.dur $subject>><</for>>`;
				this.cd.set("Rain of Fire",2);
				V().B.fireRainUsed = true;
			}
			else if (act <= 70 && act > 40){
				console.log("Single-target stun selected");
				act = random(1,100);
				if (act <= 50) {
					console.log("Stone Gaze rolled");
					go = true;
					puppets().forEach(function(puppet){
						if (puppet.petrified) {
							go = false;
						}
					});
					if (go){
						console.log("Stone Gaze selected");
						V().action = new Action("Stone Gaze");
						action()._targetMod = ["ignore downed"];
						action()._dur = -1;
						V().action._actText = `Bill turns the full force of his huge, all-consuming eye on $target.name. The schlera around the slitted pupil glows a sickly, ugly yellow, the color of rotting pus. You see Bill's gaze become a physical force, a cone of light that swallows $target.name in its entirety, and before your eyes, you see their flesh turn to stone.`;
						V().action._act = applyEffect("Petrified");
						this.cd.set("Stone Gaze",3);
					}
				}
				else if (count < 3) {
					V().target = Hitlist.targetEnemy(["ignore downed"]);
					let g = 0;
					while (g < 11 && (target().petrified || target().asleep)){
						// This should HOPEFULLY never activate under conditions where the loop cannot be broken (everyone is already asleep or petrified) but we include a guardian just in case
						V().target = Hitlist.targetEnemy(["ignore downed"]);
						g++;
					}
					act = random(1,3);
					if (act == 1) {
						V().action = new Action("Bad Dreams");
						action()._targetMethod = null;
						V().action._dur = 4;
						V().action._effweight = 0.5;
						V().action._actText = `Bill snaps his fingers, and ${target().name} is out like a light.`;
						V().action._act = applyEffect(["Asleep","Poisoned"]);
					}
					else if (act == 2) {
						V().action = new Action("Sleeping Beauty");
						action()._targetMethod = null;
						V().action._dur = 4;
						V().action._effweight = (20/50);
						V().action._actText = `Bill snaps his fingers. A strange cloudiness passes over ${target().name}'s eyes before they slowly and deliberately lie down to sleep.`;
						V().action._act = applyEffect(["Curse","Asleep"]);
					}
					else if (act == 3) {
						count = 0;
						puppets().forEach(function(puppet) {
							if (puppet.dead){
								count++;
							}
						});
						if (count < 2) { //Bill won't use this if 2 or fewer puppets remain, because it would be too unfair to incapacitate your whole team at once
							V().action = new Action("Lights Out");
							action()._targetMod = ["ignore downed", "ignore untargetable", "ignore protection"];
							V().action._dur = 4;
							action()._actText = `Bill sneers, "I think it's past your bedtime, kids!" Then with a snap of his fingers...`;
							action()._act = `<<addEffect $target "Asleep" $action.dur>>\
							<<set _hitlist = []>>\
							<<for _puppet range puppets()>>\
								<<if !_puppet.asleep>>\
									<<run _hitlist.push(_puppet)>>\
									<<if _puppet.firefly>>\
										<<run _hitlist.push(_puppet)>>\
									<</if>>\
								<</if>>\
							<</for>>\
							<<if _hitlist.length > 0>>\
								<<set _t = random(0,_hitlist.length-1)>>\
								<<set $target = _hitlist[_t]>>\
								<<addEffect $target "Asleep" $action.dur>>\
							<</if>>`;
							//Bill should not hit the same puppet twice with this attack; this WILL ALWAYS put two puppets to sleep.
						}
					}
				}
			}
			else if (act <= 85 && act > 70){
				console.log("Memento Mori rolled");
				V().target = Hitlist.targetEnemy(["ignore downed"]);
				go = true;
				console.log("Target already doomed? "+target().doom);
				if (target().doom){ //Doom doesn't stack, so no point in reapplying it if target already has it
					go = false;
				}
				if (go){
					console.log("Memento Mori selected");
					V().action = new Action("Memento Mori");
					action()._targetMethod = null;
					V().action._dur = 3;
					V().action._actText = `Bill's eye glows blood-red as he points his finger straight at $target.name.

					<b><i>"Die."</i></b>`;
					V().action._act = `<<set $action.effweight = (1/3)>>\
					<<addEffect $target "Doom" -1 $subject>>\
					<<set $action.effweight = 0.5>>\
					<<addEffect $target "Poisoned" $action.dur $subject>>\
					<<addEffect $target "Burning" $action.dur $subject>>`;
				}
			}
			else if (act <= 95 && act > 85){
				count = 0;
				puppets().forEach(function(puppet){
					if (puppet.alert) {
						count++;
					}
				});
				if (count < 3) {
					V().action = new Action("Scream");
					action()._useText = null;
					action()._actText = `Bill's whole body suddenly glows a dark, violent red. His "face" -- though it's really more like his whole body -- splits open to reveal a gut-churning array of teeth and tongues that seem to extend far deeper than his body should allow.

					Then he <i>screams</i>.

					You are dead certain that there is not a single creature on Earth, no, in the <i>universe</i> that could make a scream like that. You clamp your hands over your ears, but it does nothing. This isn't just a sound you hear in your bones, it is a sound you hear in your <i>soul</i>.`
					action()._act = massAttack({target: "enemies", content: applyEffect("Stunned")});
				}
			}
			else {
				console.log("Attack selected");

				V().action = new Action();
				V().action._weight = 0.9;
				V().action._useText = null;
				V().action._actText = `Bill charges forward with a clenched fist, but stops inches away from $target.name. Then, almost playfully, he snaps out a finger to flick them in the face.`;
				action()._act = function () {
					return `<<echoDamage>>\
					<<set _container = []>>\
					<<for _effect range $subject.effects>>\
						<<if !_effect.buff>>\
							<<run _container.push(_effect)>>\
						<</if>>\
					<</for>>\
					<<if _container.length > 0>>\
					Bill transfers all his ailments onto ${target().name}!\
					<<for _effect range _container>>\
						<<run subject().removeEffect(_effect)>>\
						<<if _effect.name == "Perdition">>\
							<<set _effect.sticky = false>>\
						<</if>>\
						<<run target().addEffect(_effect)>>\
					<</for>>\
					<</if>>`;
				}
			}

			} //end loop
			return;
		}
	},

	// ADVENTURE TIME 2

	"Marceline": {
		"fullname": "Marceline the Vampire Queen",
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 500,
		"stats": {
			"Attack"	: 50,
			"Defense"	: 50,
			"Special"	: 50
		},
		"tolerances": {
			"Poisoned": -1,
			"Off-Balance": -1,
			"Stunned": -1,
			"Curse": 1
		},
		"specialInit": function(actor) {
			actor.boss = true;
			actor.immortal = true;
			actor.specialdeath = "Marceline Fakeout";
			actor.maskhp = true;
			actor.HPregenPercent = 0.05;
		},
		"cooldown": {
			"prone": 0,
			"eat": 4
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Puzzle boss. Can't be killed, but reducing her HP to 0 stuns her for X turns. Solution is Undertale-esque, like in her intro episode you have to entertain her enough that she decides you're friends.

//			Possibly different method for each puppet.
//			-Fighter: aggro abilities draw her attention and make her start a dramatic pose-off, she keeps transforming into bigger monsters to scare you off and you have to do a set of abilities in sequence to get through the pantomime to her satisfaction
//			-Rogue: get her drunk with red wine
//			-Mage: break the windows and kill her with sunlight

//			abilities
//			-default: fakeout swipe with her claws, does nothing
//			-20%: picks someone up and throws them, inflicts prone
//			-35%: shrieks in someone's face, stuns
//			-15%: drains someone, minor piercing damage + absorbs their buffs
//			--maybe this absorbs ailments too, and you can trick her into drinking bad ones to stun her?
//			-eats a strawberry

			console.log("Before switch. Fighter_Route = "+V().B.Fighter_Route);

				switch (V().B.Fighter_Route) {
					case 1:
						V().action = new Action("grab");
						action()._useText = null;
						action()._actText = `<<set _p = $puppets.find(function (p) { return p && p.name === "Mage"})>>\
						"Hey, hero!" Marceline calls mockingly. "Whatcha gonna do about <i>this?</i>"

						With lightning speed, her hand snaps out and plucks Mage effortlessly off the ground. <<if _p.dead>>She doesn't seem to notice that Mage is already defeated, even as they flop ragdoll-like in her grip.<</if>> "Poor little wizard. All that power, and none of it can save you now!" She flicks out her forked tongue and stares straight at Fighter as she says, "If you don't do anything, I'm gonna suck out all their bloooood. Whatcha gonna do, hero?"`;
						action()._act = `<<addEffect _p "Grappled" -1>>\
						<<set $B.Fighter_Route++>>`;
						return;
					case 2:
						V().action = new Action("drink");
						action()._weight = 1;
						action()._pierce = true;
						action()._useText = null;
						action()._actText = `<<set _p = $puppets.find(function (p) { return p && p.name === "Mage"})>>\
						<<set $target = _p>>\
						Marceline sinks her teeth into <<print _p.name>>'s neck, sucking out their blood! She sighs with satisfaction, then tosses them to the ground like garbage.

						"Aw, too slow! Guess you're not much of a hero after all."`;
						action()._act = function () {
							return `<<echoDamage>>\
							<<print _p.removeEffect("Grappled")>>\
							<<set $B.Fighter_Route = 0>>`;
						}
						return;
					case 3:
						V().action = new Action("grab");
						action()._useText = null;
						action()._actText = `<<set _p = $puppets.find(function (p) { return p && p.name === "Rogue"})>>\
						Marceline vanishes.

						You hear her chuckle, the sound echoing all throughout the huge space, impossible to place. "You think you can hide from me? You merely adopted the darkness. I was born into it, <i>molded</i> by it. The shadows were never on <i>your</i> side. <i>I see you.</i>"

						In a flash, she appears behind Rogue, and grabs them tightly with both hands. <<if _p.dead>>Is that who she was talking about? The effect is rather diminished when they're already defeated, giving no resistance as she holds them up. She doesn't seem to care, though.<</if>> "You wanna save this one, too? Gimme your worst. I think I'll bite them just a little... maybe turn them into one of my thralls. Heheheheh!"`;
						action()._act = `<<addEffect _p "Grappled" -1>>\
						<<set $B.Fighter_Route++>>`;
						return;
					case 4:
						V().action = new Action("drink");
						action()._weight = 1;
						action()._pierce = true;
						action()._useText = null;
						action()._actText = `<<set _p = $puppets.find(function (p) { return p && p.name === "Rogue"})>>\
						<<set $target = _p>>\
						Marceline sinks her teeth into <<print _p.name>>'s neck, sucking out their blood! She sighs with satisfaction, then tosses them to the ground like garbage.

						"Aw, too slow! Guess you're not much of a hero after all."`;
						action()._act = function () {
							return `<<echoDamage>>\
							<<print _p.removeEffect("Grappled")>>\
							<<set $B.Fighter_Route = 0>>`;
						}
						return;
					case 5:
						V().action = new Action("advance");
						action()._useText = null;
						action()._actText = `<<set $B.Fighter_Route++>>\
						<<set $target = $puppets.find(function (p) { return p && p.name === "Rogue"})>>\
						Marceline touches down and begins advancing with heavy, thundering steps, her body stretching longer and taller as she raises her claws above her head. "That's it! It's <i>my</i> turn to give you everything I've got! Your puny shield can't stand against my claws! You blood is mine! <i>Bluh!</i>" But though her tone sounds angry, she's grinning wider than ever.`;
						action()._act = null;
						return;
					case 6:
						V().action = new Action("claw");
						action()._weight = 0.5;
						action()._useText = null;
						action()._actText = `<<set $B.Fighter_Route = 0>>\
						Marceline leaps with impossible agility and rakes her claws across Fighter, batting them across the arena like a cat playing with a mouse. "Hahahaha!" she laughs. "Told you, pipsqueak!"`;
						action()._act = dmgandeffect('t',"Knocked Down",-1);
						return;
					case 7:
						V().action = new Action("invisible");
						action()._useText = null;
						action()._actText = `<<set $B.Fighter_Route++>>\
						Marceline floats back. "Alright. No more fooling around. There's no way you can dodge <i>this.</i>" With a strange sound, like a finger traced against the rim of a glass, she vanishes, just like before.

						"Can you see me?" she taunts, her voice echoing around and around in the wide space of the church. "Don't worry. <i>I see you.</i>"`;
						action()._dur = -1;
						action()._act = applyEffect("Invisible",{self:true});
						return;
					case 8:
						V().action = new Action("invisible attack");
						action()._weight = 1;
						action()._pierce = true;
						action()._useText = null;
						action()._actText = `<<set $B.Fighter_Route = 0>>\
						<<set $target = $puppets.find(function (p) { return p && p.name === "Fighter"})>>\
						All of a sudden, Fighter is lifted into the air by an unseen force. Their arms are pinned to their sides as their helmet is lifted off their head, exposing the flesh of their neck. There is a familiar laugh, and then two bright red puncture wounds appear in their neck. After a noisy slurping sound, they shudder, and fall limply to the ground.

						Marceline reappears in her normal position across the stage, and licks her lips with satisfaction. "Aw, don't feel too bad. It's not your fault you can't see through invisibility. It just means you're a boring dumb fakey hero who's boring and dumb."`;
						action()._act = `<<echoDamage>>\
						<<run $subject.removeEffect("Invisible")>>`;
						return;
					default:
						console.log("Fighter Route switch triggered, default case.");
				}

				console.log("Marceline actions: after Fighter route switch, before regular actions. Fighter Route = "+V().B.Fighter_Route);

				if (this.CDcheck("eat")) {
					V().action = new Action("eat");
					action()._useText = null;
					action()._actText = `Marceline reaches out a massive claw and... grabs an apple? You can't see where she got it from, but it's a beautiful specimen, the skin a deep, lustrous red. Marceline sinks her fangs into it, and the red drains away, as if she's drinking it. She lets out a satisfied sigh, and tosses the now-colorless apple aside.`;
					action()._act = null;
					this.cd.set("eat",4);
				}
				else if (this.CDcheck("prone") && act <= 20) {
					V().action = new Action("throw");
					action()._targetMod = ["ignore downed"];
					action()._dur = -1;
					action()._useText = null;
					action()._actText = function () {
						return `Marceline lifts ${target().name} by the head and flings them across the stage!`;
					};
					action()._act = applyEffect("Knocked Down");
					this.cd.set("prone",2);
				}
				else if (act > 20 && act <= 60) {
					V().action = new Action("scream");
					action()._targetMod = ["ignore downed"];
					action()._useText = null;
					action()._actText = function () {
						return `Marceline gets all up in ${target().name}'s face and lets out a shrill, bat-like shriek!`;
					};
					action()._act = applyEffect("Stunned");
				}
				else {

					V().action = new Action("fakeout");
					action()._useText = null;
					action()._actText = function () {
						return `Marceline swings at $target.name with her sharp claws, but misses by a hair! She just keeps laughing, seemingly unbothered.`;
					}
					action()._act = `<<set $dmg = 0>><<echoDamage "nocalc">>`; // This can still knock over someone off-balance
				}

			} //end loop
			return;
		}
	},

	"Chair": {
		"gender": 'x',
		"hp": 500,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 20,
			"Special"	: 10
		},
		"tolerances": {
			"Poisoned": -1,
			"Stunned": -1
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

			//Offense. Damage (weight 1) or off-balance.

				if (act <= 30) {
					V().action = new Action("offbalance");
					action()._targetMod = ["ignore downed"];
					action()._useText = null;
					action()._actText = function () {
						return `A chair suddenly appears behind ${target().name}. It moves by itself to ram sharply into their legs, forcing them to stumble. Just as they lean back to steady themselves, the chair disappears again.`;
					};
					action()._act = applyEffect("Off-Balance");
				}
				else {

					V().action = new Action("attack");
					action()._weight = 1;
					action()._useText = null;
					action()._actText = `A chair suddenly flies out of the pews to smack into ${target().name}.`;
					action()._act = justdmg();
				}

			} //end loop
			return;
		}
	},

	"Table": {
		"gender": 'x',
		"hp": 500,
		"stats": {
			"Attack"	: 20,
			"Defense"	: 20,
			"Special"	: 20
		},
		"tolerances": {
			"Poisoned": -1,
			"Stunned": -1
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

			//"Rogue", ailments and weak multi-hits.

				if (act <= 35) {
					V().action = new Action("poison");
					action()._targetMod = ["ignore downed"];
					action()._dur = 3;
					action()._useText = null;
					action()._actText = `Marceline's kitchen table starts pelting you with rotten food. Gross!`;
					action()._act = applyEffect("Poisoned");
				}
				else if (act > 35 && act <= 70) {
					V().action = new Action("burn");
					action()._targetMod = ["ignore downed"];
					action()._dur = 3;
					action()._useText = null;
					action()._actText = `The candles on Marceline's kitchen table suddenly flare to life before flying at ${target().name}, covering them in burning wax.`;
					action()._act = applyEffect("Burning");
				}
				else {

					V().action = new Action("attack");
					action()._weight = 0.5;
					action()._useText = null;
					action()._actText = `Marceline's table starts flinging dishes and cutlery at you!`;
					action()._act = `<<multihit 3 "spread">>`;
				}

			} //end loop
			return;
		}
	},

	"Armor": {
		"gender": 'x',
		"hp": 500,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 40,
			"Special"	: 10
		},
		"tolerances": {
			"Poisoned": -1,
			"Stunned": -1
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Weak attack, protect other, and stun (encases one person in armor for several turns, they can't act but take reduced damage)

				if (!this.protector && !(V().enemies[0].dead && V().enemies[1].dead) && act <= 30){
					var t = null;
					while (t === null){
						t = random(0,1); // does not protect Marceline
						if (V().enemies[t].dead) {
							t = null;
						}
					}
					V().target = V().enemies[t];
					V().action = new Action("Protector");
					action()._targetMethod = null;
					V().action._actText = `A suit of armor near the wall breaks into its component parts, then rearranges into a protective casing around another piece of furniture.`;
				}
				else if (act > 30 && act <= 40) {
					V().action = new Action("stun");
					action()._targetMod = ["ignore downed"];
					action()._dur = 3;
					action()._useText = null;
					action()._actText = `A suit of armor springs to life and starts flying towards $target.name. Just before it hits, it breaks apart, reforming again around them. $target.name struggles against the armor, but it holds them fast.`;
					action()._act = `<<print target().addEffect("Encased")>><<print subject().addEffect("Encased")>>`;
				}
				else {

					V().action = new Action("attack");
					action()._weight = 1;
					action()._useText = null;
					action()._actText = `A suit of armor springs to life and slaps ${target().name} across the face!`;
					action()._act = justdmg();
				}

			} //end loop
			return;
		}
	},

	// CHAMPIONSHIP

	"PB Champ": {
		"bestiaryNo": 0,
		"gender": 'F',
		"hp": 1000,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 30,
			"Special"	: 50
		},
		"specialInit": function(actor) {
			actor._idname = "PB Champ";
			actor.name = "Bonnibel";
			actor.ready = true;
			actor.inventory = new Map([
					["Bottled Chi",3],
					["Adrenaline",3],
					["Stoneskin",3],
					["Nootropic",3],
					["Powdered Glass",2],
					["Grenade",2],
					["Calamity Bomb",2],
					["Gas Bomb",1],
					["Flamethrower",1],
					["Chaff Grenade",1],
					["Panacea",3]
				]);
			actor.attackItemLogic = function () {
				while (V().action === null) { // hasItem check should prevent infinite loop but BE CAREFUL
					var act = random(1,100);
					var noPowderedGlass = false;
					var noCalamityBomb = false;
					var count = 0;

					if (act <= 40) { // use single-target item
						console.log("Bonnibel single-target attack item branch");
						effectCheck(["alert","dead"]);
						console.log("Chi check performed, count = "+count);
						if (count == puppets().length) {
							noPowderedGlass = true; // if all puppets are alert or dead, there are no viable targets for Powdered Glass
						}
						effectCheck(["dead"]);
						if (count == puppets().length) {
							noCalamityBomb = true; // if all puppets are protected or dead, there are no viable targets for Calamity Bomb
						}
						if (noPowderedGlass && noCalamityBomb) {
							act = 2;
						} else if (noPowderedGlass) {
							act = random(2,3);
						} else if (noCalamityBomb) {
							act = random(1,2);
						} else {
							act = random(1,3);
						}
						if (this.inventory.get("Powdered Glass") > 0 && act == 1) {
							if (!target().alert && !target().chi && !target().stasis) {
								V().action = new ItemAction("Powdered Glass");
								action()._targetMod = ["smart"];
								action()._actText = `Bonnibel pours what appears to be bright pink sugar onto her palm. She blows it into ${target().name}'s face, and they recoil and claw at their face as if they were shards of glass.`;
							}
						}
						else if (this.inventory.get("Grenade") > 0 && act == 2) {
							V().action = new ItemAction("Grenade");
							action()._targetMod = ["smart"];
						}
						else if (this.inventory.get("Calamity Bomb") > 0 && act == 3) {
							V().action = new ItemAction("Calamity Bomb");
							action()._targetMod = ["smart", "debuff"];
						}
					}
					else { // use multi-target item
						act = random(1,3);
						if (this.inventory.get("Gas Bomb") > 0 && act == 1) {
							V().action = new ItemAction("Gas Bomb");
						}
						else if (this.inventory.get("Flamethrower") > 0 && act == 2) {
							V().action = new ItemAction("Flamethrower");
							action()._actText = `Bonnibel assembles a flamethrower from components on her tool belt, and douses your puppets in flame.`;
						}
						else if (this.inventory.get("Chaff Grenade") > 0 && act == 3) {
							V().action = new ItemAction("Chaff Grenade");
							V().action._weight = 1;
							V().action._dur = 3;
							V().action._actText = `Bonnibel lobs a grenade at you -- but to your surprise, when it explodes it leaves a massive cloud of shiny metal flakes. It just looks like silly confetti to you, but your puppets stutter and freeze up trying to see through all the flashing lights!`;
							V().action._act = massAttack({content: applyEffect("Dizzy"), cut: true});
						}
					}
				}
			}
		},
		"cooldown": {
			"stasis": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);
				console.log("Bonnibel act = "+act);
				var hasItem;
				var stasisCount = 0;
				var deadCount = 0;
				enemies().forEach(function(enemy) {
					if (enemy.stasis) {stasisCount++;}
					if (enemy.dead) {deadCount++;}
				});

//			Rogue. Can use items freely, but has limited stock. Has 1 of each attack item + chaff grenade, puts rest of her points into drugs and Bottled Chi.

//			if SPC buffed, 75% chance to use attack item
//			normal:
//			50%: support
//			-first, check if anyone has >= 2 buffs and <= 1 ailment. If yes, they are added to a hitlist. If hitlist contains viable targets, 50% chance to use Stasis (target selection totally random). Otherwise...
//			-target is random, but (1-hp/maxHP) chance to reroll if they are below half health (don't waste items on doomed people)
//			-25%: bottled chi
//			-50%: buff drug for focus stat (Gumball gets 25% for all)
//			-12.5%: buff drug for other stat
//			20%: attack item
//			20%: off-balance one
//			10%/default: gun or reload

			this.inventory.forEach(function(stock,item) {
				switch (item) {
					case "Powdered Glass":
					case "Grenade":
					case "Calamity Bomb":
					case "Flamethrower":
					case "Gas Bomb":
					case "Chaff Grenade":
						if (stock > 0) {
							hasItem = true;
							break;
						}
				}
			});

			if (this.get(StatName("spc")) > this.getBase(StatName("spc")) && act <= 85 && hasItem === true) {
				this.attackItemLogic();
				this.inventory.inc(action().name,-1);
				return;
			}

				act = random(1,100);
				console.log("Special attack item check failed, new act = "+act);

			if (stasisCount < (V().enemies.length - deadCount) && act <= 50) {
				if (this.CDcheck("stasis")) {
					var buffCount;
					var ailmentCount;
					var hitlist = [];
					enemies().forEach(function(enemy) {
						buffCount = 0;
						ailmentCount = 0;
						if (!enemy.stasis && !enemy.stunned){
							enemy.effects.forEach(function(effect) {
								if (effect.buff) {buffCount++;}
								if (!effect.buff) {ailmentCount++;}
							});
							if (buffCount >= 2 && ailmentCount <= 1) {
								hitlist.push(enemy);
							}
						}
					});
					if (hitlist.length > 0) {
						act = random(0,hitlist.length-1);
						V().target = hitlist[act];
						V().action = new Action("Thaumastasis");
						action().actText = `Bonnibel pulls a strange device out of her pocket, and points it at ${target().name}. There is an indescribable noise, and then the flow of magic around ${target().name} has frozen like amber.`;
						this.cd.set("stasis",5);
						return;
					}
				}
				hasItem = false;
				this.inventory.forEach(function(stock,item) {
					switch (item) {
						case "Bottled Chi":
						case "Adrenaline":
						case "Stoneskin":
						case "Nootropic":
							if (stock > 0) {
								hasItem = true;
								break;
							}
					}
				});
				if (hasItem) {
					var keepGoing = true;
					var chance;
					while (keepGoing) {
						$.wiki('<<allytarget "buff">>');
						if (deadCount == 3) { // There is no point in rerolling if the user is the only viable target
							keepGoing = false;
						}
						else if (target().name != "Bonnibel" && target().hp < (target().maxHP / 2)){ // Don't waste items on people who are about to die (but Bonnibel is a little selfish and excludes herself from this check)
							chance = random(1,100);
							if (chance < ((target().hp / target().maxHP) * 100)) {
								keepGoing = false;
							}
						}
						else {
							keepGoing = false;
						}
					}
					while (V().action === null) { // The hasItem check SHOULD prevent an infinite loop from occurring here, but be careful
						act = random(1,8);
						if (act <= 2 && this.inventory.get("Bottled Chi") > 0) {
							V().action = new ItemAction("Bottled Chi");
						}
						else if (target().name == "Gumball") {
							act = random(1,3);
							switch (act) {
								case 1:
									if (this.inventory.get("Adrenaline") > 0) {V().action = new ItemAction("Adrenaline")}
									break;
								case 2:
									if (this.inventory.get("Stoneskin") > 0) {V().action = new ItemAction("Stoneskin")}
									break;
								case 3:
									if (this.inventory.get("Nootropic") > 0) {V().action = new ItemAction("Nootropic")}
									break;
							}
						}
						else {
							switch (target().name) {
								case "Bonnibel":
									if (this.inventory.get("Nootropic") > 0 && act <= 6 && act > 2) {
										V().action = new ItemAction("Nootropic");
									}
									else if (this.inventory.get("Stoneskin") > 0 && act == 7) {
										V().action = new ItemAction("Stoneskin");
									}
									else if (this.inventory.get("Adrenaline") > 0 && act == 8) {
										V().action = new ItemAction("Adrenaline");
									}
									break;
								case "Dipper":
									if (this.inventory.get("Adrenaline") > 0 && act <= 6 && act > 2) {
										V().action = new ItemAction("Adrenaline");
									}
									else if (this.inventory.get("Stoneskin") > 0 && act == 7) {
										V().action = new ItemAction("Stoneskin");
									}
									else if (this.inventory.get("Nootropic") > 0 && act == 8) {
										V().action = new ItemAction("Nootropic");
									}
									if (V().B.dipper_drug_event != "done" && V().action !== null) {V().B.dipper_drug_event = "active";}
									break;
								case "Stevonnie":
									if (this.inventory.get("Stoneskin") > 0 && act <= 6 && act > 2) {
										V().action = new ItemAction("Stoneskin");
									}
									else if (this.inventory.get("Nootropic") > 0 && act == 7) {
										V().action = new ItemAction("Nootropic");
									}
									else if (this.inventory.get("Adrenaline") > 0 && act == 8) {
										V().action = new ItemAction("Adrenaline");
									}
									break;
							}
						}
					}
					this.inventory.inc(action().name,-1);
				}
			}
			else if (act <= 80 && act > 50) {
				this.attackItemLogic();
				this.inventory.inc(action().name,-1);
			}
			else if (deadCount < 3 && act <= 90 && act > 80) { // no point in using this if she is only one left
				V().action = new Action("sonar");
				action()._targetMod = ["ignore downed"];
				action()._useText = null;
				action()._actText = function () {
					return `Bonnibel pulls out a strange device and points it at ${target().name}. You hear a strange, high-pitched noise just on the edge of your hearing. It's easy enough for you to ignore, but ${target().name} can't seem to stand it -- they twitch and spasm, jerking backward and swaying.`;
				}
				action()._act = applyEffect("Off-Balance");
			}
			else {
				if (this.ready){
					V().action = new Action("shotgun");
					action()._targetMod = ["pierce"];
					action().weight = 1;
					action().pierce = true;
					action().useText = null;
					action().actText = `Bonnibel blasts ${target().name} with her shotgun.`;
					action().act = justdmg();
					this.ready = false;
				}
				else {
					V().action = new Action("load");
					action().useText = null;
					action().actText = `Bonnibel loads a cartridge into her shotgun.`;
					action().act = null;
					this.ready = true;
				}
			}

			} //end loop
			return;
		}
	},

	"Dipper Champ": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 1000,
		"stats": {
			"Attack"	: 50,
			"Defense"	: 10,
			"Special"	: 30
		},
		"specialInit": function(actor) {
			actor._idname = "Dipper Champ";
			actor.name = "Dipper";
			actor.ready = false;
		},
		"cooldown": {
			"Secret": 0,
			"dispel": 0,
			"Deduction": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Mage. Can spend a turn charging up to empower abilities.

//			30%: Chaos Thunder: hit one, x1 normally, x2 if charged
//			40%: Flawless Deduction (Logomancer reference!): Forsaken, exact mimic of Mage's spell (can only be used if charged)
//			20%: Appalling Secret (Fallen London reference!): dmg + Poison, analogous to Mage's Fireball, charge increases poison damage
//			Anti-Weirdness Field: dispel one buff, charge dispels all buffs (but still only one target)

			var hitlist = [];
			enemies().forEach(function(enemy) {
				if (!enemy.stasis) {
					enemy.effects.forEach(function(effect) {
						if (!effect.buff && !effect.sticky) {
							hitlist.push(enemy);
						}
					});
				}
			});

			// Everyone is added to the hitlist once for every ailment they possess. This means that characters with more ailments will have a higher chance of getting selected.

			var uniqueAilments = 0;
			hitlist.forEach(function(enemy,i) {
				if (i != 0) {
					if (enemy !== hitlist[i-1]) {
						uniqueAilments++;
					}
				}
			});

			// If two hitlist entries don't match each other, they're different enemies. This allows us to track how many total characters have ailments. (This is important for the mass version, because Dipper shouldn't waste his charge on a mass cure if only one person has ailments.)

			if ( ((this.ready && uniqueAilments >= 3) || !this.ready) && act <= hitlist.length * 20 ) {
				if (this.ready) {
					V().action = new Action("First Aid");
					action().actText = `Dipper takes out a pack of bandages and medicine and sprints across the field, administering to everyone's wounds with expert care.`;
					action().act = `<<for _enemy range enemies()>><<print _enemy.removeEffect(_enemy.effects[_enemy.effects.length-1])>><</for>>`;
					this.ready = false;
					return;
				}
				else {
					var t = random(0,hitlist.length-1);
					V().target = hitlist[t];
					V().action = new Action("First Aid");
					action().actText = `Dipper takes out a pack of bandages and medicine and gives ${target().name} a quick treatment for their ailments.`;
					action().act = `<<print target().removeEffect(target().effects[target().effects.length-1])>>`;
					return;
				}
			}

				act = random(1,100);

			if (this.CDcheck("Deduction") && this.ready && act <= 40) {
				V().action = new Action("Forsaken");
				action()._targetMod = ["ignore downed"];
				action().effweight = 1.25;
				action().useText = `Dipper uses "Flawless Deduction".`;
				action().actText = `Dipper paws through his journal, his eyes flicking up to ${target().name} and then back to the page repeatedly. After several seconds of this, he snaps the journal shut and jabs a finger at them triumphantly. "Strike there! That's their weak point!"`
				this.ready = false;
				this.cd.set("Deduction",5);
			}
			else if (act > 40 && act <= 50) {
				if (target() !== null) {
					V().action = new Action("Appalling Secret");
					action()._targetMod = ["debuff"];
					action().weight = 1;
					action().dur = 3;
					if (this.ready) {
						action().effweight = 0.9;
					} else {
						action().effweight = 0.6;
					}
					action().actText = `Dipper reads something from his journal that makes you want to throw up.`;
					action().act = dmgandeffect('t',"Poisoned",action().dur);
					this.ready = false;
					console.log("Appalling Secret selected, duration = "+V().action.dur+" ?= "+action().dur);
				}
			}
			else if (act > 50 && act <= 60) {
				var threshold = 1;
				if (this.ready) {threshold = 2;}
				$.wiki('<<dispelTarget '+threshold+'>>');
				if (State.temporary.go){
					V().action = new Action("Anti-Weirdness Field");
					action().weight = 1;
					V().action.actText = `Dipper pulls something from his pocket and taps at it. A burst of strange energy washes over ${target().name}, stripping them of their magic.`;
					if (this.ready) {
						action().act = `<<echoDamage>><<for _effect range $target.effects>>\
						<<if _effect.buff && !_effect.sticky>>\
							<<print target().removeEffect(_effect)>>\
							<<break>>\
						<</if>>\
					<</for>>`;
						this.ready = false;
					} else {
						V().action.act = `<<echoDamage>>`+
					`<<for _effect range $target.effects>>\
						<<if _effect.buff && !_effect.sticky>>\
							<<print target().removeEffect(_effect)>>\
						<</if>>\
					<</for>>`;
					}
					this.cd.set("dispel",2);
					return;
				}
			}
			else if (act > 60 && act <= 90) {

				V().action = new Action("Chaos Thunder");
				if (this.ready){
					action().weight = 2;
				} else {
					action().weight = 1;
				}
				if (!V().B.chaos_thunder_event){
					action().useText = null;
				}
				action().actText = `Dipper extends his arm like a wizard casting a grand spell, and shouts, "CHAOS THUNDER!" Lightning splits the air, leaving a wave of multicolored stars around the hapless puppet it fries.`
				action().act = justdmg(`<<set $subject.ready = false>><<if $B.gumball_spell_event != "done">><<set $B.gumball_spell_event = "active">><</if>>`);
			}
			else if (!this.ready) {
				V().action = new Action("prepare");
				action().useText = null;
				action().actText = `Dipper pauses to look up something in his journal. He suddenly smirks with satisfaction, and writes down a note.`;
				action().act = `Dipper's next attack will be stronger.<<set $subject.ready = true>>`;
			}

			} //end loop
			return;
		}
	},

	"Gumball Champ": {
		"bestiaryNo": 0,
		"gender": 'M',
		"hp": 1000,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 30,
			"Special"	: 30
		},
		"specialInit": function(actor) {
			actor._idname = "Gumball Champ";
			actor.name = "Gumball";
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

			//Similar to original but no longer skips turns

			if (V().B.gumball_spell_event == "active") {
				V().action = new Action("");
				action().useText = null;
				action().actText = `Gumball's face splits in a manic grin. He throws his hands out towards you and screams, "ULTIMA!!!"

				Nothing happens.

				Gumball starts waving his hands in increasingly frantic movements. "Flare! Firaga! Magic Missile! C'mon, give me SOMETHING here!"<<if !$enemies[3].dead>>

				Stevonnie giggles, but not cruelly. "Hey, don't feel bad. Maybe you're just more of a fighter type?"<<if !$enemies[1].dead>>

				Dipper barks a laugh, much less kindly. "Nah, you wish. You're totally like, the joke character."<</if>><</if>><<if !$enemies[0].dead>>

				Bonnibel huffs. "Don't be ridiculous. Magic isn't real. And anyway, you're getting the verbal and somatic components all wrong. You can't just wave your hands and get whatever you want."<</if>>

				Gumball throws his hands up in defeat and just glowers.<<set $B.gumball_spell_event = "done">>`
				action().act = null;
				return;
			}

			if (!V().enemies[1].dead && !V().enemies[2].dead && !this.untargetable && act <= 10) {
				console.log("Action: sneak");
				V().action = new Action("Sneak");
				V().action.useText = null;
				V().action.actText = `Gumball's eyes flick from side to side. When he thinks no one is watching him, he slinks away from the fight.`;
			}
			else if (act <= 25 && act > 10) {
				console.log("Action: stun");
				V().action = new Action("Something in your eye");
				action()._targetMod = ["ignore downed"];
				V().action.useText = null;
				V().action.actText = `Gumball spits in $target.name's eyes!`;
			}
			else if (act <= 45 && act > 25) {

				V().action = new Action("Below the Belt");
				V().action.weight = 0.9;
				V().action.useText - null;
				V().action.actText = `Gumball kicks $target.name in the shins!`;
			}
			else if (act <= 65 && act > 45) {

				V().action = new Action();
				V().action.weight = 0.9;
				V().action.dur = 3;
				V().action.useText = null;
				V().action.actText = `Gumball rushes forward and punches $target.name hard in the gut, leaving them gasping.`;
				V().action.act = dmgandeffect('t',"Winded");
			}
			else {
				console.log("Action: item");
				V().action = new ItemAction("placeholder");
				V().action.useText = `Gumball rummages through his pockets...`;
				act = random(1,20); //rolling a d20, as is custom
				if (act == 1) {
					// critical fail: gumball
					V().action.actText = `...and only finds a gumball. He giggles to himself and sticks it to the arena wall with a mischevious grin. In the process, he seems to have forgotten about attacking you.`;
					V().action.act = null;
				}
				else if (act > 1 && act <= 6) {
					// 5 in 20: rubber band (effectively a weaker Throwing Knife)

					V().action.weight = 1;
					V().action.actText = `...and retrieves a thick rubber band. "Oh, cool!" He looks at you with a predatory glint in his eyes. "Hey," he says with a smirk, stretching the band between his fingers like a slingshot. "Wanna see a trick?"`;
					V().action.act = justdmg();
				}
				else if (act > 6 && act <= 11) {
					// 5 in 20: candy bar
					V().action.effweight = V().STD_BUFF;
					V().action.dur = 3;
					V().action.actText = `...and retrieves a brightly-wrapped candy bar. "Oh, awesome! I forgot I had this!" He downs the whole thing in a few bites. You dread the sugar high he's going to get...`;
					V().action.act = applyEffect("SPC Boost",{self:true});
				}
				else if (act > 11 && act <= 16) {
					// 5 in 20: protein bar
					V().action.effweight = V().STD_BUFF;
					V().action.dur = 3;
					V().action.actText = `...and pulls out a protein bar. He glares at it as if its existence offends him, then nonchalantly shrugs and takes a bite. "Food's food," he says.`;
					V().action.act = applyEffect("DEF Boost",{self:true});
				}
				else if (act > 16 && act <= 19) {
					// 3 in 20: angry cat
					V().action.weight = 0.8;
					V().action.actText = `...and pulls out a thin, mangy cat.

He screams and drops it, much to the cat's displeasure. "How did that even fit in there?! No -- wait -- good kitty -- AAAAHHHH!"`;
					V().action.act = `<<for _enemy range enemies()>>`+
										`<<set $target = _enemy>>`+
										`<<echoDamage>>`+
									`<</for>>`+
									`<<for _puppet range puppets()>>`+
										`<<set $target = _puppet>>`+
										`<<echoDamage>>`+
									`<</for>>`;
				}
				else if (act == 20) {
					// critical success: neutrino bomb
					V().action.weight = 1.5;
					V().action.actText = `...and pulls out a neutrino bomb?!

He yelps and throws the beeping thing up into the air, but catches it before it hits the ground. "Why do I even have this?!" he yells, then shakes his head. "Whatever, don't look a gift horse in the mouth! CATCH!"

<i>BOOM.</i>`
					V().action.act = `<<for _puppet range puppets()>>`+
										`<<set $target = _puppet>>`+
										`<<echoDamage>>`+
									`<</for>>`;
				}
			}

			} //end loop
			return;
		}
	},

	"Stevonnie": {
		"bestiaryNo": 0,
		"gender": 'N',
		"hp": 1000,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 50,
			"Special"	: 10
		},
		"cooldown": {
			"Meditate": 2,
			"supermove": 0
		},
		"actions": function () {
			while (V().action === null){
				var act = random(1,100);

//			Fighter, with the twist that they can use Thorns for a counterattack.

//			Meditate
//			50%: Protector (only if not already protecting)
//			5%: Thorns (30% if protecting, 90% if marked)
//			15%: Farewell to Arms
//			15%: stun
//			15%/default: Sword

			var count = meditateLogic();

			if (!this.stasis && this.CDcheck("Meditate") && ((count >= 10) || (act <= (count*10)))) {
				V().action = new Action("Meditate");
				V().action.actText = `Stevonnie closes their eyes and starts to breathe in a calm, steady rhythm. You think you see them glowing slightly.`;
				this.cd.set("Meditate",5);
				return;
			}

				act = random(1,100);

			if ( !this.stasis && !this.thorns && ( (this.protector && act <= 30) || (this.marked && act <= 90) ) ) {
				V().action = new Action("Thorns");
				action().useText = null;
				action().actText = `Stevonnie concentrates for a second, and their gem flashes a bright pink.`;
				action().act = applyEffect("Thorns",{self:true});
				return;
			}

				act = random(1,100);

			if ( !this.stasis && !this.thorns && act <= 5 ) {
				V().action = new Action("Thorns");
				action().useText = null;
				action().actText = `Stevonnie concentrates for a second, and their gem flashes a bright pink.`;
				action().act = applyEffect("Thorns",{self:true});
				return;
			}
			else if (!this.protector && act > 5 && act <= 55) {
				console.log("Stevonnie chose Protector");
				var hitlist = [];
				var total_chance = 0;
				var chance;
				enemies().forEach(function(enemy,i){
					console.log(i);
					if (!enemy.dead && enemy.name != "Stevonnie") {
						hitlist.push({target: enemy, chance: 0});
						console.log(enemy.name+" added to hitlist");
					}
				});
				if (hitlist.length > 0) {
					// Incentivize protecting more injured characters: everyone's base % chance is equal to the proportion of HP they've lost
					// However, additional weights for Dipper and below half HP means this doesn't neatly equate to a % chance
					// Final selection is random but weighted, everyone has a (personal weight / total weight) chance of selection
					// To avoid bias towards later characters, everyone is given a unique range by adding the previous character's weight to their own
					// e.g. if Bonnibel and Dipper are at full HP but Gumball is at 50% HP, Bonnibel = 0; Dipper = 10; Gumball = 90 (50 normal + 40 for below half HP). The total value is 100, so the random selection variable will be from 0 to 100. Gumball's value will be changed to 90 + 10 = 100 and will only be selected if the random variable is less than or equal to his weight AND greater than Dipper's weight; this gives him a 90% chance of being selected and Dipper a 10% chance.
					hitlist.forEach(function(enemy,i){
						console.log(enemy.target.name);
						if (enemy.target.name == "Stevonnie") {
							// do nothing
						}
						else {
							enemy.chance = (1 - (enemy.target.hp / enemy.target.maxHP)) * 100;
							if (enemy.target.name == "Dipper") {
								enemy.chance += 10; // Dipper gets a bonus to be protected because of his low DEF
							}
							if (enemy.target.hp < (enemy.target.maxHP / 2)) {
								enemy.chance += 40; // higher chance if they are below half HP
							}
							console.log(enemy.target.name+" protector chance = "+enemy.chance);
						}
						total_chance += enemy.chance;
					});
					chance = random(0,total_chance);
					hitlist.forEach(function(enemy,i){
						if (i != 0) {
							enemy.chance += hitlist[i-1].chance;
							if (chance <= enemy.chance && chance > hitlist[i-1].chance) {
								V().target = enemy.target;
							}
						}
						else if (chance <= enemy.chance) {
							V().target = enemy.target;
						}
					});
					if (V().target !== null) {
						V().action = new Action("Protector");
						V().action.actText = `Stevonnie leaps fearlessly to ${target().name}'s side, raising their shield to protect ${target().them} from all harm.`;
					}
					if (V().B.bonnibel_protection_event != "done" && target().name == "Bonnibel"){
						V().B.bonnibel_protection_event = "active";
					}
				}
			}
			else if (act > 55 && act <= 70) {
				console.log("Stun branch")
				if (!target().alert && !target().chi && !target().stasis){ // Anything that's part Connie is smart enough to check these
					console.log("Target valid");
					V().action = new Action("Pommel Strike");
					action()._targetMod = ["ignore downed"];
					action().actText = function () {
						return `Stevonnie rushes forward, but at the last moment, reverses their grip on their sword to ram the pommel into ${target().name}'s face, forcing them to reel back in a daze.`;
					};
					action().act = applyEffect("Stunned");
				}
			}
			else if (act <= 85 && act > 70) {
				if (target() !== null) {
					V().action = new Action("A Farewell to Arms");
					action()._targetMod = ["debuff"];
					action().weight = 0.9;
					action().actText = function () {
						return `Stevonnie throws their shield out like a discus, expertly hitting ${target().name} straight in the arm joints.`;
					};
				}
			}
			else {
				if (V().enemies[0].dead && V().enemies[1].dead && V().enemies[2].dead && this.CDcheck("supermove")) {

					V().action = new Action("Meteor Strike");
					action().weight = 1.5;
					action().actText = `Stevonnie grips their sword with both hands, then charges forward with blinding speed to strike ${target().name} with a devastating thrust.`;
					action().act = justdmg();
					this.cd.set("supermove",3);
				}

				V().action = new Action("Sword");
			}

			} // end loop
			return;
		}
	},

};

(function () {
	//	quick hack to populate bestiary numbers if you don't want to do it yourself
	//	not foolproof, can create duplicate numbers, don't use if you're assigning your own numbers
	var num = 1;
	for (let [pn,v] of Object.entries(setup.enemyData)) {
		if (!v.noBestiary && (v.bestiaryNo === 0)) {
			v.bestiaryNo = num;
			num++;
		}
	}
})();
/* twine-user-script #15: "effect-manager.js" */
Effect.prototype.calculatePower = function (effectTarget,effectSubject) {
  if (!(effectTarget instanceof Actor)) {
    effectTarget = target();
  }
  if (!(effectSubject instanceof Actor)) {
    effectSubject = subject();
  }
  console.assert(effectTarget instanceof Actor,`ERROR in calculatePower: invalid effectTarget`);
  console.assert(effectSubject instanceof Actor,`ERROR in calculatePower: invalid effectSubject`);

  let power;
  let check = this.buff ? setup.min_buff : setup.min_debuff;

  if (effectSubject.stats[StatName("spc")] !== undefined) {
    if (this.statmod) {
      let def = this.buff ? 0 : effectTarget.get(StatName("spc"));
      power = Math.round(
        (setup.effbase + setup.effdamper * (effectSubject.get(StatName("spc")) - def)) * action().effweight);
    } else if (this.dot) {
      return effectSubject.get(StatName("spc"));
    }
  }
  else {
    power = (this.effectData.power || 0);
  }

  return Math.max(power,check);
}

Actor.prototype.testEffect = function (name,mods = {}) {
  //  Tests if an effect will be applied (for previews).
  //  Returns string or Boolean.
  //  If the effect will go through, return true; else, return a string describing the exact point of failure.

  console.assert(typeof(name) == "string",`ERROR in testEffect: no effect passed`);
  var E = new Effect(name);
  let entry;
  if (V().bestiary instanceof Bestiary && V().bestiary.fetch(this.name) instanceof BestiaryEntry) {
    entry = V().bestiary.fetch(this.name);
  }

  //  block check
  this.effects.filter(function (e) { return e && e.block })
    .sort(function(a,b) { return a.priority - b.priority; })
    .forEach(function (effect) {
      if (effect.blockCondition(E)) {
        console.log("block found");
        return "block";
      }
    },this);

  //  tolerance check
  let n = (E.synonym || E.name);
  if (this.tolerances.get(n).current != 0 && !mods.pierceImmunity) {

    console.log("tolerance found");
    //  If this character has a bestiary entry, we must check if the tolerance is known
    if (entry && entry.tolerancesKnown[n] !== true) {
      //  If it isn't, we return true -- no spoilers!
      console.log("tolerance not known");
      return true;
    }

    if (this.getTol(n) === -1) {
      //  If tolerance value is -1, target is immune.
      return "immune";
    }
    else if (this.getTol(n) > 0 && !mods.pierceTol) {
      console.log("tolerance");
      return "tolerance";
    }
  }
  return true;
}

Actor.prototype.addEffect = function (name,mods) {
  console.assert(typeof(name) == "string" || name instanceof Effect,`ERROR in addEffect: no effect passed`);
  mods = (mods || {});
  if (!action()) { V().action = new Action("") }
  var dur = (mods.dur || action().dur || 1);
  var E;

  if (name instanceof Effect) { E = name; mods.bypass = true }

  if (mods.bypass === true) {
    if (typeof(name) == "string") { E = new Effect(name,dur,mods.power,mods) }
  }
  else if (temporary().hit === false) {
    //  Missed/blocked attacks do not apply effects
    return "";
  }
  else {

    if (temporary().effectApplied === undefined) {
      temporary().effectApplied = {}
    }
    if (V().target === null) V().target = this;
    temporary().effectApplied[name] = this.testEffect(name,mods);
    this.effectApplied = temporary().effectApplied;

    //  Create dummy Effect to access database properties
    E = new Effect(name);
    if (E.statmod && subject() instanceof Puppet && target() instanceof Enemy) {
      V().B.debuff_used = true;
    }
    if (!this.dead || E.persistAfterDeath) {

      let found = false;
      let power;
      let subj;
      subj = mods.actor instanceof Actor ? mods.actor : subject();

      if (!(E.unblockable || mods.unblockable === true)) {

        if (!E.buff) {
          $.wiki('<<shieldCheck>>');
          if (temporary().hit === false) {
            //  shieldCheck sets _hit to false if blocked; in this case, we should terminate this function immediately, because the effect was blocked.
            return "";
          }
        }

        //  Block effect logic. Filter character effects to only block effects, sort them by priority, then check the block condition for each. If block condition passes, return blockText and terminate immediately.

        this.effects.filter(function (e) { return e && e.block })
          .sort(function(a,b) { return a.priority - b.priority; })
          .forEach(function (effect) {
            if (effect.blockCondition(E)) {
              this.addPopup({shake: false, type: "block", content: "BLOCKED"});
              return effect.blockText(this)+"\r\n";
            }
          },this);

      }

      let n = (E.synonym || E.name);
      if (this.tolerances.get(n).current != 0 && !mods.pierceImmunity) {
        //  Tolerance logic. If the tolerance stat is not 0, we need to check the tolerance.
        //  Note that this checks the maximum tolerance, not the variable point value.

        //  If this character has a bestiary entry, mark this tolerance known
        if (V().bestiary instanceof Bestiary && V().bestiary.fetch(this.name) instanceof BestiaryEntry) {
          V().bestiary.fetch(this.name).tolerancesKnown[n] = true;
        }

        //  If pierceTol enabled, set tolerance value to 0
        if (mods.pierceTol === true && this.tolerances.get(n).current > 0) {
          this.tolerances.get(n).currentVal = 0;
        }

        if (this.getTol(n) === -1) {
          //  If tolerance value is -1, target is immune. Print a message to this effect and terminate function.
          this.addPopup({shake: false, type: "block", content: "IMMUNE"});
          return `${this.name} is immune to ${name}.`+"\r\n";
        }
        else if (this.getTol(n) > 0) {
          //  If tolerance is above 0, decrement tolerance and print a message to that effect, then terminate function.
          this.decTol(n,action().toleranceDamage);
          this.addPopup({shake: true, type: "block", content: "RESISTED"});
          return `${this.name}'s tolerance to ${name} was weakened.`+"\r\n";
        }
        else if (this.getTol(n) === 0) {
          //  If tolerance is 0, continue to application section but reset tolerance.
          this.resetTol(n);
        }
      }

      //  Power calculation. If valid power property passed as argument, that overrides standard power calculation.
      power = typeof(mods.power) == "number" ? power = mods.power : E.calculatePower(this,subj);

      if (E.unique) {
        //  Only one instance of a unique effect can be present in a given party. Remove any instances of this effect from other characters in this character's party.

        this.ownParty.filter(function (a) { return a && a.name !== this.name },this).forEach(function (actor) {
          actor.removeEffect(E.name,{pierce: true, unsticky: true, removeStack: true, noPopup: true});
        });
      }

      if (E.exclusive) {
        //  No two exclusive effects can be present on a character at once. Filter for existing exclusive effects on the character, then remove them all.
        this.effects.filter(function (e) { return e && e.exclusive}).forEach(function (effect) {
          this.removeEffect(effect,{pierce: true, unsticky: true, removeStack: true, noPopup: true});
        },this);
      }

      if (!E.stackable) {
        //  If effect is not stackable, we need to check if it already exists in the character's effects.
        found = this.effects.find(function (e) { return e && e.name === name});
        if (found instanceof Effect) {
          //  If the effect was found, we need to update it.
          //  Extend the existing effect's duration by the duration of this application.
          found.duration += dur;
          if (found.dot) {
            //  If existing effect is DoT, calculate if applied effect's damage is stronger; if yes, overwrite both power and weight.
            E = new Effect(name,dur,power,{weight: action().effweight});
            if (E.damage(this) > found.damage(this)) {
              found.power = power;
              found.weight = action().effweight;
            }
          } else if (power > found.power) {
            //  For non-DoT effects, overwrite power if application's is stronger. We will have to remove and re-apply the effect to ensure correct updating.
            found.onRemove(this); found.power = power; found.onApply(this);
          }
          if (!mods.noPopup) {
            let shake = (E.buff || mods.noShake) ? false : true;
            this.addPopup({shake: shake, type: "addEffect", content: E.name});
          }
          //  Flag msg as true in case this is applied at RoundEnd, and return the addText for this effect.
          temporary().msg = true;
          return E.addText(this)+"\r\n";
        }
      }

      if (name === "Off-Balance" && this.down) {
        return `${this.name} would have been pushed off-balance, but ${this.theyre} already knocked down!`+"\r\n";
      }

      if (name === "Knocked Down") {
        //  Getting knocked down removes off-balance
        this.removeEffect("Off-Balance",{pierce: true, noPopup: true});
      }

      if (E.dot) mods.weight = action().effweight;
      if (E.guard === true) {
        mods.target = target();
        target().protectedBy = this.id;
      }

      //  Create our finalized effect with the correct variables
      E = new Effect(name,dur,power,mods);
    } else {
      return "";
    }
  }

  this.effects.push(E);
  E.onApply(this);
  //  If this actor had a delayed action in progress and the effect made them
  //  unable to act AND the delayed action is not persistent, reset it
  if (!this.actionReady) {
      this.delayedAction = null;
  }
  if (!mods.noPopup) {
    //  Add popup for effect. By default, ailments shake, buffs do not.
    let shake = (E.buff || mods.noShake) ? false : true;
    this.addPopup({shake: shake, type: "addEffect", content: E.name});
  }

  var text = E.addText(this);

  if (typeof(text) == "string" && text.length > 0) {
    text += '\r\n';
  }

  return text;
};

Actor.prototype.testRemoval = function (effect,mods = {}) {
  //  Tests if an effect will be removed (for previews).
  //  Returns string or Boolean.
  //  If the removal will happen, return true; else, return a string describing the exact point of failure.

  console.assert(typeof(effect) === "string",`ERROR in testEffect: effect must be string`);
  if (this.stasis && !mods.pierce === true) {
    return "block";
  } else if (effect === "all") {
    if (this.effects.length === 0) return "none";
  } else if (effect === "ailments") {
    if (this.effects.filter(function(e) { return e && !e.buff }).length === 0) return "none";
  } else if (effect === "buffs") {
    if (this.effects.filter(function(e) { return e && e.buff }).length === 0) return "none";
  } else {
    var E = this.effects.find(function(e) { return e && e.name === effect; });
    if (E === undefined) return "absent";
    if ((E.sticky && !mods.unsticky) || (E.ULTIMATESTICKY && mods.unsticky !== "ultimate")) return "sticky";
  }
  return true;

}

Actor.prototype.removeEffect = function (effect,mods = {}) {
  //	effect = Effect or string. If Effect, will remove that particular Effect object from actor's effects array. If string, will search for an Effect with that name and remove it if found.
  //	mods = object, contains optional properties:
  //		pierce = Boolean. Set true to remove effects through stasis.
  //		unsticky = Boolean. Set true to remove sticky effects, "ultimate" to remove ULTIMATESTICKY
  //		removeStack = Boolean. Set true to remove all instances of a stackable effect (only matters if string used for effect ID)

  console.assert(typeof(effect) === "string" || effect instanceof Effect,`ERROR in removeEffect: effect must be string or Effect`);
  var result = "";
  if (!this.stasis || mods.pierce === true){
    var E;
    if (typeof(effect) == 'string') {
      E = this.effects.find(function(e) { return e && e.name === effect; });
      if (E === undefined) {
        return;
      }
    }
    else {
      E = effect;
    }
    if (!V().inbattle || ((!E.ULTIMATESTICKY || mods.unsticky == "ultimate") && (!E.sticky || mods.unsticky))) {
      E.onRemove(this);
      if (!mods.noPopup) {
        if (temporary().queue instanceof Set) {
          temporary().queue.add(this);
        }
        var shake = E.buff ? true : false;
        this.battleMsg.push({shake: shake, type: "removeEffect", content: "- "+E.name});
      }
      this.effects.delete(E);
      result += E.removeText(this) + '\n';
      if (E.stackable && typeof(effect) == 'string' && mods.removeStack === true) {
        while (E !== undefined) {
          E = this.effects.find(function(e) { return e && e.name === effect; });
          if (E !== undefined) {
            E.onRemove(this);
            this.effects.delete(E);
            result += E.removeText(this) + '\n';
          }
        }
      }
      return result;
    }
    else {
      return `${E.name} status can't be removed!<br/>`;
    }
  } else {
    return `${this.name}'s Stasis held the effect in place!<br/>`;
  }
};
/* twine-user-script #16: "logic-functions.js" */
function meditateLogic (mods) {
	// Logic for determining the effectiveness of cure-all actions such as Meditate.
	// Returns the threat sum of all ailments on the subject.

	mods = (mods || []);
	mods.pushUnique("threat");
	return subject().effectCount("ailment",mods)
}

function effectCheck (type) {
	//	Mass form of effectCount. Returns the number of puppets currently possessing the named effect.
	//	Assumes sticky effects should be counted.
	//	type = String, name of effect to be checked

	let count = 0;
	puppets().forEach(function(puppet){
		if (puppet.effectCount(type) > 0) {
			count++;
		}
	});
	return count;
}

function dispelCheck (mods) {
	//	Logic for determining the effectiveness of buff dispel abilities.
	//	Returns the threat sum of all puppet buffs.
	//	This simulates the targeting for an actual attack, so if a martyr exists, only it will be considered;
	//	and untargetable puppets will be ignored by default.

	mods = (mods || []);
	mods.pushUnique("threat");
	var party = subject().otherParty.filter(function (a) { return a && !a.dead });
	var martyr = party.find(function (p) { return p && p.martyr === true });
	if (!(mods.includes("mass") || mods.includes("ignore martyr")) && martyr instanceof Actor) {
		// mass attacks do not worry about martyrs
		return martyr.effectCount("buff",mods);
	} else {
		var count = 0;
		for (let p of party) {
			if (mods.includes("ignore untargetable") || !p.untargetable) {
				count += p.effectCount("buff",mods);
			}
		}
		return count;
	}
}

function cureCheck (mods) {
	//	Logic for determining the effectiveness of ailment cure abilities.
	//	Returns the threat sum of all enemy ailments.

	mods = (mods || []);
	mods.push("threat");
	var party = subject().ownParty.filter(function (a) { return a && !a.dead });
	var count = 0;
	for (let p of party) {
		count += p.effectCount("ailment",mods);
	}
}
/* twine-user-script #17: "targeting.js" */
window.Hitlist = class Hitlist extends Array {
	constructor(party,mods) {
		//	Creates a Hitlist of all actors in the party array, initializing their chance values to 1.
		//	If no party is passed, Hitlist will be empty; populate it later with addTarget.

		mods = (mods || []);
		console.assert(mods instanceof Array,`ERROR in Hitlist constructor: mods must be array`);

		super(0);
		if (party instanceof Array) {
			this.addTarget(party,mods);
		}
	}

	addTarget (target,mods) {
		//	Adds targets to the array and initalizes their chance value.
		//	Can pass party or single actors. If you pass a party, it will only be added if the hitlist is currently empty.

		console.assert(target instanceof Array || target instanceof Actor,`ERROR in addTarget: target argument must be array or Actor`);
		mods = (mods || []);

		if (target instanceof Actor) {
			var initChance = 1;
			if (mods.includes("ally")) {
				if (
						!(mods.includes("noself") && target == subject()) &&
						!(mods.includes("effect") && target.stasis)
						) {
					this.push({target: target, chance: initChance});
				}
			} else {
				if (setup.THREAT_TARGETING === true && subject() instanceof Enemy) {
					// If threat targeting used, chance is initialized to subject's threat towards target.
					initChance = subject().threat.get(target.name);
				}
				if (
						!target.dead &&
						!(mods.includes("noself") && target == subject()) &&
						(target.martyr || mods.includes("ignore untargetable") || !target.untargetable)
						) {
					// Do not add actors that are dead or untargetable.
					// Martyr supercedes untargetable; martyrs will be targeted even if they are untargetable.
					// Exception for untargetability if "ignore untargetable" is passed.
					this.push({target: target, chance: initChance});
				}
			}
		} else if (target instanceof Array) {
			for (let t of target) {
				this.addTarget(t,mods);
			}
		}
	}

	returnTarget (mods,bypass) {
		//	Returns a target randomly, weighted by chance value.
		//	mods must be an array.
		//	Automatically adjusts chances based on Firefly, Wallflower, and untargetable.
		//	Set bypass to true to ignore these factors (e.g. if you populated the hitlist with unique logic)

		mods = (mods || []);
		console.assert(mods instanceof Array,`ERROR in returnTarget: mods must be array`);

		for (let t of this) {
			// Martyrs are instantly selected as target, provided they aren't dead
			if (t.target.martyr && !t.target.dead && !(mods.includes("ignore martyr") || mods.includes("ally"))) {
				return t.target;
			}
			// Dead and untargetable characters cannot be targeted, set chance to 0
			if (t.target.dead || (t.target.untargetable && !(mods.includes("ignore untargetable") || mods.includes("ally")))) {
				t.chance = 0;
			} else if (bypass !== true) {
				// fireflies have their chances multiplied (default by 2)
				if (t.target.firefly) {
					t.chance *= setup.FIREFLY_FACTOR;
				}
				// wallflowers have their chances multiplied (default by 0.5)
				if (t.target.wallflower) {
					t.chance *= setup.WALLFLOWER_FACTOR;
				}
			}
		}

		// remove targets with 0 chance
		i = 0;
		while (i < this.length) {
			if (this[i].chance > 0) i++;
			else this.splice(i, 1);
		}

		// If this empties the array (length of 0), there are no viable targets; flag targetfail and return null
		if (this.length == 0) {
			temporary().targetfail = true;
			return null;
		}

		// If truly random targeting is desired, we will ignore chance values and just pick a target with the random function
		if (mods.includes("random")) {
			let target = this.map(function (t) { return t.target }).random();
			return Hitlist.protectionCheck(Hitlist.guardCheck(target),mods);
		}

		// vectorize chance values
//		console.log("before vectorization,"); console.log(this);
		var chance = this.map(function (t) { return t.chance });
		const total = chance.reduce((a, c) => a + c, 0);
		this.forEach((el, i) => el.chance = el.chance/total, this);
//		console.log("after vectorization,"); console.log(this);

		// return target randomly, weighted by chance value
		var i, sum=0, r=Math.random();
		for (i of this) {
			sum += i["chance"];
			if (r <= sum) return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods);
		}
		temporary().targetfail = true;
		console.log(`ERROR in returnTarget: failed to find target. Likely cause is empty hitlist; check targeting logic.`);
		console.log(`Echoing hitlist for verification.`);
		console.log(this);
		return;
	}

	dispelFactors (mods) {
		//	Adds extra weight to targets with buffs, based on effects' threat value.

		mods = (mods || []);
		console.assert(mods instanceof Array,`ERROR in dispelFactors: mods must be array`);

		for (let t of this) {
			for (let eff of t.target.effects) {
				if (eff.buff && (!eff.sticky || mods.includes("unsticky"))) {
					t.target.chance += eff.threat;
				}
			}
		}
		if (mods.includes("exclusive dispel")) {
			this.onlyVulnerable();
		}
	}

	onlyVulnerable () {
		//	Filters hitlist to only targets with chance > 1 (i.e. those selected by addFactors)
		//	This will not do anything if the resulting hitlist would be empty.

		var altered = false;
		if (this.some(el => el.chance > 1)) {
			altered = true;
			let i = 0;
			while (i < this.length) {
				if (this[i].chance > 1) i++;
				else this.splice(i, 1);
			}
		}
		return altered;
	}

	martyrCheck () {
		//	Searches for a martyr in the hitlist. If a live martyr is found, it is returned; else, returns undefined.

		var test = this.find(function (t) { return t && t.target.martyr && !t.target.dead });
		return typeof(test) === "object" ? test.target : false;
	}

	static protectionCheck (target,mods) {
		// Checks if target is protected by someone with the Protector effect

		mods = (mods || []);
		console.assert(mods instanceof Array,`ERROR in returnTarget: mods must be array`);

		if (!(mods.includes("ignore protection") || mods.includes("ally")) && target.protectedBy) {
			var newTarget = target.ownParty.find(function(t) { return t && t.id === target.protectedBy; });
			temporary().targetingMsg = newTarget.name+" took the hit for "+target.name+"!\n";
			return newTarget;
		} else {
			return target;
		}
	}

	static guardCheck (target) {
		//	For use with the battle grid. Checks if the target is guarded by a frontline character.
		//	By default, this check is bypassed by ranged attacks and friendly fire.

		var rangeCheck = true;
		try {
			rangeCheck = !V().action.ranged;
		} catch (e) {
			// no change needed
		}

		if (setup.BATTLE_GRID === true
			&& rangeCheck
			&& (subject().id.charAt(0) !== target.id.charAt(0))) {

			console.assert(target instanceof Actor,`ERROR in guardCheck: target must be Actor`);
			var newTarget = target;

			// Search for character immediately in front of this one (same column, row - 1)
			newTarget = target.ownParty.find(function (a) { return a && a.col === this.col && a.row === this.row - 1 },target);
			if (newTarget instanceof Actor && !newTarget.guardBreak) {
				newTarget = Hitlist.guardCheck(newTarget); // Run again to test if the new target is in turn guarded by a front row character
			} else {
				newTarget = target;
			}
			return newTarget;
		} else {
			return target;
		}
	}

	clone () {
		// Return a new instance containing our current data.
		return new Hitlist(this.map(function (t) {return t.target}));
	}

	toJSON() {
		// Return a code string that will create a new instance
		// containing our current data.
		let data = this.map(function (t) {return t.target});
		return JSON.reviveWrapper('new Hitlist($ReviveData$)', data);
	}
};

Hitlist.targetEnemy = function (args) {
	//	Targeting logic for offensive abilities.
	//	args = string or array of strings, modifies logic

	//	If all of one party are dead, there are no valid targets. Flag targetfail and return null.
	if (deadCount() == puppets().length || enemies().filter(function (e) { return e.dead; }).length == enemies().length) {
		temporary().targetfail = true;
		return null;
	}

	var mods = [];
	if (args instanceof Array) {
		mods = args;
	} else if (typeof(args) == "string") {
		mods = [args];
	}

	var party = V().puppets;

	// Check if this widget is being run for an uncontrollable actor.
	if (subject().uncontrollable) {
		// if can target any party (e.g. confusion), pass "any" as an argument to the widget and target party will be selected randomly
		if (mods.includes("any")) {
			let selector = random(1,2);
			switch (selector) {
				case 1:
					party = V().puppets;
					break;
				case 2:
					party = V().enemies;
					break;
			}
		}
		else if (mods.includes("enemies")) {
			party = subject().otherParty;
		}
		else if (mods.includes("allies")) {
			party = subject().ownParty;
		}
	}

	party = party.filter(function (a) { return a !== null; });

	// if only untargetables remain, must ignore untargetable
	if (!mods.includes("ignore untargetable")) {
		let untargetTest = party.filter(function (p) { return (p.dead || p.untargetable) });
		if (untargetTest.length == party.length) {
			mods.push("ignore untargetable");
		}
	}

	var hitlist = new Hitlist(party,mods);

	// If there's an active martyr in the target party, we can stop here.
	if (!mods.includes("ignore martyr") && hitlist.martyrCheck() instanceof Actor) {
		return hitlist.martyrCheck();
	}

	// If subject is uncontrollable, target will be selected completely randomly. By default, it is possible for a charmed or confused actor to attack themselves.
	if (subject().uncontrollable) {
		mods.pushUnique("random");
		return hitlist.returnTarget(mods);
	}

	if (mods.includes("dispel")) {
		hitlist.dispelFactors(mods);
	}

	// mercy setting
	var mercy = 0;
	if (subject().mercy < 1 || mods.includes("smart")) {
	// if enemy's mercy is below 1, they will always use smart targeting
		mercy = 2;
	}
	else {
	// 1 in (mercy) chance of random targeting, to give players a break
		mercy = random(1,subject().mercy);
	}

	// smart targeting
	switch (V().difficulty) {
		case "hard":
		// Hard difficulty: If any puppets are vulnerable, non-vulnerable puppets will be ignored
			if (mercy > 1) {
				hitlist.addFactors(mods);
				hitlist.onlyVulnerable();
			}
			break;

		case "medium":
			// Medium difficulty: All puppets will be considered, but vulnerable puppets will get additional chances to be selected.
			if (mercy > 1) {
				hitlist.addFactors(mods);
			}
			break;

		case "easy":
			// Easy difficulty: Smart targeting is only used with the "smart" mod.
			if (mods.includes("smart")) {
				hitlist.addFactors(mods);
			}
			break;
	}

	return hitlist.returnTarget(mods);
};

Hitlist.targetAlly = function (args) {
	//	Targeting logic for support abilities.
	//	args = string or array of strings, modifies logic

	//	If all of one party are dead, there are no valid targets. Flag targetfail and return null.
	if (subject().ownParty.filter(function (e) { return e.dead; }).length == enemies().length) {
		temporary().targetfail = true;
		return null;
	}

	var mods = [];
	if (args instanceof Array) {
		mods = args;
	} else if (typeof(args) == "string") {
		mods = [args];
	}
	mods.push("ally");

	var party = subject().ownParty.filter(function (a) { return a !== null; });
	var hitlist = new Hitlist(party,mods);
	if (!mods.includes("random")) {
		hitlist.allyFactors(mods);
	}
	return hitlist.returnTarget(mods,true);
};

Hitlist.prototype.addFactors = function (mods) {
	//	Adds additional weighting to targets depending on passed mods.
	//	Assumes action is an attack targeting enemy.

	mods = (mods || []);
	console.assert(mods instanceof Array,`ERROR in addFactors: mods must be array`);

	var mostDamaging = Math.max(...this.map(function (t) { return t.target.lastDmg }));
	var highestStat = {};
	var lowestStat = {};
	for (let [pn,v] in setup.statInfo) {
		highestStat[pn] = Math.max(...this.map(function (t) { return t.target.get(pn) }))
	}
	for (let [pn,v] in setup.statInfo) {
		lowestStat[pn] = Math.min(...this.map(function (t) { return t.target.get(pn) }))
	}
	if (mods.includes("most HP")) {
		var greatestHP = Math.max(...this.filter(function (t) { return t.chance > 0 }).map(function (t) { return t.target.hp }));
	} else if (mods.includes("least HP")) {
		var lowestHP = Math.min(...this.filter(function (t) { return t.chance > 0 }).map(function (t) { return t.target.hp }));
	}
	for (let t of this) {
		// Exclusive mods: These will target ONLY the character with the highest or lowest parameter.
		// As such, they are mutually exclusive and ignore other mods.
		if (mods.includes("least HP") && t.target.hp <= lowestHP) {
			t.chance += 1;
		} else if (mods.includes("most HP") && t.target.hp >= greatestHP) {
			t.chance += 1;
		} else if (mods.includes("most damage") && t.target.lastDmg >= mostDamaging) {
			t.chance += 1;
		} else if (mods.includes("most DEF") && t.target.get(StatName("def")) >= highestStat[StatName("def")]) {
			t.chance += 1;
		} else if (mods.includes("least DEF") && t.target.get(StatName("def")) >= lowestStat[StatName("def")]) {
			t.chance += 1;
		} else if (mods.includes("most ATK") && t.target.get(StatName("atk")) >= highestStat[StatName("atk")]) {
			t.chance += 1;
		} else if (mods.includes("least ATK") && t.target.get(StatName("atk")) >= lowestStat[StatName("atk")]) {
			t.chance += 1;
		} else if (mods.includes("most SPC") && t.target.get(StatName("spc")) >= highestStat[StatName("spc")]) {
			t.chance += 1;
		} else if (mods.includes("least SPC") && t.target.get(StatName("spc")) >= lowestStat[StatName("spc")]) {
			t.chance += 1;
		} else if (mods.includes("no effect") && !t.target.effects.includesAny(action().effects)) {
			t.chance += 1;
		} else if (mods.includes("exclusive")) {
			t.chance = 0;
		} else {
			// Preferentially target Off-Balance characters to proc Knocked Down,
			// and target Knocked Down characters to take advantage of DEF penalty.
			// To exclude this clause, pass "ignore downed"; such as for non-damaging moves
			if (!mods.includes("ignore downed") && (t.target.offbalance || t.target.down)) {
				t.chance += 1;
			}
			// Characters who inflicted the most damage on the last turn get an extra weight.
			if (!mods.includes("ignore damaging") && t.target.lastDmg >= mostDamaging) {
				t.chance += 1;
			}
			// If this attack pierces defense, preferentially target the character with the highest defense.
			if (mods.includes("pierce") && t.target.get(StatName("def")) >= highestStat[StatName("def")]) {
				t.chance += 1;
			}
			// Otherwise, preferentially target characters with a DEF debuff to get the most out of the attack.
			// To exclude this clause, pass "ignore vulnerable"; such as for non-damaging moves
			else if (!mods.includes("ignore vulnerable") && t.target.get(StatName("def")) < t.target.getBase(StatName("def"))) {
				t.chance += 1;
			}
			// Preferentially target more injured characters.
			// To exclude this clause, pass "ignore vulnerable"; such as for non-damaging moves
			// To weight this even higher, pass "ruthless"; multiplies this factor by RUTHLESS_FACTOR.
			if (mods.includes("ruthless")) {
				t.chance += (1-((t.target.hp)/t.target.maxHP))*setup.RUTHLESS_FACTOR;
			}
			else if (!mods.includes("ignore vulnerable")) {
				t.chance += (1-((t.target.hp)/t.target.maxHP));
			}
			// If this attack applies a debuff, preferentially target characters with a SPC debuff,
			// and ignore those with protective effects.
			if (mods.includes("effect") && !(t.target.chi || t.target.stasis)
				&& t.target.get(StatName("spc")) < t.target.getBase(StatName("spc"))) {
					t.chance += 1;
			}
		}
	}
};

Hitlist.prototype.allyFactors = function (mods) {
	//	Adds extra weight to targets based on passed mods; for support abilities
	//	mods:
	//		"pragmatic": exclude allies with HP below proportion specified by PRAGMATIC_CUTOFF
	//		"vulnerable": chance boosted by proportion of HP remaining
	//		"most vulnerable": only the character with the lowest HP will be selected
	//		"ailments": chance boosted by threat value of all ailments on character

	mods = (mods || []);
	console.assert(mods instanceof Array,`ERROR in allyFactors: mods must be array`);

	if (mods.includes("pragmatic")) {
		for (let t of this) {
			if (t.target.hp < (t.target.maxHP * Math.clamp(setup.PRAGMATIC_CUTOFF,0,1))) {
				t.chance = 0;
			}
		}
	}

	if (mods.includes("most HP")) {
		var greatestHP = Math.max(...this.filter(function (t) { return t.chance > 0 }).map(function (t) { return t.target.hp }));
	} else if (mods.includes("least HP")) {
		var lowestHP = Math.min(...this.filter(function (t) { return t.chance > 0 }).map(function (t) { return t.target.hp }));
	}
	for (let t of this) {
		if (mods.includes("least HP") && t.target.hp <= lowestHP) {
			t.chance += 1;
		} else if (mods.includes("most HP") && t.target.hp >= greatestHP) {
			t.chance += 1;
		} else if (mods.includes("no effect") && !t.target.hasEffect(action().effects)) {
			t.chance += 1;
		} else if (mods.includes("exclusive")) {
			t.chance = 0;
		} else {
			if (mods.includes("vulnerable")) {
				t.chance += (1-((t.target.hp)/t.target.maxHP))*2;
			}
			if (mods.includes("ailments")) {
				t.chance += t.target.effectCount("ailment",["threat","nosticky"])
			}
		}
	}
};
/* twine-user-script #18: "0_config.js" */
/* Configuration settings. See the SugarCube documentation for more options and info. */

if (window.hasOwnProperty("storyFormat")) {
	// Running inside Twine application
	setup.Path = "C:/whatever"; // Set an absolute path for media files; this is useful if you're testing the story in Twine
} else {
	// Running in a browser
	setup.Path = "";
	// Config.saves.autoload = true; // Automatically loads autosave on startup
}

setup.SoundPath = setup.Path + "sound/";
setup.ImagePath = setup.Path + "images/";

Config.macros.maxLoopIterations = 100;
/* RPGs have a high chance of producing infinite loop errors, so lowering this from the default 1000 is helpful when testing. You probably will never need to exceed 100 iterations, but if you do you can increase this. */

Config.history.maxStates = 1;
// This eliminates Twine's history feature, which prevents people from accessing previous moments (and cuts down on save file size). Given the complexity of an RPG and the fact that many parts of the engine move the player through multiple passages at once, this is probably what you want; but if you do want people to interact with the history, you can change this.

// Config.saves.autosave = true;
/* This generates an autosave on every passage. This is recommended to prevent your player from losing progress. */

Config.saves.isAllowed = function () {
	return !State.variables.inbattle;
};
// This will disallow saving in battle. This is probably a good idea, but make sure you keep track of your inbattle variable so you don't accidentally prevent people from saving in the main story.

setup.version = "4.00";

Config.saves.version = 0;
// Records a version number for saves. Update this when you update your version. This is helpful for updating saves from older versions.
// NOTE: This is separate from the game version. Only update this when you need a new case for onLoad.

Save.onLoad.add(function (save) {
	switch (save.version){
			// You would make a case for older version numbers, and adjust variables as necessary. If you've made variable changes since that would cause conflicts with the save, you can update them here.
		case 0:
			/*
			save.version++;
			save.state.history.forEach(function (moment) {
				//Access story variables through moment.variables
			});
			*/
		default:
			// all is (hopefully) well, do nothing
	}
});
/* twine-user-script #19: "database-actions.js" */
Object.assign(setup.actionData, {
	//	Actions defined here will be added to the action database.
	//	Note that actions defined here will overwrite entries in the core database if they have the same name.

	"Example": {
		"passive": 				false,
		"silent": 				false,
		"truce":					false,
		"fullround": 			false,
		"basic": 					false,
		"pierce":					false,
		"instant":				false,
		"oncePerTurn":		false,
		"noself":					false,
		"noShock":				false,
		"ranged":					false,
		"counter":				false,
		"cost": 					0,
		"hpcost":					0,
		"accuracy":				true,
		"critRate":				0,
		"critMultiplier":	1.5,
		"weight": 				0,
		"effweight": 			0,
		"dur": 						0,
		"useSpecial":			0,
		"uses":						null,
		"warmup":					null,
		"cooldown":				null,
			"enemyCD":			null,
			"nameCD":				null,
		"element":				null,
		"target": 				"enemy",
		"phase": 					"targeting phase",
		"formula":				null,
		"info": function (action) {return ``},
		"desc": ``,
		"useText": null,
		"actText": function () {
			return ``;
		},
		"act": function () {

		},
		"preview": function () {

		}
	},

});
/* twine-user-script #20: "database-effects.js" */
Object.assign(setup.effectData, {

	"Example": {
		"persistAfterBattle":	false,
		"persistAfterDeath":	false,
		"buff": 							false,
		"stackable": 					false,
		"sticky": 						false,
		"ULTIMATESTICKY": 		false,
		"unblockable": 				false,
		"topDec":							false,
		"exclusive":					false,
		"unique":							false,
		"statmod": 						false,
		"uncontrollable": 		false,
		"untargetable": 			false,
		"skillLock":					false,
		"guardBreak":					false,
		"threat":							undefined,
		"shock":							0,
		// block subtype:
		"block": false,
			"blockCondition": function (effect) {
				return false;
			},
			"blockText": function (actor) {
				return ``;
			},
		// hold subtype:
		"hold":	false,
			"holdAction": function () {
				return {useText: null,
					actText: "",
					act: null};
			},
		// DoT subtype:
		"dot": false,
			"dmgtype": "",
			"msg": function (target) {return ``},
		// shield subtype:
		"shield": false,
			"uses": 0,
			"onHit": function (puppet) {
						return ``;
			},

		"priority": 0,	// hold or block only
		"onApply": function (puppet) {

		},
		"onRemove": function (puppet) {

		},
		"info": function (effect) {
			return ``;
		},
		"addText": function (target) {
			return ``;
		},
		"removeText": function (target) {
			return ``;
		}
	},




//	END OF DATABASE
});
/* twine-user-script #21: "database-enemies.js" */
Object.assign(setup.enemyData,{
  "Example": {
    "bestiaryNo": false,
    "gender": 'N',
    "hp": 0,
    "stats": {

    },
    "tolerances": {

    },
    "elements": {

    },
    "cooldown": {

    },
    "actions": function () {
      while (V().action === null) {
        var act = random(1,100);

        if (true) {
          // action 1
        } else {
          // default action
        }

      } // end loop
      return;
    }
  },

});
/* twine-user-script #22: "database-items.js" */
setup.itemData = {

	// CONSUMABLES

	"Example Item": {
		"usable": [],
		"value": 0,
		"onUse": function (puppet) {
			return;
		},
		"info": "",
		"desc": ""
	},


	"Salve": {
		"usable": ["inbattle","inmenu"],
		"special": setup.actionData["Salve"].special,
		"onUse": function (puppet) {
			puppet.hp += this.special;
			inv().decItem(this.name);
			return;
		},
		"info": function (item) { console.log(item); return `Restores ${item.special} HP.`},
		"desc": "A glowing, viscous fluid within a glass bottle. Supposedly, it instantly heals wounds when applied. You're not sure how, but it's better than dying. Probably."
	},

	"Antidote": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Poisoned.",
		"desc": "Isn't it convenient that everyone in the arena uses the exact same poison?"
	},

	"Fire Extinguisher": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Burning.",
		"desc": "...This is a bucket of water. MegaCorp are cheapskates."
	},

	"Canned Air": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Winded and restores 1 Energy.",
		"desc": "Regular inhalers are too pedestrian for MegaCorp, apparently. You're not entirely sure what's in this, but it gives more of a kick than regular oxygen."
	},

	"Healing Crystal": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Dizzy.",
		"desc": "A magic crystal that supposedly absorbs feelings of confusion and disorientation from the mind. Amazingly, it actually works."
	},

	"Nanites": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Injury.",
		"desc": "MegaCorp®’s patented nanobot surgery machines can fix any injury in a snap! They can fix so many things. They have so many wonderful ideas. Let them in. Let them fix you."
	},

	"Painkiller": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Pain.",
		"desc": "Pain is just your body holding you back. Shut it up with MegaCorp® brand extra-strength painkillers. What does that old meat sack know anyway?"
	},

	"Asprin": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Cures Headache.",
		"desc": "Is it normal for asprin to cure a headache that fast? you think. Then you laugh. The headache is making you think such funny thoughts. The headache hurts so much. You would do anything to make it go away. Anything."
	},

	"Panacea": {
		"usable": ["inbattle"],
		"value": 10,
		"info": "Cures all status ailments.",
		"desc": "The mythical medicine has jumped out of the history books and onto your shelves! Don't ask how it's made. The answer would only upset you. But you'll take it anyway, won't you?"
	},

	"Bottled Chi": {
		"usable": ["inbattle"],
		"value": 2,
		"info": "Bestows Chi Shield.",
		"desc": "No need to spend a lifetime meditating on mountains – now you can buy enlightenment right off the shelves! Comes in lemon, berry, and ennui flavors."
	},

	"Stimulant": {
		"usable": ["inbattle"],
		"value": 10,
		"info": "Restores 5 Energy.",
		"desc": `Just "Stimulant". What kind? No need to trouble yourself. It keeps your puppets going, and that's all that matters, right?`
	},

	"Adrenaline": {
		"usable": ["inbattle"],
		"value": 3,
		"info": "Bestows an ATK Boost.",
		"desc": "A hormone that releases the body's stored sugars into the bloodstream, providing a boost in energy. At least, that's what normal adrenaline is. You can keep injecting MegaCorp's version all day without crashing. It could be something as innocuous as including extra sugars to replace the ones lost in the adrenaline rush. It could be."
	},

	"Stoneskin": {
		"usable": ["inbattle"],
		"value": 3,
		"info": "Bestows a DEF Boost.",
		"desc": "Lather yourself up with Stoneskin formula and watch the slings and arrows of misfortune bounce off your natural armor! Don't worry, there are no lasting side-effects anymore. Many, many test subjects valiantly donated their bodies to science to ensure your safety!"
	},

	"Nootropic": {
		"usable": ["inbattle"],
		"value": 3,
		"info": "Bestows a SPC Boost.",
		"desc": "Performance-enhancing drugs: not just for athletes! Put your mind into overdrive with MegaCorp®'s new brain-boosting formula."
	},

	"Throwing Knife": {
		"usable": ["inbattle"],
		"value": 3,
		"info": "Inflicts high damage to one enemy.",
		"desc": "Very different from an ordinary knife! The weight has to be balanced just so, and the cutting edge is dull -- more of a dart than a knife. But it'll fly straight and true."
	},

	"Powdered Glass": {
		"usable": ["inbattle"],
		"value": 4,
		"info": "Damages and Stuns one enemy.",
		"desc": "By crushing glass in just the right way, you can grind it into shards so tiny they look like grains of sand. Throw it into someone's eyes, and, well, you get the picture. They won't, because it's kind of hard to see with sharp things in your eyes."
	},

	"Grenade": {
		"usable": ["inbattle"],
		"value": 6,
		"info": "Inflicts high damage to one enemy, remaining enemies take half damage.",
		"desc": "It's just a grenade. Just a totally normal explosive powered by totally mundane chemical reactions. You're sure. You're pretty sure. You stare at it nervously, daring it to show you what dark arts MegaCorp used to make it."
	},

	"Flamethrower": {
		"usable": ["inbattle"],
		"value": 6,
		"info": "Damages and Burns all enemies. Damage is greater against fewer enemies.",
		"desc": "Have a burning need to burn your enemies to ash? Try the MegaCorp® Flamethrower 4000! No longer has the potential for those embarrassing backfire explosions you got with the 3000."
	},

	"Gas Bomb": {
		"usable": ["inbattle"],
		"value": 6,
		"info": "Damages and Poisons all enemies. Damage is greater against fewer enemies.",
		"desc": `You don't know what kind of "gas" is supposed to be in this. Perhaps it's better that way. The casing feels oddly soft, like rotting flesh.`
	},

	"Calamity Bomb": {
		"usable": ["inbattle"],
		"value": 6,
		"info": "Damages an enemy and inflicts Injury, Pain, and Headache.",
		"desc": "A small, strange explosive wrapped in cursed scrolls."
	},

	"Flashbang": {
		"usable": ["inbattle"],
		"value": 5,
		"info": "Stuns all enemies.",
		"desc": "This bomb contains chemicals that shine brightly instead of exploding. The flash is so bright it'll shock your foes' retinas into blindness, for a time."
	},

	"Smelling Salts": {
		"usable": ["inbattle"],
		"info": "Cures Asleep.",
		"desc": "Resist the urge to sniff these, the pungent mix of ammonia and other nasty stuff won't be fragrant at all. This is designed to shock a body back into consciousness no matter how battered its state. It's jokingly said to be strong enough to wake the dead, but this is (currently) beyond MegaCorp's capabilities. It will, however, wake puppets from even magical sleep, so strong is the body's desire to escape the smell."
	},

	"Anti-Mineral Water": {
		"usable": ["inbattle"],
		"info": "Cures Petrification.",
		"desc": `Takes the "in" out of "inorganic"! Using it on materials not originally organic is not recommended.`
	},

	"Apple of Life": {
		"usable": ["inmenu"],
		"onUse": function (puppet) {
			puppet.maxhp += 100;
			inv().decItem(this.name);
			return `${puppet.name} gains 100 max HP!`;
		},
		"info": "Permanently increases max HP by 100.",
		"desc": `The apple Adam and Eve didn't eat. It's lost much of its power, this far from the Garden, but it'll still make a puppet a little more vivacious than usual.`
	},

	// EQUIPMENT

	// If you don't plan to call item data directly through a function or iterator,
	// you can use equipment to modify character by proxy via the onEquip
	// and onRemove functions. These are passed the character being equipped
	// and can modify their attributes in any way you choose. Typically,
	// these functions would be inverses of each other, but you can add
	// special functionality for one or the other for e.g. cursed items.

	// restrictedTo must be defined and must be an array. Make it an empty array to make equipment unrestricted.
	// Kudos if you recognize where I got the default items' naming scheme from.

	"Example Equipment": {
		"equippable": {slot: "", tags: [], restrictedTo: []},
		"onEquip": function (puppet) {

		},
		"onRemove": function (puppet) {

		},
		"desc": "",
		"info": ""
	},


	"Symbol of Destruction": {
		"equippable": {slot: "Weapon", tags: ["symbol"], restrictedTo: []},
		"onEquip": function (puppet) {
			puppet.stats["Attack"].addMod("Symbol of Destruction",5,true);
		},
		"onRemove": function (puppet) {
			puppet.stats["Attack"].removeMod("Symbol of Destruction");
		},
		"desc": "A weapon.",
		"info": "ATK +5"
	},

	"Aura of Protection": {
		"equippable": {slot: "Armor", tags: ["aura"], restrictedTo: []},
		"onEquip": function (puppet) {
			puppet.tolerances.addMod("Stunned","Aura of Protection",{ immune: true });
			puppet.tolerances.addMod("Off-Balance","Aura of Protection",1);
		},
		"onRemove": function (puppet) {
			puppet.tolerances.removeMod("Stunned","Aura of Protection");
			puppet.tolerances.removeMod("Off-Balance","Aura of Protection");
		},
		"desc": "An armor.",
		"info": "Stunned Immunity | Off-Balance Tol +1"
	},

	"Color of Defeat": {
		"equippable": {slot: "Accessory", tags: ["color"], restrictedTo: ["Artist"]},
		"onEquip": function (puppet) {
			this.modID.HPregen = puppet._HPregen.flat.addMod("Color of Defeat",1,true);
			this.modID.blue = puppet.elements.addMod("blue","Color of Defeat",25,true,"flat");
		},
		"onRemove": function (puppet) {
			puppet._HPregen.flat.removeMod("Color of Defeat",this.modID.HPregen);
			puppet.elements.removeMod("blue","Color of Defeat",this.modID.blue,"flat");
		},
		"desc": "Something else.",
		"info": "HP regeneration +1 | Blue soak +25"
	},

	"Color of Growth": {
		"equippable": {slot: "Accessory", tags: ["color"], restrictedTo: []},
		"onEquip": function (puppet) {
			this.modID.HPregen = puppet._HPregen.percent.addMod("Color of Defeat",0.01,true);
			this.modID.red = puppet.elements.addMod("red","Color of Defeat",-0.25,true,"percent");
		},
		"onRemove": function (puppet) {
			puppet._HPregen.percent.removeMod("Color of Defeat",this.modID.HPregen);
			puppet.elements.removeMod("red","Color of Defeat",this.modID.red,"percent");
		},
		"desc": "Something else.",
		"info": "HP regeneration +1% | Red resistance +25%"
	},

	"Cursed Ring": {
		"equippable": {slot: "Accessory", tags: ["ring"], restrictedTo: []},
		"sticky": true,
		"fakeName": "Mysterious Ring",
		"onEquip": function (puppet) {
			this.modID = puppet.stats["Attack"].addMod("Cursed Ring",-1,true);
			this.known = true;
		},
		"onRemove": function (puppet) {
			puppet.stats["Attack"].removeMod("Cursed Ring",this.modID);
		},
		"desc": function (item) {
			return (item.known) ? "A cursed ring that saps the wearer's strength."
			: "A mysterious gold ring. You don't know what it does.";
		},
		"info": function (item) {
			return (item.known) ? "CURSED | ATK -1" : "It's a mystery!";
		}
	},

	"Zweihander": {
		"equippable": {slot: new Set(["Weapon","Armor"]), restrictedTo: []},
		"onEquip": function (actor) {
			actor.stats["Attack"].addMod("Zweihander",{add: 20},true);
		},
		"onRemove": function (actor) {
			actor.stats["Attack"].removeMod("Zweihander");
		},
		"info": "Attack +20",
		"desc": "A massive sword too heavy to hold in only one hand."
	}
};
/* twine-user-script #23: "database-music.js" */
setup.musicData = {
	"Happy 8bit Loop 01": {
		author: "Tristan Lohengrin",
		license: "CC BY",
		distributor: "Freesound"
	}
};
/* twine-user-script #24: "database-puppets.js" */
setup.PUPPET_HP = 1000;

setup.puppetData = {

	"Example": {
		"gender": 'N',
		"hp": 0,
		"stats": {

		},
		"actions": [

		],
		"defaultAction": ''
	},



	"Rogue": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 30,
			"Special"	: 50
		},
		"actions": [
			"Crafty",
			"Knife",
			"Crossbow",
			"Something in your eye",
			"Poison Prick",
			"Off Your High Horse",
			"A Farewell to Arms",
			"Below the Belt",
			"Dead Ringer",
			"Flurry",
			"Sneak"
		],
		"defaultAction": "Knife",
		"crisis": "Stash",
		"specialInit": function (actor) {
			actor.crafty = true;
			actor.crisisFactor = (10/4);
			actor.stash = [
				new ItemAction("Panacea"),
				new ItemAction("Bottled Chi"),
				new ItemAction("Adrenaline"),
				new ItemAction("Stoneskin"),
				new ItemAction("Nootropic"),
				new ItemAction("Stimulant"),
				new ItemAction("Powdered Glass"),
				new ItemAction("Grenade"),
				new ItemAction("Flamethrower"),
				new ItemAction("Gas Bomb"),
				new ItemAction("Flashbang"),
				new ItemAction("Calamity Bomb")
			];
			actor.stash.forEach(function (item) {
				item.free = true;
				item._crisis = true;
			});
		}
	},

	"Fighter": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 50,
			"Special"	: 10
		},
		"actions": [
			"Firefly",
			"Sword",
			"Punch",
			"Hammer",
			"Bull Rush",
			"Assault",
			"Meditate",
			"Berserker",
			"Defender",
			"Protector",
			"Martyr"
		],
		"defaultAction": "Sword",
		"crisis": "Perfect Defense",
		"specialInit": function (actor) {
			actor.firefly = true;
		}
	},

	"Mage": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 50,
			"Defense"	: 10,
			"Special"	: 30
		},
		"actions": [
			"Focus",
			"Sacrifice",
			"Blast",
			"Fireball",
			"Favor",
			"Restoration",
			"Neutralize",
			"Blessing",
			"Curse"
		],
		"defaultAction": "Focus",
		"crisis": "Desperate Attack"
	},

	"Bard": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 30,
			"Special"	: 30
		},
		"actions": [
			"Rapier",
			"Dagger",
			"Shout",
			"Non-Sequitor",
			"Insult",
			"Joke",
			"Equivocate",
			"Rewrite",
			"Provoke",
			"Sneak"
		],
		"defaultAction": "Rapier",
		"crisis": "Desperate Attack"
	},

	"Archer": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 70,
			"Defense"	: 10,
			"Special"	: 10
		},
		"actions": [
			"Shot",
			"Soulshot",
			"Exacerbate",
			"Explosive Bolt",
			"Mark",
			"Mercy",
			"Hunter",
			"Call to Arms"
		],
		"defaultAction": "Shot",
		"crisis": "Bloody Rain",
		"portrait": "ARCHR"
	},

	"Cleric": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 70,
			"Special"	: 10
		},
		"actions": [
			"Firefly",
			"Club",
			"Helping Hand",
			"Assured Aegis",
			"Protector_Cleric",
			"Martyr_Cleric",
			"Lifegiver",
			"Downfall",
			"Meditate_Cleric",
			"Walled City"
		],
		"defaultAction": "Club",
		"crisis": "Divine Protection",
		"portrait": "CLRIC",
		"specialInit": function (actor) {
			actor.firefly = true;
		}
	},

	"Witch": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 10,
			"Defense"	: 10,
			"Special"	: 70
		},
		"actions": [
			"Crafty",
			"Pox",
			"Focus",
			"Gift",
			"Cleanse",
			"Forgetfulness",
			"Curse",
			"Frenzy",
			"Thaumastasis",
			"Age of Enlightenment"
		],
		"defaultAction": "Focus",
		"crisis": "Desperate Attack",
		"specialInit": function (actor) {
			actor.crafty = true;
		}
	},

	"Artist": {
		"gender": 'N',
		"hp": setup.PUPPET_HP,
		"en": 10,
		"ENregen": 2,
		"stats": {
			"Attack"	: 30,
			"Defense"	: 30,
			"Special"	: 30
		},
		"actions": [
			"Crimson Flames",
			"Azure Frost",
			"Gold Sparks",
			"White Light",
			"Black Night",
			"Violet Bloom",
			"Orange Blaze",
			"Green Toxin",
			"Prismatic Spray",
			"Red Tide",
			"Blue Lightning",
			"Yellow Scorch",
			"Sacrament",
			"Blasphemy",
			"Heal"
		],
		"defaultAction": "White Light",
		"crisis": "Desperate Attack",
		"portrait": "ARTST"
	}
};
/* twine-user-script #25: "effect-manager-overwrite.js" */
/*

Actor.prototype.addEffect = function (name,mods) {
  console.assert(typeof(name) == "string" || name instanceof Effect,`ERROR in addEffect: no effect passed`);
  mods = (mods || {});

  //  Define your own addEffect function here; it will overwrite the default
};

*/
/* twine-user-script #26: "enemy-actions.js" */
Object.assign(setup.actionData, {
	// Note that this will overwrite any actions with identical names

	// DIPPER

	"Dispel Magick": {
		"cooldown": 4,
		"useText": function () {
			var god;
			switch (target().name){
				case "Rogue":
				case "Witch":
					god = "Chattur'gha";
					break;
				case "Fighter":
				case "Archer":
					god = "Ulyaoth";
					break;
				default:
					god = "Xel'lotath";
					break;
			}
			return `Dipper frantically flips through his journal before yelling, "Nekleth Redgemor ${god}!"`
		},
		"actText": function () {
			return `Magickal runes swirl around Dipper before crashing violently to the earth, releasing a nauseating wave that strips ${target().name} of ${target().their} powers.`;
		},
		"act": removeEffect({dispel: true})
	},

	"Recovery": {
		"targetMethod": function () {
			var dipper = enemies().find(function (e) {return e.name === "Dipper"});
			var mabel = enemies().find(function (e) {return e.name === "Mabel"});
			if (mabel.effectCount("ailment") > 0 && mabel.effectCount("ailment") >= dipper.effectCount("ailment")){
				//If Mabel has any ailments and more ailments than Dipper, Dipper will always heal her
				return mabel;
			} else if (dipper.effectCount("ailment") > 0) {
				//If first check failed, Dipper must have more ailments than Mabel; if he has any ailments, he will always heal himself.
				return dipper;
			} else {
				//If no one has ailments, target is random
				return Hitlist.targetAlly(["random"]);
			}
		},
		"effweight": setup.STD_BUFF,
		"dur": 3,
		"target": "ally",
		"useText": function () {
			return `Dipper frantically flips through his journal before yelling, "Narokath Santak ${action().god}!"`;
		},
		"actText": function () {
			let extension = "";
			switch (action().god) {
				case "Chattur'gha":
					extension += `pulses with a violent red light.`;
					break;
				case "Ulayoth":
					extension += `glows with the deep blue of the abyss.`;
					break;
				case "Xel'lotath":
					extension += `shines with a green light that hurts to look at.`;
					break;
			}
			return `Eldritch runes glow beneath Dipper's feet, and ${target().name} `+extension;
		},
		"act": function () {
			let rand = random(1,3);
			switch (rand) {
				case 1:
					action().god = "Chattur'gha";
					action()._special = "DEF";
					break;
				case 2:
					action().god = "Ulayoth";
					action()._special = "ATK";
					break;
				case 3:
					action().god = "Xel'lotath";
					action()._special = "SPC";
					break;
			}
			return `<<for _effect range $target.effects>>\
								<<if !_effect.buff>>\
									<<set _effect.duration -= 1>>\
									<<if _effect.duration == 0>>\
										<<print target().removeEffect(_effect)>>\
									<</if>>\
								<</if>>\
							<</for>>\
							<<print target().addEffect("${action().special} Boost")>>`;
		}
	},

	"Damage Field": {
		"targetMod": ["debuff"],
		"weight": 0.8,
		"effweight": setup.STD_DEBUFF,
		"dur": 3,
		"useText": function () {
			return `Dipper frantically flips through his journal before yelling, "Bankorok Redgemor ${action().god}!"`;
		},
		"actText": function () {
			switch (action().god) {
				case "Chattur'gha":
					return `Pillars of red energy burst from the ground under $target.name like claws, searing their flesh where they touch.`;
				case "Ulayoth":
					return `Waves of blue energy pulse around $target.name and chill them with a numbing cold.`;
				case "Xel'lotath":
					return `The floor under $target.name flashes with a sickening green energy that makes your vision swim.`;
			}
			return `ERROR: invalid god`;
		},
		"act": function () {
			let rand = random(1,3);
			switch (rand) {
				case 1:
					action().god = "Chattur'gha";
					action()._special = "Pain";
					break;
				case 2:
					action().god = "Ulayoth";
					action()._special = "Injury";
					break;
				case 3:
					action().god = "Xel'lotath";
					action()._special = "Headache";
					break;
			}
			return `<<echoDamage>>\
				<<print target().addEffect("${action().special}")>>`;
		}
	},

	"Bind Creature": {
		"targetMod": ["ignore downed"],
		"dur": 1,
		"weight": 0.7,
		"useText": function () {
			let god = "";
			switch (target().name){
				case "Rogue":
				case "Witch":
					god = "Chattur'gha";
					break;
				case "Fighter":
				case "Archer":
					god = "Ulyaoth";
					break;
				default:
					god = "Xel'lotath";
					break;
			}
			return `Dipper frantically flips through his journal before yelling, "Bankorok Aretak ${god}!"`;
		},
		"actText": function () {
			return `${target().name} is lashed by chains of light.`;
		},
		"act": applyEffect("Stunned",{dmg: true})
	},

	// BIG DIPPER

	"Empowered Dispel Magick": {
		"cooldown": 4,
		"nameCD": "Dispel Magick",
		"useText": function () {
			return `A deep voice intones, "Pargon Nekleth Redgemor Mantorok."`
		},
		"actText": function () {
			return `Magickal runes swirl around Dipper before crashing violently to the earth, releasing a nauseating wave that dispels everyone's magic.`;
		},
		"act": massAttack({target: "enemies", content: removeEffect({dispel: true})})
	},

	"Empowered Recovery": {
		"targetMethod": function () {
			return subject();
		},
		"effweight": 0.2,
		"dur": 3,
		"target": "ally",
		"useText": function () {
			return `A deep voice intones, "Pargon Narokath Santak Mantorok."`;
		},
		"actText": function () {
			return `Veins of indigo darkness wrap around Dipper like a caress.`;
		},
		"act": function () {
			return `<<for _effect range $subject.effects>>\
								<<if !_effect.buff>>\
									<<set _effect.duration -= 1>>\
									<<if _effect.duration == 0>>\
										<<print target().removeEffect(_effect)>>\
									<</if>>\
								<</if>>\
							<</for>>\
							<<print subject().addEffect("Blessing")>>`;
		}
	},

	"Empowered Damage Field": {
		"weight": 1,
		"effweight": 0.3,
		"dur": 3,
		"useText": function () {
			return `A deep voice intones, "Pargon Bankorok Redgemor Mantorok."`;
		},
		"actText": function () {
			return `$target.name is crushed by a field of violet energy. Though it's only the puppet that was hit, you get a feeling like someone's walked over your grave.`;
		},
		"act": applyEffect("Curse",{dmg: true})
	},

	"Empowered Bind Creature": {
		"targetMod": ["ignore downed"],
		"dur": 1,
		"weight": 1,
		"useText": function () {
			return `A deep voice intones, "Pargon Bankorok Aretak Mantorok."`;
		},
		"actText": function () {
			return `${target().name} is savagely lashed by chains of darkness.`;
		},
		"act": applyEffect("Stunned",{dmg: true})
	},

	"Empowered Magickal Attack": {
		"weight": 0.75,
		"dur": 2,
		"useText": function () {
			return `A deep voice intones, "Pargon Antorbok Redgemor Mantorok."`;
		},
		"actText": function () {
			return `Dark lightning leaps from Dipper's feet to strike your puppets in turn. The shock makes them stagger and move erratically, draining their energy.`;
		},
		"act": massAttack({target: "enemies", content: applyEffect("Winded",{dmg: true})})
	},

	// MABEL

	"Cuteness Poisoning": {
		"targetMod": ["custom"],
		"weight": 1,
		"effweight": 0.3,
		"dur": 3,
		"actText": function () {
			return `Mabel conjures an image of a kitten... no, wait, <i>two</i> kittens? And they're riding on a <i>puppy</i>? Omigosh, it's so cute you could just <i>DIE!</i>`;
		},
		"act": applyEffect("Poisoned",{dmg: true})
	},

	"Galacta Burning": {
		"targetMod": ["custom"],
		"weight": 1,
		"effweight": 0.3,
		"dur": 3,
		"actText": function () {
			return `Mabel points her hands at you, and multicolored cartoon stars fly from her fingertips, leaving glittering trails behind them. When they run into ${target().name} they explode in a fiery burst, as hot as if they were real stars.`;
		},
		"act": applyEffect("Burning",{dmg: true})
	},

	"Glitter Bomb": {
		"cooldown": 2,
		"weight": 1,
		"dur": 3,
		"actText": function () {
			return `Out of nowhere, Mabel summons a dazzling, multicolored ball of sparkles and glitter. With a manic laugh she throws it at $target.name, and it explodes with a blinding firework of color!`;
		},
		"act": applyEffect("Dizzy",{dmg: true})
	},

	"Chaos Blaster": {
		"weight": 1,
		"actText": function () {
			return `You blink, and Mabel is suddenly holding a massive gun absolutely drowning in glitter and unicorn decals. She triumphantly points it at $target.name and shouts, "CHAOS... BLASTERRR!!" A shimmering, multicolored beam erupts from the cannon before it explodes magnificently in a burst of glitter.`;
		},
		"act": justdmg()
	},

	"Kitty Cannon": {
		"targetMod": ["custom","random"],
		"weight": 0.5,
		"actText": function () {
			return `Mabel's fists are suddenly replaced with mewling kittens. Just as you're trying to guess what tactical advantage this could possibly provide, they fly at your puppets like missiles!`;
		},
		"act": multihitCustom({content: `<<echoDamage>>`, hits: 3, spread: true})
	},

	// MEGA MABEL

	"Cuteness Overload": {
		"targetMod": ["custom"],
		"weight": 0.8,
		"effweight": 0.3,
		"dur": 3,
		"actText": function () {
			return `Mabel conjures a huge panorama of impossibly cute things. It's like your own petting zoo in here! There are ducks riding ponies! Puppies snuggling in boxes! Cats doing that thing where they curl their head in their little paws! It's... too much! The cuteness is going to make you EXPLODE!`;
		},
		"act": massAttack({target: "enemies", content: applyEffect("Poisoned",{dmg: true})})
	},

	"Galacta Blazing": {
		"targetMod": ["custom"],
		"weight": 0.8,
		"effweight": 0.3,
		"dur": 3,
		"actText": function () {
			return `Mabel flies up and raises her hands to the stars... and suddenly, the stars seem a whole lot closer. Mabel rains down what looks like the whole galaxy on you, stars bursting into psychedelic sparkles and flames where they hit.`;
		},
		"act": massAttack({target: "enemies", content: applyEffect("Burning",{dmg: true})})
	},

	"Anarchy Rave": {
		"cooldown": 3,
		"nameCD": "Glitter Bomb",
		"weight": 0.8,
		"dur": 3,
		"actText": function () {
			return `Mabel rocks out, literally bouncing off the walls with her aerial acrobatics. A disco ball appears out of nowhere and the arena is suddenly ablaze with strobe lights.

			And lasers. The disco ball also shoots lasers. The hot, burny kind, not the fun kind.`;
		},
		"act": massAttack({target: "enemies", content: applyEffect("Dizzy",{dmg: true})})
	},

	"Chaos Thunder": {
		"weight": 1.25,
		"actText": function () {
			return `Mabel does her best witchy cackle, letting her hands arc and crackle with electricity. She throws her arms straight up, and the magic shoots into to the sky in a brilliant stream. Then with a final, bellowing laugh, she closes her hand into a fist and brings it down like a hammer.

			"CHAOS... THUNDERRR!!"

			Lightning splits the air, leaving a wave of multicolored stars around the hapless puppet it fries.`;
		},
		"act": justdmg()
	},

});
/* twine-user-script #27: "mods.js" */
const customMods = function () {

const ActionProto = Object.getPrototypeOf(new Action(""));

//  PUPPET MODS

const PuppetProto = Object.getPrototypeOf(new Puppet("Dummy"));

//  crisisPoints: number; tracks progress to Crisis ability
if(!PuppetProto.crisisPoints) {
  Object.defineProperty(PuppetProto,'crisisPoints', {
    configurable: true,
    enumerable: true,
    get: function() { return this._crisisPoints },
    set: function(amt) { this._crisisPoints = Math.clamp(amt,0,100) }
  })
}

if(!PuppetProto._crisisPoints) {
  Object.defineProperty(PuppetProto,'_crisisPoints', {
    configurable: true,
    writable: true,
    enumerable: false,
    value: 0
  })
}

//  crisisFactor: number; modulates the rate of crisis point gain
if(!PuppetProto.crisisFactor) {
  Object.defineProperty(PuppetProto,'crisisFactor', {
    configurable: true,
    enumerable: true,
    get: function() { return (this._crisisFactor || setup.CRISIS_FACTOR) },
    set: function(amt) { this._crisisFactor = amt }
  })
}

// XPtoNext: Calculates the XP required for the next level. Pokemon's formulas are the default; change as necessary.
if(!PuppetProto.XPtoNext) {
  Object.defineProperty(PuppetProto,'XPtoNext', {
    configurable: true,
    enumerable: true,
    value: function (level) {
      if (level === undefined) {
        level = this.level;
      }
      var toNext;
      if (level >= setup.LEVEL_CAP) {
        return "--";
      }
      else if (level <= 0) {
        return 0;
      }
      switch (this.levelRate){
        case 'fast':
          return Math.floor((4*(this.level)^3)/5);
        case 'medium':
          return Math.floor((this.level^3));
        case 'slow':
          return Math.floor((5*(this.level)^3)/4);
        default:
          console.log("ERROR in XPtoNext: levelRate not recognized");
          return 0;
      }
    }
  })
}

//  initialThreat: Generates starting threat values. Required if threat targeting enabled, unused otherwise. Can implement any functions or logic here to produce variable results.
if(!PuppetProto.initialThreat) {
  Object.defineProperty(PuppetProto,'initialThreat', {
    configurable: true,
    enumerable: true,
    value: function () {
      return 1;
    }
  })
}

//  ENEMY MODS

const EnemyProto = Object.getPrototypeOf(new Enemy("Dummy"));

//  decayThreat: Logic for threat reduction per turn. Required if threat targeting enabled, unused otherwise.
if(!EnemyProto.decayThreat) {
  Object.defineProperty(EnemyProto,'decayThreat', {
    configurable: true,
    enumerable: true,
    value: function () {
      if (setup.THREAT_TARGETING === true) {
        this.threat.forEach(function(value,key) {
          this.threat.set(key,value-setup.THREAT_DECAY);
          if (this.threat.get(key) < 1) {
            this.threat.set(key,1);
          }
        }, this);
      }
    }
  })
}

}
window.customMods = customMods;
/* twine-user-script #28: "saves-modifier.js" */
/* GEMS saves descriptions module. */
/* Code by The Mad Exile, with modifications by Another RPG Enthusiast */
(function() {
	// Add metadata to saves.
	Save.onSave.add(function (save) {
		var active = save.state.history[save.state.index];
		save.metadata = {
			area	: active.variables.currentArea,
			party	: active.variables.puppets.filter(function (p) { return p !== null; }),
			money	: active.variables.currency,
//			level	: active.variables.puppets[0].level
		};
	});

	// Create save description from metadata.
	function createSaveDescription(metadata) {
		var desc = `<div class="save-desc monospace"><div class="save-left">`;
//		var extra = `<div class="save-extra">`;

		if (metadata.area !== undefined) { desc += `<span class="save-area">${metadata.area}</span>`; }
//		if (metadata.level !== undefined) { desc += `<span class="save-level">LV ${metadata.level}</span>`; }
		if (metadata.money !== undefined) { desc += `<span class="save-money">${setup.CURRENCY_NAME}: ${metadata.money}</span>`; }
		desc += `</div>`;
		if (metadata.party !== undefined) {
			desc += `<span class="save-party" style="min-width:${setup.PORTRAIT_SIZE*setup.PARTY_SIZE}px;">`;
			metadata.party.forEach(function(puppet) {
				desc += `<div style="display:inline-flex; flex-direction:column;"><span class="save-puppet" style="width:${setup.PORTRAIT_SIZE}px; height:${setup.PORTRAIT_SIZE}px;">`;
				if (setup.SHOW_PORTRAITS === true && puppet.portrait !== undefined) {
					desc += `<img src="${puppet.portrait}" />`;
				} else {
					desc += `${puppet.portrait}`;
				}
				desc += `</span>LV ${puppet.level}</div>`;
			});
			desc += '</span>';
		}
//		extra += `</div>`

		return desc+`</div>`;
	}

	// Modify native Save dialog descriptions upon opening the dialog.
	if (true) {
		$(document).on(':dialogopening', function () {
			if ($('#ui-dialog-body').hasClass('saves')) {
				$('#ui-dialog-body.saves tr').each(function (_, el) {
					var $tr = $(el);
					var $load = $tr.find('button.load:not([disabled])');

					if ($load.length === 0) {
						return;
					}

					var slot = $load.attr('id').split('-')[2];
					var save = slot === 'auto'
						? Save.autosave.get()
						: Save.slots.get(Number(slot));

					if (save !== null && typeof(save.metadata) == 'object') {
						$tr.find('td>div:first-child')
							.empty()
							.append(createSaveDescription(save.metadata));
					}
				});
				// Refresh the custom display when deleting saves
				$('#ui-dialog-body.saves button.delete').on('click', function () {
					$(document).trigger(':dialogopening');
				});
			}
		});
	}
})();
/* twine-user-script #29: "ui settings.js" */
Setting.addHeader("Settings", "These settings will reset if you clear your browser cookies and/or website data.<br>Click anywhere on the switch or text to toggle.");

/* Monitor for when the Settings dialog is opened. */
$(document).on(':dialogopening', function (ev) {
    setTimeout(function () {
        if (V().inbattle && $(ev.target).hasClass('settings')) {
            $('#settings-reset').hide();
			$('#setting-body-difficulty').hide();
        }
    }, Engine.minDomActionDelay);
});

var settingFunctions = {
  confirmToggle: function () {
		if (settings.showconfirm) {
			setup.SHOW_CONFIRM = true;
		} else {
			setup.SHOW_CONFIRM = false;
		}
	},
	turnToggle: function () {
		if (settings.autoend) {
			setup.AUTO_ENDTURN = true;
		} else {
			setup.AUTO_ENDTURN = false;
		}
	},
	actionsToggle: function () {
		if (settings.compressedActions) {
			setup.COMPRESSED_ACTIONS = true;
		} else {
			setup.COMPRESSED_ACTIONS = false;
		}
	},
  animationToggle: function () {
		if (settings.animation) {
			setup.ANIMATIONS = true;
		} else {
			setup.ANIMATIONS = false;
		}
	},
	difficulty: function () {
		switch (settings.difficulty) {
			case "Easy":
				V().difficulty = "easy";
				break;
			case "Normal":
				V().difficulty = "normal";
				break;
			case "Hard":
				V().difficulty = "hard";
				break;
		}
	},
  dyslexicToggle: function () {
    if (settings.dyslexic) {
			$("html").addClass("dyslexic");
		} else {
			$("html").removeClass("dyslexic");
		}
  },
  linkColor: function () {
		switch (settings.linkColor) {
			case "Blue":
				$("html").removeClass("greenLinks");
        $("html").removeClass("redLinks");
				break;
			case "Green":
        $("html").removeClass("redLinks");
        $("html").addClass("greenLinks");
				break;
			case "Red":
        $("html").removeClass("greenLinks");
        $("html").addClass("redLinks");
				break;
		}
	}
};

Setting.addToggle("showconfirm", {
	label	: "Show Confirm Phase",
	default	: true,
	onInit	: settingFunctions.confirmToggle,
	onChange: settingFunctions.confirmToggle
});

Setting.addToggle("autoend", {
	label	: "End turn automatically when all characters have acted",
	default	: true,
	onInit	: settingFunctions.turnToggle,
	onChange: settingFunctions.turnToggle
});

Setting.addToggle("compressedActions", {
	label	: "Compress action list (turn off on mobile)",
	default	: true,
	onInit	: settingFunctions.actionsToggle,
	onChange: settingFunctions.actionsToggle
});

Setting.addToggle("animation", {
  label   : "Animations",
	default : true,
	onInit	: settingFunctions.animationToggle,
	onChange: settingFunctions.animationToggle
});

Setting.addHeader("Accessibility");

Setting.addList("difficulty", {
	label   : "Difficulty Level",
	list    : ["Easy", "Normal", "Hard"],
	default : "Hard",
	onInit	: settingFunctions.difficulty,
	onChange: settingFunctions.difficulty
});

Setting.addList("linkColor", {
  label   : "Link Color",
  list    : ["Blue","Green","Red"],
	default : "Blue",
	onInit	: settingFunctions.linkColor,
	onChange: settingFunctions.linkColor
});

Setting.addToggle("dyslexic", {
  label   : "Dyslexic mode",
	default : false,
	onInit	: settingFunctions.dyslexicToggle,
	onChange: settingFunctions.dyslexicToggle
});
/* twine-user-script #30: "bundle.js" */
// mouseover.min.js, for SugarCube 2, by Chapel
// v1.0.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
Macro.add("mouseover",{tags:["onhover","onmouseover","onmousein","onmouseenter","onmouseout"],skipArgs:!0,handler:function(){if(this.payload.length<2)return this.error("No event tag used.");var e={mouseover:[],mousein:[],mouseout:[]},o=$(document.createElement("span")).addClass("macro-"+this.name).wiki(this.payload[0].contents).appendTo(this.output);this.payload.forEach((function(o){switch(o.name){case"onhover":case"onmouseover":e.mouseover.push(o.contents);break;case"onmousein":case"onmouseenter":e.mousein.push(o.contents);break;case"onmouseout":e.mouseout.push(o.contents);break;default:return}})),e.mouseover.length&&o.on("mouseover",this.createShadowWrapper((function(o){$.wiki(e.mouseover.join(" "))}))),e.mousein.length&&o.on("mouseenter",this.createShadowWrapper((function(o){$.wiki(e.mousein.join(" "))}))),e.mouseout.length&&o.on("mouseout",this.createShadowWrapper((function(o){$.wiki(e.mouseout.join(" "))})))}});
// end mouseover.min.js
// dialog-api-macro-set.min.js, for SugarCube 2, by Chapel
// v1.3.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
Macro.add("dialog",{tags:["onopen","onclose"],handler:function(){var t="",s=null,n=null,o=this.args.length>0?this.args[0]:"",e=this.args.length>1?this.args.slice(1).flatten():[];this.payload.forEach((function(o,e){0===e?t=o.contents:"onopen"===o.name?s=s?s+o.contents:o.contents:n=n?n+o.contents:o.contents})),e.push("macro-"+this.name),Dialog.setup(o,e.join(" ")),Dialog.wiki(t),s&&"string"==typeof s&&s.trim()&&$(document).one(":dialogopened",(function(){$.wiki(s)})),n&&"string"==typeof n&&n.trim()&&$(document).one(":dialogclosed",(function(){$.wiki(n)})),Dialog.open()}}),Macro.add("popup",{handler:function(){if(this.args.length<1)return this.error("need at least one argument; the passage to display");if(!Story.has(this.args[0]))return this.error("the passage "+this.args[0]+"does not exist");var t=this.args[0],s=this.args.length>1?this.args[1]:"",n=this.args.length>2?this.args.slice(2).flatten():[];n.push("macro-"+this.name),Dialog.setup(s,n.join(" ")),Dialog.wiki(Story.get(t).processText()),Dialog.open()}}),Macro.add("dialogclose",{skipArgs:!0,handler:function(){Dialog.close()}});
// end dialog-api-macro-set.min.js
// events.min.js, for SugarCube 2, by Chapel
// v2.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
setup.eventMacroNamespace="macro-event",Macro.add("trigger",{handler:function(){var t;return this.args.length>2||0===this.args.length?this.error("incorrect number of arguments"):"string"!=typeof this.args[0]?this.error("first argument should be a string and a valid event type"):(t=this.args[0],void(1===this.args.length||this.args[1]&&"string"==typeof this.args[1]&&"document"===this.args[1].toLowerCase().trim()?$(document):$(this.args[1])).trigger(t))}}),Macro.add(["event","on","one"],{tags:["which"],handler:function(){var t,r,s=this.payload,e="on",n="",a="";return this.args.length>3||0===this.args.length?this.error("incorrect number of arguments"):"string"!=typeof this.args[0]?this.error("first argument should be a string and a valid event type"):(2===this.args.length&&"string"==typeof this.args[1]&&"once"!==this.args[1]&&(n=this.args[1]),(this.args.includes("once")||"one"===this.name)&&(e="one"),t=this.args[0],void $(document)[e](t+"."+setup.eventMacroNamespace,n,(function(t){if(a=s[0].contents,s.length>1)for(r=1;r<s.length;r++)s[r].args.includes(t.which)&&(a+=s[r].contents);new Wikifier(null,a)})))}}),Macro.add("off",{handler:function(){var t;return this.args.length>2||0===this.args.length?this.error("incorrect number of arguments"):"string"!=typeof this.args[0]?this.error("first argument should be a string and a valid event type or namespace"):(t=this.args[0],void(1===this.args.length||this.args[1]&&"string"==typeof this.args[1]&&"document"===this.args[1].toLowerCase().trim()?$(document):$(this.args[1])).off(t))}});
// end events.min.js
// simple-inventory.min.js, for SugarCube 2, by Chapel
// v2.3.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var r={tryGlobal:!0,defaultStrings:{empty:"The inventory is empty...",listDrop:"Discard",separator:"\n"}};function i(r,i,t,n){$(document).trigger({type:"initialized"===n?":inventory-init":":inventory-update",instance:r,receiving:i,moved:t,context:n})}function t(r){if(r=r?(r=[].slice.call(arguments)).flatten():[],!(this instanceof t))return new t(r);this.inv=r,i(this,null,r=r.length?r:null,"initialized")}Object.assign(t,{is:function(r){return r instanceof t},log:function(r){return t.is(r)?"Inventory.log() -> "+r.toArray().join(" - "):"Inventory.log() -> object is not an inventory..."},removeDuplicates:function(r){if(t.is(r)){var i,n=r.toArray();return i=[],n.forEach((function(r){i.includes(r)||i.push(r)})),i}}}),Object.assign(t.prototype,{transfer:function(r){if(arguments.length<2)return this;if(!t.is(r))return this;for(var n=[].slice.call(arguments),e=[],s=0,a=(n=n.slice(1).flatten()).length;s<a;s++)this.inv.includes(n[s])&&(this.inv.delete(n[s]),e.push(n[s]));return e.length?(r.inv=r.inv.concat(e),i(this,r,e,"transfer"),this):this},has:function(){var r=[].slice.call(arguments).flatten();return!(!r||!r.length)&&this.inv.includesAny(r)},hasAll:function(){var r=[].slice.call(arguments).flatten();return!(!r||!r.length)&&this.inv.includesAll(r)},pickUp:function(r){var t=[].slice.call(arguments).flatten(),n=this;return t&&t.length&&("unique"!==r&&"unique"!==t[0]||(t=function(r){var i=[];return r.forEach((function(r){n.inv.includes(r)||i.includes(r)||i.push(r)})),i}(t=t.splice(1))),this.inv=this.inv.concat(t),i(this,null,t,"pickup")),this},drop:function(){var r,t=[].slice.call(arguments).flatten(),n=this;if(t&&t.length){var e=[];t.forEach((function(i){n.has(i)&&(e.push(i),r=n.inv.indexOf(i),n.inv.deleteAt(r))})),i(this,null,e,"drop")}return this},sort:function(){return this.inv=this.inv.sort(),i(this,null,null,"sort"),this},show:function(i){return i&&"string"==typeof i||(i=r.defaultStrings.separator),this.inv.length?this.inv.join(i):r.defaultStrings.empty},empty:function(){var r=clone(this.inv);return this.inv=[],i(this,null,r,"drop"),this},toArray:function(){return this.inv},count:function(r){if(r&&"string"==typeof r){var i=0;return this.toArray().forEach((function(t){t===r&&i++})),i}return this.toArray().length},isEmpty:function(){return 0===this.toArray().length},linkedList:function(i,n){i&&t.is(i)||(i=!1);var e=this.toArray(),s=this,a=$(document.createElement("span"));return e&&e.length?(e.forEach((function(t,e,o){var l=$(document.createElement("span")),u=$(document.createElement("a")),h=n||r.defaultStrings.drop,c=function(r,i){var t=Math.random().toString(36).substring(7);return arguments.length<2&&(r=Math.random().toString(36).substring(7),i=random(99)),"simple-inv-"+i+"-"+Date.now()+"-"+r.replace(/[^A-Za-z0-9]/g,"")+"-"+t}(t,e);u.wiki(h).addClass("simple-inv drop-link"),u.ariaClick((function(){i?s.transfer(i,t):s.drop(t),$("#"+c).empty()})),l.attr("id",c).addClass("simple-inv link-listing").wiki(t+" ").append(u),e<o.length-1&&l.wiki("<br />"),a.append(l)})),a):(a.wiki(r.defaultStrings.empty),a)},constructor:t,toJSON:function(){return JSON.reviveWrapper("new setup.Inventory("+JSON.stringify(this.inv)+")")},clone:function(){return new t(this.inv)}}),setup.Inventory=t,setup.simpleInv={inventory:t},r.tryGlobal&&(window.Inventory=window.Inventory||t),Macro.add("newinventory",{handler:function(){if(this.args.length<1)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');Wikifier.setValue(r,new t(this.args.slice(1).flatten()))}}),Macro.add("pickup",{handler:function(){if(this.args.length<2)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");i.pickUp(this.args.slice(1).flatten())}}),Macro.add("drop",{handler:function(){if(this.args.length<2)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");i.drop(this.args.slice(1).flatten())}}),Macro.add("transfer",{handler:function(){if(this.args.length<3)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");var n=this.args[1].trim();if("$"!==n[0]&&"_"!==n[0])return this.error('variable name "'+this.args[1]+'" is missing its sigil ($ or _)');var e=Wikifier.getValue(n);if(!t.is(e))return this.error("variable "+n+" is not an inventory!");i.transfer(e,this.args.slice(2).flatten())}}),Macro.add("dropall",{handler:function(){if(1!==this.args.length)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");i.empty()}}),Macro.add("clear","dropall",!1),Macro.add("sort",{handler:function(){if(1!==this.args.length)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");i.sort()}}),Macro.add("inventory",{handler:function(){if(this.args.length<1||this.args.length>2)return this.error("incorrect number of arguments");var r=this.args[0].trim();if("$"!==r[0]&&"_"!==r[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var i=Wikifier.getValue(r);if(!t.is(i))return this.error("variable "+r+" is not an inventory!");var n=$(document.createElement("span")),e=!!this.args[1]&&this.args[1];n.wiki(i.show(e)).addClass("macro-"+this.name).appendTo(this.output)}}),Macro.add("linkedinventory",{handler:function(){if(this.args.length<2||this.args.length>3)return this.error("incorrect number of arguments");var r=!1,i="",n=this.args[1].trim(),e="string"==typeof this.args[0]&&this.args[0];if(!e)return this.error("first argument should be the link text");if("$"!==n[0]&&"_"!==n[0])return this.error('variable name "'+this.args[1]+'" is missing its sigil ($ or _)');var s=Util.slugify(n);s=this.name+"-"+s;var a=Wikifier.getValue(n);if(!t.is(a))return this.error("variable "+n+" is not an inventory!");if(this.args.length>2){if("$"!==(i=this.args[2].trim())[0]&&"_"!==i[0])return this.error('variable name "'+this.args[2]+'" is missing its sigil ($ or _)');if(r=Wikifier.getValue(i),!t.is(r))return this.error("variable "+i+" is not an inventory!")}a.linkedList(r,e).attr({id:s,"data-rec":i,"data-self":n,"data-action":e}).addClass("macro-"+this.name).appendTo(this.output)}})}();
// end simple-inventory.min.js
// css-macro.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";function t(t){if(t.length%2!=0)return"Style rules should be a list of key/value pairs; you've passed an odd number.";var r={};return t.forEach((function(e,n){n%2==0&&(r[e]=t[n+1])})),r}function r(t,r){try{return"string"==typeof r?r:(t instanceof jQuery||(t=$(t)),t.css(r))}catch(t){return t.message}}Macro.add("css",{handler:function(){var e=function(){try{var e,n=[].slice.call(arguments).flatten(),s=n.shift();return"string"==typeof n[0]?e=t(n):"object"==typeof n[0]&&(e=clone(n[0])),r(s,e)}catch(t){return t.message}}(this.args);if("string"==typeof e)return this.error(e)}})}();
// end css-macro.min.js
// articles.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var e=new Map,r=["eunuch","eucalyptus","eugenics","eulogy","euphemism","euphony","euphoria","eureka","european","euphemistic","euphonic","euphoric","euphemistically","euphonically","euphorically","heir","heiress","herb","homage","honesty","honor","honour","hour","honest","honorous","honestly","hourly","one","ouija","once","ubiquitous","ugandan","ukrainian","unanimous","unicameral","unified","unique","unisex","universal","urinal","urological","useful","useless","usurious","usurped","utilitarian","utopic","ubiquitously","unanimously","unicamerally","uniquely","universally","urologically","usefully","uselessly","usuriously"],i=["a","an"],t=/[aeiou8]/i,n=/[A-Z]+$/,u=/[UFHLMNRSX]/,a=/[.,\/#!$%\^&\*;:{}=\-_`~()]/g;function o(e){return"a"===e?"an":"a"}function s(r,t,n){var u;return State.length>0?(u="cannot add article override -> needs to be run in StoryInit special passage or earlier",console.error(u),u):t&&"string"==typeof t?(r&&"string"==typeof r&&(r=r.toLowerCase().trim()),i.includes(r)?(t=t.trim(),void(n?e.set(t,{article:r,caseSensitive:!!n}):e.set(t.toLowerCase(),{article:r,caseSensitive:!!n}))):(u='cannot add article override -> invalid article, must be "a" or "an"',console.error(u),u)):(u="cannot add article override -> invalid word",console.error(u),u)}function l(e){var i;return i=t.test(e.first())?"an":"a",function(e,i){return!!r.includes(e.toLowerCase())&&o(i)}(e,i)||function(e,r){return!(!n.test(e)||!u.test(e.first()))&&o(r)}(e,i)||i}function c(r){if(r&&"string"==typeof r){var i=r.trim().split(" ")[0].trim();return function(r){var i=(r=r.trim()).toLowerCase();if(e.has(i)||e.has(r)){var t=e.get(i)||e.get(r);return t.caseSensitive&&!e.has(r)?null:t.article}return null}(i=i.replace(a,""))||l(i)}}function h(e,r){if(!e||"string"!=typeof e)return e;var i=c(e);return(r?i.toUpperFirst():i)+" "+e}setup.articles={find:c,output:h,override:s},Macro.add("setarticle",{handler:function(){var e=s(this.args[0],this.args[1],this.args[2]);e&&"string"==typeof e&&this.error(e)}}),Macro.add(["a","an","A","An"],{handler:function(){var e=this.name.first()===this.name.first().toUpperCase();this.output.append(h(String(this.args[0]),e))}})}();
// end articles.min.js
// operations.min.js, for SugarCube 2, by Chapel
// v1.1.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var e=e||{},r=!0,t=!0,n=[0,100];function o(e,r){var t,n=[],o=0,i=1;if("string"==typeof e)n=e.split("d");else if("number"==typeof e&&r)n=[e,r];else{if(!(Array.isArray(e)&&e.length>=2))throw new TypeError("dice(): could not process arguments...");e.length=2,n=e}if(n[0]=Number(n[0]),"string"==typeof n[1]&&"F"===n[1].trim().toUpperCase()?(n[1]=3,i=-1):n[1]=Number(n[1]),n.some((function(e){return Number.isNaN(e)})))throw new TypeError("dice(): could not process arguments...");for(t=0;t<n[0];t++){o+=Math.floor(State.random()*n[1])+i}return o}function i(e,r){if("string"==typeof e){var t=[(n=e.trim().replace(/\s/g,"").match(/(\d+[d][\df]\d*)(.*)/i))[1],Number(n[2])];return o(t[0])+t[1]}return o(e,r);var n}e.dice={roll:i},r&&(window.dice=window.dice||i),Number.prototype.dice||Object.defineProperty(Number.prototype,"dice",{configurable:!0,writable:!0,value:function(e){if(0===this)return 0;if(this<0)throw new TypeError("Number.prototype.dice: cannot roll a negative number of dice!");if(("string"!=typeof e||"F"!==e.trim().toUpperCase())&&(null==e||"number"!=typeof e||e<=0||!Number.isInteger(e)))throw new TypeError("Number.prototype.dice: error in argument");if(!Number.isInteger(this))throw new TypeError("Number.prototype.dice: cannot roll partial dice!");return i(this,e)}}),Number.prototype.fairmath||Object.defineProperty(Number.prototype,"fairmath",{configurable:!0,writable:!0,value:function(e){var r=n;if(this<r[0]||this>r[1])throw new TypeError("Number.prototype.fairmath called on a number that is out of the defined range (the number was "+this+").");if(null==e||"number"!=typeof e||e>100||e<-100||arguments.length<1)throw new TypeError("Number.prototype.fairmath given incorrect argument or an argument that is out of the valid 0-100 range.");if(0===e)return Math.clamp(Math.trunc(this),r[0],r[1]);if(e<0)return e*=-1,Math.clamp(Math.trunc(this-(this-r[0])*(e/r[1])),r[0],r[1]);if(e>0)return Math.clamp(Math.trunc(this+(r[1]-this)*(e/r[1])),r[0],r[1]);throw new Error("Number.prototype.fairmath encountered an unspecified error.")}}),Number.prototype.between||Object.defineProperty(Number.prototype,"between",{configurable:!0,writable:!0,value:function(e,r){if("number"!=typeof e||"number"!=typeof r)throw new TypeError("Number.between() -> both values must be numbers");var t=Number(this);if(e===r)return t===e;if(r<e){var n=r;r=e,e=n}return t>=e&&t<=r}}),Math.fairmath||Object.defineProperty(Math,"fairmath",{configurable:!0,writable:!0,value:function(e,r){return e.fairmath(r)}}),Math.between||Object.defineProperty(Math,"between",{configurable:!0,writable:!0,value:function(e,r,t){return e.between(r,t)}}),t&&(Math.fm||Object.defineProperty(Math,"fm",{configurable:!0,writable:!0,value:function(e,r){return e.fairmath(r)}}),Number.prototype.fm||Object.defineProperty(Number.prototype,"fm",{configurable:!0,writable:!0,value:function(e){return this.fairmath(e)}}),Number.prototype.d||Object.defineProperty(Number.prototype,"d",{configurable:!0,writable:!0,value:function(e){return this.dice(e)}}))}();
// end operations.min.js
// disable.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var a=["button","fieldset","input","menuitem","optgroup","option","select","textarea"];Macro.add("disable",{tags:null,handler:function(){var t,i,e,s=$(document.createElement("span")).addClass("macro-"+this.name).wiki(this.payload[0].contents);try{t=this.args.raw.trim()?!!Scripting.evalJavaScript(this.args.full):void 0}catch(a){return this.error("bad evaluation: "+a.message)}!function(a,t){a instanceof $||(a=$(a)),a.ariaDisabled(void 0===t||!!t),function(a){a.ariaIsDisabled()?a.addClass("disabled"):a.removeClass("disabled")}(a)}((i=s,e=$(i).find(a.join(",")).first(),e[0]||(e=$(i).children().eq(0))[0]?e:$(i)),t),$(this.output).append(s)}})}();
// end disable.min.js
// fading-macro-set.min.js, for SugarCube 2, by Chapel
// v1.1.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
Macro.add("fadein",{tags:null,handler:function(){var t,a,s=$(document.createElement("span")),e=this.payload[0].contents;if(0===this.args.length)return this.error("no arguments given");t=Util.fromCssTime(this.args[0]),a=this.args.length>1?Util.fromCssTime(this.args[1]):0,s.wiki(e).addClass("macro-"+this.name).appendTo(this.output).hide().delay(a).fadeIn(t)}}),Macro.add("fadeout",{tags:null,handler:function(){var t,a,s=$(document.createElement("span")),e=this.payload[0].contents;if(0===this.args.length)return this.error("no arguments given");t=Util.fromCssTime(this.args[0]),a=this.args.length>1?Util.fromCssTime(this.args[1]):0,s.wiki(e).addClass("macro-"+this.name).appendTo(this.output).delay(a).fadeOut(t)}});
// end fading-macro-set.min.js
// ui-macro.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){var s={update:UIBar.setStoryElements,stow:UIBar.stow,unstow:UIBar.unstow,toggle:function(){$("#ui-bar").hasClass("stowed")?UIBar.unstow():UIBar.stow()},hide:function(){$("#ui-bar").css("display","none")},show:function(){$("#ui-bar").css("display","block")},kill:function(){$("#ui-bar").css("display","none"),$("#story").css("margin-left","2.5em")},restore:function(){$("#ui-bar").css("display","block"),$("#story").css("margin-left","20em")},jump:UI.jumpto,saves:UI.saves,restart:UI.restart,settings:UI.settings,share:UI.share,aliases:{refresh:"update",reload:"update",destroy:"kill",revive:"restore",jumpto:"jump",save:"saves",load:"saves",setting:"settings",sharing:"share"}},r=Object.keys(s);function t(t){return t&&"string"==typeof t?function(s){return r.includes(s)}(t=t.toLowerCase().trim())||(t=function(r){return s.aliases[r]||null}(t))?(s[t](),!1):'Command "'+t+'" is not a valid command.':"Command is not a string."}Macro.add("ui",{handler:function(){Array.isArray(this.args)&&this.args.length||this.error("No commands passed to macro.");var s,r=function(s){if(!Array.isArray(s))return"Command list error.";var r=[];return s.forEach((function(s){r.push(t(s))})),r}(this.args.flatten());s=(r=r.filter((function(s){return"string"==typeof s}))).join(" "),r.length&&s&&this.error(s)}})}();
// end ui-macro.min.js
// message-macro.min.js, for SugarCube 2, by Chapel
// v1.0.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
setup.messageMacro={},setup.messageMacro.default="Help",Macro.add("message",{tags:null,handler:function(){var e=this.payload[0].contents,a=$(document.createElement("span")),s=$(document.createElement(this.args.includes("btn")?"button":"a")),t=$(document.createElement("span"));s.wiki(this.args.length>0&&"btn"!==this.args[0]?this.args[0]:setup.messageMacro.default).ariaClick(this.createShadowWrapper((function(){a.hasClass("open")?t.css("display","none").empty():t.css("display","block").wiki(e),a.toggleClass("open")}))),a.attr("id","macro-"+this.name+"-"+this.args.join("").replace(/[^A-Za-z0-9]/g,"")).addClass("message-text").append(s).append(t).appendTo(this.output)}});
// end message-macro.min.js
// swap-macro-set.min.js, for SugarCube 2, by Chapel
// v1.1.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var t=!0,a=!0,e="violet",s="red",r="swappable";setup.swap=setup.swap||{};var n=null;function i(a){var e=function(){return a};setup.swap.current=e,t&&(window.swapCurrent=e)}function o(a,o){var p=$(document.createElement("span"));return $(document.createElement("a")).wiki(a).css("color",e).attr({"data-swap-flag":"false","data-orig-content":a,"data-wiki-code":o||""}).addClass(r).appendTo(p).ariaClick((function(a){a.preventDefault();var r=$(this);if("true"===r.attr("data-swap-flag"))r.attr("data-swap-flag","false").css("color",e),n=null;else if(n){var o=n.text(),p=r.text(),l=n.attr("data-wiki-code"),c=r.attr("data-wiki-code");n.attr("data-swap-flag","false").css("color",e).empty().wiki(p),r.attr("data-swap-flag","false").css("color",e).empty().wiki(o),l&&"string"==typeof l&&l.trim()&&(i(p),$.wiki(l)),c&&"string"==typeof c&&c.trim()&&(i(o),$.wiki(c)),setup.swap.current&&"function"==typeof setup.swap.current&&delete setup.swap.current,t&&window.swapCurrent&&"function"==typeof window.swapCurrent&&delete window.swapCurrent,n=null}else n=r,r.attr("data-swap-flag","true").css("color",s)})),p}function p(){n=null,$("a."+r).each((function(){var t=$(this);t.empty().wiki(t.attr("data-orig-content")).attr("data-swap-flag","false").css("color",e)}))}Macro.add("swap",{tags:["onswap"],skipArgs:!0,handler:function(){var t=this.payload[0].contents,a=this.payload[1]?this.payload[1].contents:"",e=this.output,s=this.name;o(t,a).addClass("macro-"+s).appendTo(e)}}),Macro.add("resetswap",{handler:function(){var t=this.args&&this.args[0]&&"string"==typeof this.args[0]?this.args[0]:"Reset";$(document.createElement(a?"button":"a")).wiki(t).ariaClick({label:"Reset all swappable elements."},(function(t){t.preventDefault(),p()})).appendTo(this.output)}}),setup.swap.create=o,setup.swap.reset=p}();
// end swap-macro-set.min.js
// cycles.min.js, for SugarCube 2, by Chapel
// v2.1.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var e="%%cycles",t=!0,r="cycles.pause",i="cycles.pause.menu",s="cycles.postdisplay";function n(){return State.variables[e]}function a(e,t){if(!(this instanceof a))return new a(e,t);if(!e||"object"!=typeof e)throw new Error("Cycle() -> invalid definition object");if(!e.name||"string"!=typeof e.name||!e.name.trim())throw new Error("Cycle() -> invalid name");if(this.name=e.name,!e.phases||!Array.isArray(e.phases)||e.phases.length<2)throw new Error("Cycle() -> phases should be an array of at least two strings");if(!e.phases.every((function(e){return e&&"string"==typeof e&&e.trim()})))throw new Error("Cycle() -> each phase should be a valid, non-empty string");this.phases=clone(e.phases),e.period=Number(e.period),(Number.isNaN(e.period)||e.period<1)&&(e.period=1),Number.isInteger(e.period)||(e.period=Math.trunc(e.period)),this.period=e.period,e.increment=Number(e.increment),(Number.isNaN(e.increment)||e.increment<1)&&(e.increment=1),Number.isInteger(e.increment)||(e.increment=Math.trunc(e.increment)),this.increment=e.increment,this.active=void 0===e.active||!!e.active,t=Number(t),(Number.isNaN(t)||t<0)&&(t=0),Number.isInteger(t)||(t=Math.trunc(t)),this.stack=t}State.variables[e]={},Object.assign(a,{is:function(e){return e instanceof a},add:function(e,t){if(!t||"object"!=typeof t)throw new Error("Cycle.add() -> invalid definition object");if(e&&"string"==typeof e&&e.trim())t.name=e;else if(!t.name||"string"!=typeof t.name||!t.name.trim())throw new Error("Cycle.add() -> invalid name");var r=new a(t,0);return n()[t.name]=r,r},has:function(e){var t=n();return t.hasOwnProperty(e)&&a.is(t[e])},get:function(e){return a.has(e)?n()[e]:null},del:function(e){return!!a.has(e)&&(delete n()[e],!0)},check:function(e){if(a.has(e)){var t=[].slice.call(arguments).flatten().slice(1);return a.get(e).check(t)}},clear:function(e){n()},_emit:function(e,t){$(document).trigger({type:":cycle-"+t,cycle:e})},_retrieveCycles:n}),Object.assign(a.prototype,{constructor:a,revive:function(){var e={};return Object.keys(this).forEach((function(t){e[t]=clone(this[t])}),this),e},clone:function(){return new a(this.revive(),this.stack)},toJSON:function(){return JSON.reviveWrapper("new setup.Cycle("+JSON.stringify(this.revive())+", "+this.stack+")")},current:function(){return this.phases[Math.trunc(this.stack/this.period)%this.phases.length]},length:function(){return this.period*this.phases.length},turns:function(){return this.period/this.increment},turnsTotal:function(){return this.length()/this.increment},update:function(e){e=Number(e),Number.isNaN(e)&&(e=this.increment);var t=this.current();return this.stack+=e,this.stack<0&&(this.stack=0),Number.isInteger(this.stack)||(this.stack=Math.trunc(this.stack)),t!==this.current()&&a._emit(this,"change"),this},reset:function(){return this.stack=0,a._emit(this,"reset"),this.update(0)},suspend:function(){var e=this.active;return this.active=!1,e!==this.active&&a._emit(this,"suspend"),this},resume:function(){var e=this.active;return this.active=!0,e!==this.active&&a._emit(this,"resume"),this},toggle:function(){return this.active?this.suspend():this.resume(),this},isSuspended:function(){return!this.active},editIncrement:function(e){return e=Number(e),(!Number.isNaN(e)||e>0)&&(Number.isInteger(e)||(e=Math.trunc(e)),this.increment=e),this.increment},check:function(){var e=[].slice.call(arguments).flatten();return e.includes(this.current())}}),postdisplay[s]=function(){var e;tags().includes(r)||e?e=!1:tags().includes(i)?e=!0:Object.keys(n()).forEach((function(e){var t=a.get(e);t.active&&t.update()}))},setup.Cycle=a,t&&(window.Cycle=window.Cycle||a),Macro.add("newcycle",{tags:["phase"],handler:function(){if(this.args.length<1)return this.error("A cycle must at least be given a name.");if(this.payload.length<2)return this.error("A cycle must be given at least two phases.");var e=this.payload.slice(1).map((function(e){return function(e){if(e.args.length<1)return null;var t=e.args.flatten();return t.every((function(e){return"string"==typeof e}))?t:null}(e)})).flatten();if(e.includes(null))return this.error("Each `<<phase>>` tag must be given a valid name.");try{a.add(this.args[0],{phases:e,period:this.args[1],increment:this.args[2],active:this.args[3]&&"string"==typeof this.args[3]&&"suspend"!==this.args[3].trim()})}catch(e){var t=e.message&&e.message.split("->")[1];return t=!!t&&t.trim(),this.error(t||e.message)}}}),Macro.add("editcycle",{handler:function(){if(this.args.length<1||"string"!=typeof this.args[0]||!this.args[0].trim())return this.error("You must name the cycle you wish to act on.");if(this.args.length<2)return this.error("You must provide an action to perform.");var e=a.get(this.args[0]);if(null===e)return this.error('Cannot find a cycle named "'+this.args[0]+'".');if(this.args.includes("suspend")?e.suspend():this.args.includes("toggle")?e.toggle():this.args.includes("resume")&&e.resume(),this.args.includes("increment")){var t=this.args[this.args.indexOf("increment")+1];"number"==typeof t&&e.editIncrement(t)}if(this.args.includesAny("reset","clear")&&e.reset(),this.args.includes("change")){var r=this.args[this.args.indexOf("change")+1];r=Number(r),!Number.isNaN(r)&&Number.isInteger(r)&&e.update(r)}}}),Macro.add("showcycle",{handler:function(){if(this.args.length<1||"string"!=typeof this.args[0]||!this.args[0].trim())return this.error("You must name the cycle you wish to act on.");var e=a.get(this.args[0]);if(null===e)return this.error('Cannot find a cycle named "'+this.args[0]+'".');var t=e.current();this.args.includes("uppercase")?t=t.toUpperCase():this.args.includes("lowercase")?t=t.toLowerCase():this.args.includes("upperfirst")&&(t=t.toUpperFirst()),$(document.createElement("span")).addClass("macro-"+this.name).append(t).appendTo(this.output)}})}();
// end cycles.min.js
// continue.min.js, for SugarCube 2, by Chapel
// v1.0.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var n=["a",":button",'*[role="button"]',".continue-macro-ignore","#ui-bar","#ui-dialog"],t=0;function o(){$(document).on("click.continue-macro keyup.continue-macro",n.join(", "),(function(n){n.stopPropagation()}))}function e(){if(State.length>0)return!1;var t=[].slice.call(arguments).flatten();return n=n.concat(t),!0}function c(n,o){var e=function(){var n="."+Date.now().toString(36)+"-"+t;return t++,n}();if(o&&"function"==typeof o){var c="click.continue-macro"+e;n&&(c=c+" keyup.continue-macro"+e),$(document).one(c,(function(){o.call(),$(document).off(e)}))}}prehistory["%%continue-expiration"]=function(){t=0},$(document).one(":passagerender",(function(){o()})),Macro.add("ignore",{handler:function(){if(!e(this.args))return this.error("the <<ignore>> macro should only be run from StoryInit or equivalent.")}}),Macro.add("cont",{tags:null,handler:function(){var n,t=this.args.includes("append"),o=this.args.includesAny("key","keypress","press","button"),e=this.payload[0].contents;t&&(n=$(document.createElement("span")).addClass("macro-"+this.name).appendTo(this.output)),c(o,this.createShadowWrapper((function(){t&&n&&n instanceof $?n.wiki(e):$.wiki(e)})))}}),setup.cont=c,setup.cont.ignore=e,setup.cont.reset=function(){var t=[].slice.call(arguments).flatten();n=n.concat(t),$(document).off(".continue-macro"),o()},window.cont=window.cont||setup.cont}();
// end continue.min.js
// speech.min.js, for SugarCube 2, by Chapel
// v1.1.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var a=new Map;function t(t,e,r){if(void 0===r&&e&&(r=e,e=null),State.length)throw new Error("addCharacter() -> must be called before story starts");t&&r?(a.has(t)&&console.error('addCharacter() -> overwriting character "'+t+'"'),a.set(t,{displayName:e,image:r})):console.error("addCharacter() -> invalid arguments")}function e(t,e,r,s){var n=$(document.createElement("div")).addClass(Util.slugify(e)+" say"),i=a.has(e)?a.get(e).image:null,o=$(document.createElement("img")).attr("src",s||i||"");o.attr("src")&&o.attr("src").trim()&&n.append(o);var c=e.toUpperFirst();return a.has(e)&&a.get(e).displayName&&(c=a.get(e).displayName),n.append($(document.createElement("p")).wiki(c)).append($(document.createElement("p")).wiki(r)),t&&(t instanceof $||(t=$(t)),n.appendTo(t)),n}setup.say=e,setup.addCharacter=t,Macro.add("character",{handler:function(){t(this.args[0],this.args[1],this.args[2])}}),$(document).one(":passagestart",(function(){var t=Array.from(a.keys());t.push("say"),Macro.add(t,{tags:null,handler:function(){"say"!==this.name?e(this.output,this.name,this.payload[0].contents):e(this.output,this.args[0],this.payload[0].contents,this.args[1])}})}))}();
// end speech.min.js
// popover.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";function o(o,i){i=function(){return[].slice.call(arguments).flatten().filter((function(o){return o&&"string"==typeof o&&o.trim()}))||[]}(i),$("#ui-overlay, #ui-dialog").addClass("popover"),$("#ui-overlay, #ui-dialog, #ui-dialog-body").addClass(i),i.includesAny("noclick","no-click")&&$("#ui-overlay").removeClass("ui-close"),Dialog.setup("","popover"),Dialog.wiki(o),Dialog.open(),$(document).one(":dialogclosed",(function(){$("#ui-overlay").addClass("ui-close"),$("#ui-overlay, #ui-dialog").removeClass("popover"),$("#ui-overlay, #ui-dialog, #ui-dialog-body").removeClass(i)}))}Macro.add("popover",{tags:null,handler:function(){o(this.payload[0].contents,this.args)}}),Macro.add("dismisspopover",{skipArgs:!0,handler:function(){$("ui-overlay").hasClass("popover")&&Dialog.close()}}),setup.popover=o}();
// end popover.min.js
// type-sim.min.js, for SugarCube 2, by Chapel
// v2.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";Macro.add("typesim",{tags:null,handler:function(){if(!this.args.length||!this.args[0]||"string"!=typeof this.args[0])return this.error("no text to type out was provided");var t,e=$(document.createElement("span")).addClass("macro"+this.name),n=$(document.createElement("div"));this.payload[0].contents&&this.payload[0].contents.trim()&&(t=this.payload[0].contents),function(t,e,n){if(t&&"string"==typeof t){!e||e instanceof $||(e=$(e));var i=0,s=t.split(""),a=[],o=$(document.createElement("textarea")).addClass("type-sim").on("input.type-sim",(function(){var e=$(this);i=a.push(s[i]),e.val(a.join("")),t.length===a.length&&(e.off("input.type-sim").ariaDisabled(!0),n&&"function"==typeof n&&n(a.join("")),$(document).trigger({type:":type-sim-end",message:a.join("")}))}));e&&e[0]&&e.append(o)}}(this.args[0],e,(function(){n.wiki(t)})),e.append(n).appendTo($(this.output))}})}();
// end type-sim.min.js
// first-macro.min.js, for SugarCube 2, by Chapel
// v1.1.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
Macro.add("first",{skipArgs:!0,tags:["then","finally"],handler:function(){var a,t=$(document.createElement("span")),n=this.payload[this.payload.length-1],s=visited()-1;a=s<this.payload.length?this.payload[s].contents:"finally"===n.name?n.contents:"",t.wiki(a).addClass("macro-"+this.name).appendTo(this.output)}});
// end first-macro.min.js
// preload.min.js, for SugarCube 2, by Chapel
// v1.0.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";function t(t,e){var n=0,r=t.length;t.forEach((function(t){!function(t,e){var n=new Image;n.onload=e,n.onerror=e,n.src=t}(t,(function(){++n===r&&e()}))}))}function e(){return State.length<=0}function n(){var n=[].slice.call(arguments).flatten(),r=!!e()&&LoadScreen.lock();return t(n,(function(){r&&LoadScreen.unlock(r)})),r}setup.preload=n,setup.preload.force=!1,Macro.add("preload",{handler:function(){if(!e()&&!setup.preload.force)return this.error("Attempting to preload images outside of `StoryInit` or similar can cause performance issues. Set `setup.preload.force` to `true` if you want to do it anyway.");n(this.args.flatten().filter((function(t){return"string"==typeof t})))}})}();
// end preload.min.js
// fs.min.js, for SugarCube 2, by Chapel
// v1.1.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){function t(t){return console.error(t),null}function e(e){try{return JSON.stringify(e)}catch(e){return t(e)}}function r(r){try{var a;if(void 0===r)return null;if(null!=(a="string"!=typeof r?e(r):r))return LZString.compressToBase64(a)}catch(e){return t(e)}}function a(e){try{return LZString.decompressFromBase64(e)}catch(e){return t(e)}}function n(e){try{return JSON.parse(e)}catch(r){try{return JSON.parse(a(e))}catch(e){return t(e)}}}function i(e,r){try{if("$"!==r[0]&&"_"!==r[0])throw new Error("Invalid stateful variable");State.setVar?State.setVar(r,clone(e)):"$"===r[0]?State.variables[r.substr(1)]=clone(e):State.temporary[r.substr(1)]=clone(e)}catch(e){return t(e)}}function s(r,a){if("string"!=typeof a&&(a=e(a)),null!=a){(r=r&&"string"==typeof r?Util.slugify(r.trim()).toLowerCase():"file.twinedata").includes(".")||(r+=".twinedata");try{saveAs(new Blob([a],{type:"text/plain;charset=UTF-8"}),r)}catch(e){return t(e)}}}function o(e){var r=e.target.files[0],s=new FileReader,o=e.storyVar||"$fileData",c=e.dataType||"text";$(s).on("load",(function(e){try{var r=e.currentTarget;if(!r.result)return;var s=function(t,e){if(null==e)return null;switch(t){case"json":return n(e);case"base64":case"b64":case"64":return n(a(e));default:return e}}(c,r.result);i(s,o),$(document).trigger({type:":import-macro",success:!0,data:clone(s),raw:r.result,storyVar:o})}catch(e){return i(null,o),$(document).trigger({type:":import-macro",success:!1,data:null,raw:null,storyVar:o}),t(e)}})),s.readAsText(r)}function c(t,e,r,a,n){var i,s=function(t,e,r,a){var n=$(document.createElement(a?"a":"button")).wiki(t),i=$(document.createElement("label")).attr("for","file-import").addClass("upload-file").append(n),s=$(document.createElement("input")).attr({id:"file-import",type:"file","data-format":r}).css("display","none").on("change",(function(t){o(Object.assign(clone(t),{storyVar:e,dataType:$(this).attr("data-format")}))})),c=$(document.createElement("span")).append(i,s);return n.ariaClick((function(){i.trigger("click")})),c}(e,r,a,n);i=t&&"string"==typeof t?$(t):t||"#passages",s.appendTo(i)}setup.fileSystem={config:{defaultText:"Import",renderAsLink:!1},JSON:{stringify:e,parse:n},b64:{compress:r,decompress:a},toState:i,toFile:s,fromFile:o},window.Chapel=window.Chapel||{},Chapel.fileSystem=Chapel.fileSystem||setup.fileSystem,Macro.add("import",{handler:function(){var t=this.output,e=this.args[2],r=this.args[0],a=this.args[1];if(e&&"string"==typeof e||(e=setup.fileSystem.config.defaultText),!r||"string"!=typeof r||"$"!==r[0]&&"_"!==r[0])return this.error("Invalid variable name.");c(t,e,r,a=a&&"string"==typeof a?a.trim():"text",setup.fileSystem.config.renderAsLink)}}),Macro.add("export",{handler:function(){var t=this.args[0],a=this.args[1],n=this.args[2];if(!t)return this.error("No data to save...");n=n&&"string"==typeof n?n.trim():"text",function(t,a,n){var i;switch(n){case"json":i=e(t);break;case"base64":case"b64":case"64":i=r(e(t)||t);break;default:i="string"==typeof t?t:e(t)}s(a,i)}(t,a=a&&"string"==typeof a?a.trim():"file.twinedata",n)}})}();
// end fs.min.js
// playtime.min.js, for SugarCube 2, by Chapel
// v2.1.0, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){"use strict";var e=!0,t="playtime",a="pausetimer";function n(){return Date.now()-State.variables[t]}function r(e){if(e&&!(e<0)&&"number"==typeof e){var t=[];return t.push(Math.floor(e/1e3)%60),t.push(Math.floor(e/6e4)%60),t.push(Math.floor(e/36e5)),t}}State.variables[t]=Date.now(),predisplay["start-playtime"]=function(e){delete predisplay[e],State.variables[t]||(State.variables[t]=Date.now())},prehistory["pause-playtime"]=function(e){tags().includes(a)&&(State.variables[t]+=time())};var i=["h","hr","hrs","hour","hours"],s=["m","min","mins","minute","minutes"],u=["s","sec","secs","second","seconds"];function o(e){return function(e,t){if(e&&Array.isArray(e)&&!(e.length<3)){var a=e[2]<10?"0"+e[2]:""+e[2],n=e[1]<10?"0"+e[1]:""+e[1],r=e[0]<10?"0"+e[0]:""+e[0];return t?"<b>"+a+":"+n+"</b>:"+r:a+":"+n+":"+r}}(r(n()),e)}setup.playTime=function(e){return"string"==typeof e?function(e){var t=n(),a=r(t);return i.includes(e)?a[2]:s.includes(e)?a[1]:u.includes(e)?a[0]:t}(e):o(e)},e&&(window.playTime=window.playTime||setup.playTime),Macro.add("playtime",{handler:function(){var e=this.args.map((function(e){return String(e).trim().toLowerCase()})),t=$(document.createElement("span")),a=o(e.includesAny(["format","f","fmt","b","bold","true"]));t.wiki(a).addClass("macro-"+this.name).appendTo(this.output)}})}();
// end playtime.min.js
// notify.min.js, for SugarCube 2, by Chapel
// v1.1.1, 2021-04-20, 53d1a20e9321b3782a303cf7dbe00f5c51e947db
!function(){var s=/\d+m?s$/;function e(s,e,t){"string"==typeof s&&("number"!=typeof e&&(e=!1),$(document).trigger({type:":notify",message:s,delay:e,class:t||""}))}$(document.body).append("<div id='notify'></div>"),$(document).on(":notify",(function(s){s.message&&"string"==typeof s.message&&(s.message.trim(),s.class?"string"==typeof s.class?s.class="open macro-notify "+s.class:Array.isArray(s.class)?s.class="open macro-notify "+s.class.join(" "):s.class="open macro-notify":s.class="open macro-notify",s.delay?("number"!=typeof s.delay&&(s.delay=Number(s.delay)),Number.isNaN(s.delay)&&(s.delay=2e3)):s.delay=2e3,$("#notify").empty().wiki(s.message).addClass(s.class),setTimeout((function(){$("#notify").removeClass()}),s.delay))})),Macro.add("notify",{tags:null,handler:function(){var t=this.payload[0].contents,a=!1,n=!1;if(this.args.length>0){var i=s.test(this.args[0]);"number"==typeof this.args[0]||i?(a=i?Util.fromCssTime(this.args[0]):this.args[0],n=this.args.length>1&&this.args.slice(1).flatten()):n=this.args.flatten().join(" ")}e(t,a,n)}}),setup.notify=e}();
// end notify.min.js
/* twine-user-script #31: "meters.js" */
(function () {
    'use strict';
    // meters.js, by Chapel; for SugarCube 2
    // v1.0.1

    var options = {
        tryGlobal : true, // attempt to send `Meter` to the global scope?
        allowClobbering : true, // allow a new meter to replace a previously defined meter with the same name instead of throwing
        IAmAGrownUp : true // make sure you have enough rope to hang yourself
    };


    var defaultSettings = {
        full : '#2ECC40', // color when the bar is full
        empty : '#FF4136', // color when the bar is empty
        back : '#DDDDDD', // color of the backing
        height : '12px', // height of the bar
        width : '180px', // width of the bar
        animate : false, // ms
        easing : 'swing', // animation easing
        text : '#111111', // label text color
        label : '', // label text
        align : 'center' // label alignment
    };

    var _validAlignments = ['center', 'left', 'right'];
    var _validEasing = ['swing', 'linear'];

    function _handleString (str, def) {
        if (str && typeof str === 'string') {
            str = str.toLowerCase().trim();
            if (str) {
                return str;
            }
        }
        return def || '';
    }

    function _colorEasing (t) {
        // from: https://gist.github.com/gre/1650294
        return (t < 0.5) ? 2 * t * t : -1 + (4 - 2 * t) *t;
    }

    function Meter (opts, value) {
        if (!(this instanceof Meter)) {
            return new Meter(opts, value);
        }

        var defs = clone(defaultSettings);

        this.settings = Object.assign(defs, opts);

        // default malformed settings

        this.settings.align = _handleString(this.settings.align);
        this.settings.easing = _handleString(this.settings.easing);

        if (!_validAlignments.includes(this.settings.align)) {
            this.settings.align = 'center';
        }

        if (!_validEasing.includes(this.settings.easing)) {
            this.settings.easing = 'swing';
        }

        // set the value, or default to 1

        value = Number(value);
        if (Number.isNaN(value)) {
            value = 1;
        }
        value = Math.clamp(value, 0, 1);
        this.value = value;

        // the backing of the meter, and the container
        var $wrapper = $(document.createElement('div'))
            .addClass('chapel-meter')
            .attr({
                'data-val' : value,
                'data-label' : this.settings.label
            })
            .css({
                'position' : 'relative',
                'background-color' : this.settings.back,
                'height' : this.settings.height,
                'width' : this.settings.width,
                'overflow' : 'hidden',
				'border-radius' : '3px'
            });

        // the meter's label
        var $label = $(document.createElement('div'))
            .addClass('meter-label')
            .css({
                'top' : 0,
                'right' : 0,
                'font-size' : this.settings.height,
                'font-weight' : 'bold',
                'line-height' : '100%',
                'width' : '100%',
                'height' : '100%',
                'vertical-align' : 'middle',
                'text-align' : this.settings.align,
                'color' : this.settings.text,
                'z-index' : 1,
                'position' : 'relative',
                'bottom' : '100%'
            })
            .wiki(this.settings.label)
            .appendTo($wrapper);

        // this is just here to give the bar a smooth transitioning coloration
        var $barTop = $(document.createElement('div'))
            .addClass('meter-top')
            .css({
                'background-color' : this.settings.full,
                'opacity' : _colorEasing(this.value),
                'width' : '100%',
                'height' : '100%',
                'z-index' : 0
            });

        // this actually holds the value and the 'real' bar color
        var $barBottom = $(document.createElement('div'))
            .addClass('meter-bottom')
            .css({
                'position' : 'absolute',
                'top' : 0,
                'left' : 0,
                'background-color' : this.settings.empty,
                'opacity' : 1,
                'width' : (this.value * 100) + '%',
                'height' : '100%',
                'z-index' : 0
            })
            .append($barTop)
            .appendTo($wrapper);

        this.$element = $wrapper;
        this.$bars = { // undocumented
            top : $barTop,
            bottom : $barBottom
        };
        this.$label = $label; // undocumented

        // mostly a reminder
        $label.css('font-size', (parseInt($wrapper.css('height'), 10) < parseInt($('.passage').css('font-size'), 10)) ? 
            $wrapper.css('height') : $('.passage').css('font-size'));
        $label.css('line-height', $wrapper.css('height'));
    }

    Object.assign(Meter, {
        _list : new Map(), // undocumented; meter data dump
        is : function (thing) { // see if passed "thing" is a meter instance
            return thing instanceof Meter;
        },
        has : function (name) { // does the named meter exist?
            return Meter._list.has(name) && Meter.is(Meter._list.get(name));
        },
        get : function (name) { // return the meter instance
            if (Meter.has(name)) {
                return Meter._list.get(name);
            }
            return null;
        },
        del : function (name) { // delete the meter with the indicated name
            if (Meter.has(name)) {
                Meter._list.delete(name);
            }
        },
        add : function (name, opts, value) { // add a new meter; the constructor should not be used
            if (Meter.has(name) && !options.allowClobbering) {
                console.error('Meter "' + name + '" already exists.');
                return;
            }
            var meter = new Meter(opts, value);
            Meter._list.set(name, meter);
            return meter;
        },
        _emit : function (inst, name) { // undocumented; emit an event on the given meter
            if (!Meter.is(inst)) {
                return;
            }
            inst.$element.trigger({
                type : ':' + name,
                meter : inst
            });
        }
    });

    Object.assign(Meter.prototype, {
        constructor : Meter,
        _label : function (wait) { // undocumented; reprocess the meter label and set the sizes
            // THE LABEL IS AN ACTUAL NIGHTMARE
            var self = this;
            function process () {
                self.$label.empty().wiki(self.settings.label);
                self.$label.css('font-size', (parseInt(self.$element.css('height'), 10) < parseInt(self.$element.parent().css('font-size'), 10)) ? 
                    self.$element.css('height') : self.$element.parent().css('font-size'));
                self.$label.css('line-height', self.$element.css('height'));
            }
            if (wait) {
                setTimeout(process, Engine.minDomActionDelay);
            } else {
                process();
            }
            return this;
        },
        _width : function () { // undocumented; change the meter width
            var self = this;
            this.$bars.bottom.animate({
                'width' : (this.value * 100) + '%'
            }, this.settings.animate, this.settings.easing, function () {
                Meter._emit(self, 'meter-animation-complete');
            });
            return this;
        },
        _color : function () { // undocumented; blend the full and empty meter colors
            this.$bars.top.animate({
                'opacity' : _colorEasing(this.value)
            }, this.settings.animate, this.settings.easing);
            return this;
        },
        animate : function () { // animate bar changes
            Meter._emit(this, 'meter-animation-start');
            return this._color()._width()._label();
        },
        val : function (n) { // set and get bar value
            if (n !== undefined) {
                n = Number(n);
                if (Number.isNaN(n)) {
                    n = 1;
                }
                n = Math.clamp(n, 0, 1);

                this.value = n;
                this.animate();
            }
            return this.value;
        },
        options : function (opts) {
            // set or get bar settings
            if (opts && typeof opts === 'object') {
                Object.assign(this.settings, opts);
            }
            return this.settings;
        },
        unwrap : function () {
            // return unwrapped container element
            return this.$element[0];
        },
        place : function ($target, options) { // put the bar in a known element, with a wrapper
            var $wrapper = $(document.createElement('span'));
            if (!($target instanceof jQuery)) {
                $target = $($target);
            }
            if (!$target[0]) {
                console.warn('meter#place() -> no valid target');
            }
            if (options && typeof options === 'object') {
                // options can contain classes or attributes for the wrapper
                if (options.classes && (Array.isArray(options.classes) || typeof options.classes === 'string')) {
                    $wrapper.addClass(options.classes);
                }
                if (options.attr && typeof options.attr === 'object') {
                    $wrapper.attr(options.attr);
                }
            }
            $target.append($wrapper.append(this.$element));
            // make sure to process the label
            this._label(true);
            return this;
        },
        // event methods for meters
        on : function (eventType, cb) {
            if (typeof cb !== 'function') {
                return this;
            }
            if (!eventType || typeof eventType !== 'string' || !eventType.trim()) {
                return this;
            }
            eventType = eventType.split(' ').map( function (type) {
                type = type.split('.')[0];
                return type + '.userland';
            }).join(' ');
            this.$element.on(eventType, cb);
            return this;
        },
        one : function (eventType, cb) {
            if (typeof cb !== 'function') {
                return this;
            }
            if (!eventType || typeof eventType !== 'string' || !eventType.trim()) {
                return this;
            }
            eventType = eventType.split(' ').map( function (type) {
                type = type.split('.')[0];
                return type + '.userland';
            }).join(' ');
            this.$element.one(eventType, cb);
            return this;
        },
        off : function (eventType) {
            if (eventType && typeof eventType === 'string' && eventType.trim()) {
                eventType = eventType.split(' ').map( function (type) {
                    type = type.split('.')[0];
                    return type + '.userland';
                }).join(' ');
            } else {
                eventType = '.userland'; // remove all user events
            }
            this.$element.off(eventType);
            return this;
        },
        // ariaClick-style setup
        click : function (options, cb) {
            // let SugarCube handle the errors
            this.$element.ariaClick(options, cb);
            return this;
        },
        // for completeness and in case a meter winds up in the state
        clone : function () {
            return new Meter(this.settings, this.value);
        },
        toJSON : function () {
            return JSON.reviveWrapper('new setup.Meter(' + JSON.stringify(this.settings) + ', ' + this.value + ')');
        }
    });

    // setup-spaced API
    setup.Meter = Meter;

    if (options.tryGlobal) { // global API, if undefined
        window.Meter = window.Meter || Meter;
    }

    // <<newmeter '$variable' [optional: starting value (between 0 and 1)]>>...<</newmeter>>
    // optional child tags: <<metercolors full [empty] [backing]>>, <<metersizing height [width]>>, <<meteranimation timeOrBool [easing]>>, <<meterlabel labelText [textColor] [alignment]>>
    Macro.add('newmeter', {
        tags : ['colors', 'sizing', 'animation', 'label'],
        handler : function () {

            if (State.length > 0 && !options.IAmAGrownUp) {
                // you are not a grown up
                return this.error('The `<<newmeter>>` macro must be called in your `StoryInit` special passage. Seriously. No excuses. --Love, Chapel');
            }

            if (this.args.length < 1) {
                return this.error('The `<<newmeter>>` macro requires at least one argument: a meter name.');
            }

            var meterName = this.args[0], 
                colorsTag = null, 
                sizeTag = null, 
                animTag = null,
                labelTag = null;

            if (typeof meterName !== 'string') {
                return this.error('Invalid meter name.');
            }

            meterName = meterName.trim();

            if (Meter.has(meterName) && !options.allowClobbering) {
                return this.error('Cannot clobber the existing meter "' + meterName + '".');
            }

            if (this.payload.length) {
                // get each child tag for processing
                colorsTag = this.payload.find( function (pl) {
                    return pl.name === 'colors';
                });
                sizeTag = this.payload.find( function (pl) {
                    return pl.name === 'sizing';
                });
                animTag = this.payload.find( function (pl) {
                    return pl.name === 'animation';
                });
                labelTag = this.payload.find( function (pl) {
                    return pl.name === 'label';
                });
            }

            var opts = {};

            if (colorsTag) {
                // process the colors tag
                if (!colorsTag.args.length) {
                    return this.error('No arguments passed to the `<<colors>>` tag.');
                }

                switch (colorsTag.args.length) {
                    case 1:
                        opts.empty = colorsTag.args[0];
                        opts.full = 'transparent'; // make the meter one solid color
                        break;
                    case 2:
                        opts.full = colorsTag.args[0];
                        opts.empty = colorsTag.args[1];
                        break;
                    default:
                        opts.full = colorsTag.args[0];
                        opts.empty = colorsTag.args[1];
                        opts.back = colorsTag.args[2];
                }
            }

            if (sizeTag) {
                // process the sizin tag
                if (!sizeTag.args.length) {
                    return this.error('No arguments passed to the `<<sizing>>` tag.');
                }

                opts.width = sizeTag.args[0];

                if (sizeTag.args[1]) {
                    opts.height = sizeTag.args[1];
                }

            }

            if (animTag) {
                // process the animations tag
                if (!animTag.args.length) {
                    return this.error('No arguments passed to the `<<animation>>` tag.');
                }

                if (typeof animTag.args[0] === 'boolean' && !animTag.args[0]) {
                    opts.animate = 0; // functionally no animation--we still want the event, though, so we'll just 0 it out
                } else if (typeof animTag.args[0] === 'string') {
                    opts.animate = Util.fromCssTime(animTag.args[0]);
                } else {
                    return this.error('The argument to the `<<animation>>` tag should be `true`, `false`, or a valid CSS time value.');
                }

                if (animTag.args[1] && ['swing', 'linear'].includes(animTag.args[1])) {
                    opts.easing = animTag.args[1];
                }
            }

            if (labelTag) {
                // process the label tag
                var text = labelTag.args[0];
                if (text && typeof text === 'string') {
                    opts.label = text.trim();
                } else {
                   return this.error('The labelText argument for the `<<label>>` tag is required.');
                }

                if (labelTag.args[1] && typeof labelTag.args[1] === 'string') {
                    opts.text = labelTag.args[1];
                }
                if (labelTag.args[2] && typeof labelTag.args[2] === 'string') {
                    opts.align = labelTag.args[2];
                }
            }

            Meter.add(meterName, opts, this.args[1]);

        }
    });

    // <<showmeter '$variable' [value]>>
    Macro.add('showmeter', {
        handler : function () {

            if (this.args.length < 1) {
                return this.error('This macro requires at least one argument: the meter\'s name.');
            }

            // get the meter
            var meterName = this.args[0];

            if (typeof meterName !== 'string') {
                return this.error('Invalid meter name.');
            }

            meterName = meterName.trim();

            var meter = Meter.get(meterName);

            if (!meter || !Meter.is(meter)) {
                return this.error('The meter "' + meterName + '" does not exist.');
            }

            // set the meter, if necessary
            if (typeof this.args[1] === 'number') {
                meter.val(this.args[1]);
            }

            // render the meter
            meter.place(this.output, {
                classes : 'macro-' + this.name,
                attr : { id : 'meter-' + Util.slugify(meterName) }
            });

        }
    });

    // <<updatebar '$variable' value>>
    Macro.add('updatemeter', {
        handler : function () {

            if (this.args.length < 2) {
                return this.error('This macro requires two arguments: the meter\'s name and a value.');
            }

            // get the meter
            var meterName = this.args[0];

            if (typeof meterName !== 'string') {
                return this.error('Invalid meter name.');
            }

            meterName = meterName.trim();

            var meter = Meter.get(meterName);

            if (!meter || !Meter.is(meter)) {
                return this.error('The meter "' + meterName + '" does not exist.');
            }

            // set it
            meter.val(this.args[1]); // if it's on the page, should update and animate auto-magically.

        }
    });

}());
/* twine-user-script #32: "ctp.js" */
window.CTP = function (config) {
  this.id = "";
  this.selector = "";
  this.stack = [];
  
  this.log = {
    index: 0,
    clear: [0],
    nobr: [],
    transition: []
  };
  
  Object.keys(config).forEach(function (pn) {
    this[pn] = clone(config[pn]);
  }, this);
};

CTP.prototype.add = function (entry) {
  var _this = this;
  var mods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  this.stack.push(entry);
  mods.replace("t8n", "transition").split(" ").forEach(function (el) {
    if (el) _this.log[el].pushUnique(_this.stack.length - 1);
  }, this);
  return this;
};

CTP.prototype.ctpEntry = function (index) {
  if (index < 0 || index >= this.stack.length) return "";
  var t8n = this.log.transition.includes(index) ? "macro-ctp-entry-t8n" : "";
  var br = index === 0 || this.log.clear.includes(index) ? " " : this.log.nobr.includes(index) ? " " : "<br>";
  return br + '<span class="macro-ctp-entry macro-ctp-entry-index-' + index + ' ' + t8n + '">' + this.stack[index] + '</span>';
};

CTP.prototype.advance = function () {
  if (this.log.index === this.stack.length - 1) return this;
  var index = ++this.log.index;
  var _el = $(this.selector);
  if (this.log.clear.includes(index)) _el.empty();
  _el.wiki(this.ctpEntry(index));
  return this;
};

CTP.prototype.out = function () {
  var _this2 = this;
  var clear = this.log.clear;
  var clearIndex = this.log.index > 0 ? clear.findIndex(function (el) {
    return el >= _this2.log.index;
  }, this) - 1 : 0;
  var ret = this.stack.map(function (el, index) {
    return index;
  }).slice(clearIndex, this.log.index + 1).reduce(function (acc, cur) {
    return acc + _this2.ctpEntry(cur);
  }, "");
  return ret;
};

CTP.prototype.clone = function () {
  return new CTP(this);
};

CTP.prototype.toJSON = function () {
  var ownData = {};
  Object.keys(this).forEach(function (pn) {
    ownData[pn] = clone(this[pn]);
  }, this);
  return JSON.reviveWrapper('new CTP($ReviveData$)', ownData);
};

Macro.add("ctp", {
  tags: ["ctpNext"],
  handler: function handler() {
    var _id = this.args[0];
    var _selector = "#" + Util.slugify(_id);
    var ctp = new CTP({
      id: _id,
      selector: _selector
    });
    this.payload.forEach(function (el, index) {
      var _args = el.args;
      if (el.name === "ctp") _args.reverse().pop();
      ctp.add(el.contents.trim(), _args.join(" "));
    });
    variables()["#macro-ctp-dump"] = variables()["#macro-ctp-dump"] || {};
    variables()["#macro-ctp-dump"][_id] = ctp;
    $(this.output).wiki('<span id="' + Util.slugify(_id) + '" class="macro-ctp-wrapper">' + ctp.out() + '</span>');
  }
});

Macro.add("ctpAdvance", {
  handler: function handler() {
    var _id = this.args[0];
    variables()["#macro-ctp-dump"] = variables()["#macro-ctp-dump"] || {};
    var ctp = variables()["#macro-ctp-dump"][_id];
    if (ctp) {
      ctp.advance();
      if (ctp.log.index === ctp.stack.length - 1) {
        delete variables()["#macro-ctp-dump"][_id];
      }
    }
  }
});

$(document).on(':passageinit', function () {
  delete variables()["#macro-ctp-dump"];
});
/* twine-user-script #33: "linkdropdown.js" */
/*
    Copyright Kronwiz.
    This file is part of https://github.com/kronwiz/twineworks repository.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

function linkdropdown_getRandomInt(max) {
  return Math.floor(Math.random() * Math.floor(max));
}

function linkdropdown_click( e ) {
	var $link = $(e.target);
	var offset = $link.outerHeight();
	var dd_id = $link.attr("dd_id");
	var $dropdown = $("#" + dd_id);

	// toggle dropdown visibility status
	if ( $dropdown.css("display") != "block" ) {
		$link.addClass("open");
		$dropdown.css({"top": offset + "px", "display": "block"});
	}
	else {
		$dropdown.css("display", "none");
		$link.removeClass("open");
	}
}

Macro.add('linkdropdown', {
	tags     : null,
	handler  : function () {
		var content = this.payload[0].contents;

		if (this.args.length < 1) {
			return this.error('need at least one argument: the link text');
		}
		var linktext = this.args[0];

		// a fairly good random number to be used for the dropdown <div> id
		var dd_id = "linkdropdown_dropdown_" + linkdropdown_getRandomInt(12345678901234567890);

		var $container = $(document.createElement("span"));
		$container.css("position", "relative");
		$container.addClass("linkdropdown");

		var $link = $(document.createElement("a"));
		// store the dropdown id in the corresponding anchor to be used later on
		$link.attr("dd_id", dd_id);
		$link.on("click", linkdropdown_click);
		$link.addClass("linkdropdown-anchor");
		$link.wiki(linktext);

		var $dropdown = $(document.createElement("div"));
		$dropdown.css({"position": "absolute", "top": "0px", "left": "0px", "display": "none", "z-index": 3});
		$dropdown.attr("id", dd_id);
		$dropdown.addClass("linkdropdown-dropdown");
		$dropdown.wiki(content);

		$container.append($link).append($dropdown);
		$container.appendTo(this.output);
	}
});
/* twine-user-script #34: "live-update.js" */
/* global Scripting, _typeof, toStringOrDefault */

// <<live>> and <<update>> macros, by Cyrus Firheir
// GitHub @ https://github.com/cyrusfirheir/cycy-wrote-custom-macros/tree/master/live-update

(function () {
	"use strict";

	$(document).on(":liveupdate", function () {
		$(".macro-live").trigger(":liveupdateinternal");
	});

	Macro.add(['update', 'upd'], {
		handler: function handler() {
			$(document).trigger(":liveupdate");
		}
	});

	Macro.add(['live', 'l', 'lh'], {
		skipArgs: true,
		handler: function handler() {
			if (this.args.full.length === 0) {
				return this.error('no expression specified');
			}
			try {
				var statement = this.args.full;
				var result = toStringOrDefault(Scripting.evalJavaScript(statement), null);
				if (result !== null) {
					var lh = this.name === "lh";
					var $el = $("<span></span>").addClass("macro-live").wiki(lh ? Util.escape(result) : result).appendTo(this.output);
					$el.on(":liveupdateinternal", this.createShadowWrapper(function (ev) {
						var out = toStringOrDefault(Scripting.evalJavaScript(statement), null);
						$el.empty().wiki(lh ? Util.escape(out) : out);
					}));
				}
			} catch (ex) {
				return this.error("bad evaluation: " + (_typeof(ex) === 'object' ? ex.message : ex));
			}
		}
	});

	Macro.add(['liveblock', 'lb'], {
		tags: null,
		handler: function handler() {
			try {
				var content = this.payload[0].contents.trim();
				if (content) {
					var $el = $("<span></span>").addClass("macro-live macro-live-block").wiki(content).appendTo(this.output);
					$el.on(":liveupdateinternal", this.createShadowWrapper(function (ev) {
						$el.empty().wiki(content);
					}));
				}
			} catch (ex) {
				return this.error("bad evaluation: " + (_typeof(ex) === 'object' ? ex.message : ex));
			}
		}
	});
})();
/* twine-user-script #35: "numberpool-macro-set.min.js" */
/*! <<numberpool>> macro set for SugarCube v2 */
!function(){"use strict";if("undefined"==typeof version||void 0===version.title||"SugarCube"!==version.title||void 0===version.major||version.major<2||void 0===version.minor||version.minor<5)throw new Error("<<numberpool>> macro set requires SugarCube 2.5.0 or greater, aborting load");Macro.add("numberinput",{handler:function(){function validateAndApply(el,addend){var curValue=Math.trunc(Wikifier.getValue(varName)),newValue=Math.trunc(el.value),newPoolValue=null;if(Number.isNaN(newValue)||!Number.isFinite(newValue))return el.value=curValue,!1;if(null!=addend&&(newValue+=addend),newValue<minValue?newValue=minValue:newValue>maxValue&&(newValue=maxValue),null!==pool){var poolValue=pool.get(),delta=(newValue-curValue)*poolCost;delta<0?newPoolValue=poolValue-delta:delta>0&&poolValue>=poolCost?(poolValue<delta&&(newValue=curValue+Math.trunc(poolValue/poolCost),delta=poolValue-poolValue%poolCost),newPoolValue=poolValue-delta):newValue=curValue}return Wikifier.setValue(varName,newValue),el.value=newValue,null!==newPoolValue&&pool.set(newPoolValue),!0}var _this=this;if(this.args.length<4){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("default value"),this.args.length<3&&errors.push("min value"),this.args.length<4&&errors.push("max value"),this.error("no "+errors.join(" or ")+" specified")}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var varId=Util.slugify(varName),defValue=Number(this.args[1]),minValue=Number(this.args[2]),maxValue=Number(this.args[3]),poolCost=1,autofocus=!1;if(this.args.length>5?(poolCost=Number(this.args[4]),autofocus="autofocus"===this.args[5]):this.args.length>4&&("autofocus"===this.args[4]?autofocus=!0:poolCost=Number(this.args[4])),Number.isNaN(defValue)||!Number.isFinite(defValue)||Math.trunc(defValue)!==defValue)return this.error("default value ("+this.args[1]+") is not a whole number");if(Number.isNaN(minValue)||!Number.isFinite(minValue)||Math.trunc(minValue)!==minValue)return this.error("min value ("+this.args[2]+") is not a whole number");if(Number.isNaN(maxValue)||!Number.isFinite(maxValue)||Math.trunc(maxValue)!==maxValue)return this.error("max value ("+this.args[3]+") is not a whole number");if(Number.isNaN(poolCost)||!Number.isFinite(poolCost)||Math.trunc(poolCost)!==poolCost||poolCost<=0)return this.error("pool cost ("+this.args[4]+") is not a whole number greater than zero");if(defValue<minValue)return this.error("default value ("+this.args[1]+") is less than min value ("+this.args[2]+")");if(defValue>maxValue)return this.error("default value ("+this.args[1]+") is greater than max value ("+this.args[3]+")");var pool=function(){var parent=_this.contextSelect(function(ctx){return"numberpool"===ctx.name});return null!==parent&&parent.hasOwnProperty("pool")?parent.pool:null}();Config.debug&&this.debugView.modes({block:!0});var $elControl=jQuery(document.createElement("div")),$elInput=jQuery(document.createElement("input"));$elControl.attr("id",this.name+"-body-"+varId).addClass("macro-"+this.name).appendTo(this.output),jQuery(document.createElement("button")).attr({id:this.name+"-minus-"+varId,tabindex:0}).text("").on("click",function(){return validateAndApply($elInput[0],-1)}).appendTo($elControl),$elInput.attr({id:this.name+"-input-"+varId,name:this.name+"-input-"+varId,type:"text",pattern:"\\d+",tabindex:0}).on("change",function(){validateAndApply(this)}).on("keypress",function(ev){13===ev.which&&(ev.preventDefault(),$elInput.trigger("change"))}).appendTo($elControl),jQuery(document.createElement("button")).attr({id:this.name+"-plus-"+varId,tabindex:0}).text("").on("click",function(){return validateAndApply($elInput[0],1)}).appendTo($elControl),$elInput.val(defValue),validateAndApply($elInput[0]),autofocus&&($elInput.attr("autofocus","autofocus"),postdisplay["#autofocus:"+$elInput.attr("id")]=function(task){delete postdisplay[task],setTimeout(function(){return $elInput.focus()},Engine.minDomActionDelay)})}}),Macro.add("numberpool",{tags:["onchange"],handler:function(){if(0===this.args.length)return this.error("no variable name specified");if(this.payload.length>2)return this.error("multiple <<onchange>> sections specified");if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var curValue=Wikifier.getValue(varName);if("number"!=typeof curValue||Number.isNaN(curValue)||!Number.isFinite(curValue))return this.error("pool value is not a number");var varId=Util.slugify(varName);TempState.hasOwnProperty(this.name)||(TempState[this.name]={}),TempState[this.name].hasOwnProperty(varId)||(TempState[this.name][varId]=0),Object.defineProperty(this,"pool",{value:Object.defineProperties({},{get:{value:function(){return Wikifier.getValue(varName)}},set:{value:function(content){return function(value){value!==Wikifier.getValue(varName)&&(Wikifier.setValue(varName,value),content&&new Wikifier(null,content))}}(this.payload.length>1?this.payload[1].contents.trim():"")}})}),jQuery(document.createElement("div")).attr("id",this.name+"-"+varId+"-"+TempState[this.name][varId]++).addClass("macro-"+this.name).wiki(this.payload[0].contents.replace(/^\n/,"")).appendTo(this.output)}}),Macro.add("numberslider",{handler:function(){function stepValidate(value){if(fracDigits>0){var ma=Number(minValue+"e"+fracDigits),sa=Number(stepValue+"e"+fracDigits),_va=Number(value+"e"+fracDigits)-ma;return Number(_va-_va%sa+ma+"e-"+fracDigits)}var va=value-minValue;return va-va%stepValue+minValue}function validateAndApply(el){var curValue=Wikifier.getValue(varName),newValue=Number(el.value),newPoolValue=null;if(Number.isNaN(newValue)||!Number.isFinite(newValue))return el.value=curValue,!1;if(newValue=stepValidate(newValue),newValue<minValue?newValue=minValue:newValue>maxValue&&(newValue=maxValue),null!==pool)if(fracDigits>0){var pa=Number(pool.get()+"e"+fracDigits),ca=Number(curValue+"e"+fracDigits),na=Number(newValue+"e"+fracDigits),delta=na-ca;pa<delta&&(na-=delta-pa,delta=na-ca,newValue=Number(na+"e-"+fracDigits)),newPoolValue=Number(pa-delta+"e-"+fracDigits)}else{var poolValue=pool.get(),_delta=newValue-curValue;poolValue<_delta&&(newValue-=_delta-poolValue,_delta=newValue-curValue),newPoolValue=poolValue-_delta}return Wikifier.setValue(varName,newValue),el.value=newValue,null!==newPoolValue&&pool.set(newPoolValue),!0}var _this2=this;if(this.args.length<5){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("default value"),this.args.length<3&&errors.push("min value"),this.args.length<4&&errors.push("max value"),this.args.length<5&&errors.push("step value"),this.error("no "+errors.join(" or ")+" specified")}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'+this.args[0]+'" is missing its sigil ($ or _)');var varId=Util.slugify(varName),defValue=Number(this.args[1]),minValue=Number(this.args[2]),maxValue=Number(this.args[3]),stepValue=Number(this.args[4]),autofocus=this.args.length>5&&"autofocus"===this.args[5];if(Number.isNaN(defValue)||!Number.isFinite(defValue))return this.error("default value ("+this.args[1]+") is not a number");if(Number.isNaN(minValue)||!Number.isFinite(minValue))return this.error("min value ("+this.args[2]+") is not a number");if(Number.isNaN(maxValue)||!Number.isFinite(maxValue))return this.error("max value ("+this.args[3]+") is not a number");if(Number.isNaN(stepValue)||!Number.isFinite(stepValue)||stepValue<=0)return this.error("step value ("+this.args[4]+") is not a number greater than zero");if(defValue<minValue)return this.error("default value ("+this.args[1]+") is less than min value ("+this.args[2]+")");if(defValue>maxValue)return this.error("default value ("+this.args[1]+") is greater than max value ("+this.args[3]+")");var fracDigits=function(){var str=String(stepValue),pos=str.lastIndexOf(".");return-1===pos?0:str.length-pos-1}();if(stepValidate(maxValue)!==maxValue)return this.error("max value ("+this.args[3]+") is not a multiple of the step value ("+this.args[4]+") plus the min value ("+this.args[2]+")");var pool=function(){var parent=_this2.contextSelect(function(ctx){return"numberpool"===ctx.name});return null!==parent&&parent.hasOwnProperty("pool")?parent.pool:null}();Config.debug&&this.debugView.modes({block:!0});var $elControl=jQuery(document.createElement("div")),$elInput=jQuery(document.createElement("input")),$elValue=void 0,showValue=void 0;$elControl.attr("id",this.name+"-body-"+varId).addClass("macro-"+this.name).appendTo(this.output),$elInput.attr({id:this.name+"-input-"+varId,name:this.name+"-input-"+varId,type:"range",min:minValue,max:maxValue,step:stepValue,tabindex:0}).on("change input."+Util.slugify(this.name),function(){validateAndApply(this),"function"==typeof showValue&&showValue()}).on("keypress",function(ev){13===ev.which&&(ev.preventDefault(),$elInput.trigger("change"))}).appendTo($elControl),!Browser.isIE||Browser.ieVersion>9?($elValue=jQuery(document.createElement("span")).attr("id",this.name+"-value-"+varId).appendTo($elControl),showValue=function(){$elValue.text(Number($elInput.val()).toFixed(fracDigits))}):$elInput.off("input."+Util.slugify(this.name)),$elInput.val(defValue),validateAndApply($elInput[0]),"function"==typeof showValue&&showValue(),autofocus&&($elInput.attr("autofocus","autofocus"),postdisplay["#autofocus:"+$elInput.attr("id")]=function(task){delete postdisplay[task],setTimeout(function(){return $elInput.focus()},Engine.minDomActionDelay)})}})}();
/* twine-user-script #36: "scrolldown.js" */
/*
	<<scrolldown [duration]>>

	Credit to The Mad Exile

	duration : (optional) The length of time to animate the scroll, as the
	           strings 'fast' or 'slow' or a valid CSS time value (e.g. 5s
	           and 500ms).  The default duration is 'slow'.
*/
Macro.add('scrolldown', {
	handler : function () {
		var tar   = document.scrollingElement || 'html,body';
		var duration;

		if (this.args.length > 0) {
			switch (this.args[0]) {
			case 'fast':
			case 'slow':
				duration = this.args[0];
				break;
			default:
				try {
					duration = Math.max(Engine.minDomActionDelay, Util.fromCssTime(this.args[0]));
				}
				catch (ex) {
					return this.error(ex.message);
				}
				break;
			}
		}
		else {
			duration = 'slow';
		}

		setTimeout(function () {
			$(tar).animate({
				scrollTop: $(document).height() - $(window).height()
			}, duration);
		}, Engine.minDomActionDelay);
	}
});
/* twine-user-script #37: "shake-macro-set.min.js" */
/*! <<shake>> macro set for SugarCube 2.x */
!function() {
  "use strict";
  if("undefined" == typeof version || "undefined" == typeof version.title || "SugarCube" !== version.title ||
  "undefined" == typeof version.major || version.major<2 || "undefined" == typeof version.minor || version.minor<5) {
    throw new Error("<<shake>> macro requires SugarCube 2.5.0 or greater, aborting load");
  }

  Macro.add("shake",
    {
      tags: null,
      handler: function() {
        var duration = this.args.length>0 ? this.args[0] : 1/0, shakeClass="shake";
        if(1/0 !== duration) try {
          duration = Math.max(Engine.minDomActionDelay, Util.fromCssTime(duration))
        }
        catch(e) {
          return this.error(e.message)
        }
        Config.debug && this.debugView.modes({block:!0});
        var $wrapper = jQuery(document.createElement("span"));
        $wrapper.addClass("macro-"+this.name+" "+shakeClass).wiki(this.payload[0].contents).appendTo(this.output),
        1/0 !== duration && setTimeout(function(){$wrapper.removeClass(shakeClass)}, Engine.minDomActionDelay+duration)
      }
    }
  ),
  Macro.add(["shakescreen","shaketarget"],
    {
      handler: function() {
        var $targets, duration, shakeClass;
        if("shakescreen" === this.name) $targets=jQuery("#passages"), duration = this.args.length>0 ? this.args[0] : 1/0, shakeClass="shake-block";
        else {
          if(0 === this.args.length) return this.error("no selector specified");
          if($targets = jQuery(this.args[0]), 0 === $targets.length) return this.error('no elements matched the selector "'+this.args[0]+'"');
          duration = this.args.length>1 ? this.args[1] : 1/0,
          shakeClass = "block" === jQuery($targets[0]).css("display") ? "shake-block" : "shake"
        }
        if("stop" === duration) return void $targets.removeClass(shakeClass);
        if(1/0 !== duration) try {
          duration = Math.max(Engine.minDomActionDelay,Util.fromCssTime(duration))
        }
        catch(e) {
          return this.error(e.message)
        }
        $targets.addClass(shakeClass), 1/0 !== duration && setTimeout(function(){$targets.removeClass(shakeClass)}, Engine.minDomActionDelay+duration)
      }
    }
  )
}();
</script><tw-passagedata pid="1" name="battle grid setup" tags="nobr" position="100,100" size="100,100">/* Initializes the battle grid. Run as part of the &quot;Preparation&quot; passage.
  To customize, overwrite with a passage of the same name. */

&lt;&lt;set $puppetGrid = []&gt;&gt;
&lt;&lt;for _r = 0; _r &lt; setup.COLUMN_SIZE; _r++&gt;&gt;
    &lt;&lt;set _row to []&gt;&gt;
    &lt;&lt;for _c to 0; _c &lt; setup.ROW_SIZE; _c++&gt;&gt;
        /* Create the object used to store the default properties of a map cell. */
        &lt;&lt;set _cell to {
            id: (&quot;cell_r&quot; + _r + &quot;_c&quot; + _c),
            contents: null,
            movement: []
        }&gt;&gt;
        &lt;&lt;run _row.push(_cell)&gt;&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;run $puppetGrid.push(_row)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _puppet range puppets()&gt;&gt;
  &lt;&lt;set $puppetGrid[_puppet.row-1][_puppet.col-1].contents = _puppet&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;set $enemyGrid = []&gt;&gt;
&lt;&lt;for _r = 0; _r &lt; setup.COLUMN_SIZE; _r++&gt;&gt;
    &lt;&lt;set _row to []&gt;&gt;
    &lt;&lt;for _c to 0; _c &lt; setup.ROW_SIZE; _c++&gt;&gt;
        /* Create the object used to store the default properties of a map cell. */
        &lt;&lt;set _cell to {
            id: (&quot;cell_r&quot; + _r + &quot;_c&quot; + _c),
            contents: null,
            movement: []
        }&gt;&gt;
        &lt;&lt;run _row.push(_cell)&gt;&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;run $enemyGrid.push(_row)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _enemy range enemies()&gt;&gt;
  &lt;&lt;set $enemyGrid[_enemy.row-1][_enemy.col-1].contents = _enemy&gt;&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="2" name="grid actorlist enemies" tags="nobr" position="225,100" size="100,100">&lt;&lt;for _r, _row range $enemyGrid&gt;&gt;
	&lt;&lt;for _c, _cell range _row&gt;&gt;
		&lt;&lt;if _cell.contents instanceof Actor&gt;&gt;
			&lt;&lt;actorBox _cell.contents&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				/* no content; empty box */
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;timed 0s&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#enemies .actors.grid&quot;).css({
	  &quot;grid-template-columns&quot;: `repeat(${setup.ROW_SIZE},1fr)`
	});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/timed&gt;&gt;</tw-passagedata><tw-passagedata pid="3" name="grid actorlist puppets" tags="nobr" position="350,100" size="100,100">&lt;div @class=&quot;_puppetsClass&quot;&gt;
&lt;&lt;if $B.phase == &quot;move&quot; || $B.phase == &quot;command&quot;&gt;&gt;
  &lt;div style=&quot;position:absolute; top:-3em; right:0&quot;&gt;&lt;&lt;backbtn&gt;&gt;&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $B.phase == &quot;selection&quot;&gt;&gt;
  &lt;div id=&quot;endturn&quot; style=&quot;position:absolute; top:-3em; right:0&quot;&gt;
  &lt;&lt;include &quot;End Turn Button&quot;&gt;&gt;
  &lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $B.phase == &quot;command&quot;&gt;&gt;
  &lt;div style=&quot;grid-area: 1 / 2&quot;&gt;
    &lt;&lt;actorBox $subject &quot;grid&quot;&gt;&gt;
  &lt;/div&gt;
  &lt;div style=&quot;grid-area: 2 / 2&quot;&gt;
    &lt;&lt;include &quot;commands&quot;&gt;&gt;
  &lt;/div&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;for _r, _row range $puppetGrid&gt;&gt;
	&lt;&lt;for _c, _cell range _row&gt;&gt;
		&lt;&lt;if _cell.contents instanceof Actor&gt;&gt;
			&lt;&lt;actorBox _cell.contents&gt;&gt;
		&lt;&lt;elseif $B.phase == &quot;move&quot; &amp;&amp; def $subject&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				&lt;&lt;capture _r, _c, _cell&gt;&gt;
				&lt;&lt;link &quot;[MOVE]&quot;&gt;&gt;
					&lt;&lt;set &lt;&lt;set $subject.position = [_r+1,_c+1]&gt;&gt;
					&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
				&lt;&lt;/capture&gt;&gt;
			&lt;/div&gt;
		&lt;&lt;else&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				/* no content; empty box */
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;/div&gt;

&lt;&lt;timed 0s&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#puppets .actors.grid&quot;).css({
	  &quot;grid-template-columns&quot;: `repeat(${setup.ROW_SIZE},1fr)`
	});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/timed&gt;&gt;</tw-passagedata><tw-passagedata pid="4" name="ActorBox Move" tags="nobr" position="475,100" size="100,100">/* For Puppets in the movement phase, their name becomes a link that swaps their position with the subject (except for the subject&#39;s own name) */
&lt;&lt;run console.log(&quot;rendering &quot;+_actor.name+&quot; for movement phase, not subject? &quot;+(_actor !== $subject))&gt;&gt;
&lt;&lt;if _actor instanceof Puppet &amp;&amp; _actor !== $subject&gt;&gt;
  &lt;&lt;capture _actor&gt;&gt;
  &lt;&lt;set _link = `&lt;&lt;link &quot;_actor.name&quot;&gt;&gt;
        &lt;&lt;set $subject.position = [_actor.row,_actor.col]&gt;&gt;
      &lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
    &lt;&lt;/link&gt;&gt;`&gt;&gt;
  &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
    &lt;&lt;print setup.scaledTextDiv(_actor.name,setup.NAME_LENGTH,{bold:true},_link)&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;print _link&gt;&gt;
  &lt;&lt;/if&gt;&gt;
  &lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
  &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
    &lt;&lt;print setup.scaledTextDiv(_actor.name,setup.NAME_LENGTH,{bold:true})&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;print _actor.name&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="5" name="Widget: move command" tags="widget nobr" position="600,100" size="100,100">&lt;&lt;widget &quot;move&quot;&gt;&gt;
&lt;&lt;link &quot;Move&quot;&gt;&gt;
  &lt;&lt;run $(document).trigger(&quot;:move-selected&quot;)&gt;&gt;
  &lt;&lt;set $B.phase = &quot;move&quot;&gt;&gt;
  &lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;movement phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="6" name="movement phase" tags="nobr" position="725,100" size="100,100">&lt;br/&gt;
Click a space to move there or swap positions. Click BACK when done.</tw-passagedata><tw-passagedata pid="7" name="Player Phase" tags="nobr battle" position="850,100" size="100,100">&lt;&lt;set _destinationQueue = []&gt;&gt;
&lt;&lt;specialcheck&gt;&gt;
&lt;&lt;if $B.specialdeath.length &gt; 0&gt;&gt;
	&lt;&lt;set _specialmsg = true&gt;&gt;
	&lt;&lt;set _destinationQueue.push($B.specialdeath.shift())&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;victorycheck&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _destinationQueue.length &gt; 0&gt;&gt;
	&lt;&lt;goto `_destinationQueue[0]`&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set $B.phase = &quot;selection&quot;&gt;&gt;

&lt;&lt;if setup.TURN_MODEL.toLowerCase() === &quot;free&quot;&gt;&gt;
	&lt;&lt;set _doneCount = 0&gt;&gt;
	&lt;&lt;for _puppet range puppets()&gt;&gt;
		&lt;&lt;if (!_puppet.active || _puppet.dead || _puppet.noact) &amp;&amp; !_puppet.down&gt;&gt;
			&lt;&lt;set _doneCount++&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;if !(_destinationQueue.length &gt; 0 || _specialmsg)&gt;&gt;
		&lt;&lt;if setup.AUTO_ENDTURN === true &amp;&amp; _doneCount == puppets().length&gt;&gt;
			&lt;&lt;endRound&gt;&gt;
		&lt;&lt;elseif setup.TURN_EXCHANGE === true &amp;&amp; $B.enemyTurns &gt; 0&gt;&gt;
			&lt;&lt;set $B.phase = null&gt;&gt;
			&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;span id=&quot;actorlist&quot;&gt;
&lt;&lt;include &quot;actorlist&quot;&gt;&gt;
&lt;/span&gt;
&lt;div id=&quot;phase&quot;&gt;

&lt;/div&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="8" name="actorlist" tags="nobr" position="975,100" size="100,100">/* setup */
&lt;&lt;set _queue = new Set()&gt;&gt;
&lt;&lt;set _enemiesClass = &quot;actors enemies&quot;&gt;&gt;
&lt;&lt;set _puppetsClass = &quot;actors&quot;&gt;&gt;
&lt;&lt;include &quot;battle display mods actorlist&quot;&gt;&gt;

&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;set _enemiesClass += &quot; grid&quot;; _puppetsClass += &quot; grid&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;div id=&quot;enemies&quot;&gt;
&lt;&lt;include &quot;actorlist enemies&quot;&gt;&gt;
&lt;/div&gt;

&lt;div id=&quot;battlelines&quot;&gt;
&lt;&lt;include &quot;special battle lines&quot;&gt;&gt;
&lt;/div&gt;

&lt;div id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="9" name="actorlist enemies" tags="nobr" position="1100,100" size="100,100">&lt;div @class=&quot;_enemiesClass&quot;&gt;
&lt;&lt;set _martyr = enemies().find(function (e) { return e.martyr})&gt;&gt; /* check if an enemy martyr exists; used in targeting */
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;include &quot;grid actorlist enemies&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;for _i, _enemy range $enemies&gt;&gt;
	&lt;&lt;set _enemyClass = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;if !_enemy.hidden&gt;&gt;
		&lt;&lt;actorBox _enemy _enemyClass&gt;&gt;
	&lt;&lt;else&gt;&gt;
		/* display nothing */
	&lt;&lt;/if&gt;&gt; /* end hidden if */
&lt;&lt;/for&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="10" name="actorlist puppets" tags="nobr" position="1225,100" size="100,100">&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;include &quot;grid actorlist puppets&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;div @class=&quot;_puppetsClass&quot;&gt;

&lt;&lt;if $B.phase === &quot;command&quot;&gt;&gt;
	&lt;div style=&quot;position:absolute; top:0; right:0&quot;&gt;&lt;&lt;backbtn&gt;&gt;&lt;/div&gt;
	&lt;&lt;actorBox $subject&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
		&lt;&lt;set _puppetClass = &quot;&quot;&gt;&gt;
		&lt;&lt;actorBox _puppet _puppetClass&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;

&lt;&lt;if setup.TURN_MODEL.toLowerCase() === &quot;free&quot; &amp;&amp; $B.phase == &quot;selection&quot;&gt;&gt;
	&lt;br/&gt;
	&lt;div id=&quot;endturn&quot;&gt;
	&lt;center&gt;
	&lt;&lt;include &quot;End Turn Button&quot;&gt;&gt;
	&lt;/center&gt;
	&lt;/div&gt;
	&lt;br/&gt;
	&lt;br/&gt;
	&lt;span id=&quot;quit&quot;&gt;&lt;&lt;include &quot;Quit Button&quot;&gt;&gt;&lt;/span&gt;
	&lt;div id=&quot;roundCounter&quot;&gt;ROUND &lt;&lt;print $B.turnCounter&gt;&gt;&lt;/div&gt;
&lt;&lt;elseif $B.phase == &quot;command&quot;&gt;&gt;
	&lt;br/&gt;
	&lt;&lt;include &quot;commands&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="11" name="End Turn Button" tags="nobr" position="100,225" size="100,100">&lt;&lt;if $B.enemyTurns == 0 || _doneCount == puppets().length&gt;&gt;
	&lt;&lt;button &quot;END TURN&quot;&gt;&gt;
		&lt;&lt;endRound&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;button &quot;ADVANCE TURN&quot;&gt;&gt;
		&lt;&lt;set $B.phase = null&gt;&gt;
		&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="12" name="Quit Button" tags="nobr" position="225,225" size="100,100">&lt;&lt;link &quot;Surrender and return to the Hub&quot;&gt;&gt;&lt;&lt;replace &quot;#quit&quot;&gt;&gt;Really quit? [[Yes|Defeat]] | &lt;&lt;link &quot;No&quot;&gt;&gt;&lt;&lt;replace &quot;#quit&quot;&gt;&gt;&lt;&lt;include &quot;Quit Button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;&lt;&lt;/link&gt;&gt;&lt;&lt;/replace&gt;&gt;&lt;&lt;/link&gt;&gt;</tw-passagedata><tw-passagedata pid="13" name="commands" tags="nobr" position="350,225" size="100,100">&lt;div class=&quot;commandcontainer&quot;&gt;
&lt;div class=&quot;commands&quot;&gt;
	&lt;span id=&quot;actbtn&quot;&gt;&lt;&lt;act $subject&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;span id=&quot;restbtn&quot;&gt;&lt;&lt;rest $subject&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;span id=&quot;itembtn&quot;&gt;&lt;&lt;items $subject&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;&lt;span id=&quot;movebtn&quot;&gt;&lt;&lt;move $subject&gt;&gt;&lt;/span&gt;&lt;br /&gt;&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $B.surrender is true&gt;&gt;
		&lt;&lt;spare $subject&gt;&gt;&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="14" name="status" tags="nobr" position="475,225" size="100,100">&lt;&lt;if def $B.actor &amp;&amp; $B.actor !== null&gt;&gt;

&lt;div class=&quot;statusname&quot;&gt;$B.actor.name&lt;/div&gt;
&lt;div style=&quot;float: right;&quot;&gt;
&lt;&lt;if def setup.STATUS_SCREENS.battle &amp;&amp; setup.STATUS_SCREENS.battle.length &gt; 0&gt;&gt;
&lt;span id=&quot;statusback&quot;&gt;
&lt;&lt;link &quot;&lt;&quot;&gt;&gt;
	&lt;&lt;set $stScreen--&gt;&gt;
	&lt;&lt;if $stScreen &lt; 1&gt;&gt;
		&lt;&lt;set $stScreen = setup.STATUS_SCREENS.battle.length+1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if setup.STATUS_SCREENS.battle[$stScreen-2] == &quot;aggression&quot; &amp;&amp; $B.actor instanceof Puppet&gt;&gt;
		&lt;&lt;set $stScreen--&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;status&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;/span&gt;
&lt;span id=&quot;statusforward&quot;&gt;
&lt;&lt;link &quot;&gt;&quot;&gt;&gt;
	&lt;&lt;set $stScreen++&gt;&gt;
	&lt;&lt;if setup.STATUS_SCREENS.battle[$stScreen-2] == &quot;aggression&quot; &amp;&amp; $B.actor instanceof Puppet&gt;&gt;
		&lt;&lt;set $stScreen++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $stScreen &gt; setup.STATUS_SCREENS.battle.length+1&gt;&gt;
		&lt;&lt;set $stScreen = 1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;status&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;&lt;if $stScreen == 1&gt;&gt;
/* 1 = stat screen, default, unlinked to STATUS_SCREENS and always available */
	&lt;&lt;for _k, _v range $B.actor.stats&gt;&gt;
		&lt;&lt;if !setup.hiddenStats.includes(_k)&gt;&gt;
			&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;:&lt;/span&gt;
			&lt;span class=&quot;stat&quot;&gt;
				&lt;&lt;if $B.actor.maskstats || ($B.actor instanceof Enemy &amp;&amp; def $bestiary &amp;&amp; !$bestiary.fetch($B.actor.name).statsKnown[_k])&gt;&gt;
					&lt;b&gt;??&lt;/b&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;stat _k&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;/span&gt;
			&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;elseif setup.STATUS_SCREENS.battle[$stScreen-2] == &quot;elements&quot;&gt;&gt;
	&lt;div style=&quot;font-size: 12px;&quot;&gt;ELEMENTAL RESISTANCE&lt;/div&gt;&lt;br/&gt;
	&lt;&lt;for _k, _v range $B.actor.elements&gt;&gt;
	&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;&lt;/span&gt;
	&lt;span style=&quot;float:right&quot;&gt;
		&lt;&lt;if def $bestiary &amp;&amp; $B.actor instanceof Enemy &amp;&amp; !$bestiary.fetch($B.actor.name).statsKnown[_k]&gt;&gt;
			&lt;&lt;if setup.SOAK&gt;&gt;?? /&lt;&lt;/if&gt;&gt;&lt;div style=&quot;display: inline-block; min-width:55px; text-align:right&quot;&gt;???%&lt;/div&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;if setup.SOAK&gt;&gt;&lt;&lt;soak _v&gt;&gt; /&lt;&lt;/if&gt;&gt;&lt;div style=&quot;display: inline-block; min-width:55px; text-align:right&quot;&gt;&lt;&lt;res _v&gt;&gt;&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;/span&gt;
	&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;elseif setup.STATUS_SCREENS.battle[$stScreen-2] == &quot;ailments&quot;&gt;&gt;
	&lt;div style=&quot;font-size: 12px;&quot;&gt;AILMENT TOLERANCE&lt;/div&gt;&lt;br/&gt;
	&lt;&lt;for _k, _v range $B.actor.tolerances&gt;&gt;
		&lt;&lt;if _v.current != 0&gt;&gt;
			&lt;&lt;if def $bestiary &amp;&amp; $B.actor instanceof Enemy &amp;&amp; !$bestiary.fetch($B.actor.name).tolerancesKnown[_k]&gt;&gt;
				&lt;span class=&quot;tolerance&quot;&gt;????&lt;/span&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;print _k&gt;&gt;
				&lt;&lt;tol _v&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;elseif setup.STATUS_SCREENS.battle[$stScreen-2] == &quot;aggression&quot;&gt;&gt;
	&lt;div style=&quot;font-size: 12px;&quot;&gt;AGGRESSION&lt;/div&gt;&lt;br/&gt;
	&lt;&lt;set _totalThreat = 0&gt;&gt;
	&lt;&lt;for _k, _v range $B.actor.threat&gt;&gt;
		&lt;&lt;set _totalThreat += _v&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;if _totalThreat == 0&gt;&gt;
		&lt;&lt;set _totalThreat = 1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _k, _v range $B.actor.threat&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;&lt;/span&gt;
		&lt;&lt;set _value = (_v / _totalThreat)*100; _value = _value.toFixed(0)&gt;&gt;
		&lt;span class=&quot;right&quot;&gt;&lt;&lt;print _value+&quot;%&quot;&gt;&gt;&lt;/span&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;
&lt;&lt;effectinfo&gt;&gt;

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="15" name="actions" tags="nobr battle" position="600,225" size="100,100">&lt;&lt;set $B.phase = &quot;actions&quot;&gt;&gt;
&lt;span class=&quot;hotkey monospace&quot;&gt;
[Q] = basic action
&lt;&lt;if typeof(subject().lastAction) === &quot;string&quot;&gt;&gt; |
	&lt;&lt;if new Action(subject().lastAction).check()&gt;&gt;
		&lt;&lt;set _style = &quot;color:gray&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _style = &quot;&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;span @style=_style&gt; [W] = last action (&lt;&lt;print subject().lastAction&gt;&gt;)&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if subject().crisis instanceof Array &amp;&amp; subject().crisis.length &gt; 0&gt;&gt; |
	&lt;&lt;if subject().crisisPoints &gt;= 100&gt;&gt;
		&lt;&lt;set _style = &quot;font-weight:bold&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _style = &quot;color:gray&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;span @style=_style&gt; [E] = &lt;&lt;crisisLink&gt;&gt;&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;

&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
	&lt;&lt;set _actionClass = &quot;compressed&quot;&gt;&gt;
	&lt;div id=&quot;actionBox&quot;&gt;
	&lt;/div&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actionClass = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;div id=&quot;actionList&quot; @class=&quot;_actionClass&quot;&gt;
&lt;&lt;actionListBattle&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="16" name="crisis actions" tags="nobr" position="725,225" size="100,100">&lt;&lt;set $B.phase = &quot;crisis&quot;&gt;&gt;
&lt;span class=&quot;hotkey monospace&quot;&gt;
[E] = &lt;span id=&quot;regularActions&quot;&gt;
&lt;&lt;link &quot;Regular Actions&quot;&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;actions&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;

&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
	&lt;&lt;set _actionClass = &quot;compressed&quot;&gt;&gt;
	&lt;div id=&quot;actionInfo&quot;&gt;
	&lt;/div&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actionClass = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;div id=&quot;actionList&quot; @class=&quot;_actionClass&quot;&gt;
&lt;&lt;actionListBattle $subject &quot;crisis&quot;&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="17" name="items" tags="nobr battle" position="850,225" size="100,100">&lt;&lt;set $B.phase = &quot;items&quot;&gt;&gt;

&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
	&lt;&lt;set _actionClass = &quot;compressed&quot;&gt;&gt;
	&lt;div id=&quot;actionBox&quot;&gt;
	&lt;/div&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actionClass = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;div id=&quot;actionList&quot; @class=&quot;_actionClass&quot;&gt;
&lt;&lt;itemList&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="18" name="action box default" tags="nobr" position="975,225" size="100,100">&lt;div class=&quot;actionBoxHelp&quot;&gt;Hover over an action to see info&lt;/div&gt;</tw-passagedata><tw-passagedata pid="19" name="Targeting Phase" tags="nobr battle" position="1100,225" size="100,100">&lt;&lt;set $B.phase = &quot;targeting&quot;&gt;&gt;
&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;include &quot;actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;if $B.targeting == &quot;enemy&quot;&gt;&gt;
	&lt;&lt;addclass &quot;#puppets&quot; &quot;invisible&quot;&gt;&gt;
&lt;&lt;elseif $B.targeting == &quot;ally&quot;&gt;&gt;
	&lt;&lt;addclass &quot;#enemies&quot; &quot;invisible&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;backbtn&gt;&gt;

Select a target. &lt;span class=&quot;hotkey monospace&quot;&gt;[hotkeys: 1-0] &lt;&lt;if $B.reverse_display&gt;&gt;[enemies are displayed in reverse order]&lt;&lt;/if&gt;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;if $B.targeting == &quot;all&quot;&gt;&gt;
&lt;&lt;set _targetingEnemy = true&gt;&gt;
&lt;span class=&quot;hotkey monospace&quot; id=&quot;target_help&quot;&gt;
[Hotkeys targeting &lt;&lt;if _targetingEnemy === true&gt;&gt;enemies&lt;&lt;else&gt;&gt;allies&lt;&lt;/if&gt;&gt;. Press Shift to switch targets.]
&lt;/span&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="20" name="Confirm Phase" tags="nobr battle" position="1225,225" size="100,100">&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;if setup.SHOW_CONFIRM&gt;&gt;
&lt;&lt;set $B.phase = &quot;confirm&quot;&gt;&gt;
&lt;&lt;backbtn&gt;&gt;

&lt;&lt;include &quot;Confirm Text&quot;&gt;&gt;
&amp;nbsp;
&lt;span id=&quot;confirmLink&quot;&gt;
&lt;&lt;link &quot;Confirm?&quot;&gt;&gt;
	&lt;&lt;include &quot;Action Handler&quot;&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;/span&gt;&lt;br /&gt;
&lt;span class=&quot;preview&quot;&gt;
&lt;&lt;if $action.preview instanceof Function&gt;&gt;
	&lt;&lt;print $action.preview()&gt;&gt;
&lt;&lt;elseif $action.preview === null&gt;&gt;
	/* blank */
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.preview&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;include &quot;Action Handler&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="21" name="Action Handler" tags="nobr" position="100,350" size="100,100">&lt;&lt;switch setup.TURN_MODEL.toLowerCase()&gt;&gt;
	&lt;&lt;case &quot;timeline&quot;&gt;&gt;
		&lt;&lt;if $action.waitTime &gt; 0&gt;&gt;
			&lt;&lt;set subject().ticks += $action.waitTime&gt;&gt;
			&lt;&lt;set subject().delayedAction = new Action($action.name)&gt;&gt;
			&lt;&lt;if $target instanceof Actor&gt;&gt;
				&lt;&lt;set subject().target = $target.id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;goto &quot;Advance Timeline&quot;&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;goto &quot;Action Phase&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;default&gt;&gt;
		&lt;&lt;goto &quot;Action Phase&quot;&gt;&gt;
&lt;&lt;/switch&gt;&gt;</tw-passagedata><tw-passagedata pid="22" name="Battle Continue Button" tags="nobr" position="225,350" size="100,100">&lt;center id=&quot;continue&quot;&gt;
&lt;&lt;if passage() == &quot;Anim Test Live&quot;&gt;&gt;
	&lt;&lt;button &quot;Return to Landing&quot; &quot;Start&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;button &quot;Continue...&quot;&gt;&gt;
		/* If there are actions still in the queue, we must allow them to execute by re-running the Action Queue. */
		&lt;&lt;if $B.actionQueue.length &gt; 0&gt;&gt;
			&lt;&lt;replace &quot;#content&quot; &quot;t8n&quot;&gt;&gt;
				&lt;&lt;include &quot;Action Queue&quot;&gt;&gt;
				&lt;&lt;timed 0s&gt;&gt;&lt;&lt;include &quot;animation activator&quot;&gt;&gt;&lt;&lt;/timed&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		/* Otherwise, the turn is over and we move the player to the next phase. */
		&lt;&lt;else&gt;&gt;
			&lt;&lt;switch setup.TURN_MODEL.toLowerCase()&gt;&gt;
				&lt;&lt;case &quot;free&quot;&gt;&gt;
					&lt;&lt;if passage() == &quot;Enemy Phase&quot; &amp;&amp; ($B.enemyTurns &gt; 0 || $B.turn == &quot;enemy&quot;)&gt;&gt;
					/* As long as there are enemy turns remaining (or the enemy&#39;s turn is active), continue refreshing the Enemy Phase until the enemies are all done. */
						&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
					&lt;&lt;else&gt;&gt;
						&lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
					&lt;&lt;/if&gt;&gt;
				&lt;&lt;case &quot;timeline&quot;&gt;&gt;
					&lt;&lt;goto &quot;Advance Timeline&quot;&gt;&gt;
			&lt;&lt;/switch&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/center&gt;</tw-passagedata><tw-passagedata pid="23" name="Action Phase" tags="nobr battle" position="350,350" size="100,100">/* This phase is ONLY FOR PLAYERS. Enemy actions only run &quot;action effects&quot; (see below) */
&lt;&lt;set $B.phase = null&gt;&gt;
&lt;&lt;run $(document).trigger(&quot;:action-performed&quot;)&gt;&gt;
&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include &quot;status&quot;&gt;&gt;
&lt;/span&gt;
&lt;span id=&quot;content&quot;&gt;

/* Some abilities (such as AoE attacks) don&#39;t always end with the same target as the one they started with. This saves the initial target if you want to use it for something, e.g. a reaction scene. */
&lt;&lt;set _initialTarget = $target&gt;&gt;

/* Saves the number of kills from before the action. By comparing this to the kills array afterwards, you can identify whether or not a kill happened during the action. */
&lt;&lt;set _initialKills = $B.kills.length&gt;&gt;

/* Tracks characters who have counterattacked this action. Required to enable counters. */
&lt;&lt;set _counters = []&gt;&gt;

&lt;&lt;if $action.name == &quot;spare&quot;&gt;&gt;
	&lt;&lt;run $enemy_to_spare.surrender()&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Add any bonus threat from the action. */
&lt;&lt;if setup.THREAT_TARGETING === true &amp;&amp; target() instanceof Enemy &amp;&amp; subject() instanceof Puppet&gt;&gt;
	&lt;&lt;run target().threat.inc(subject().name,$action.threat)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;action effects&quot;&gt;&gt;

/* mark turn done for Puppets */
&lt;&lt;if $action.instant&gt;&gt;
	/* do nothing */
&lt;&lt;elseif $subject.inspired&gt;&gt;
	&lt;&lt;set $subject.inspired = false&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject.active = false&gt;&gt;
	&lt;&lt;if setup.TURN_MODEL.toLowerCase() === &quot;free&quot;&gt;&gt;
		&lt;&lt;set $B.enemyTurns++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Remember this action for the last action shortcut: */
&lt;&lt;if !$action.nosave &amp;&amp; !$action.passagejump &amp;&amp; !($action.name == &quot;struggle&quot; || $action.name == &quot;spare&quot;)&gt;&gt;
	&lt;&lt;set _lastAction = subject().actions.find(function (a) { return a &amp;&amp; a.name == $action.saveMod })&gt;&gt;
	&lt;&lt;if _lastAction instanceof Action&gt;&gt;
		&lt;&lt;set subject().lastAction = _lastAction.name&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;br/&gt;
&lt;&lt;include &quot;Battle Continue Button&quot;&gt;&gt;

&lt;/span&gt;</tw-passagedata><tw-passagedata pid="24" name="preAction" tags="nobr" position="475,350" size="100,100">/* Run in &quot;action effects&quot;. Variable adjustments made before action execution. */

/* Subtract action cost */
&lt;&lt;if typeof(subject().en) == &quot;number&quot;&gt;&gt;
	&lt;&lt;if $action instanceof ItemAction&gt;&gt;
		&lt;&lt;set $B.item_used = true&gt;&gt;
		&lt;&lt;if $subject.crafty&gt;&gt;
			&lt;&lt;set $action._cost = Math.round(setup.ITEM_COST/2)&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set $action._cost = setup.ITEM_COST&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set $subject.en -= $action.cost&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Subtract HP cost */
&lt;&lt;if $action.hpcost &gt; 0&gt;&gt;
	&lt;&lt;set subject().hp -= $action.hpcost&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Prime delayed action if one exists */
&lt;&lt;if typeof($action.setupAction) == &quot;string&quot;&gt;&gt;
	&lt;&lt;set subject().delayedAction = new Action($action.setupAction)&gt;&gt;
	&lt;&lt;if setup.TURN_MODEL.toLowerCase() === &quot;timeline&quot;&gt;&gt;
		&lt;&lt;set subject().ticks += $action.waitTime&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set subject().delayCounter = $action.setupDelay&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* For Enemies, set cooldown for the action */
&lt;&lt;if subject() instanceof Enemy &amp;&amp; Number.isInteger($action.enemyCD)&gt;&gt;
	&lt;&lt;run subject().cd.set($action.nameCD,$action.enemyCD)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set $target = Hitlist.protectionCheck($target,$action.targetMod)&gt;&gt;
/* see targeting.js for protectionCheck details */</tw-passagedata><tw-passagedata pid="25" name="postAction" tags="nobr" position="600,350" size="100,100">/* Run in &quot;action effects&quot;. Variable adjustments made before action execution. */

/* If action was a Crisis, reset crisis points */
&lt;&lt;if $action.crisis &amp;&amp; def subject().crisisPoints&gt;&gt;
	&lt;&lt;set subject().crisisPoints = 0&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* If action was an item, decrement item stock and reset item flag */
&lt;&lt;if subject() instanceof Puppet &amp;&amp; $action instanceof ItemAction &amp;&amp; !$action.free&gt;&gt;
	&lt;&lt;run $inventory.decItem($action.name)&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Set last element for e.g. Artist&#39;s attacks */
&lt;&lt;if typeof($action.element) == &#39;string&#39;&gt;&gt;
	&lt;&lt;set subject().lastUsed = $action.element&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if setup.TURN_MODEL.toLowerCase() === &quot;timeline&quot;&gt;&gt;
	&lt;&lt;include &quot;Tick Formula&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if subject() instanceof Puppet&gt;&gt;
	/* If action has limited uses, decrement that */
	&lt;&lt;if def $action.uses&gt;&gt;
		&lt;&lt;run subject().actions.find(function(a) { return a &amp;&amp; a.name == $action.name }).uses -= 1&gt;&gt;
		/* Have to perform a search because $action is a clone of the original, reducing its uses will not reduce the uses of the action in the subject&#39;s actions list */
	&lt;&lt;/if&gt;&gt;

	/* If action has a cooldown, reset it */
	&lt;&lt;if def $action.cd&gt;&gt;
		&lt;&lt;run subject().actions.find(function(a) { return a &amp;&amp; a.name == $action.name }).resetCD()&gt;&gt;
		/* Have to perform a search because $action is a clone of the original */
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;if $action.oncePerTurn&gt;&gt;
		&lt;&lt;run subject().actions.find(function(a) { return a &amp;&amp; a.name == $action.name }).used = true&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Additional code goes here */
&lt;&lt;include &quot;postAction custom&quot;&gt;&gt;

&lt;&lt;if $B.surrender &amp;&amp; def $action.name&gt;&gt;
	&lt;&lt;print $enemy_to_spare.surrenderCheck()&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="26" name="action effects" tags="nobr" position="725,350" size="100,100">/* Where the action actually happens. Kept separate from Action Phase for modularity purposes. */
&lt;&lt;include &quot;battle interruptions&quot;&gt;&gt;

&lt;&lt;include &quot;preAction&quot;&gt;&gt;

&lt;&lt;if $action.silent === true&gt;&gt;
	&lt;&lt;if $action.act instanceof Function&gt;&gt;
		&lt;&lt;print $action.act()&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;print $action.act&gt;&gt;
	&lt;&lt;/if&gt;&gt;
		&lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;

&lt;&lt;else&gt;&gt;

&lt;&lt;set _queue = new Set()&gt;&gt; /* Queue for damage popups. */

&lt;div style=&quot;display:flex; flex-direction:column&quot;&gt; /* container for action display components */

/* Gameplay effect of the action. This will be displayed last (see actions.css), but must be run first because later portions depend on the results. */
&lt;&lt;if $action.act !== null&gt;&gt;
&lt;div id=&quot;actEffect&quot;&gt;

&lt;&lt;if def _targetingMsg&gt;&gt;
/* This section covers text that has to be generated elsewhere for various reasons, such as the alert for a Protector covering another character. */
&lt;&lt;print _targetingMsg&gt;&gt;
&lt;&lt;unset _targetingMsg&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $action.noRedundant&gt;&gt;
	&lt;&lt;set _list = [target().name]&gt;&gt;
	&lt;&lt;if ($target.ownParty.length - deadCount($target.ownParty)) &lt; $action.hits&gt;&gt;
		&lt;&lt;set $action.hits = $target.ownParty.length - deadCount($target.ownParty)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;for _hitNo = 1; _hitNo &lt;= $action.hits; _hitNo++&gt;&gt;
	&lt;&lt;set _hit = true&gt;&gt;
	&lt;&lt;if $action.spread &amp;&amp; _hitNo &gt; 1&gt;&gt;
		&lt;&lt;if $action.noRedundant &amp;&amp; _list.length &lt; $target.ownParty.length&gt;&gt;
			&lt;&lt;set _keepGoing = true&gt;&gt;
			&lt;&lt;for _keepGoing&gt;&gt;
				&lt;&lt;set $target = Hitlist.targetEnemy($action.targetMod)&gt;&gt;
				&lt;&lt;if _list.includes(target().name)&gt;&gt;
					&lt;&lt;set _keepGoing = true&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;set _keepGoing = false; _list.push(target().name)&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy($action.targetMod)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;accuracyCheck&gt;&gt;
	&lt;&lt;if _hit === true&gt;&gt;
		&lt;&lt;if !$action.targetMod.includes(&quot;unblockable&quot;)&gt;&gt;
			&lt;&lt;shieldCheck&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if _hit === true&gt;&gt;
			&lt;&lt;if _hitNo === $action.hits &amp;&amp; $action.finisher instanceof Function&gt;&gt;
				&lt;&lt;print $action.finisher()&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;if $action.act instanceof Function&gt;&gt;
					&lt;&lt;print $action.act()&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;print $action.act&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;print setup.MISS_MESSAGE&gt;&gt;
		&lt;&lt;set target().battleMsg.push({shake: false, content:&quot;MISS&quot;})&gt;&gt;
		&lt;&lt;if $action.onMiss instanceof Function&gt;&gt;
			&lt;&lt;print $action.onMiss()&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;/div&gt; /* close action effects div */
&lt;&lt;/if&gt;&gt;

/* Flavor text relating to the action. It is a div element, making it a separate block from the gameplay effects. By default, it has a bottom margin of 1em to create a separator between flavor text and gameplay text. */

&lt;div id=&quot;actFlavor&quot;&gt;

/* First is action use text. A regular action takes the form &quot;Actor uses...&quot; Items take the form &quot;Actor uses a/n...&quot; This is a div element, which means it creates an automatic line break. */

&lt;&lt;if !($action.useText === null || ($action.useText instanceof Function &amp;&amp; $action.useText() === null))&gt;&gt;
/* Set useText to null to bypass this element. This is useful if you only want one of the two areas to display. */
&lt;div id=&quot;useText&quot;&gt;
&lt;&lt;if $action.useText instanceof Function&gt;&gt;
	&lt;&lt;print $action.useText()&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.useText&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

/* Special &quot;interrupt&quot; field, for battle interruptions, displayed after the use text but before the act text. To populate it, in &quot;battle interruptions&quot;, target &quot;#interrupt&quot; with the replace macro, and remember to remove the &quot;invisible&quot; class with removeClass. Note that as with all DOM macros, the element must be rendered before code is executed, so this will likely require wrapping the code in a timed 0s macro. */
&lt;div id=&quot;interrupt&quot;&gt;&lt;/div&gt;

/* Then descriptive text. This is a div element, so it creates an automatic line break. */

&lt;&lt;if $action.actText != null&gt;&gt;
/* Set actText to null to bypass this element. This is useful if you only want one of the two areas to display. */
&lt;div id=&quot;actText&quot;&gt;
&lt;&lt;if $action.actText instanceof Function&gt;&gt;
	&lt;&lt;print $action.actText(_hit)&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.actText&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;/div&gt; /* close flavor text div */

&lt;&lt;if setup.ANIMATIONS === true &amp;&amp; _queue.size &gt; 0&gt;&gt;
&lt;div class=&quot;actors animationContainer&quot;&gt;
&lt;&lt;set _animationActive = true&gt;&gt;

&lt;&lt;for _i, _p range _queue&gt;&gt;
  &lt;div style=&quot;position:relative&quot;&gt;
    &lt;div @id=&quot;&#39;dmgBox&#39;+_i&quot; style=&quot;display:inline-block&quot;&gt;
		&lt;&lt;capture _p&gt;&gt;
		&lt;&lt;liveblock&gt;&gt;
    	&lt;&lt;actorBox _p &quot;&quot; &quot;simplified&quot; &quot;dmgDisplay&quot;&gt;&gt;
		&lt;&lt;/liveblock&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
    &lt;/div&gt;
		&lt;&lt;for _x, _m range _p.battleMsg&gt;&gt;
	    &lt;div @id=&quot;&#39;dmg&#39;+_i+&#39;-&#39;+_x&quot; class=&quot;dmgPopup&quot;&gt;
				&lt;&lt;print _m.content&gt;&gt;
	    &lt;/div&gt;
		&lt;&lt;/for&gt;&gt;
  &lt;/div&gt;
&lt;&lt;/for&gt;&gt;

&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;/div&gt; /* close container */

&lt;&lt;/if&gt;&gt; /* end silent check */

&lt;&lt;include &quot;postAction&quot;&gt;&gt;

&lt;&lt;if def _OG&gt;&gt;
	&lt;&lt;set $subject = _OG.subject; $target = _OG.target; $action = _OG.action&gt;&gt;
	&lt;&lt;unset _OG&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="27" name="Spell Phase" tags="nobr battle" position="850,350" size="100,100">&lt;&lt;set $B.phase = &quot;spell&quot;&gt;&gt;
&lt;&lt;backbtn&gt;&gt;

&lt;&lt;if isNaN($action.cost)&gt;&gt;
You need to input a number.&lt;br/&gt;
&lt;&lt;elseif $action.cost &lt; $B.mincost&gt;&gt;
Spell requires at least $B.mincost Energy.&lt;br/&gt;
&lt;&lt;elseif $subject.en &lt; $action.cost&gt;&gt;
Not enough Energy!&lt;br/&gt;
&lt;&lt;/if&gt;&gt;

How much Energy do you want to put into $action.name? (Minimum $B.mincost)&lt;br /&gt;
&lt;&lt;numberboxplus &quot;$action._cost&quot; $B.mincost autofocus&gt;&gt;
&lt;&lt;include &quot;spell check&quot;&gt;&gt;
&lt;&lt;/numberboxplus&gt;&gt;&lt;br/&gt;
(Press Enter to confirm.)&lt;br/&gt;</tw-passagedata><tw-passagedata pid="28" name="spell check" tags="nobr" position="975,350" size="100,100">&lt;&lt;run $action._cost *= 1&gt;&gt;
&lt;&lt;if ($action.cost &lt; $B.mincost) or ($subject.en &lt; $action.cost) or isNaN($action.cost)&gt;&gt;
&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Spell Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;run $action.spellMod()&gt;&gt;

&lt;&lt;if $action.phase != &quot;Confirm Phase&quot;&gt;&gt;
	&lt;&lt;set $B.targeting = $action.target&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Targeting Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include $action.phase&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="29" name="RoundEnd" tags="nobr battle" position="1100,350" size="100,100">&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;

&lt;&lt;if $B.turn == &quot;player&quot;&gt;&gt;
/* If the turn reads &quot;player&quot;, it&#39;s because the enemy round just finished. Run end of turn for enemies. */
	/* If it&#39;s a new player turn, it&#39;s a &quot;true&quot; new round, so need to update and reset controller variables. */
	&lt;&lt;set $B.turnCounter++; $B.embargo--; $B.enemyTurns = 0&gt;&gt;
	&lt;&lt;endTurn $enemies&gt;&gt;
	&lt;&lt;newTurn $puppets&gt;&gt;
	&lt;&lt;if _message&gt;&gt;
		&lt;&lt;button &quot;Continue...&quot; &quot;Player Phase&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;elseif $B.turn eq &quot;enemy&quot;&gt;&gt;
/* If the turn reads &quot;enemy&quot;, the player turn just finished. Run end of turn for player. */
	&lt;&lt;endTurn $puppets&gt;&gt;
	&lt;&lt;if _message&gt;&gt;
		&lt;br/&gt;&lt;&lt;button &quot;Continue...&quot; &quot;Enemy Phase&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="30" name="Enemy Phase" tags="nobr battle" position="1225,350" size="100,100">&lt;&lt;victorycheck&gt;&gt;

&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;&lt;if (deadCount() == puppets().length)&gt;&gt;
/* If all puppets are dead, it&#39;s game over -- no point in finishing this passage, just let victorycheck do its thing. */
&lt;&lt;else&gt;&gt;

	&lt;&lt;if $B.ambush&gt;&gt;
		&lt;&lt;set $B.ambush = false; $B.turn = &quot;enemy&quot;&gt;&gt;
		&lt;center style=&quot;font-weight:bold&quot;&gt;AMBUSHED!&lt;/center&gt;&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;set _start = $B.enemyTurns&gt;&gt;

	&lt;&lt;set _enemy = enemies().sort(function(a,b) { return a.priority - b.priority; })
		.find(function (e) { return e &amp;&amp; e.active &amp;&amp; (!e.dead || e.actionReady) })&gt;&gt;
	/* Returns the first active enemy that is not dead */
	/* Exception is made for enemies that are dead but have a persistent delayed action */
	&lt;&lt;if _enemy instanceof Enemy&gt;&gt;
	/* If first check fails, could not find a valid enemy -- all enemies have acted */
		&lt;&lt;set $subject = _enemy&gt;&gt;
		&lt;&lt;set $target = null&gt;&gt;
		&lt;&lt;set $action = null&gt;&gt;
		&lt;&lt;if setup.TURN_MODEL.toLowerCase() !== &quot;timeline&quot; &amp;&amp; _enemy.isFirstAction&gt;&gt;
			&lt;&lt;newTurn `[_enemy]`&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;set _enemy.active = false&gt;&gt;

		&lt;&lt;if !_enemy.fakedeath || _enemy.actionReady&gt;&gt;

			&lt;&lt;if _enemy.noact &amp;&amp; !_enemy.actionReady&gt;&gt;
				&lt;&lt;set _effect = _enemy.effects.sort(function(a,b) { return a.priority - b.priority; })
					.find(function (e) { return e &amp;&amp; e.holdAction instanceof Function })&gt;&gt;
				/* Sorts effects by priority and returns the first hold effect (one with a holdAction) */
				&lt;&lt;run console.assert(_effect !== undefined,`ERROR in Enemy Phase: ${_enemy.name} has noact but no hold effect`)&gt;&gt;
				&lt;&lt;set $action = _effect.holdAction()&gt;&gt;
				&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;

			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _counters = []&gt;&gt;
				&lt;&lt;if _enemy.actionReady&gt;&gt;
					&lt;&lt;set $action = _enemy.delayedAction&gt;&gt;
					&lt;&lt;set _enemy.delayedAction = null&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;run _enemy.actions()&gt;&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;run $B.actionsThisTurn[_enemy.id].push($action.name)&gt;&gt;
				&lt;&lt;if $target === null &amp;&amp; $action.targetMethod instanceof Function&gt;&gt;
					/* If a target hasn&#39;t already been selected, use the action&#39;s targetMethod (defaults to Hitlist methods) */
					&lt;&lt;set $target = $action.targetMethod()&gt;&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;run console.assert($target instanceof Actor,&quot;ERROR in Enemy Phase: no target found for &quot;+$action.name+&quot;. Check the action&#39;s targeting logic for errors, e.g. all targets in Stasis when trying to apply an effect.&quot;)&gt;&gt;
				&lt;&lt;if !_targetfail&gt;&gt;
					&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;if $action.fullround === true&gt;&gt;
					/* Full-round actions use up all remaining attacks. */
					&lt;&lt;run _enemy.noAttacks = 0&gt;&gt;
				&lt;&lt;elseif !$action.instant&gt;&gt;
					/* Otherwise, noAttacks is reduced by 1, unless the action was instant. */
					&lt;&lt;run _enemy.noAttacks--&gt;&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;if _enemy.noAttacks &gt; 0&gt;&gt;
					/* If the enemy still has attacks remaining, their turn isn&#39;t done; set active to true again so they will act again when this passage is re-called. */
					&lt;&lt;set _enemy.active = true&gt;&gt;
				&lt;&lt;elseif setup.TURN_MODEL.toLowerCase() === &quot;free&quot;&gt;&gt;
					/* Otherwise, the enemy is done. If the model is free-action, we need to remove their turn from the pool. */
					&lt;&lt;run $B.actionsThisTurn[_enemy.id] = []&gt;&gt;
					&lt;&lt;run $B.enemyTurns -= 1&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;

		&lt;&lt;else&gt;&gt;
		/* If faking death, enemies should do nothing, so just go to the next enemy.
			All code outside this if/else such as newTurn and threat decay will still execute. */
			&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end fakedeath if */

		&lt;&lt;run _enemy.decayThreat()&gt;&gt;

	&lt;&lt;else&gt;&gt;
	/* If this check failed, the enemy turn is done. Advance the round. */
		&lt;&lt;switch setup.TURN_MODEL.toLowerCase()&gt;&gt;
			&lt;&lt;case &quot;timeline&quot;&gt;&gt;
				&lt;&lt;goto &quot;Advance Timeline&quot;&gt;&gt;
			&lt;&lt;case &quot;free&quot;&gt;&gt;
				&lt;&lt;set $B.turn = &quot;player&quot;&gt;&gt;
				&lt;&lt;goto &quot;RoundEnd&quot;&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;include &quot;Battle Continue Button&quot;&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="31" name="Widget: backbtn" tags="widget nobr" position="100,475" size="100,100">&lt;&lt;widget &quot;backbtn&quot;&gt;&gt;
&lt;span class=&quot;btn back right&quot; id=&quot;battlebackbtn&quot;&gt;[[Back [R]|Player Phase][$B.phase = &quot;selection&quot;; $B.targeting = null; $action = null; $target = null; $subject = null; $removed_effects = [];]]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="32" name="Widget: endRound" tags="widget nobr" position="225,475" size="100,100">&lt;&lt;widget &quot;endRound&quot;&gt;&gt;
&lt;&lt;set $B.turn = &quot;enemy&quot;; $B.phase = null&gt;&gt;
&lt;&lt;run $(document).trigger(&quot;:endRound-run&quot;)&gt;&gt;
&lt;&lt;goto &quot;RoundEnd&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="33" name="Widget: status" tags="widget nobr" position="350,475" size="100,100">&lt;&lt;widget &quot;status&quot;&gt;&gt;
&lt;&lt;link setup.STATUS_BUTTON&gt;&gt;
	&lt;&lt;if $args[0] eq $B.actor&gt;&gt;
		&lt;&lt;set $B.actor = null&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $B.actor to $args[0]&gt;&gt;
		&lt;&lt;if ndef $stScreen&gt;&gt;
			&lt;&lt;set $stScreen = 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;status&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="34" name="Widget: act command" tags="widget nobr" position="475,475" size="100,100">&lt;&lt;widget &quot;act&quot;&gt;&gt;
/*	arg 0 = puppet to command */
&lt;&lt;if $args[0].down is true&gt;&gt;
	&lt;&lt;if $args[0].en &gt;= setup.STRUGGLE_COST&gt;&gt;
		&lt;&lt;link &quot;Struggle&quot;&gt;&gt;
			&lt;&lt;set $subject = $args[0]; $action = new Action(&quot;struggle&quot;); $target = null&gt;&gt;
			&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Confirm Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;b&gt;Exhausted!&lt;/b&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Act&quot;&gt;&gt;
		&lt;&lt;set $subject = $args[0]&gt;&gt;
		&lt;&lt;run $(document).trigger(&quot;:act-selected&quot;)&gt;&gt;
		&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;actions&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span class=&quot;hotkey monospace right&quot;&gt;[Q]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="35" name="Widget: rest command" tags="widget nobr" position="600,475" size="100,100">&lt;&lt;widget &quot;rest&quot;&gt;&gt;
&lt;&lt;link &quot;Rest&quot;&gt;&gt;
	&lt;&lt;set $subject = $args[0]; $action = new Action(&quot;rest&quot;); $target = null&gt;&gt;
	&lt;&lt;run $(document).trigger(&quot;:rest-selected&quot;)&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Confirm Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;span class=&quot;hotkey monospace right&quot;&gt;[W]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="36" name="Widget: items command" tags="widget nobr" position="725,475" size="100,100">&lt;&lt;widget &quot;items&quot;&gt;&gt;
&lt;&lt;if $B.embargo &gt; 0&gt;&gt;
	&lt;span class=&quot;embargo&quot;&gt;
	Nope! [&lt;&lt;print $B.embargo&gt;&gt;]
	&lt;/span&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;if ($args[0].en &gt;= setup.ITEM_COST) || ($args[0].crafty &amp;&amp; $args[0].en &gt;= Math.round(setup.ITEM_COST/2))&gt;&gt;
		&lt;&lt;link &quot;Item&quot;&gt;&gt;
			&lt;&lt;set $subject = $args[0]&gt;&gt;
			&lt;&lt;run $(document).trigger(&quot;:item-selected&quot;)&gt;&gt;
			&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;items&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;b&gt;Item&lt;/b&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span class=&quot;hotkey monospace right&quot;&gt;[E]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="37" name="Widget: spare command" tags="widget nobr" position="850,475" size="100,100">&lt;&lt;widget &quot;spare&quot;&gt;&gt;
&lt;&lt;link &quot;Spare&quot;&gt;&gt;
	&lt;&lt;set $subject = $args[0]; $target = $enemy_to_spare; $action = {name: &quot;spare&quot;, cost: 0}&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Confirm Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="38" name="Widget: actionListBattle" tags="widget nobr" position="975,475" size="100,100">&lt;&lt;widget &quot;actionListBattle&quot;&gt;&gt;
/* Widget for display of player actions in battle. */

&lt;&lt;set _char = ($args[0] || subject())&gt;&gt;
&lt;&lt;run console.assert(_char instanceof Puppet,&quot;ERROR in actionListBattle: no Puppet&quot;)&gt;&gt;

&lt;&lt;if $args.includes(&quot;crisis&quot;)&gt;&gt;
	&lt;&lt;set _actions = _char.crisis&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actions = _char.actions&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;for _action range _actions&gt;&gt;
&lt;&lt;if !_action.invisible&gt;&gt;
	&lt;&lt;set _actionID = &quot;action&quot;+_actions.indexOf(_action)&gt;&gt;
	&lt;div @id=&quot;_actionID&quot; class=&quot;actionDisplay&quot;&gt;
		&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;print _action.printCompressed()&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;print _action&gt;&gt;
		&lt;&lt;/if&gt;&gt;

		&lt;&lt;capture _action, _actionID&gt;&gt;
		&lt;&lt;timed 0s&gt;&gt;
			&lt;&lt;set _selector = &quot;#&quot;+_actionID+&quot; .action-name&quot;&gt;&gt;
			&lt;&lt;replace _selector&gt;&gt;
				&lt;&lt;actionName _action&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/timed&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="39" name="Widget: itemList" tags="widget nobr" position="1100,475" size="100,100">&lt;&lt;widget &quot;itemList&quot;&gt;&gt;
&lt;&lt;set _char = ($args[0] || subject())&gt;&gt;
&lt;&lt;run console.assert(_char instanceof Puppet,&quot;ERROR in itemList: no Puppet&quot;)&gt;&gt;
&lt;&lt;set _inv = (_char.inventory || inv())&gt;&gt;
&lt;&lt;for _name, _item range _inv&gt;&gt;
&lt;&lt;if _item.usable.includes(&quot;inbattle&quot;) &amp;&amp; _item.action instanceof Action&gt;&gt;
	&lt;&lt;set _action = _item.action&gt;&gt;
	&lt;&lt;set _actionID = &quot;item_&quot;+_name.split(&#39; &#39;).join(&#39;_&#39;)&gt;&gt;
	&lt;div @id=&quot;_actionID&quot; class=&quot;actionDisplay&quot;&gt;
		&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;print _action.printCompressed()&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;print _action&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;capture _action, _actionID&gt;&gt;
		&lt;&lt;timed 0s&gt;&gt;
			&lt;&lt;set _selector = &quot;#&quot;+_actionID+&quot; .action-name&quot;&gt;&gt;
			&lt;&lt;replace _selector&gt;&gt;
				&lt;&lt;actionName _action&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/timed&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="40" name="Widget: actionName" tags="widget nobr" position="1225,475" size="100,100">&lt;&lt;widget &quot;actionName&quot;&gt;&gt;
/* Renders the action link and other formatting e.g. for skill locks. */
&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; ($args[0] instanceof Action),&quot;ERROR in actionName: no Action&quot;)&gt;&gt;
&lt;&lt;set _action = $args[0]&gt;&gt;

&lt;&lt;mouseover&gt;&gt;
&lt;span class=&quot;mouseover&quot;&gt;
&lt;&lt;if _action.standardCheck()&gt;&gt;
/* If insufficient energy, uses, or cooldown, just display the action name (no link). */
&lt;&lt;print _action.name&gt;&gt;
&lt;&lt;elseif _action.lockCheck()&gt;&gt;
/* If dizzy and action not basic, display the name as crossed out followed by a gray &quot;Dizzy!&quot; message. */
&lt;del&gt;&lt;&lt;print _action.name&gt;&gt;&lt;/del&gt; &lt;span class=&quot;action-lock&quot;&gt;Dizzy!&lt;/span&gt;
&lt;&lt;elseif _action.HPCheck()&gt;&gt;
/* If puppet has insufficient HP for an HP-consuming skill, the name is crossed out. */
&lt;del&gt;&lt;&lt;print _action.name&gt;&gt;&lt;/del&gt; &lt;span class=&quot;action-lock&quot;&gt;Not enough HP!&lt;/span&gt;
&lt;&lt;elseif _action.elementCheck()&gt;&gt;
&lt;del&gt;&lt;&lt;print _action.name&gt;&gt;&lt;/del&gt; &lt;span class=&quot;action-lock&quot;&gt;No element.&lt;/span&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;_action.name&quot;&gt;&gt;
		&lt;&lt;actionLink&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;onmouseover&gt;&gt;
	&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
		&lt;&lt;run $(&quot;#actionBox&quot;).css(&quot;visibility&quot;,&quot;visible&quot;)&gt;&gt;
		&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
			&lt;&lt;print _action&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;onmouseout&gt;&gt;
	&lt;&lt;if setup.COMPRESSED_ACTIONS === true&gt;&gt;
		&lt;&lt;run $(&quot;#actionBox&quot;).css(&quot;visibility&quot;,&quot;hidden&quot;)&gt;&gt;
		&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
			&lt;&lt;include &quot;action box default&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/span&gt;
&lt;&lt;/mouseover&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="41" name="Widget: actionLink" tags="widget nobr" position="100,600" size="100,100">&lt;&lt;widget &quot;actionLink&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0&gt;&gt;
	&lt;&lt;set _action = $args[0]&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !_action.check()&gt;&gt;

	&lt;&lt;run $(document).trigger(&quot;:action-selected&quot;)&gt;&gt;
	&lt;&lt;unset _s&gt;&gt;
	&lt;&lt;if _action.passagejump&gt;&gt;
		&lt;&lt;goto _action.passagejump&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $action = clone(_action)&gt;&gt;
		&lt;&lt;if !$action.nosave&gt;&gt;
			&lt;&lt;set $subject.lastAction = $action.name&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;set $B.targeting = _action.target&gt;&gt;
		&lt;&lt;set $B.noself = _action.noself&gt;&gt;
		&lt;&lt;if _action.phase is &quot;Confirm Phase&quot;&gt;&gt;
			&lt;&lt;set $target = null&gt;&gt;
			&lt;&lt;set $B.targeting = null&gt;&gt;
		&lt;&lt;elseif _action.phase is &quot;Spell Phase&quot;&gt;&gt;
			&lt;&lt;set $B.mincost = _action.cost&gt;&gt;
			&lt;&lt;set $B.targeting = null&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;include &quot;actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include _action.phase&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="42" name="Widget: crisisLink" tags="widget nobr" position="225,600" size="100,100">&lt;&lt;widget &quot;crisisLink&quot;&gt;&gt;
&lt;&lt;if typeof($args[0]) == &quot;string&quot;&gt;&gt;
	&lt;&lt;set _text = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _text = &quot;Crisis&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span id=&quot;crisisLink&quot;&gt;
&lt;&lt;link _text&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;crisis actions&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="43" name="Widget: advanceDelay" tags="widget nobr" position="350,600" size="100,100">/* Decrements the counter for delayed actions. */
&lt;&lt;widget &quot;advanceDelay&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Actor,`ERROR in advanceDelay: no actor passed`)&gt;&gt;
&lt;&lt;set _a = $args[0]&gt;&gt;
&lt;&lt;if _a.delayCounter &gt; 0&gt;&gt;
	&lt;&lt;set _a.delayCounter -= 1&gt;&gt;
	&lt;&lt;if _a.delayedAction.delayMessage !== null&gt;&gt;
		&lt;&lt;set _message to true&gt;&gt;
		&lt;div id=&quot;actFlavor&quot;&gt;
			&lt;&lt;print _a.delayedAction.delayMessage(_a)&gt;&gt;
		&lt;/div&gt;
		&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="44" name="Widget: advanceRespawn" tags="widget nobr" position="475,600" size="100,100">/* Decrements the respawn counter if the character has one. */
&lt;&lt;widget &quot;advanceRespawn&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Actor,`ERROR in advanceRespawn: no actor passed`)&gt;&gt;
&lt;&lt;set _a = $args[0]&gt;&gt;
&lt;&lt;if _a.dead &amp;&amp; _a.respawn &gt; 0&gt;&gt;
	&lt;&lt;set _a.respawn -= 1&gt;&gt;
	&lt;&lt;if _a.respawn &lt;= 0&gt;&gt;
		&lt;&lt;set _a.dead = false; _a.hp = Math.round(_a.maxHP * _a.respawnHP); _a.resetRespawn()&gt;&gt;
		&lt;&lt;set _message to true&gt;&gt;
		&lt;div id=&quot;actFlavor&quot;&gt;
			&lt;&lt;print _a.respawnMessage&gt;&gt;
		&lt;/div&gt;
		&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="45" name="Widget: regen" tags="widget nobr" position="600,600" size="100,100">/* Activates per-turn regeneration. */
&lt;&lt;widget &quot;regen&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Actor,`ERROR in regen: no actor passed`)&gt;&gt;
&lt;&lt;set _a = $args[0]&gt;&gt;
&lt;&lt;if !_a.dead &amp;&amp; !_a.healBlock&gt;&gt;
	&lt;&lt;run _a.regenHP()&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if !_a.noENregen&gt;&gt;
	&lt;&lt;set _a.en += _a.ENregen&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="46" name="Widget: advanceCooldown" tags="widget nobr" position="725,600" size="100,100">/* Decrements action cooldowns and refreshes used actions. */
&lt;&lt;widget &quot;advanceCooldown&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Actor,`ERROR in advanceCooldown: no actor passed`)&gt;&gt;
&lt;&lt;set _a = $args[0]&gt;&gt;
&lt;&lt;if _a instanceof Puppet&gt;&gt;
	&lt;&lt;for _action range _a.actions&gt;&gt;
		&lt;&lt;if _action.used === true&gt;&gt;
			&lt;&lt;run _action.used = false&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if _action.cd&gt;&gt;
			&lt;&lt;run _action.cd -= 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;elseif _a instanceof Enemy &amp;&amp; !_a.noact&gt;&gt;
	&lt;&lt;run _a.decCD()&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="47" name="Widget: DoT" tags="widget nobr" position="850,600" size="100,100">/* Executes damage-over-time effects for a given actor. */
&lt;&lt;widget &quot;DoT&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Actor,`ERROR in DoT: no actor passed`)&gt;&gt;
&lt;&lt;set _a = $args[0]&gt;&gt;
&lt;&lt;for _effect range _a.effects.filter(function(e) { return e.dot })&gt;&gt;
	/* DoT check */
	&lt;&lt;if !_a.dead&gt;&gt;
		&lt;&lt;set _message = true&gt;&gt;
		&lt;&lt;set $dmg = _effect.damage(_a)&gt;&gt;
		&lt;div id=&quot;actFlavor&quot;&gt;
			&lt;&lt;print _effect.msg(_a)&gt;&gt;
		&lt;/div&gt;
		&lt;div id=&quot;actEffect&quot;&gt;
			&lt;&lt;echoDamage _a &quot;indirect&quot; &quot;nocalc&quot;&gt;&gt;
		&lt;/div&gt;
		&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="48" name="Widget: newTurn" tags="widget nobr" position="975,600" size="100,100">&lt;&lt;widget &quot;newTurn&quot;&gt;&gt;
/* arg 0 = party array. MUST be an array; use an array with 1 element if you wish to call this for a single actor */
&lt;&lt;run console.assert($args[0] instanceof Array,&quot;ERROR in newTurn: invalid argument&quot;)&gt;&gt;

&lt;&lt;for _actor range $args[0].filter(function (a) { return a !== null; })&gt;&gt;
	&lt;&lt;run console.assert(_actor instanceof Actor,&quot;ERROR in newTurn: non-Actor element&quot;)&gt;&gt;
	&lt;&lt;set _actor.active = true&gt;&gt;
	&lt;&lt;set _actor.lastDmg = 0&gt;&gt;

	/* Refill retaliations if actor still alive */
	&lt;&lt;if !_actor.dead&gt;&gt;
		&lt;&lt;run _actor._retaliations.refill()&gt;&gt;
  &lt;&lt;/if&gt;&gt;

	&lt;&lt;if _actor.delayedAction instanceof Action &amp;&amp; _actor.delayedAction.delayHold === true&gt;&gt;
		&lt;&lt;set _actor.active = false&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;if _actor instanceof Puppet&gt;&gt;
		/* Puppet-exclusive tasks:
			decrement counter for delayed actions (enemies do this at end of round)
			decrement respawn (enemy respawn only decremented at end of round)
			regen HP (enemies regen at end of round) */
		&lt;&lt;advanceDelay _actor&gt;&gt;
		&lt;&lt;advanceRespawn _actor&gt;&gt;
		&lt;&lt;regen _actor&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;advanceCooldown _actor&gt;&gt;

	/* decay top-decrementing effects */
  &lt;&lt;decayEffects _actor.effects true&gt;&gt;

&lt;&lt;/for&gt;&gt;
&lt;&lt;include &quot;custom newTurn&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="49" name="Widget: endTurn" tags="widget nobr" position="1100,600" size="100,100">&lt;&lt;widget &quot;endTurn&quot;&gt;&gt;
&lt;&lt;run console.assert($args[0] instanceof Array,&quot;ERROR in endTurn: invalid argument&quot;)&gt;&gt;

&lt;&lt;set _party = $args[0].filter(function (a) { return a !== null; })&gt;&gt;
&lt;&lt;for _actor range _party&gt;&gt;
	&lt;&lt;run console.assert(_actor instanceof Actor,&quot;ERROR in endTurn: non-Actor element&quot;)&gt;&gt;
	&lt;&lt;if (_actor.delayedAction instanceof Action &amp;&amp; _actor.delayedAction.delayHold)&gt;&gt;
		&lt;&lt;set _actor.active = false&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _actor.active = true&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	/* Check and execute damage-over-time effects. */
	&lt;&lt;DoT _actor&gt;&gt;

	/* decay bottom-decrementing effects */
	&lt;&lt;decayEffects _actor.effects false&gt;&gt;

	&lt;&lt;if _actor instanceof Enemy&gt;&gt;
		&lt;&lt;advanceDelay _actor&gt;&gt;
		&lt;&lt;advanceRespawn _actor&gt;&gt;
		&lt;&lt;regen _actor&gt;&gt;
		&lt;&lt;run _actor._noAttacks.refill()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;include &quot;custom endTurn&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="50" name="Widget: decayEffects" tags="widget nobr" position="1225,600" size="100,100">&lt;&lt;widget &quot;decayEffects&quot;&gt;&gt;
/* arg 0 = effects array, arg 1 = Boolean, top decrement (optional, defaults to false) */
&lt;&lt;run console.assert($args[0] instanceof Array,&quot;ERROR in decayEffects: invalid argument&quot;)&gt;&gt;
&lt;&lt;run console.assert(_actor !== undefined,&quot;ERROR in decayEffects: undefined _actor&quot;)&gt;&gt;

&lt;&lt;set _topDec = Boolean($args[1])&gt;&gt;
&lt;&lt;set _decayMsg = &quot;&quot;&gt;&gt;
&lt;&lt;for _effect range $args[0].filter(function (eff) { return eff.topDec == temporary().topDec })&gt;&gt;
	&lt;&lt;run console.assert(_effect instanceof Effect,&quot;ERROR in decayEffects: non-Effect element&quot;)&gt;&gt;
  &lt;&lt;set _m = _effect.decay(_actor)&gt;&gt;
  &lt;&lt;if _m.length &gt; 1&gt;&gt;
    &lt;&lt;set _decayMsg += _m&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _decayMsg.length &gt; 0&gt;&gt;
	&lt;&lt;set _message = true&gt;&gt;
  &lt;div id=&quot;actEffect&quot;&gt;
    &lt;&lt;print _decayMsg&gt;&gt;
  &lt;/div&gt;
  &lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="51" name="Widget: endofbattle" tags="widget nobr" position="100,725" size="100,100">&lt;&lt;widget &quot;endofbattle&quot;&gt;&gt;
&lt;&lt;set $inbattle = false&gt;&gt;

&lt;&lt;for _id range $B.playerBars&gt;&gt;
	&lt;&lt;run Meter.del(_id)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _id range $B.enemyBars&gt;&gt;
	&lt;&lt;run Meter.del(_id)&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if deadCount() == puppets().length&gt;&gt;
	&lt;&lt;set $B.defeated = true&gt;&gt;
&lt;&lt;elseif deadCount() == puppets().length-1&gt;&gt;
	&lt;&lt;set $B.SoleSurvivor = true&gt;&gt;
&lt;&lt;elseif deadCount() == 0&gt;&gt;
	&lt;&lt;set $B.Perfect = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !$B.defeated&gt;&gt;
	&lt;&lt;set encounters()[$scenario] = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $B.style&gt;&gt;
	&lt;&lt;addclass &quot;body&quot; $B.style&gt;&gt;
	&lt;&lt;removeclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;custom end of battle&quot;&gt;&gt;

&lt;&lt;refreshPuppets&gt;&gt;

&lt;&lt;unset $B; $subject; $target; $enemies; $enemyGrid; $puppetGrid&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="52" name="Preparation" tags="" position="225,725" size="100,100">&lt;&lt;set $inbattle = true&gt;&gt;
&lt;&lt;unset $subject, $target&gt;&gt;
&lt;&lt;set $B = {actor: null, turn: &quot;player&quot;, turnCounter: 0, enemyTurns: 0, actionsThisTurn: {}, phase: &quot;selection&quot;, embargo: 0, event: false, surrender: false, kills: [], specialdeath: [], actionQueue: [], XPreward: 0, moneyReward: 0, destination: previous()}&gt;&gt;
&lt;&lt;callEncounter $scenario&gt;&gt;
&lt;&lt;for _enemy range enemies()&gt;&gt;
	&lt;&lt;set $B.actionsThisTurn[_enemy.id] = []&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;refreshPuppets&gt;&gt;
&lt;&lt;if typeof($B.style) == &#39;string&#39;&gt;&gt;
	&lt;&lt;addclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set $B.playerBars = []&gt;&gt;
&lt;&lt;for _i, _p range $puppets&gt;&gt;
	&lt;&lt;set _id = &#39;p&#39;+_i&gt;&gt;
	&lt;&lt;run $B.playerBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
		&lt;&lt;animation setup.HEALTH_BAR_TIME linear&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;set $B.enemyBars = []&gt;&gt;
&lt;&lt;for _i, _e range $enemies&gt;&gt;
	&lt;&lt;set _id = &#39;e&#39;+_i&gt;&gt;
	&lt;&lt;run $B.enemyBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.ENEMY_BAR_COLOR&gt;&gt;
		&lt;&lt;animation setup.HEALTH_BAR_TIME linear&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;include &quot;battle grid setup&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;include &quot;custom battle preparation&quot;&gt;&gt;
&lt;&lt;set $stScreen = 1&gt;&gt;
&lt;&lt;if $B.ambush&gt;&gt;
	&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;goto &quot;Enemy Phase&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="53" name="Widget: damageCalc" tags="widget nobr" position="350,725" size="100,100">&lt;&lt;widget &quot;damageCalc&quot;&gt;&gt;
&lt;&lt;set _w = $action.weight&gt;&gt;
&lt;&lt;if $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set _target = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _target = $target&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _atk = ($subject.get(StatName(&quot;atk&quot;)) * (1 - $action.useSpecial)) + ($subject.get(StatName(&quot;spc&quot;)) * $action.useSpecial)&gt;&gt;
&lt;&lt;set _def = $subject.get(StatName(&quot;def&quot;))&gt;&gt;

/* base damage */
&lt;&lt;include &quot;damageCalc formula&quot;&gt;&gt;

/* Find element factor, and multiply it to damage */
&lt;&lt;set _factor = 1; _flatFactor = 0&gt;&gt;
&lt;&lt;if typeof($action.element) == &quot;string&quot;&gt;&gt;
	&lt;&lt;set _factor = _target.getElement($action.element,&quot;percent&quot;)&gt;&gt;
	&lt;&lt;set _flatFactor = _target.getElement($action.element,&quot;flat&quot;)&gt;&gt;
&lt;&lt;elseif $action.element instanceof Array&gt;&gt;
	&lt;&lt;set _factor = 0&gt;&gt;
	&lt;&lt;if setup.AVERAGE_ELEMENTS === true&gt;&gt;
		&lt;&lt;for _v range $action.element&gt;&gt;
			&lt;&lt;set _factor += _target.getElement(_v,&quot;percent&quot;)&gt;&gt;
			&lt;&lt;set _flatFactor += _target.getElement(_v,&quot;flat&quot;)&gt;&gt;
		&lt;&lt;/for&gt;&gt;
		&lt;&lt;set _factor = _factor*1.0/$action.element.length&gt;&gt;
		&lt;&lt;set _flatFactor = _flatFactor*1.0/$action.element.length&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;for _v range $action.element&gt;&gt;
			&lt;&lt;set _factor = Math.max(_target.getElement(_v,&quot;percent&quot;),_factor)&gt;&gt;
			&lt;&lt;set _flatFactor = Math.min(_target.getElement(_v,&quot;flat&quot;),_flatFactor)&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _baseDmg = $dmg&gt;&gt;
&lt;&lt;set $dmg *= _factor; $dmg -= _flatFactor&gt;&gt;

/* Element message */
&lt;&lt;if def setup.elementMessages&gt;&gt;
	&lt;&lt;if _baseDmg &lt; $dmg&gt;&gt;
		&lt;&lt;set _elntmsg = setup.elementMessages.weakpoint&gt;&gt;
	&lt;&lt;elseif _baseDmg &gt; $dmg &amp;&amp; $dmg &gt; 0&gt;&gt;
		&lt;&lt;set _elntmsg = setup.elementMessages.resist&gt;&gt;
	&lt;&lt;elseif $dmg &lt; _baseDmg &amp;&amp; $dmg == 0&gt;&gt;
		&lt;&lt;set _elntmsg = setup.elementMessages.immune&gt;&gt;
	&lt;&lt;elseif $dmg &lt; _baseDmg &amp;&amp; $dmg &lt; 0&gt;&gt;
		&lt;&lt;set _elntmsg = setup.elementMessages.absorb&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;damageCalc custom factors&quot;&gt;&gt;

&lt;&lt;if !$B.phase &amp;&amp; $dmg &gt; 0&gt;&gt;
	/*	Only check for critical hits if:
			-no battle phase is specified (we are not selecting actions)
			-damage was not absorbed
	*/
	&lt;&lt;critCheck&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Check against minimum */
&lt;&lt;if ($dmg &lt; _baseDmg &amp;&amp; $dmg &lt;= 0)&gt;&gt;
	/* If elemental factors pushed damage to 0 or below, we shouldn&#39;t bump it up to the minimum; do nothing */
&lt;&lt;elseif _noDmgFloor &amp;&amp; $dmg &lt; 0&gt;&gt;
	&lt;&lt;set $dmg = 0&gt;&gt;
	&lt;&lt;set _noDmgFloor = false&gt;&gt; /* preventing data bleed */
&lt;&lt;elseif $dmg &lt; setup.MIN_DMG&gt;&gt;
	&lt;&lt;set $dmg = setup.MIN_DMG&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Round to integer */
&lt;&lt;set $dmg = Math.round($dmg)&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="54" name="Widget: healCalc" tags="widget nobr" position="475,725" size="100,100">&lt;&lt;widget &quot;healCalc&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0 &amp;&amp; $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set $target = $args[0]&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !action().formula&gt;&gt;
	&lt;&lt;include &quot;heal formula&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $heal = action().formula()&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="55" name="Widget: manaBurn" tags="widget nobr" position="600,725" size="100,100">&lt;&lt;widget &quot;manaBurn&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0 &amp;&amp; $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set $target = $args[0]&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;run console.assert($target instanceof Actor,&quot;ERROR in manaBurn: invalid target&quot;)&gt;&gt;

/* Protection check */
&lt;&lt;if !target().dead &amp;&amp; subject().id.charAt(0) !== target().id.charAt(0) &amp;&amp; target().protectedBy&gt;&gt;
	&lt;&lt;set _temp = $target.name&gt;&gt;
	&lt;&lt;set $target = $target.ownParty.find(function(t) { return t &amp;&amp; t.id === $target.protectedBy; })&gt;&gt;
	&lt;&lt;print $target.name+&quot; took the hit for &quot;+_temp+&quot;!\n&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if _queue instanceof Set&gt;&gt;
	&lt;&lt;set _queue.add($target)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !target().dead&gt;&gt;
	&lt;&lt;manaBurnCalc&gt;&gt;
	$target.name loses $dmg Energy!
	&lt;&lt;if setup.ANIMATIONS === true&gt;&gt;
		&lt;&lt;set target().battleMsg.push({shake: true, type: &quot;mana damage&quot;, content:$dmg})&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="56" name="Widget: echoDamage" tags="widget nobr" position="725,725" size="100,100">&lt;&lt;widget &quot;echoDamage&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0 &amp;&amp; $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set $target = $args[0]&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;run console.assert($target instanceof Actor,&quot;ERROR in echoDamage: invalid target&quot;)&gt;&gt;
&lt;&lt;set _dmgMods = $args&gt;&gt;

&lt;&lt;if _queue instanceof Set&gt;&gt;
	&lt;&lt;set _queue.add($target)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if def $bestiary &amp;&amp; target() instanceof Enemy &amp;&amp; $action.element&gt;&gt;
	&lt;&lt;set $bestiary.fetch(target().name).statsKnown[$action.element] = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !(_dmgMods.includes(&quot;nocalc&quot;) || _dmgMods.includes(&quot;indirect&quot;))&gt;&gt;
	&lt;&lt;damageCalc&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !target().dead&gt;&gt;
	&lt;&lt;set _continue = true&gt;&gt;
	&lt;&lt;if def _elntmsg&gt;&gt;&lt;b&gt;&lt;&lt;print _elntmsg+&quot; &quot;&gt;&gt;&lt;/b&gt;&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $dmg &lt; 0&gt;&gt;
		$target.name feeds on the energy, and recovers &lt;&lt;print $dmg*-1&gt;&gt; HP.
		&lt;&lt;set target().battleMsg.push({shake: false, type: &quot;healing&quot;, content:$dmg*-1})&gt;&gt;
	&lt;&lt;else&gt;&gt;
		$target.name takes $dmg damage!
		&lt;&lt;if !(_dmgMods.includes(&quot;indirect&quot;) || !(_queue instanceof Set) || setup.ANIMATIONS === false)&gt;&gt;
			&lt;&lt;set target().battleMsg.push({shake: true, type: &quot;damage&quot;, content:$dmg})&gt;&gt;
			&lt;&lt;if _elntmsg == setup.elementMessages.weakpoint &amp;&amp; typeof(setup.popupMod.weakpoint) == &quot;string&quot;&gt;&gt;
				&lt;&lt;set target().battleMsg.last().mod = setup.popupMod.weakpoint&gt;&gt;
			&lt;&lt;elseif _crit &amp;&amp; typeof(setup.popupMod.crit) == &quot;string&quot;&gt;&gt;
				&lt;&lt;set target().battleMsg.last().mod = setup.popupMod.crit+&quot; big&quot;&gt;&gt;
				&lt;&lt;set _crit = false&gt;&gt;
			&lt;&lt;elseif _elntmsg == setup.elementMessages.resist &amp;&amp; typeof(setup.popupMod.resist) == &quot;string&quot;&gt;&gt;
				&lt;&lt;set target().battleMsg.last().mod = setup.popupMod.resist&gt;&gt;
			&lt;&lt;elseif _elntmsg == setup.elementMessages.immune&gt;&gt;
				&lt;&lt;set target().battleMsg.last().content = &quot;IMMUNE&quot;;
					target().battleMsg.last().type = &quot;block&quot;&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if !_dmgMods.includes(&quot;indirect&quot;)&gt;&gt;
			&lt;&lt;include &quot;crisis formula&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;&lt;br /&gt;
	&lt;&lt;set $target.hp -= $dmg&gt;&gt;
	&lt;&lt;if subject() instanceof Actor&gt;&gt;
		&lt;&lt;set subject().lastDmg += $dmg&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if !_dmgMods.includes(&quot;indirect&quot;)&gt;&gt;
		&lt;&lt;if setup.THREAT_TARGETING === true &amp;&amp; subject() instanceof Puppet &amp;&amp; target() instanceof Enemy&gt;&gt;
			&lt;&lt;include &quot;echoDamage threat gain&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if (!$action.noReflection || target().absreflect) &amp;&amp; target().dmgreflection &amp;&amp; !_dmgreflecting &amp;&amp; target() !== subject() &amp;&amp; $dmg &gt; 0&gt;&gt;
		/* If target has defined damage reflection, they reflect the attack&#39;s damage times their damage reflection value onto their attacker. Note that this code is executed before deathcheck, meaning damage will be reflected even if the attack defeats the enemy. You can change this by moving deathcheck above this section and including a check that disallows damage reflection if the target is dead. */
			&lt;&lt;set $dmg = Math.round($dmg * target().dmgreflection)&gt;&gt;
			&lt;&lt;set _OG = {target: $target, subject: $subject}&gt;&gt;
			&lt;&lt;set $target = _OG.subject; $subject = _OG.target&gt;&gt;
			&lt;&lt;set _dmgreflecting = true&gt;&gt; /* this prevents infinite recursion if a damage reflector attacks a damage reflector; can only reflect damage once per attack */
			&lt;&lt;echoDamage &quot;nocalc&quot;&gt;&gt;
			&lt;&lt;set $target = _OG.target; $subject = _OG.subject&gt;&gt;
			&lt;&lt;unset _OG; _dmgreflecting&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end dmgreflection block */
		&lt;&lt;if target().onHit instanceof Array &amp;&amp; target().onHit.length &gt; 0 &amp;&amp; !_dmgreflecting &amp;&amp; target().id !== subject().id&gt;&gt;
		/* If target has onHit functions, they are executed here. Note that the target and subject are not reversed here, so if you want the effect to target the attacker, use &quot;subject&quot; as the selector, and vice versa. */
			&lt;&lt;for _action range target().onHit&gt;&gt;
				&lt;&lt;if _action instanceof Function&gt;&gt;
					&lt;&lt;print _action()&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;run console.log(&quot;ERROR in onHit: onHit elements must be functions&quot;)&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end onHit block */
	&lt;&lt;/if&gt;&gt; /* end indirect block */
	&lt;&lt;deathcheck&gt;&gt;
	&lt;&lt;if !target().dead &amp;&amp; !_dmgMods.includes(&quot;indirect&quot;)&gt;&gt;
		&lt;&lt;if !$action.noShock&gt;&gt;
			&lt;&lt;for _effect range target().effects.filter(function (eff) { return eff &amp;&amp; Number.isInteger(eff.shock)})&gt;&gt;
				&lt;&lt;set _shock = random(1,100)&gt;&gt;
				&lt;&lt;if _shock &lt;= _effect.shock&gt;&gt;
					&lt;&lt;print target().removeEffect(_effect)&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end shock block */
		&lt;&lt;if target().offbalance &amp;&amp; $dmg &gt;= 0&gt;&gt;
			&lt;&lt;print target().addEffect(&quot;Knocked Down&quot;,{time: -1})&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end off-balance block */
	&lt;&lt;/if&gt;&gt; /* end post-deathcheck block */
&lt;&lt;/if&gt;&gt; /* end target dead check block */

&lt;&lt;include &quot;Counter Logic&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="57" name="Counter Logic" tags="nobr" position="850,725" size="100,100">&lt;&lt;if !(_dmgMods.includes(&quot;indirect&quot;) || _dmgMods.includes(&quot;nocounter&quot;) || _counterActive || target().dead || target().noact || target().retaliations === 0 || target() === subject())
	&amp;&amp; _counters instanceof Array
	&amp;&amp; !_counters.includes(target().id)
	&amp;&amp; target().counter instanceof Action&gt;&gt;
/* Branch for adding target character to counterattack protocol. Counterattacks are only considered if you have enabled counters by setting the _counters variable before the action; this is done at the start of the action and Enemy Phases in the default engine, enabling counters for both puppets and enemies. */
/* By default, counters can trigger even on missed attacks. */
/* Target must hold a valid Action in its counter attribute to counterattack, and cannot be under a hold effect or have exhausted its allowed number of retaliations for this turn. */
	&lt;&lt;if target().counter.trigger&gt;&gt;
	/* This check is for if you want counters to be triggered only on special circumstances, such as only if the attack is ranged, or only if the attack makes contact. Define the trigger as a function in the counter action that returns true if the counter is triggered and false otherwise. By default, an unset trigger will return true, meaning the counter will always activate. */
		&lt;&lt;run _counters.push(target().id)&gt;&gt; /* Adds target to counter list, which will be read at the end of this action to perform the counter */
		&lt;&lt;run $B.actionQueue.push([target().id,target().counter])&gt;&gt;
		&lt;&lt;if target().retaliations &gt; 0&gt;&gt;
		/* Set retaliations to -1 for infinite counters. */
			&lt;&lt;set target().retaliations -= 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="58" name="Widget: shieldCheck" tags="widget nobr" position="975,725" size="100,100">&lt;&lt;widget &quot;shieldCheck&quot;&gt;&gt;
&lt;&lt;if $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set _targ = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _targ = target()&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _shield = _targ.effects.find(function (eff) { return eff &amp;&amp; eff.shield; })&gt;&gt;
&lt;&lt;if ndef _shield&gt;&gt;
	&lt;&lt;set _continue = true&gt;&gt;
&lt;&lt;elseif _shield.onHit instanceof Function&gt;&gt;
	&lt;&lt;run console.log(`echoDamage for ${target().name}: shield found`)&gt;&gt;
	&lt;&lt;run _shield.uses -= 1&gt;&gt;
	&lt;&lt;set _targ.battleMsg.push({shake: false, type: &quot;block&quot;, content:&quot;BLOCKED&quot;})&gt;&gt;
	&lt;&lt;print _shield.onHit(_targ)&gt;&gt;
	&lt;&lt;set _continue = false&gt;&gt;
	&lt;&lt;set _hit = false&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;run console.log(&quot;ERROR in echoDamage: shield effect has no onHit function&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="59" name="Widget: accuracyCheck" tags="widget nobr" position="1100,725" size="100,100">&lt;&lt;widget &quot;accuracyCheck&quot;&gt;&gt;
&lt;&lt;if $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set _target = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _target = $target&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;accuracy formula&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="60" name="Widget: critCheck" tags="widget nobr" position="1225,725" size="100,100">&lt;&lt;widget &quot;critCheck&quot;&gt;&gt;
&lt;&lt;include &quot;crit formula&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="61" name="Widget: effectcalc" tags="widget nobr" position="100,850" size="100,100">/* DEPRECIATED as of v1.28. Use the Effect.calculatePower method instead. */
&lt;&lt;widget &quot;effectcalc&quot;&gt;&gt;
&lt;&lt;switch $args[0]&gt;&gt;
	&lt;&lt;case &quot;debuff&quot;&gt;&gt;
		&lt;&lt;set _power = Math.round((setup.effbase+setup.effdamper*(_subject.get(StatName(&quot;spc&quot;))-_target.get(StatName(&quot;spc&quot;))))*$action.effweight)&gt;&gt;
		&lt;&lt;if _power &lt; setup.min_debuff&gt;&gt;
			&lt;&lt;set _power = setup.min_debuff&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;case &quot;buff&quot;&gt;&gt;
		&lt;&lt;set _power = Math.round((setup.effbase+setup.effdamper*(_subject.get(StatName(&quot;spc&quot;))))*$action.effweight)&gt;&gt;
		&lt;&lt;if _power &lt; setup.min_buff&gt;&gt;
			&lt;&lt;set _power = setup.min_buff&gt;&gt;
		&lt;&lt;/if&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="62" name="Decurse Station" tags="noreturn" position="225,850" size="100,100">&lt;&lt;longreturn&gt;&gt;&lt;&lt;set _decurseCost = 1; _appraiseCost = _decurseCost&gt;&gt;

Run afoul of some nasty curses? Not to worry, a cleric of MegaCorp® is on staff and happy to help... for the right price, of course.

That price is &lt;&lt;print _decurseCost&gt;&gt; &lt;&lt;print setup.CURRENCY_NAME&gt;&gt;.

&lt;b&gt;Points: &lt;&lt;live $currency&gt;&gt;&lt;/b&gt;

&lt;&lt;nobr&gt;&gt;
&lt;div id=&quot;business-area&quot;&gt;
&lt;&lt;include &quot;decurse options&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;</tw-passagedata><tw-passagedata pid="63" name="decurse options" tags="nobr" position="350,850" size="100,100">&lt;&lt;if $currency &lt; _decurseCost&gt;&gt;
  Oh, dear. It seems you can&#39;t afford the cleric&#39;s services. Better luck next time! If there is a next time.
&lt;&lt;else&gt;&gt;
  &lt;&lt;link &quot;Appraise suspicious item&quot;&gt;&gt;
    &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse-appraise&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;/link&gt;&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;&lt;link &quot;Remove cursed item&quot;&gt;&gt;
    &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse-remove&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="64" name="decurse-appraise" tags="nobr" position="475,850" size="100,100">&lt;&lt;set _x = Array.from(inv().values()).filter(function (item) { return item &amp;&amp; (item.sticky === true &amp;&amp; !item.known); })&gt;&gt;
&lt;&lt;if _x.length &gt; 0&gt;&gt;
&lt;&lt;link &quot;Try a different service...&quot;&gt;&gt;
  &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse options&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;br/&gt;
&lt;br/&gt;
  &lt;&lt;for _index, _item range _x&gt;&gt;
    &lt;div @id=&quot;_index&quot;&gt;
      &lt;b&gt;_item.name&lt;/b&gt;
      &lt;div class=&quot;shop-button&quot;&gt;
      &lt;&lt;if $currency &gt;= _appraiseCost&gt;&gt;
        &lt;&lt;capture _item, _index&gt;&gt;
          [&lt;&lt;link &quot;APPRAISE&quot;&gt;&gt;
            &lt;&lt;set $currency -= 1&gt;&gt;
            &lt;&lt;update&gt;&gt;
            &lt;&lt;set _item.known = true&gt;&gt;
            &lt;&lt;set _id = &quot;#&quot;+_index&gt;&gt;
            &lt;&lt;replace _id&gt;&gt;
              &lt;div class=&quot;itembox&quot;&gt;
              &lt;b&gt;_item.name&lt;/b&gt;&lt;br/&gt;
              &lt;&lt;print _item.info&gt;&gt;&lt;br/&gt;
              &lt;span class=&quot;actdesc&quot;&gt;&lt;&lt;print _item.desc&gt;&gt;&lt;/span&gt;
              &lt;/div&gt;
            &lt;&lt;/replace&gt;&gt;
          &lt;&lt;/link&gt;&gt;]
        &lt;&lt;/capture&gt;&gt;
      &lt;&lt;/if&gt;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;&lt;/for&gt;&gt;
&lt;&lt;else&gt;&gt;
  It seems you don&#39;t have any unknown items. &lt;&lt;link &quot;Try a different service...&quot;&gt;&gt;
    &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse options&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="65" name="decurse-remove" tags="nobr" position="600,850" size="100,100">&lt;&lt;set _x = $puppets.filter(function (puppet) { return puppet &amp;&amp; puppet.hasCursedItem() === true; })&gt;&gt;
&lt;&lt;if _x.length &gt; 0&gt;&gt;
&lt;&lt;link &quot;Try a different service...&quot;&gt;&gt;
  &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse options&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;br/&gt;
&lt;br/&gt;
  &lt;&lt;for _i, _p range _x&gt;&gt;
    &lt;&lt;actorDisplay _p &quot;decurse&quot;&gt;&gt;
  &lt;&lt;/for&gt;&gt;
&lt;&lt;else&gt;&gt;
  It seems no one is currently saddled with any cursed items. &lt;&lt;link &quot;Try a different service...&quot;&gt;&gt;
    &lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse options&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="66" name="Effect Adder" tags="widget nobr" position="725,850" size="100,100">/* Handles effect applications. */

&lt;&lt;widget &quot;addEffect&quot;&gt;&gt;
/* Sets power for relevant effects and avoids duplicating an effect if it&#39;s already in the array. */
/* args0 is target, args1 is effect name, args2 is duration, args3 is inflictor (where applicable). If you want the power to be a flat value, pass a number to args3 instead and it will be used as an override. */
&lt;&lt;if $args.length &gt; 0&gt;&gt;

&lt;&lt;set _target = $args[0]&gt;&gt; /* for clarity */
&lt;&lt;set _subject = $subject&gt;&gt;

&lt;&lt;print _target.addEffect($args[1],{time: $args[2], actor: $args[3]})&gt;&gt;

&lt;&lt;else&gt;&gt;
&lt;&lt;run console.log(&quot;ERROR in addEffect: no arguments passed&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt; /* end args check */
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="67" name="Item Shop" tags="noreturn" position="850,850" size="100,100">&lt;&lt;longreturn&gt;&gt;

MegaCorp® is happy to provide you with their top-of-the-line items, provided you have the cash. You have a limited budget, so choose which items you want to bring into your next battle. MegaCorp® will (with uncharacteristic generosity) fully refund you for any items you wish to exchange, so don&#39;t worry about going broke.

&lt;b&gt;Points: &lt;&lt;live $currency&gt;&gt;&lt;/b&gt;

&lt;span id=&quot;items&quot;&gt;&lt;&lt;include &quot;item shop display&quot;&gt;&gt;&lt;/span&gt;</tw-passagedata><tw-passagedata pid="68" name="item shop display" tags="nobr" position="975,850" size="100,100">&lt;&lt;for _k, _v range $inventory&gt;&gt;
&lt;&lt;if _v.usable.includes(&quot;inbattle&quot;)&gt;&gt;
&lt;div&gt;
&lt;b&gt;_v.name&lt;/b&gt; (Stock: _v.maxstock)
&lt;div class=&quot;shop-button&quot;&gt;
&lt;&lt;capture _v&gt;&gt;
	&lt;&lt;if $currency &gt;= _v.value &amp;&amp; _v.maxstock &lt; setup.ITEM_MAX&gt;&gt;
	[&lt;&lt;link &quot;BUY&quot;&gt;&gt;
		&lt;&lt;replace &quot;#items&quot;&gt;&gt;
			&lt;&lt;run _v.maxstock++&gt;&gt;
			&lt;&lt;set $currency -= _v.value&gt;&gt;
			&lt;&lt;update&gt;&gt;
			&lt;&lt;include &quot;item shop display&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $currency &gt;= _v.value &amp;&amp; _v.maxstock &gt; 0&gt;&gt; / &lt;&lt;/if&gt;&gt;
	&lt;&lt;if _v.maxstock &gt; 0&gt;&gt;
	[&lt;&lt;link &quot;SELL&quot;&gt;&gt;
		&lt;&lt;replace &quot;#items&quot;&gt;&gt;
			&lt;&lt;run _v.maxstock--&gt;&gt;
			&lt;&lt;set $currency += _v.value&gt;&gt;
			&lt;&lt;update&gt;&gt;
			&lt;&lt;include &quot;item shop display&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/capture&gt;&gt;
 &lt;b&gt;Cost: _v.value&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;&lt;print _v.info&gt;&gt;&lt;br/&gt;
&lt;span class=&quot;action-desc&quot;&gt;&lt;&lt;print _v.desc&gt;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="69" name="PassageDone" tags="nobr" position="1100,850" size="100,100">&lt;&lt;if _animationActive&gt;&gt;
  &lt;&lt;include &quot;animation activator&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;include &quot;PassageDone-custom&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="70" name="PassageFooter" tags="nobr" position="1225,850" size="100,100">&lt;&lt;include &quot;PassageFooter-custom&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="71" name="PassageHeader" tags="nobr" position="100,975" size="100,100">&lt;&lt;if tags().includes(&quot;menu&quot;)&gt;&gt;
	&lt;&lt;unset $subject, $target&gt;&gt;
	&lt;&lt;include &quot;menubar&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;PassageHeader-custom&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="72" name="PassageReady" tags="" position="225,975" size="100,100">&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;chain&gt;&gt;
	&lt;&lt;set $B.actors = $enemies.concat($puppets)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;include &quot;PassageReady-custom&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="73" name="StoryInit" tags="" position="350,975" size="100,100">&lt;&lt;include &quot;hotkey definitions&quot;&gt;&gt;

&lt;&lt;set setup.formula = &quot;subtractive&quot;&gt;&gt;
&lt;&lt;set setup.TURN_MODEL = &quot;free&quot;&gt;&gt;

&lt;&lt;set setup.base = 80&gt;&gt; /* base constant for dmg formula */
&lt;&lt;set setup.damper = 1&gt;&gt; /* damping factor for dmg formula */
&lt;&lt;set setup.effbase = 30&gt;&gt; /* base constant for stat mods */
&lt;&lt;set setup.effdamper = 0.5&gt;&gt; /* damping factor for stat mods */
&lt;&lt;set setup.MIN_DMG = 1&gt;&gt; /* minimum damage */
&lt;&lt;set setup.min_DoT = 1&gt;&gt; /* minimum DoT damage */
&lt;&lt;set setup.min_buff = 0&gt;&gt; /* minimum buff effect */
&lt;&lt;set setup.min_debuff = 5&gt;&gt; /* minimum debuff effect */

/* The following stat names will be referenced in situations that call for them (damage formula, etc.), change these if you want to change stat names */
&lt;&lt;set setup.STAT_NAMES = {
	&quot;Attack&quot;: &quot;Attack&quot;,
	&quot;Defense&quot;: &quot;Defense&quot;,
	&quot;Special&quot;: &quot;Special&quot;,
	&quot;Crit&quot;: &quot;Skill&quot;,
	&quot;Accuracy&quot;: &quot;Accuracy&quot;,
	&quot;Evasion&quot;: &quot;Evasion&quot;,
	&quot;Speed&quot;: &quot;Speed&quot;,
	&quot;Initiative&quot;: &quot;Initiative&quot;,
	&quot;Energy&quot;: &quot;Energy&quot;,
	&quot;EnergyShort&quot;: &quot;EN&quot;
}&gt;&gt;

/*	Tooltip information associated with each stat, to be displayed in the status menu.
		Also used elsewhere as a reference for the identity of core stats. */
&lt;&lt;set setup.statInfo = {
	&quot;Attack&quot;: &quot;Increases damage of regular attacks by 1 per point.&quot;,
	&quot;Defense&quot;: &quot;Reduces damage taken by 1 per point.&quot;,
	&quot;Special&quot;: &quot;Improves effectiveness of status effects, mitigates received status ailments, and increases damage of item attacks by 1 per point.&quot;,
	&quot;Skill&quot;: &quot;Increases critical hit chance by 1% per point.&quot;,
	&quot;Accuracy&quot;: &quot;Increases attack accuracy by 1% per point.&quot;,
	&quot;Evasion&quot;: &quot;Reduces incoming attack accuracy by 1% per point.&quot;,
	&quot;Initiative&quot;: &quot;Determines starting turn order and tiebreakers. Starting tick is highest combatant&#39;s Initiative minus this value.&quot;,
	&quot;Speed&quot;: &quot;Shortens recovery time by 1 tick per point.&quot;
}&gt;&gt;

/*	These stats will not be displayed in the menu or status pane even if they are core stats
		Entries must match stat names exactly, case-sensitive */
&lt;&lt;set setup.hiddenStats = [&quot;Skill&quot;,&quot;Accuracy&quot;,&quot;Evasion&quot;]&gt;&gt;

/*	Default equipment slots. Keys are the name of the slot, value is number of subslots (only considered if &gt;1) */
&lt;&lt;set setup.DEFAULT_EQUIP_SLOTS = {
  &quot;Weapon&quot;: 1,
	&quot;Armor&quot;: 1,
	&quot;Accessory&quot;: 2
  }&gt;&gt;

/* An array of all the elements that will appear in your game, in the order you wish for them to be displayed on the elemental resistances screen. The Actor constructor will automatically initialize everyone&#39;s values for these strings to 1. Note that any use of these elements must be set to EXACTLY the same string, case-sensitive. */
&lt;&lt;set setup.ELEMENT_LIST to [&quot;black&quot;,&quot;white&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]&gt;&gt;

&lt;&lt;set setup.elementMessages = {
		weakpoint: &quot;Super effective!&quot;,
		resist: &quot;It&#39;s not very effective...&quot;,
		immune: &quot;No effect!&quot;,
		absorb: &quot;Absorbed!&quot;
	}&gt;&gt;

/* An array of all additional status screens you want displayed in the status box. There are separate lists for the menu status screen and the battle status pane, if you want different information displayed in each. If you set one of the attributes to an empty array or unset it entirely, the arrow buttons will not display at all, and the player will only see the default screen. */
&lt;&lt;set setup.STATUS_SCREENS to {
	menu: [&quot;equipment&quot;,&quot;elements&quot;,&quot;ailments&quot;],
	bestiary: [&quot;stats&quot;,&quot;elements&quot;,&quot;ailments&quot;,&quot;rewards&quot;],
	battle: [&quot;elements&quot;,&quot;ailments&quot;]
	}&gt;&gt;

&lt;&lt;set setup.MENU_OPTIONS = [&quot;Status&quot;,&quot;Inventory&quot;,&quot;Equipment&quot;,&quot;Party&quot;]&gt;&gt;

&lt;&lt;set $currency = 0&gt;&gt;
&lt;&lt;set setup.CURRENCY_NAME = &quot;GP&quot;&gt;&gt;
/* This is the name that will be displayed every time the game refers to currency. By default it is the Dungeons &amp; Dragons standard, GP for &quot;gold pieces&quot;. */

/* Set whether to show animations in battle. */
&lt;&lt;set setup.ANIMATIONS = true&gt;&gt;

/* Set whether to show health meters in battle. */
&lt;&lt;set setup.SHOW_HEALTHBARS = true&gt;&gt;

&lt;&lt;set setup.ENEMY_BAR_COLOR = &quot;#cc0000&quot;&gt;&gt;
&lt;&lt;set setup.PLAYER_BAR_COLOR = &quot;green&quot;&gt;&gt;
&lt;&lt;set setup.MP_BAR_COLOR = &quot;blue&quot;&gt;&gt;
&lt;&lt;set setup.HEALTH_BAR_TIME = &quot;500ms&quot;&gt;&gt; /* animation duration for health bar updates (after taking damage, etc.) */

&lt;&lt;set setup.PORTRAITS = false&gt;&gt;
&lt;&lt;set setup.SHOW_MP = true&gt;&gt;

/* Set whether to display soak and flat regen in status screens. If you don&#39;t use either, you can set these to false for clarity. */
&lt;&lt;set setup.SOAK = true&gt;&gt;
&lt;&lt;set setup.FLAT_REGEN = true&gt;&gt;

/* Initializing constants that will be used elsewhere. DON&#39;T define variables that will be used in JavaScript database definitions here, as StoryInit is run after JavaScript initialization. */
&lt;&lt;set setup.MAX_EN = null;
      setup.EN_REGEN = null;&gt;&gt;
&lt;&lt;set setup.STRUGGLE_COST = 2&gt;&gt;
&lt;&lt;set setup.ITEM_COST = 2&gt;&gt; /* EN cost of using items */
&lt;&lt;set setup.RESPAWN_HP = 1&gt;&gt; /* proportion of HP that respawned characters will revive at */
&lt;&lt;set setup.THREAT_DECAY = 0.10&gt;&gt; /* threat decay per round */
&lt;&lt;set setup.ITEM_MAX = 9&gt;&gt; /* maximum of each item that can be stored in inventory */
&lt;&lt;set setup.PARTY_SIZE = 3&gt;&gt;
&lt;&lt;set setup.ACCURACY_RATE = true&gt;&gt; /* default accuracy of attacks in percent value or Boolean, default always-accurate */
&lt;&lt;set setup.MIN_ACCURACY = 0&gt;&gt; /* minimum accuracy rate if reduced by e.g. evasion stat */
&lt;&lt;set setup.CRITICAL_RATE = 0&gt;&gt; /* default critical hit rate in percent value, default 0% (no crits) */
&lt;&lt;set setup.CRITICAL_MULTIPLIER = 1.5&gt;&gt; /* default multiplier for critical hit damage */
&lt;&lt;set setup.CRISIS_FACTOR = (10/7)&gt;&gt; /* multiplied by dmg/maxHP to get crisis points per hit, at 1 target must take 100% max HP to fill Crisis */
&lt;&lt;set setup.DURATION_MAX = 9&gt;&gt; /* maximum turns a status effect can last */
&lt;&lt;set setup.FIREFLY_FACTOR = 2&gt;&gt; /* targeting probability multiplier for characters with Firefly */
&lt;&lt;set setup.WALLFLOWER_FACTOR = 0.5&gt;&gt; /* targeting probability multiplier for characters with Wallflower */
&lt;&lt;set setup.INDEFINITE_EFFECT_MULTIPLIER = 2&gt;&gt; /* multiplier for effect threat value for indefinite effects */
&lt;&lt;set setup.EFFECT_THREAT_CUT = 4&gt;&gt; /* divisor for threat addition based on duration */
&lt;&lt;set setup.PRAGMATIC_CUTOFF = 0.5&gt;&gt; /* proportion of HP a character must lose to be excluded from pragmatic targeting */
&lt;&lt;set setup.RUTHLESS_FACTOR = 3&gt;&gt; /* multiplied by remaining HP proportion when calculating targeting for &quot;ruthless&quot; attacks */

&lt;&lt;set setup.MISS_MESSAGE = &quot;$subject.name misses!&quot;&gt;&gt;
&lt;&lt;set setup.CRIT_MESSAGE = &quot;&lt;b&gt;Critical hit!&lt;/b&gt;&quot;&gt;&gt;

&lt;&lt;set setup.STATUS_BUTTON = &quot;[*]&quot;&gt;&gt; /* Text used for the appearance of the status button */

&lt;&lt;set setup.popupMod = {
		weakpoint: &quot;orange&quot;,
		resist: &quot;gray&quot;,
		crit: &quot;gold&quot;
	}
&gt;&gt;

&lt;&lt;set $difficulty to &quot;hard&quot;&gt;&gt;
/*
Hard: smart targeting will only target vulnerable characters
Medium: smart targeting gives preference to vulnerable characters
Easy: no smart targeting
*/

&lt;&lt;set $inventory = new Inventory([])&gt;&gt;

/* This is a controller object. Use it to store any variables you don&#39;t want to persist after battles. Then, instead of having to remember and reset every variable, just reset this to a blank object. */
&lt;&lt;set $B = {}&gt;&gt;

/* Stores whether encounters have been fought. Useful if you want to be able to quickly refer to them e.g. to allow the player to progress after they have defeated an encounter in a certain passage. */
&lt;&lt;set $encounters = {}&gt;&gt;

/* Initializing miscellaneous variables. */
&lt;&lt;set $action to null&gt;&gt;
&lt;&lt;set $effects_to_remove = 0&gt;&gt;
&lt;&lt;set $removed_effects = []&gt;&gt;
&lt;&lt;set $tutorial to false&gt;&gt;
&lt;&lt;set $inbattle to false&gt;&gt;
&lt;&lt;set $LevelUps = []&gt;&gt;

/* Determines whether the action list shows full action data or not. If true, hovering over an action will display a tooltip with the full action information. */
&lt;&lt;set setup.COMPRESSED_ACTIONS = true&gt;&gt;

/* Set whether to display the Confirm Phase in battle. This can be toggled by the user in the UI bar. */
&lt;&lt;set setup.SHOW_CONFIRM = true&gt;&gt;

/* Set whether to automatically end the player&#39;s turn. This can be toggled by the user in the UI bar. */
&lt;&lt;set setup.AUTO_ENDTURN = true&gt;&gt;

/* Set whether to use threat-based/aggro targeting. Turned off by default. */
&lt;&lt;set setup.THREAT_TARGETING = false&gt;&gt;

/* Set whether to use a 3x3 battle grid or a standard lineup. Turned off by default. */
&lt;&lt;set setup.BATTLE_GRID = false&gt;&gt;

/* Set whether to use turn exchange (force an enemy action for every player action). Turned off by default. */
&lt;&lt;set setup.TURN_EXCHANGE = false&gt;&gt;

/* Determine how multiple-element attacks calculate affinity factors.
		-true: Damage modifier will be the average of all of the target&#39;s affinities
			ex/ If target takes 0.5x damage from Red and 1x damage from Blue, a dual Red &amp; Blue attack will inflict x0.75
		-false: Damage modifier will find the best (for the attacker) of all the target&#39;s affinities
			ex/ If target takes 0.5x damage from Red and 1x damage from Blue, a dual Red &amp; Blue attack will inflict x1
*/
&lt;&lt;set setup.AVERAGE_ELEMENTS = true&gt;&gt;

/* Set whether to reveal all enemy data on kill. */
&lt;&lt;set setup.ENEMY_DATA_ON_KILL = true&gt;&gt;

/* Prevents names from stretching actor boxes; names exceeding the length will be scaled. See scaledTextDiv in support functions for more details. */
&lt;&lt;set setup.SCALE_NAMES = false&gt;&gt;

/* Determine what properties, if any, are recovered by puppets after battle. */
&lt;&lt;set $afterBattleRecovery = {
	&quot;hp&quot;: true,
	&quot;revive&quot;: true,
	&quot;actions&quot;: true
	}&gt;&gt;

/* Time values for hit animations, in ms. */
&lt;&lt;set setup.ANIM_WINDUP = 750;
	setup.ANIM_DURATION = 750;
	setup.DMG_DURATION = 1000;
	setup.ANIM_DELAY = 600;&gt;&gt;

&lt;&lt;include &quot;User-defined variables&quot;&gt;&gt;
/* Put any additional variables and code you want to run during StoryInit here so you don&#39;t have to juggle multiple files on a version update. */</tw-passagedata><tw-passagedata pid="74" name="Widget: martyrCheck" tags="widget nobr" position="475,975" size="100,100">&lt;&lt;widget &quot;martyrCheck&quot;&gt;&gt;
&lt;&lt;set _martyrTest = _party.find(function (p) { return p &amp;&amp; p.martyr === true })&gt;&gt;
/* Note that this assumes only one Martyr can be active at a time. If multiple are active, this will only find the first in the array. */
&lt;&lt;if _martyrTest&gt;&gt;
	&lt;&lt;set $target = _martyrTest&gt;&gt;
	&lt;&lt;set _continue to false&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="75" name="Widget: protectionCheck" tags="widget nobr" position="600,975" size="100,100">&lt;&lt;widget &quot;protectionCheck&quot;&gt;&gt;
/* Checks if target is protected by someone with the Protector effect */
&lt;&lt;if $target !== null &amp;&amp; $target.protectedBy&gt;&gt;
	&lt;&lt;set _temp = $target.name&gt;&gt;
	&lt;&lt;switch $target.id.charAt(0)&gt;&gt;
		&lt;&lt;case &quot;p&quot;&gt;&gt;
			&lt;&lt;set _party = $puppets&gt;&gt;
		&lt;&lt;case &quot;e&quot;&gt;&gt;
			&lt;&lt;set _party = $enemies&gt;&gt;
		&lt;&lt;default&gt;&gt;
			&lt;&lt;set _party = $puppets; console.log(&quot;ERROR in protectionCheck: invalid ID type&quot;)&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
	&lt;&lt;set $target = _party.find(function(t) { return t &amp;&amp; t.id === $target.protectedBy; })&gt;&gt;
	&lt;&lt;set _targetingMsg = $target.name+&quot; took the hit for &quot;+_temp+&quot;!\n&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="76" name="Widget: guardCheck" tags="widget nobr" position="725,975" size="100,100">&lt;&lt;widget &quot;guardCheck&quot;&gt;&gt;
/* Checks if target is blocked by another character (battle map style only) */
&lt;&lt;set _index = _party.indexOf(target())&gt;&gt;
&lt;&lt;if _index &gt;= setup.ROW_SIZE &amp;&amp; _party[_index-setup.ROW_SIZE] !== null &amp;&amp; !_party[_index-setup.ROW_SIZE].dead&gt;&gt;
	&lt;&lt;set $target = _party[_index-setup.ROW_SIZE]&gt;&gt;
&lt;&lt;elseif _index &gt;= setup.ROW_SIZE * 2&gt;&gt;
	&lt;&lt;set $target = _party[_index-setup.ROW_SIZE]&gt;&gt;
	&lt;&lt;guardCheck&gt;&gt; /* Run again to test if the new mid-row target is in turn guarded by a front row character */
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="77" name="Widget: threatTarget" tags="widget nobr" position="850,975" size="100,100">&lt;&lt;widget &quot;threatTarget&quot;&gt;&gt;
&lt;&lt;if _modifiers.includes(&quot;random&quot;)&gt;&gt;
	/* truly random selection, ignores threat */
	&lt;&lt;set $target = null&gt;&gt;
	&lt;&lt;for target() === null&gt;&gt;
		&lt;&lt;set _rand = random(0,puppets().length-1)&gt;&gt;
		&lt;&lt;if !puppets()[_rand].dead &amp;&amp; (_modifiers.includes(&quot;ignore untargetable&quot;) || !puppets()[_rand].untargetable)&gt;&gt;
			&lt;&lt;set $target = puppets()[_rand]&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;set _continue = false&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if _continue&gt;&gt;

	&lt;&lt;set _totalThreat = 0&gt;&gt;
	&lt;&lt;for _puppet range puppets().filter(function (p) { return !p.dead; })&gt;&gt;
		&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
			&lt;&lt;set _threat = subject().threat.get(_puppet.name)&gt;&gt;
			&lt;&lt;run _hitlist.push({target: _puppet, threat: _threat})&gt;&gt;
			&lt;&lt;set _totalThreat += _threat&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;

	&lt;&lt;if _hitlist.length &gt; 0&gt;&gt;
		&lt;&lt;set _rand = random(1,_totalThreat)&gt;&gt;
		&lt;&lt;for _i, _target range _hitlist&gt;&gt;
			&lt;&lt;if _i != 0&gt;&gt;
				&lt;&lt;set _target.threat += _hitlist[_i-1].threat&gt;&gt;
				&lt;&lt;if _rand &lt;= _target.threat &amp;&amp; _rand &gt; _hitlist[_i-1].threat&gt;&gt;
					&lt;&lt;set $target = _target.target&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;elseif _rand &lt;= _target.threat&gt;&gt;
				&lt;&lt;set $target = _target.target&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;else&gt;&gt; /* everyone&#39;s dead, flag targetfail */
		&lt;&lt;set _targetfail = true&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt; /* end random if */
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="78" name="Widget: randomTarget" tags="widget nobr" position="975,975" size="100,100">&lt;&lt;widget &quot;randomTarget&quot;&gt;&gt;
&lt;&lt;if deadCount() == puppets().length || enemies().filter(function (e) { return e.dead; }).length == enemies().length&gt;&gt;
	&lt;&lt;set _targetfail = true&gt;&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;set _modifiers = []&gt;&gt;
&lt;&lt;if $args[0] instanceof Array&gt;&gt;
	&lt;&lt;set _modifiers = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;for _arg range $args&gt;&gt;
		&lt;&lt;run _modifiers.push(_arg)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _continue = true&gt;&gt;

/* Check if this widget is being run for a puppet under a loss-of-control effect. */
&lt;&lt;if subject() instanceof Puppet&gt;&gt;
	&lt;&lt;if _modifiers.includes(&quot;any&quot;)&gt;&gt; /* if can target any party (e.g. confusion), pass &quot;any&quot; as an argument to the widget and target party will be selected randomly */
		&lt;&lt;set _selector = random(1,2)&gt;&gt;
		&lt;&lt;switch _selector&gt;&gt;
			&lt;&lt;case 1&gt;&gt;
				&lt;&lt;set _party = $puppets&gt;&gt;
			&lt;&lt;case 2&gt;&gt;
				&lt;&lt;set _party = $enemies&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
	&lt;&lt;elseif _modifiers.includes(&quot;enemies&quot;)&gt;&gt;
		&lt;&lt;switch subject().id.charAt(0)&gt;&gt;
			&lt;&lt;case &#39;p&#39;&gt;&gt;
				&lt;&lt;set _party = $enemies&gt;&gt;
			&lt;&lt;case &#39;e&#39;&gt;&gt;
				&lt;&lt;set _party = $puppets&gt;&gt;
			&lt;&lt;/switch&gt;&gt;
	&lt;&lt;elseif _modifiers.includes(&quot;allies&quot;)&gt;&gt;
	&lt;&lt;switch subject().id.charAt(0)&gt;&gt;
		&lt;&lt;case &#39;p&#39;&gt;&gt;
			&lt;&lt;set _party = $puppets&gt;&gt;
		&lt;&lt;case &#39;e&#39;&gt;&gt;
			&lt;&lt;set _party = $enemies&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _party = $puppets&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _party = _party.filter(function (a) { return a !== null; })&gt;&gt;

/* Priority 1: Martyr takes all hits */
&lt;&lt;martyrCheck&gt;&gt;

&lt;&lt;if _continue&gt;&gt;

/* Priority 2: aggro enemies bypass normal targeting */
&lt;&lt;if $subject.aggro &amp;&amp; def $attacker&gt;&gt;
	&lt;&lt;set $target = $puppets[$attacker]&gt;&gt; /* always targets the puppet that attacked last */
	&lt;&lt;if !$target.dead&gt;&gt;
		&lt;&lt;set _continue = false&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	/* Note that this bypasses untargetable as well */
&lt;&lt;/if&gt;&gt;

&lt;&lt;if _continue&gt;&gt;

/* check if only untargetables remain */
&lt;&lt;if !_modifiers.includes(&quot;ignore untargetable&quot;)&gt;&gt;
	&lt;&lt;set _untargetTest = _party.filter(function (p) { return (p.dead || p.untargetable) })&gt;&gt;
	&lt;&lt;if _untargetTest.length == _party.length&gt;&gt;
		&lt;&lt;run _modifiers.push(&quot;ignore untargetable&quot;)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _hitlist = []&gt;&gt;

/* If subject is a Puppet, target will be selected completely randomly. By default, it is possible for a charmed or confused puppet to attack themselves. */
&lt;&lt;if subject() instanceof Puppet&gt;&gt;
	&lt;&lt;set $target = null&gt;&gt;
	&lt;&lt;for target() === null&gt;&gt;
		&lt;&lt;set _rand = random(0,_party.length-1)&gt;&gt;
		&lt;&lt;if !_party[_rand].dead &amp;&amp; (_modifiers.includes(&quot;ignore untargetable&quot;) || !_party[_rand].untargetable)&gt;&gt;
			&lt;&lt;set $target = _party[_rand]&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;

&lt;&lt;else&gt;&gt;

&lt;&lt;if setup.THREAT_TARGETING === true&gt;&gt;

&lt;&lt;threatTarget&gt;&gt;

&lt;&lt;else&gt;&gt;

/* mercy setting */
&lt;&lt;if $subject.mercy &lt; 1 or _modifiers.includes(&quot;smart&quot;)&gt;&gt;
/* if enemy&#39;s mercy is below 1, they will always use smart targeting */
	&lt;&lt;set _mercy = 2&gt;&gt;
&lt;&lt;else&gt;&gt;
/* 1 in (mercy) chance of random targeting, to give players a break */
	&lt;&lt;set _mercy = random(1,$subject.mercy)&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* smart targeting */
&lt;&lt;if $difficulty is &quot;hard&quot;&gt;&gt;

&lt;&lt;if _mercy &gt; 1&gt;&gt;
	&lt;&lt;if !_modifiers.includes(&quot;ignore downed&quot;)&gt;&gt;
/* This clause makes enemies preferentially target off-balance and downed puppets. */
		&lt;&lt;for _puppet range _party.filter(function (p) { return !p.dead &amp;&amp; (p.offbalance || p.down); })&gt;&gt;
			&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
				&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _modifiers.includes(&quot;debuff&quot;)&gt;&gt;
/* Debuffing attacks will preferentially target puppets with lowered Special, as they will be more strongly affected */
		&lt;&lt;for _puppet range _party.filter(function (p) { return !(p.dead || p.chi || p.stasis) &amp;&amp; p.get(StatName(&quot;spc&quot;)) &lt; p.getBase(StatName(&quot;spc&quot;)); })&gt;&gt;
			&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
				&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
			&lt;&lt;/if&gt;&gt;
   		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;if _hitlist.length &gt; 0&gt;&gt;
		&lt;&lt;set _continue = false&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* normal targeting */
&lt;&lt;if _continue&gt;&gt;
	&lt;&lt;for _puppet range _party.filter(function (p) { return !p.dead; })&gt;&gt;
		&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
			&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;elseif $difficulty is &quot;medium&quot;&gt;&gt;

&lt;&lt;for _puppet range _party.filter(function (p) { return !p.dead; })&gt;&gt;
	&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
		&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;

		/* smart targeting */
		&lt;&lt;if _mercy &gt; 1&gt;&gt;
			&lt;&lt;if !_modifiers.includes(&quot;ignore downed&quot;)&gt;&gt;
			/* This clause makes enemies preferentially target off-balance and downed puppets. */
				&lt;&lt;if _puppet.offbalance || _puppet.down&gt;&gt;
					&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;if _modifiers.includes(&quot;debuff&quot;)&gt;&gt;
			/* Debuffing attacks will preferentially target puppets with lowered Special, as they will be more strongly affected */
				&lt;&lt;if !_puppet.chi &amp;&amp; &amp;&amp; !_puppet.stasis &amp;&amp; (_puppet.get(StatName(&quot;spc&quot;)) &lt; _puppet.getBase(StatName(&quot;spc&quot;)))&gt;&gt;
					&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt; /* end mercy if */
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;elseif $difficulty is &quot;easy&quot;&gt;&gt;

&lt;&lt;for _puppet range _party.filter(function (p) { return !p.dead; })&gt;&gt;
	&lt;&lt;if _modifiers.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
		&lt;&lt;run _hitlist.push(_puppet)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;/if&gt;&gt; /* end difficulty if */

&lt;&lt;if def _hitlist &amp;&amp; _hitlist.length &gt; 0&gt;&gt;
	&lt;&lt;set _origHitlist = clone(_hitlist)&gt;&gt;
	&lt;&lt;for _t range _origHitlist.filter(function (p) { return p.firefly === true; })&gt;&gt;
		&lt;&lt;run _hitlist.push(_t)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;set _n = random(0,_hitlist.length-1)&gt;&gt;
 	&lt;&lt;set $target = _hitlist[_n]&gt;&gt;
&lt;&lt;else&gt;&gt;
	/* no target found, flag this to avoid errors elsewhere */
	&lt;&lt;set _targetfail = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt; /* end threat vs. normal targeting if */

&lt;&lt;/if&gt;&gt; /* end Puppet vs. Enemy if */
&lt;&lt;/if&gt;&gt; /* end aggro if */

	/* guard check (if using battle grid) */
	&lt;&lt;if setup.BATTLE_GRID === true &amp;&amp; !$action.ranged &amp;&amp; !((subject() instanceof Puppet &amp;&amp; target() instanceof Puppet) || (subject() instanceof Enemy &amp;&amp; target() instanceof Enemy))&gt;&gt;
		/* friendly fire bypasses this check */
		&lt;&lt;guardCheck&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	/* protection check */
	&lt;&lt;if !_modifiers.includes(&quot;ignore protection&quot;)&gt;&gt;
		&lt;&lt;protectionCheck&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;unset _hitlist&gt;&gt;

&lt;&lt;/if&gt;&gt; /* end martyr if */
&lt;&lt;/if&gt;&gt; /* end initial targetfail check if */
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="79" name="Widget: allytarget" tags="widget nobr" position="1100,975" size="100,100">&lt;&lt;widget &quot;allytarget&quot;&gt;&gt;
&lt;&lt;set _hitlist = []&gt;&gt;
&lt;&lt;for _actor range enemies().filter(function (e) { return !e.dead; })&gt;&gt;
	&lt;&lt;if !($args.includes(&quot;noself&quot;) &amp;&amp; _actor == subject())&gt;&gt;
		&lt;&lt;if $args.includes(&quot;buff&quot;)&gt;&gt;
			&lt;&lt;if !_actor.stasis&gt;&gt;
				&lt;&lt;run _hitlist.push(_actor)&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;run _hitlist.push(_actor)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	 &lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _hitlist.length &gt; 0&gt;&gt;
	&lt;&lt;set _n = random(0,_hitlist.length-1)&gt;&gt;
	&lt;&lt;set $target = _hitlist[_n]&gt;&gt;
	&lt;&lt;unset _hitlist&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="80" name="Widget: dispelTarget" tags="widget nobr" position="1225,975" size="100,100">&lt;&lt;widget &quot;dispelTarget&quot;&gt;&gt;
&lt;&lt;set _threshold = $args[0]&gt;&gt;
&lt;&lt;set _go = false&gt;&gt;
&lt;&lt;set _continue = true&gt;&gt;
&lt;&lt;set _temp = 0&gt;&gt;

&lt;&lt;if !$args.includes(&quot;mass&quot;)&gt;&gt;
/* Martyr check */
	&lt;&lt;set _martyrTest = $puppets.find(function (p) { return p &amp;&amp; p.martyr === true })&gt;&gt;
	&lt;&lt;if _martyrTest&gt;&gt; /* will be false if no martyr found */
		&lt;&lt;for _effect range _martyrTest.effects.filter(function (eff) { return (eff.buff &amp;&amp; !eff.sticky) })&gt;&gt; /* Search for buffs */
			&lt;&lt;if _effect.name == &quot;Blessing&quot;&gt;&gt;
				&lt;&lt;set _temp += 3&gt;&gt; /* Blessings are higher priority to dispel */
			&lt;&lt;elseif _effect.name == &quot;Martyr&quot; || _effect.name == &quot;Defender&quot; || _effect.name == &quot;Berserker&quot;&gt;&gt;
				/* do nothing; these expire on the next round anyway, so not worth it */
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _temp += 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	  	&lt;&lt;/for&gt;&gt;
		&lt;&lt;if _temp &gt;= _threshold&gt;&gt;
			&lt;&lt;set $target = _martyrTest&gt;&gt;
			&lt;&lt;set _continue = false&gt;&gt;
			&lt;&lt;set _go = true&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set _continue = false&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if _continue&gt;&gt;
/* In order to pass, there must not have been a martyr */

&lt;&lt;set _hitlist = []&gt;&gt;
&lt;&lt;for _puppet range puppets().filter(function (p) { return !p.dead; })&gt;&gt;
	&lt;&lt;if !$args.includes(&quot;mass&quot;)&gt;&gt;
		&lt;&lt;set _temp = 0&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $args.includes(&quot;ignore untargetable&quot;) || !_puppet.untargetable&gt;&gt;
		&lt;&lt;for _effect range _puppet.effects.filter(function (eff) { return (eff.buff &amp;&amp; !eff.sticky) })&gt;&gt; /* Search for buffs */
			&lt;&lt;if _effect.name == &quot;Blessing&quot;&gt;&gt;
				&lt;&lt;set _temp += 3&gt;&gt; /* Blessings are higher priority to dispel */
			&lt;&lt;elseif _effect.name == &quot;Martyr&quot; || _effect.name == &quot;Defender&quot; || _effect.name == &quot;Berserker&quot;&gt;&gt;
				/* do nothing; these expire on the next round anyway, so not worth it */
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _temp += 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if !$args.includes(&quot;mass&quot;)&gt;&gt;
		&lt;&lt;if _temp &gt;= _threshold&gt;&gt;
			&lt;&lt;run _hitlist.push(_puppet)&gt;&gt; /* If someone has a buff, make them a possible target */
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if (!$args.includes(&quot;mass&quot;) &amp;&amp; _hitlist.length == 0) || ($args.includes(&quot;mass&quot;) &amp;&amp; _temp &lt; _threshold)&gt;&gt;
	&lt;&lt;set _go = false&gt;&gt; /* If no one has any buffs, there&#39;s no point in using this; reroll */
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _go = true&gt;&gt;
	&lt;&lt;if !$args.includes(&quot;mass&quot;)&gt;&gt; /* mass dispel doesn&#39;t need to pick a target */
		&lt;&lt;set _n = random(0,(_hitlist.length-1))&gt;&gt;
		&lt;&lt;set $target = _hitlist[_n]&gt;&gt;

	/* Protection check. Comment this out if you do not want Protectors to protect against dispels. */
	&lt;&lt;if !$args.includes(&quot;ignore protection&quot;)&gt;&gt;
		&lt;&lt;protectionCheck&gt;&gt;
	&lt;&lt;/if&gt;&gt;

 	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="81" name="Widget: multihit" tags="widget nobr" position="100,1100" size="100,100">&lt;&lt;widget &quot;multihit&quot;&gt;&gt;
&lt;&lt;set _hits = $args[0]&gt;&gt;
&lt;&lt;for _h = 1; _h &lt;= _hits; _h++&gt;&gt;
	&lt;&lt;if $args[1] is &quot;spread&quot;&gt;&gt; /* careful, this means you have to call randomTarget outside this widget if this isn&#39;t a spread attack */
		&lt;&lt;randomTarget &quot;ignore downed&quot; &quot;ignore untargetable&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;echoDamage&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="82" name="Widget: Actor Box" tags="widget nobr" position="225,1100" size="100,100">&lt;&lt;widget &quot;actorBox&quot;&gt;&gt;
/* Standard display for actor information in battle. */
/* arg 0 = actor object; arg 1 = class (defaults to &quot;actor&quot;) */
&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; $args[0] instanceof Actor,&quot;ERROR in actorBox: no Actor passed&quot;)&gt;&gt;
&lt;&lt;set _actor = $args[0]&gt;&gt;
&lt;&lt;run console.assert(_actor instanceof Puppet || _actor instanceof Enemy,&quot;ERROR in actorBox: actor is neither Puppet nor Enemy&quot;)&gt;&gt;

/* find actor&#39;s address in party array; will be used later */
&lt;&lt;if _actor instanceof Puppet&gt;&gt;
  &lt;&lt;set _idx = $puppets.findIndex(function (a) { return _actor.id == a.id; })&gt;&gt;
  &lt;&lt;set _nameID = &quot;pname&quot;+_idx&gt;&gt;
  &lt;&lt;if $inbattle&gt;&gt;
    &lt;&lt;set _healthBar = $B.playerBars[_idx]&gt;&gt;
    &lt;&lt;if !Meter.has(_healthBar)&gt;&gt;
      &lt;&lt;newmeter _healthBar 1&gt;&gt;
        &lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
        &lt;&lt;animation setup.HEALTH_BAR_TIME linear&gt;&gt;
        &lt;&lt;sizing 100%&gt;&gt;
      &lt;&lt;/newmeter&gt;&gt;
    &lt;&lt;/if&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;elseif _actor instanceof Enemy&gt;&gt;
  &lt;&lt;set _idx = $enemies.findIndex(function (a) { return _actor.id == a.id })&gt;&gt;
  &lt;&lt;set _nameID = &quot;ename&quot;+_idx&gt;&gt;
  &lt;&lt;set _healthBar = $B.enemyBars[_idx]&gt;&gt;
  &lt;&lt;if !Meter.has(_healthBar)&gt;&gt;
    &lt;&lt;newmeter _healthBar 1&gt;&gt;
      &lt;&lt;colors setup.ENEMY_BAR_COLOR&gt;&gt;
      &lt;&lt;animation setup.HEALTH_BAR_TIME linear&gt;&gt;
      &lt;&lt;sizing 100%&gt;&gt;
    &lt;&lt;/newmeter&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _boxID = &quot;box&quot;+_idx&gt;&gt;

/* determine container class; customized by arg 1, defaults to &quot;actor&quot; */
&lt;&lt;set _class = &quot;actor &quot;&gt;&gt;
&lt;&lt;if _actor.large&gt;&gt;
  &lt;&lt;set _class += &quot;large &quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !$args.includes(&quot;simplified&quot;) &amp;&amp; _actor instanceof Puppet &amp;&amp; _actor.active !== true&gt;&gt;
	&lt;&lt;set _class += &quot;inactive &quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $args.length &gt; 1 &amp;&amp; typeof($args[1]) == &quot;string&quot;&gt;&gt;
  &lt;&lt;set _class += $args[1]&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _style = &quot;&quot;&gt;&gt;
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
  &lt;&lt;set _class += &quot; grid&quot;&gt;&gt;
  &lt;&lt;set _style += _actor.gridArea&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* determine if name should be capitalized */
&lt;&lt;if _actor.caps&gt;&gt;
  &lt;&lt;set _nameStyle = &quot;text-transform:uppercase&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
  &lt;&lt;set _nameStyle = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;Actor Box Container&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="83" name="Actor Box Container" tags="nobr" position="350,1100" size="100,100">&lt;div @class=_class @id=_boxID @style=_style&gt;
&lt;&lt;if $args.includes(&quot;formation&quot;)&gt;&gt;
  &lt;&lt;include &quot;ActorBox formation&quot;&gt;&gt;
  /* see party menu-formation for details */
&lt;&lt;elseif _actor.dead &amp;&amp; (!$args.includes(&quot;dmgDisplay&quot;) || _showDead)&gt;&gt;
  /*  Dead characters display their name and the † (dagger) symbol in place of the status button
      UNLESS this box is for damage animation, in which case the dead display will only happen once all anims are finished */
  &lt;&lt;set _margin = $(_boxID).height&gt;&gt;
  &lt;span class=&quot;actorname&quot; @id=_nameID @style=_nameStyle&gt;
    &lt;&lt;set _class = &quot;statusbutton&quot;&gt;&gt;
    &lt;&lt;if _actor.large&gt;&gt;
      &lt;&lt;set _class += &quot; absolute&quot;&gt;&gt;
    &lt;&lt;/if&gt;&gt;
    &lt;span class=&quot;dead&quot;&gt;
      &lt;&lt;include &quot;Actor Box Name&quot;&gt;&gt;
      &lt;span @class=_class&gt;&amp;dagger;&lt;/span&gt;
    &lt;/span&gt;
  &lt;/span&gt;
&lt;&lt;else&gt;&gt;
  /* Element 1: name */
  &lt;span class=&quot;actorname&quot; @id=_nameID @style=_nameStyle&gt;
  &lt;&lt;include &quot;Actor Box Name&quot;&gt;&gt;
  &lt;/span&gt;

  /* Element 2: status button */
  &lt;&lt;include &quot;Actor Box Status&quot;&gt;&gt;

  /* Element 3: HP */
  &lt;&lt;include &quot;Actor Box HP&quot;&gt;&gt;

  /* Element 4: EN (Puppets only) */
  &lt;&lt;include &quot;Actor Box EN&quot;&gt;&gt;

  /* Element 5: Crisis points */
  &lt;&lt;include &quot;Actor Box Crisis&quot;&gt;&gt;

  /* Element 6: Status messages */
  &lt;&lt;include &quot;Actor Box Misc&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

  &lt;&lt;if setup.ANIMATIONS === true &amp;&amp; passage() == &quot;Player Phase&quot; &amp;&amp; _actor.battleMsg.length &gt; 0&gt;&gt;
    &lt;&lt;run console.log(_actor.name+&quot; has a battle msg in master screen&quot;)&gt;&gt;
    &lt;&lt;set _queue.add(_actor); _animationActive = true&gt;&gt;
    &lt;&lt;for _x, _m range _actor.battleMsg&gt;&gt;
      &lt;div @id=&quot;&#39;dmg&#39;+_idx+&#39;-&#39;+_x&quot; class=&quot;dmgPopup&quot;&gt;
        &lt;&lt;print _m.content&gt;&gt;
      &lt;/div&gt;
    &lt;&lt;/for&gt;&gt;
  &lt;&lt;/if&gt;&gt;

&lt;/div&gt;</tw-passagedata><tw-passagedata pid="84" name="Actor Box Name" tags="nobr" position="475,1100" size="100,100">&lt;&lt;if _actor.dead &amp;&amp; $B.phase !== &quot;targeting&quot;&gt;&gt;
  &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
    &lt;&lt;print setup.scaledTextDiv(_actor.fullname,setup.NAME_LENGTH,{bold:true})&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;print _actor.fullname&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;elseif _actor instanceof Puppet &amp;&amp; $B.phase == &quot;selection&quot; &amp;&amp; ndef _s &amp;&amp; (!_actor.noact || _actor.down) &amp;&amp; _actor.active&gt;&gt;
	/* For Puppets in the selection phase, their name becomes a link that sets them as the subject and allows the player to select their commands. */
	&lt;&lt;capture _idx, _actor&gt;&gt;
	&lt;&lt;link &quot;_actor.name&quot;&gt;&gt;
    &lt;&lt;run $(document).trigger(&quot;:puppet-selected&quot;)&gt;&gt;
		&lt;&lt;set $subject = _actor&gt;&gt;
		&lt;&lt;set $B.phase = &quot;command&quot;&gt;&gt;
		&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
			&lt;&lt;removeclass &quot;#puppets&quot; &quot;grid&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;addclass &quot;#enemies&quot; &quot;invisible&quot;&gt;&gt;
		&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
&lt;&lt;elseif $B.phase == &quot;targeting&quot;&gt;&gt;
	/* In the Targeting Phase, characters&#39; names must become links to select them, but only if they are valid targets. */
	&lt;span class=&quot;targetnumber&quot;&gt;&lt;&lt;print _idx+1&gt;&gt;&lt;/span&gt;
	&lt;&lt;if _actor.validTarget()&gt;&gt;
    /* see validTarget in Puppet and Enemy classes */
		/* If valid target, turn name into a link that assigns actor to the target variable, unsets the targeting varaible, and forwards the player to the next phase. We must also assign the ID variable determined earlier to a wrapper element to facilitate hotkey targeting. */
		&lt;&lt;capture _actor, _idx&gt;&gt;
    &lt;&lt;set _link = `&lt;&lt;link &quot;_actor.fullname&quot;&gt;&gt;
        &lt;&lt;run $(document).trigger(&quot;:target-selected&quot;)&gt;&gt;
  			&lt;&lt;set $target = _actor; $B.targeting = null&gt;&gt;
  			&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;Confirm Phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  		&lt;&lt;/link&gt;&gt;`&gt;&gt;
    &lt;&lt;mouseover&gt;&gt;
    &lt;span class=&quot;mouseover&quot;&gt;
    &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
      &lt;&lt;print setup.scaledTextDiv(_actor.fullname,setup.NAME_LENGTH,{bold:true},_link)&gt;&gt;
    &lt;&lt;else&gt;&gt;
      &lt;&lt;print _link&gt;&gt;
    &lt;&lt;/if&gt;&gt;
    &lt;/span&gt;
    &lt;&lt;onmouseover&gt;&gt;
      &lt;&lt;switch _actor.id.charAt(0)&gt;&gt;
        &lt;&lt;case &quot;p&quot;&gt;&gt;
          &lt;&lt;set _area = &quot;#puppets&quot;&gt;&gt;
        &lt;&lt;case &quot;e&quot;&gt;&gt;
          &lt;&lt;set _area = &quot;#enemies&quot;&gt;&gt;
      &lt;&lt;/switch&gt;&gt;
      &lt;&lt;set _location = `#box${_idx}`&gt;&gt;
      &lt;&lt;switch $action.area&gt;&gt;
        &lt;&lt;case &quot;all&quot; &quot;mass&quot;&gt;&gt;
          &lt;&lt;set _string = `${_area} &gt; div &gt; div`&gt;&gt;
          &lt;&lt;addclass _string &quot;selected&quot;&gt;&gt;
        &lt;&lt;case &quot;row&quot;&gt;&gt;
          &lt;&lt;for _a range _actor.ownParty.filter(function (a) { return a &amp;&amp; a.row === this.row },_actor)&gt;&gt;
            &lt;&lt;set _location = `#box${_a.ownParty.indexOf(_a)}`&gt;&gt;
            &lt;&lt;addclass _location &quot;selected&quot;&gt;&gt;
          &lt;&lt;/for&gt;&gt;
        &lt;&lt;case &quot;column&quot; &quot;col&quot;&gt;&gt;
          &lt;&lt;for _a range _actor.ownParty.filter(function (a) { return a &amp;&amp; a.col === this.col },_actor)&gt;&gt;
            &lt;&lt;set _location = `#box${_a.ownParty.indexOf(_a)}`&gt;&gt;
            &lt;&lt;addclass _location &quot;selected&quot;&gt;&gt;
          &lt;&lt;/for&gt;&gt;
        &lt;&lt;default&gt;&gt;
          &lt;&lt;addclass _location &quot;selected&quot;&gt;&gt;
      &lt;&lt;/switch&gt;&gt;
    &lt;&lt;onmouseout&gt;&gt;
      &lt;&lt;set _string = `${_area} &gt; div &gt; div`&gt;&gt;
      &lt;&lt;removeclass _string &quot;selected&quot;&gt;&gt;
    &lt;&lt;/mouseover&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;&lt;else&gt;&gt;
		/* If invalid target, just display the name as normal. */
    &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
      &lt;&lt;print setup.scaledTextDiv(_actor.fullname,setup.NAME_LENGTH,{bold:true})&gt;&gt;
    &lt;&lt;else&gt;&gt;
      &lt;&lt;print _actor.fullname&gt;&gt;
    &lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;elseif $B.phase == &quot;move&quot;&gt;&gt;
  /* See Battle Grid.tw for details. */
	&lt;&lt;include &quot;ActorBox Move&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	/* In all other phases, just display the name as normal. */
  &lt;&lt;if setup.SCALE_NAMES&gt;&gt;
    &lt;&lt;print setup.scaledTextDiv(_actor.fullname,setup.NAME_LENGTH,{bold:true})&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;print _actor.fullname&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="85" name="Actor Box Status" tags="nobr" position="600,1100" size="100,100">&lt;&lt;if !$args.includes(&quot;dmgDisplay&quot;)&gt;&gt;
	&lt;&lt;set _class = &quot;statusbutton&quot;&gt;&gt;
	&lt;&lt;if _actor.large&gt;&gt;
		&lt;&lt;set _class += &quot; absolute&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;capture _actor&gt;&gt;&lt;span @class=_class&gt;&lt;&lt;status _actor&gt;&gt;&lt;/span&gt;&lt;&lt;/capture&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="86" name="Actor Box HP" tags="nobr" position="725,1100" size="100,100">&lt;&lt;if $args.includes(&quot;dmgDisplay&quot;)&gt;&gt;
    &lt;&lt;set _hp = _actor.displayHP&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;set _hp = _actor.hp&gt;&gt;
  &lt;&lt;/if&gt;&gt;
	&lt;&lt;capture _healthBar&gt;&gt;
	&lt;div&gt;
	HP: &lt;&lt;if _actor.maskhp&gt;&gt;???
	&lt;&lt;else&gt;&gt;&lt;&lt;print _hp&gt;&gt;&lt;&lt;if _actor.showMaxHP&gt;&gt; / _actor.maxHP&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
	&lt;&lt;if (!_actor.maskhp &amp;&amp; setup.SHOW_HEALTHBARS)&gt;&gt;
		&lt;&lt;if setup.BATTLE_GRID === true &amp;&amp; _actor.large&gt;&gt;
			&lt;div class=&quot;largehealth&quot;&gt;
				&lt;&lt;showmeter _healthBar `_hp / _actor.maxHP`&gt;&gt;
			&lt;/div&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;showmeter _healthBar `_hp / _actor.maxHP`&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;/capture&gt;&gt;</tw-passagedata><tw-passagedata pid="87" name="Actor Box EN" tags="nobr" position="850,1100" size="100,100">&lt;&lt;if _actor instanceof Puppet &amp;&amp; !$args.includes(&quot;simplified&quot;)&gt;&gt;
	&lt;div&gt;
	&lt;&lt;print StatName(&quot;EnergyShort&quot;)&gt;&gt;: _actor.en / _actor.maxEN
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="88" name="Actor Box Crisis" tags="nobr" position="975,1100" size="100,100">&lt;&lt;if def _s &amp;&amp; _actor.crisis instanceof Array &amp;&amp; _actor.crisis.length &gt; 0 &amp;&amp; !$args.includes(&quot;simplified&quot;)&gt;&gt;
	/* Only display this if the character isn&#39;t currently selected (and if they have a valid Crisis in the first place) */
	&lt;&lt;set _style = &quot;font-size: 10pt; &quot;&gt;&gt;
	&lt;&lt;if _actor.crisisPoints &gt;= 100&gt;&gt;
		&lt;&lt;set _style += &quot;color:red&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _style += &quot;font-weight:normal&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div @style=_style&gt;
		Crisis: &lt;&lt;print _actor.crisisPoints&gt;&gt;%
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="89" name="Actor Box Misc" tags="nobr" position="1100,1100" size="100,100">&lt;div class=&quot;noact&quot;&gt;
	&lt;&lt;if $args.includes(&quot;simplified&quot;)&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;elseif setup.TURN_MODEL.toLowerCase() === &quot;free&quot; &amp;&amp; !_actor.active&gt;&gt;
		Done!
	&lt;&lt;elseif _actor.stunned&gt;&gt;
		Stunned!
	&lt;&lt;elseif _actor.down&gt;&gt;
		Prone!
	&lt;&lt;else&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;</tw-passagedata><tw-passagedata pid="90" name="Widget: fight" tags="widget nobr" position="1225,1100" size="100,100">&lt;&lt;widget &quot;fight&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0&gt;&gt;
	&lt;&lt;if typeof($args[1]) == &quot;string&quot;&gt;&gt;
		&lt;&lt;set _text = $args[1]&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _text = &quot;BATTLE&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;center&gt;&lt;&lt;button _text &quot;Preparation&quot;&gt;&gt;&lt;&lt;set $scenario = $args[0]&gt;&gt;&lt;&lt;/button&gt;&gt;&lt;/center&gt;
&lt;&lt;else&gt;&gt;
	&lt;b&gt;ERROR in fight: no arguments&lt;/b&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="91" name="Widget: victorymessage" tags="widget nobr" position="100,1225" size="100,100">&lt;&lt;widget &quot;victorymessage&quot;&gt;&gt;
&lt;&lt;set _m = random(1,4)&gt;&gt;
&lt;&lt;switch _m&gt;&gt;
&lt;&lt;case 1&gt;&gt;
You win!
&lt;&lt;case 2&gt;&gt;
Victory!
&lt;&lt;case 3&gt;&gt;
You&#39;ve won!
&lt;&lt;case 4&gt;&gt;
You are victorious! /* this is a reference to an old game, cookies if you recognize it */
&lt;&lt;/switch&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="92" name="Widget: victorycheck" tags="widget nobr" position="225,1225" size="100,100">&lt;&lt;widget &quot;victorycheck&quot;&gt;&gt;
&lt;&lt;set _destinationQueue = []&gt;&gt;
&lt;&lt;set _victory = 0&gt;&gt;
&lt;&lt;set _defeat = 0&gt;&gt;
&lt;&lt;set _loadBearing = enemies().find(function (e) { return e &amp;&amp; e.loadBearing })&gt;&gt;
&lt;&lt;if def _loadBearing &amp;&amp; _loadBearing.dead&gt;&gt;
	&lt;&lt;set $B.victory = true&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _victory = enemies().filter(function (e) { return e &amp;&amp; !e.uncounted &amp;&amp; e.dead }).length&gt;&gt;
	&lt;&lt;if _victory == enemies().filter(function (e) { return e &amp;&amp; !e.uncounted }).length&gt;&gt;
		&lt;&lt;set $B.victory = true&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $B.victory === true&gt;&gt;
	&lt;&lt;set _destinationQueue.push(&quot;Victory&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _loadBearing = puppets().find(function (p) { return p &amp;&amp; p.loadBearing })&gt;&gt;
&lt;&lt;if def _loadBearing &amp;&amp; _loadBearing.dead&gt;&gt;
	&lt;&lt;set $B.defeat = true&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _defeat = puppets().filter(function (p) { return p &amp;&amp; !p.uncounted &amp;&amp; p.dead }).length&gt;&gt;
	&lt;&lt;if _defeat == puppets().filter(function (p) { return p &amp;&amp; !p.uncounted }).length&gt;&gt;
		&lt;&lt;set $B.defeat = true&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $B.defeat === true&gt;&gt;
	&lt;&lt;set _destinationQueue.push(&quot;Defeat&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="93" name="Widget: refreshPuppets" tags="widget nobr" position="350,1225" size="100,100">&lt;&lt;widget &quot;refreshPuppets&quot;&gt;&gt;
/* Refreshes puppets to resting states. Use this to tidy up any flags or changes that might occur in battle. */

&lt;&lt;for _puppet range puppets()&gt;&gt;
	&lt;&lt;set delete _puppet._displayHP&gt;&gt;
	&lt;&lt;set _puppet.lastDmg = 0&gt;&gt;
	&lt;&lt;set _puppet.active = true&gt;&gt;
	&lt;&lt;set _puppet.inspired = false&gt;&gt;
	&lt;&lt;set _puppet.lastAction = null&gt;&gt;
	&lt;&lt;set _puppet.lastUsed = null&gt;&gt;
	&lt;&lt;set _puppet.battleMsg = []&gt;&gt;
	&lt;&lt;if _puppet.dead &amp;&amp; $afterBattleRecovery.revive === true&gt;&gt;
		&lt;&lt;set _puppet.dead = false&gt;&gt;
		&lt;&lt;set _puppet.hp = Math.round(_puppet.maxHP * setup.RESPAWN_HP)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if !_puppet.dead &amp;&amp; $afterBattleRecovery.hp === true&gt;&gt;
		&lt;&lt;set _puppet.hp = _puppet.maxHP&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $afterBattleRecovery.actions === true&gt;&gt;
		&lt;&lt;for _action range _puppet.actions.filter(function (a) { return a.uses !== undefined })&gt;&gt;
			&lt;&lt;run _action.refill()&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _action range _puppet.actions.filter(function (act) { return act.used === true })&gt;&gt;
		&lt;&lt;run _action.used = false&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;for _action range _puppet.actions.filter(function (act) { return act.cd !== undefined })&gt;&gt;
		&lt;&lt;run _action.cd = _action.warmup&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;for _effect range _puppet.effects.filter(function (eff) { return !eff.persistAfterBattle })&gt;&gt;
		&lt;&lt;run _puppet.removeEffect(_effect, {pierce: true, unsticky: &quot;ultimate&quot;})&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;for _k, _v range _puppet.tolerances&gt;&gt;
		&lt;&lt;run _puppet.resetTol(_k)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;if _puppet._respawn instanceof FillStat&gt;&gt;
		&lt;&lt;run _puppet._respawn.refill()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _puppet._retaliations instanceof FillStat&gt;&gt;
		&lt;&lt;run _puppet._retaliations.refill()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;include &quot;custom refreshPuppet&quot;&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="94" name="Widget: chain" tags="widget nobr" position="475,1225" size="100,100">&lt;&lt;widget &quot;chain&quot;&gt;&gt;
&lt;&lt;if $target !== null&gt;&gt;
	&lt;&lt;run getActor(&quot;target&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $subject !== null&gt;&gt;
	&lt;&lt;run getActor(&quot;subject&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $B.actor !== null&gt;&gt;
	&lt;&lt;run getActor(&quot;actor&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;run chainBattleGrid($enemyGrid); chainBattleGrid($puppetGrid)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="95" name="Widget: find" tags="widget nobr" position="600,1225" size="100,100">&lt;&lt;widget &quot;find&quot;&gt;&gt;
/* args0 is target array, args1 is attribute, args2 is key value */
/* Note that if your key is a string, it must be in quotes in the final code, which means you must send it to the widget with an extra pair of literal quotes (preceeded by the escape slash) */
&lt;&lt;print &#39;&lt;&lt;set _pos = &#39;+$args[0]+&#39;.map(function(x) { return(x.&#39;+$args[1]+&#39;) }).indexOf(&#39;+$args[2]+&#39;)&gt;&gt;&#39;&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="96" name="Widget: longreturn" tags="widget nobr" position="725,1225" size="100,100">&lt;&lt;widget &quot;longreturn&quot;&gt;&gt;
&lt;&lt;link &quot;Return&quot; $return&gt;&gt;&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="97" name="Widget: deathcheck" tags="widget nobr" position="850,1225" size="100,100">&lt;&lt;widget &quot;deathcheck&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0&gt;&gt;
	&lt;&lt;set _targ = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _targ = target()&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _targ.hp &lt;= 0 &amp;&amp; !_targ.dead&gt;&gt;
	&lt;&lt;if typeof(_targ.specialdeath) == &quot;string&quot; &amp;&amp; !$B.specialdeath.includes(_targ.specialdeath)&gt;&gt;
		&lt;&lt;run $B.specialdeath.push(_targ.specialdeath)&gt;&gt;
	&lt;&lt;elseif !_targ.immortal&gt;&gt; /* This is necessary in the case of specialdeaths that don&#39;t actually kill the enemy, such as stage changes. If you want to run these cleanup functions, set the character&#39;s specialdeath flag to false and run deathcheck again in the special death passage. */
		&lt;&lt;set _targ.dead to true&gt;&gt;
		&lt;&lt;if _targ._deathMessage !== null&gt;&gt;
			&lt;&lt;print _targ.deathMessage&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if _targ instanceof Enemy&gt;&gt;
			&lt;&lt;run $B.kills.push(_targ)&gt;&gt;
			&lt;&lt;if def $bestiary &amp;&amp; def $bestiary.fetch(_targ.name)&gt;&gt;
				&lt;&lt;set  $bestiary.fetch(_targ.name).defeated++&gt;&gt;
				&lt;&lt;if setup.ENEMY_DATA_ON_KILL&gt;&gt;
					&lt;&lt;run $bestiary.fetch(_targ.name).revealAll()&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;if typeof(subject().kills) == &#39;number&#39;&gt;&gt;
				&lt;&lt;set subject().kills++&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;set $B.XPreward += _targ.xp; $B.moneyReward += _targ.gp&gt;&gt;
			&lt;&lt;if $B.enemyTurns &gt; 0 &amp;&amp; _targ.noAttacks &gt; 1&gt;&gt;
				&lt;&lt;run $B.enemyTurns -= 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;elseif _targ instanceof Puppet&gt;&gt;
			&lt;&lt;run _targ.defeats++&gt;&gt;
		&lt;&lt;/if&gt;&gt;

		/* Remove all effects unless they are meant to persist past unconsciousness */
		&lt;&lt;for _k, _effect range _targ.effects.filter(function (eff) { return !eff.persistAfterDeath; })&gt;&gt;
			&lt;&lt;run _targ.removeEffect(_effect,{pierce: true, unsticky: true, noPopup: true})&gt;&gt;
		&lt;&lt;/for&gt;&gt;

		/* If defeated character was protected, their protector&#39;s protection effect must be removed */
		&lt;&lt;if _targ.protectedBy !== null&gt;&gt;
			&lt;&lt;switch _targ.protectedBy.charAt(0)&gt;&gt;
				&lt;&lt;case &quot;p&quot;&gt;&gt;
					&lt;&lt;set _targets = $puppets&gt;&gt;
				&lt;&lt;case &quot;e&quot;&gt;&gt;
					&lt;&lt;set _targets = $enemies&gt;&gt;
				&lt;&lt;default&gt;&gt;
					&lt;&lt;run console.log(&quot;ERROR in deathcheck: protected character&#39;s protector has invalid ID&quot;)&gt;&gt;
			&lt;&lt;/switch&gt;&gt;
			&lt;&lt;set _temp = _targets.find(function(t) { return t &amp;&amp; t.id === _targ.protectedBy; })&gt;&gt;
			&lt;&lt;print _temp.removeEffect(&quot;Protector&quot;,{pierce: true})&gt;&gt;
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;elseif _targ.immortal&gt;&gt;
		&lt;&lt;if _targ._deathMessage !== null&gt;&gt;
			&lt;&lt;print _targ.deathMessage&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="98" name="Widget: playMusic" tags="widget nobr" position="975,1225" size="100,100">&lt;&lt;widget &quot;playMusic&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0 &amp;&amp; typeof($args[0]) == &#39;string&#39;&gt;&gt;
    &lt;&lt;set _trackId = $args[0].split(&#39; &#39;).join(&#39;_&#39;)&gt;&gt;
	&lt;&lt;if !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
		&lt;&lt;audio &quot;:playing&quot; stop&gt;&gt;
	&lt;&lt;/if&gt;&gt;
    &lt;&lt;set $music = new Music($args[0])&gt;&gt;
    &lt;&lt;if !$args.includes(&quot;instant&quot;) &amp;&amp; !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
        &lt;&lt;script&gt;&gt;
		/* code provided by The Mad Exile */
        var selector = State.temporary.trackId;
        setTimeout(function () {
            SimpleAudio.select(selector)
                .loop(true)
                .volume(1)
                .play();
        }, 500); /* in milliseconds */
        &lt;&lt;/script&gt;&gt;
    &lt;&lt;else&gt;&gt;
        &lt;&lt;audio _trackId volume 1 play loop&gt;&gt;
    &lt;&lt;/if&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;musicInfo&quot;)&gt;&gt;
		&lt;&lt;replace &quot;#musicInfo&quot;&gt;&gt;&lt;&lt;include &quot;music info&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;else&gt;&gt;
    &lt;&lt;run console.log(&quot;ERROR in playMusic: non-string argument passed&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="99" name="Widget: clearMusic" tags="widget nobr" position="1100,1225" size="100,100">&lt;&lt;widget &quot;clearMusic&quot;&gt;&gt;
	&lt;&lt;audio &quot;:playing&quot; volume 1 stop&gt;&gt;
	&lt;&lt;unset $music&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;musicInfo&quot;)&gt;&gt;
		&lt;&lt;replace &quot;#musicInfo&quot;&gt;&gt;&lt;&lt;include &quot;music info&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="100" name="Widget: typewriter" tags="widget nobr" position="1225,1225" size="100,100">&lt;&lt;widget &quot;typewriter&quot;&gt;&gt;
    &lt;!-- Create a SPAN with an ID --&gt;
  &lt;span id=&quot;typewriter&quot;&gt;&lt;/span&gt;
    &lt;!-- In SugarCube, arrays start at 0 --&gt;
  &lt;&lt;set _textArrayLength to 0&gt;&gt;
    &lt;!-- Repeat every second --&gt;
  &lt;&lt;repeat $args[1]&gt;&gt;
      &lt;!-- Test if textArrayLength is greater than length of $args[0] --&gt;
      &lt;&lt;if _textArrayLength gte $args[0].length&gt;&gt;
        &lt;&lt;stop&gt;&gt;
      &lt;&lt;else&gt;&gt;
      &lt;!-- Append the current position to the existing characters --&gt;
      &lt;&lt;append &quot;#typewriter&quot;&gt;&gt;$args[0][_textArrayLength]&lt;&lt;/append&gt;&gt;
      &lt;!-- Update the length --&gt;
      &lt;&lt;set _textArrayLength++&gt;&gt;
      &lt;&lt;/if&gt;&gt;
   &lt;&lt;/repeat&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="101" name="Widgets (Depreciated)" tags="widget nobr" position="100,1350" size="100,100">&lt;&lt;widget &quot;neutralize&quot;&gt;&gt;
/* DEPRECIATED as of v1.01. Use the dispelCalc() function in the actions database instead. */
/* Determines effects to be removed by Neutralize and Restoration. */
/* Because these actions are so similar, the same widget can be used for both. */

&lt;&lt;if $target.stasis isnot true&gt;&gt;
/* Stasis blocks any effect changes, so it blocks this too. */
&lt;&lt;set _effects to $target.effects&gt;&gt; /* This is done just so you don&#39;t have to write out the longer name */
&lt;&lt;for _i = (_effects.length-1); _i &gt;= 0; _i--&gt;&gt;
/* Loop runs over the effects array starting from the END and working backwards. This is why we can&#39;t use a &quot;range&quot; loop, because that only goes forwards. */
	&lt;&lt;if $effects_to_remove &lt;= 0&gt;&gt;
		&lt;&lt;break&gt;&gt;
/* The number of effects removed by Neutralize/Restoration varies depending on energy invested. If there are more effects than the spell can remove, we end the function here. Otherwise the spell would clear all effects regardless of strength! */
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $target instanceof Puppet is true&gt;&gt;
		&lt;&lt;if _effects[_i].buff isnot true and _effects[_i].sticky isnot true&gt;&gt;
/* Because there are fewer buffs than debuffs, a single &quot;buff&quot; flag is used to distinguish them. We only want Restoration to remove debuffs, so it will only trigger the removal code if the effect&#39;s buff flag is NOT true. */
/* You may also want some effects to be irremovable. This is the purpose of the &quot;sticky&quot; flag, which is set in the story JavaScript. */
			&lt;&lt;run $removed_effects.push(_effects[_i])&gt;&gt;
			&lt;&lt;set $effects_to_remove -= 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;elseif $target instanceof Enemy is true&gt;&gt;
		&lt;&lt;if _effects[_i].buff is true and _effects[_i].sticky isnot true&gt;&gt;
			&lt;&lt;run $removed_effects.push(_effects[_i])&gt;&gt;
			&lt;&lt;set $effects_to_remove -= 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;deathcheckOLD&quot;&gt;&gt;
/* Old death check method that runs over all characters. Depreciated. */
&lt;&lt;for _enemy range $enemies&gt;&gt;
	&lt;&lt;if _enemy.hp &lt;= 0 and _enemy.dead is false&gt;&gt;
		&lt;&lt;set _enemy.hp = 0&gt;&gt;
		&lt;&lt;run $B.kills.push(_enemy.name)&gt;&gt;
		&lt;&lt;if _enemy.deathMessage is &quot;special&quot;&gt;&gt;
			&lt;&lt;print &quot;\n\n...&quot;&gt;&gt;
			&lt;&lt;set $B.specialdeath++&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set _enemy.dead to true&gt;&gt;
			&lt;&lt;print _enemy.deathMessage&gt;&gt;
			&lt;&lt;for _effect range _enemy.effects&gt;&gt;
				&lt;&lt;set _effect.duration to 0&gt;&gt;
			&lt;&lt;/for&gt;&gt;
			&lt;&lt;effectmanager _enemy&gt;&gt; /* to strip effect flags, just in case they can still interfere during the turn */
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _puppet range puppets()&gt;&gt;
	&lt;&lt;if _puppet.hp &lt;= 0 and _puppet.dead is false&gt;&gt;
		&lt;&lt;set _puppet.hp = 0&gt;&gt;
		&lt;&lt;set _puppet.dead to true&gt;&gt;
		&lt;&lt;print _puppet.deathMessage&gt;&gt;
		&lt;&lt;for _effect range _puppet.effects&gt;&gt;
			&lt;&lt;set _effect.duration to 0&gt;&gt;
		&lt;&lt;/for&gt;&gt;
		&lt;&lt;effectmanager _puppet&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;removeEffect&quot;&gt;&gt;
/* DEPRECIATED as of v0.91. Use Actor.removeEffect instead. */
&lt;&lt;set _actor = $args[0]&gt;&gt;
&lt;&lt;set _effect = $args[1]&gt;&gt;
&lt;&lt;if _actor.stasis is false or $args.includes(&quot;pierce&quot;)&gt;&gt;
	&lt;&lt;set _effect.duration = 0&gt;&gt;
	&lt;&lt;effectmanager _actor&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="102" name="Widget: restock" tags="widget nobr" position="225,1350" size="100,100">/* Restock: sets starting inventory values for each battle. */
&lt;&lt;widget &quot;restock&quot;&gt;&gt;
&lt;&lt;for _k, _v range $inventory&gt;&gt;
	&lt;&lt;set _v.stock = _v.maxstock&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="103" name="Widget: itemDrop" tags="widget nobr" position="350,1350" size="100,100">&lt;&lt;widget &quot;itemDrop&quot;&gt;&gt;
&lt;&lt;if def $args[1] &amp;&amp; typeof($args[1]) == &#39;number&#39;&gt;&gt;
	&lt;&lt;set _amt = $args[1]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _amt = 1&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _item = new Item($args[0],_amt)&gt;&gt;

&lt;&lt;set _added = $inventory.addItem($args[0],_amt)&gt;&gt;
&lt;center&gt;
&lt;div class=&quot;itembox infield&quot;&gt;
&lt;&lt;print _item&gt;&gt;
&lt;/div&gt;
&lt;&lt;if _added === false&gt;&gt;
	&lt;i&gt;You can&#39;t hold any more of these! Use or sell some and then come back.&lt;/i&gt;
&lt;&lt;/if&gt;&gt;
&lt;/center&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="104" name="Widget: effectinfo" tags="widget nobr" position="475,1350" size="100,100">&lt;&lt;widget &quot;effectinfo&quot;&gt;&gt;
&lt;&lt;for _k, _effect range $B.actor.effects&gt;&gt;
&lt;&lt;if _effect.invisible isnot true&gt;&gt;
	&lt;div class=&quot;effectinfo&quot;&gt;
	_effect.name
	&lt;&lt;if _effect.duration &gt;= 0&gt;&gt;
		&lt;span class=&quot;duration&quot;&gt;_effect.duration turn&lt;&lt;if _effect.duration &gt; 1&gt;&gt;s&lt;&lt;/if&gt;&gt;&lt;/span&gt;
	&lt;&lt;/if&gt;&gt;&lt;br/&gt;
	&lt;span class=&quot;effectdesc&quot;&gt;
	&lt;&lt;print _effect.info(_effect)&gt;&gt;
	&lt;/span&gt;
	&lt;/div&gt;&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="105" name="Widget: stat display" tags="widget nobr" position="600,1350" size="100,100">&lt;&lt;widget &quot;stat&quot;&gt;&gt;
/* Designed by greyelf */
	/* Check that a Stat Name was passed to the widget. */
	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _current to $B.actor.get($args[0]) &gt;&gt;
		&lt;&lt;set _base to $B.actor.getBase($args[0]) + $B.actor.getEquipBonus($args[0]) &gt;&gt;

		/* Check if the Stat has been raised. */
		&lt;&lt;if _current &gt; _base &gt;&gt;
			@@.stat-raised;_current@@

		/* Check if the Stat has been lowered. */
		&lt;&lt;elseif _current &lt; _base &gt;&gt;
			@@.stat-lowered;_current@@

		/* The Stat has not changed. */
		&lt;&lt;else&gt;&gt;
			_current
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="106" name="Widget: res display" tags="widget nobr" position="725,1350" size="100,100">&lt;&lt;widget &quot;res&quot;&gt;&gt;
/* Check that an argument was passed to the widget. */
	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _r = $args[0].percent.current&gt;&gt;
		&lt;&lt;set _r = Math.round((_r - 1) * -100)&gt;&gt;

		/* Weakpoint? */
		&lt;&lt;if _r &lt; 0 &gt;&gt;
			@@.stat-lowered;&lt;&lt;print _r&gt;&gt;%@@

		/* Absorbance? */
		&lt;&lt;elseif _r &gt; 100 &gt;&gt;
			&lt;&lt;run _r -= 100&gt;&gt;
			@@.green;+&lt;&lt;print _r&gt;&gt;%@@

		/* Resistance? */
		&lt;&lt;elseif _r &gt; 0 &gt;&gt;
			@@.stat-raised;&lt;&lt;print _r&gt;&gt;%@@

		&lt;&lt;else&gt;&gt;
			&lt;&lt;print _r&gt;&gt;%
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="107" name="Widget: soak display" tags="widget nobr" position="850,1350" size="100,100">&lt;&lt;widget &quot;soak&quot;&gt;&gt;
	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _r = $args[0].flat.current&gt;&gt;

		/* Weakpoint? */
		&lt;&lt;if _r &lt; 0 &gt;&gt;
			@@.stat-lowered;&lt;&lt;print _r&gt;&gt;@@

		/* Resistance? */
		&lt;&lt;elseif _r &gt; 0 &gt;&gt;
			@@.stat-raised;&lt;&lt;print _r&gt;&gt;@@

		&lt;&lt;else&gt;&gt;
			&lt;&lt;print _r&gt;&gt;
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="108" name="Widget: tol display" tags="widget nobr" position="975,1350" size="100,100">&lt;&lt;widget &quot;tol&quot;&gt;&gt;
	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;run console.log(&quot;Rendering tolerance. Max value = &quot;+_v.current)&gt;&gt;
		&lt;&lt;run console.log(&quot;Rendering tolerance. Current value = &quot;+_v.currentVal)&gt;&gt;
		/* Unlike other status widgets, this is passed the value, not the key. */
		&lt;&lt;set _v = $args[0]&gt;&gt;
		&lt;span class=&quot;tolerance&quot;&gt;

		/* Immunity? */
		&lt;&lt;if _v.current &lt; 0&gt;&gt;
			X

		/* Tolerance? */
		&lt;&lt;elseif _v.currentVal &gt; 0&gt;&gt;
			&lt;&lt;print _v.currentVal&gt;&gt;

		/* Tolerance exhausted? */
		&lt;&lt;elseif _v.currentVal == 0&gt;&gt;
			!
		&lt;&lt;/if&gt;&gt;
		&lt;/span&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="109" name="Widget: statOOB" tags="widget nobr" position="1100,1350" size="100,100">&lt;&lt;widget &quot;statOOB&quot;&gt;&gt;
/* For displaying stats outside of battle. Base and equipment mods are displayed separately here. If you wish for effect mods to persist outside of battle, you could include them as well. */

	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _p = $args[1]&gt;&gt;
		&lt;&lt;set _mod to _p.getBonus($args[0]) &gt;&gt;
		&lt;&lt;set _base to _p.getBase($args[0])&gt;&gt;

		&lt;&lt;print _base&gt;&gt;

		/* Check if equipment mod is positive. */
		&lt;&lt;if _mod &gt; 0 &gt;&gt;
			@@.green;&lt;&lt;print &quot;\+&quot;+_mod&gt;&gt;@@

		/* Check if equipment mod is negative. */
		&lt;&lt;elseif _mod &lt; 0 &gt;&gt;
			@@.stat-lowered;&lt;&lt;print &quot;-&quot;+_mod&gt;&gt;@@

		&lt;&lt;elseif _mod == 0&gt;&gt;
			/* display nothing */
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="110" name="Action Queue" tags="nobr" position="1225,1350" size="100,100">/* Special actions are added to the action queue. If the action queue contains any actions, this passage will activate instead of the normal destination when the player clicks &quot;continue&quot;. */
/* Assumes that elements of the action queue are two-element arrays with the subject&#39;s ID in the 0th element and the action as the 1st element. */
&lt;&lt;if $B.actionQueue.length &gt; 0&gt;&gt;
	&lt;&lt;set _data = $B.actionQueue.shift()&gt;&gt;
	&lt;&lt;set _OG = {target: $target, subject: $subject, action: $action}&gt;&gt;
	&lt;&lt;set $subject = getActorById(_data[0]); $action = _data[1]&gt;&gt;
	&lt;&lt;if !(subject().dead || subject().noact)&gt;&gt;
		&lt;&lt;if $action.counter&gt;&gt;
			&lt;&lt;set $target = _OG.subject&gt;&gt;
			&lt;&lt;set _counterActive = true&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;
		&lt;&lt;set _counterActive = false&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;timed 0s&gt;&gt;&lt;&lt;trigger &#39;click&#39; &quot;#continue button&quot;&gt;&gt;&lt;&lt;/timed&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;include &quot;Battle Continue Button&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="111" name="Widget: hunterCheck" tags="widget nobr" position="100,1475" size="100,100">&lt;&lt;widget &quot;hunterCheck&quot;&gt;&gt;
/* Called in the Enemy Phase, after every enemy&#39;s action. */

	&lt;&lt;unset _party&gt;&gt;

	&lt;&lt;if $target instanceof Puppet &amp;&amp; $subject instanceof Enemy&gt;&gt;
		&lt;&lt;set _party = $puppets&gt;&gt;
	&lt;&lt;elseif $target instanceof Enemy &amp;&amp; $subject instanceof Puppet&gt;&gt;
		&lt;&lt;set _party = $enemies&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;if def _party&gt;&gt;
		&lt;&lt;for _actor range _party&gt;&gt;
			&lt;&lt;if _actor.hunter &amp;&amp; !(_actor.dead || _actor.noact || _actor.uncontrollable)&gt;&gt;
				&lt;&lt;set $B.actionQueue.push([_actor.id,new Action(&quot;Hunter Counter&quot;)])&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="112" name="Widget: markAttack" tags="widget nobr" position="225,1475" size="100,100">&lt;&lt;widget &quot;markAttack&quot;&gt;&gt;
/* Called in the Action Phase, after action is finished. */
&lt;&lt;set _archer = $puppets.
	find(function (p) { return p &amp;&amp; p.name == &quot;Archer&quot; &amp;&amp; !(p.dead || p.noact || p.uncontrollable) })&gt;&gt;

&lt;&lt;if def _archer
	&amp;&amp; $subject instanceof Puppet
	&amp;&amp; subject().name != &quot;Archer&quot;
	&amp;&amp; $target instanceof Enemy
	&amp;&amp; _archer.en &gt; 0
	&amp;&amp; enemies().filter(function (e) { return e.marked &amp;&amp; !e.dead }).length &gt; 0&gt;&gt;

	&lt;&lt;set _markActive = true&gt;&gt;
	&lt;&lt;run $B.actionQueue.push([_archer.id,new Action(&quot;Mark Shot&quot;)])&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="113" name="animation activator" tags="nobr" position="350,1475" size="100,100">&lt;&lt;if _animationActive &amp;&amp; _queue.size &gt; 0 &amp;&amp; $(&quot;#continue&quot;) !== undefined&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#continue .macro-button&quot;).each((index, element) =&gt; {
			element.disabled = true;
		});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _animationsToComplete = 0&gt;&gt;
&lt;&lt;set _animationsComplete = 0&gt;&gt;
&lt;&lt;timed setup.ANIM_WINDUP+&quot;ms&quot;&gt;&gt;
&lt;&lt;if ($(&#39;#dmgBox0&#39;) !== undefined)&gt;&gt;
	&lt;&lt;run $(&quot;.animationContainer&quot;).css(&quot;height&quot;,$(&quot;#dmgBox0&quot;).outerHeight()+&quot;px&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;for _i, _p range _queue&gt;&gt;
	&lt;&lt;set _idA = &quot;#dmgBox&quot;+_i&gt;&gt;
	&lt;&lt;capture _idA, _p&gt;&gt;
    &lt;&lt;for _x, _m range _p.battleMsg&gt;&gt;
			&lt;&lt;if passage() == &quot;Player Phase&quot;&gt;&gt;
				&lt;&lt;if _p instanceof Enemy&gt;&gt;
					&lt;&lt;set _idx = $enemies.findIndex(function (a) { return _p.id == a.id; })&gt;&gt;
				&lt;&lt;elseif _p instanceof Puppet&gt;&gt;
					&lt;&lt;set _idx = $puppets.findIndex(function (a) { return _p.id == a.id; })&gt;&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;set _idB = &quot;#dmg&quot;+_idx+&#39;-&#39;+_x&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _idB = &quot;#dmg&quot;+_i+&#39;-&#39;+_x&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;capture _x, _idB, _m&gt;&gt;
			&lt;&lt;set _time = (_x*setup.ANIM_DELAY)+&quot;ms&quot;&gt;&gt;
			&lt;&lt;if _m.shake&gt;&gt; /* if true, box shakes */
				&lt;&lt;timed _time&gt;&gt;
					&lt;&lt;if $(_idA).hasClass(&quot;animate__animated&quot;)&gt;&gt;
						&lt;&lt;run resetAnimation(_idA,&quot;headShake&quot;)&gt;&gt;
					&lt;&lt;else&gt;&gt;
						&lt;&lt;run animateCSS(_idA,&quot;headShake&quot;,setup.ANIM_DURATION+&quot;ms&quot;)&gt;&gt;
					&lt;&lt;/if&gt;&gt;
					&lt;&lt;include &quot;popup animation&quot;&gt;&gt;
				&lt;&lt;/timed&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;timed _time&gt;&gt;
					&lt;&lt;include &quot;popup animation&quot;&gt;&gt;
				&lt;&lt;/timed&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
    &lt;&lt;/for&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;&lt;set _animationsToComplete += _p.battleMsg.length&gt;&gt;
	&lt;&lt;set _p.battleMsg = []&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/timed&gt;&gt;</tw-passagedata><tw-passagedata pid="114" name="popup animation" tags="nobr" position="475,1475" size="100,100">&lt;&lt;set _animation = &quot;slideOutUp&quot;&gt;&gt;
&lt;&lt;switch _m.type&gt;&gt;
	&lt;&lt;case &quot;damage&quot;&gt;&gt;
		&lt;&lt;set _p.displayHP -= _m.content&gt;&gt;
	&lt;&lt;case &quot;mana damage&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;stat-raised&quot;)&gt;&gt;
	&lt;&lt;case &quot;healing&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;green&quot;)&gt;&gt;
		&lt;&lt;set _p.displayHP += _m.content&gt;&gt;
	&lt;&lt;case &quot;regen&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;regen&quot;)&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
	&lt;&lt;case &quot;block&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
	&lt;&lt;case &quot;addEffect&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;stat-raised&quot;)&gt;&gt;
	&lt;&lt;case &quot;removeEffect&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;maroon&quot;)&gt;&gt;
		&lt;&lt;set _animation = &quot;slideOutDown&quot;&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;&lt;update&gt;&gt;
&lt;&lt;if typeof(_m.mod) == &quot;string&quot;&gt;&gt;
	&lt;&lt;run console.log(&quot;mod for &quot;+_idB+&quot; is &quot;+_m.mod)&gt;&gt;
	&lt;&lt;run $(_idB).addClass(_m.mod)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;run animateCSS(_idB,_animation,setup.DMG_DURATION+&quot;ms&quot;)&gt;&gt;</tw-passagedata><tw-passagedata pid="115" name="delayed actions" tags="nobr" position="600,1475" size="100,100">&lt;&lt;if passage() == &quot;Player Phase&quot;&gt;&gt;
  &lt;&lt;switch setup.TURN_MODEL.toLowerCase()&gt;&gt;
    &lt;&lt;case &quot;timeline&quot;&gt;&gt;
      /* find the active character */
      &lt;&lt;set _actor = allActors().find(function(p) { return p &amp;&amp; p.active })&gt;&gt;
      /* if found, check if they have a delayedAction */
      &lt;&lt;if _actor instanceof Puppet &amp;&amp; _actor.delayedAction instanceof Action&gt;&gt;
        /* if yes, set them as subject and perform the action immediately */
        &lt;&lt;set $subject = _actor; $action = _actor.delayedAction&gt;&gt;
        &lt;&lt;if def _actor.target&gt;&gt;
          &lt;&lt;set $target = getActorById(_actor.target); delete _actor.target&gt;&gt;
        &lt;&lt;else&gt;&gt;
          &lt;&lt;set $target = $action.targetMethod()&gt;&gt;
        &lt;&lt;/if&gt;&gt;
        &lt;&lt;set _actor.delayedAction = null&gt;&gt;
        &lt;&lt;goto &quot;Action Phase&quot;&gt;&gt;
      &lt;&lt;/if&gt;&gt;
    &lt;&lt;case &quot;free&quot;&gt;&gt;
      &lt;&lt;if $B.turn === &quot;player&quot;&gt;&gt;
        /* Check for puppets with actionReady. Because the action phase feeds back into this check, this will check for all puppets&#39; readied actions in sequence after each is executed. */
        &lt;&lt;set _puppet = puppets().find(function(p) { return p &amp;&amp; p.actionReady })&gt;&gt;
        /* if found, set them as subject and execute delayedAction */
        &lt;&lt;if _puppet instanceof Puppet&gt;&gt;
          &lt;&lt;set $subject = _puppet; $action = _puppet.delayedAction; $target = $action.targetMethod()&gt;&gt;
          &lt;&lt;set _puppet.delayedAction = null&gt;&gt;
          &lt;&lt;goto &quot;Action Phase&quot;&gt;&gt;
        &lt;&lt;/if&gt;&gt;
      &lt;&lt;/if&gt;&gt;
  &lt;&lt;/switch&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="116" name="Q press" tags="" position="725,1475" size="100,100">/* Defines the function of pressing the Q key. */

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;case &quot;command&quot;&gt;&gt;
			&lt;&lt;if $subject !== null&gt;&gt;
				&lt;&lt;set _id = &quot;#actbtn a&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;actions&quot;&gt;&gt;
			&lt;&lt;if typeof(subject().defaultAction) === &quot;string&quot;&gt;&gt;
				&lt;&lt;set _action = subject().actions.find(function (act) { return act &amp;&amp; act.name === subject().defaultAction })&gt;&gt;
				&lt;&lt;if _action instanceof Action&gt;&gt;
					&lt;&lt;actionLink&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;confirm&quot;&gt;&gt;
			&lt;&lt;trigger &#39;click&#39; &quot;#confirmLink a&quot;&gt;&gt;
		&lt;&lt;case &quot;selection&quot;&gt;&gt;
			/* do nothing */
		&lt;&lt;default&gt;&gt;
			&lt;&lt;trigger &#39;click&#39; &quot;button.macro-button&quot;&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Inventory&quot; &amp;&amp; def _display&gt;&gt;
	&lt;&lt;set _id = &#39;#button1 button&#39;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="117" name="W press" tags="" position="850,1475" size="100,100">/* Defines the function of pressing the W key. */

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;case &quot;command&quot;&gt;&gt;
			&lt;&lt;if $subject !== null&gt;&gt;
				&lt;&lt;set _id = &quot;#restbtn a&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;actions&quot;&gt;&gt;
			&lt;&lt;if typeof(subject().lastAction) === &quot;string&quot;&gt;&gt;
				&lt;&lt;set _action = subject().actions.find(function (act) { return act &amp;&amp; act.name === subject().lastAction })&gt;&gt;
				&lt;&lt;if _action instanceof Action&gt;&gt;
					&lt;&lt;actionLink&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Inventory&quot; &amp;&amp; def _display&gt;&gt;
	&lt;&lt;set _id = &#39;#button2 button&#39;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
&lt;&lt;elseif !tags().includes(&quot;nomenu&quot;) &amp;&amp; !tags().includes(&quot;noreturn&quot;)&gt;&gt;
	&lt;&lt;set $menu_screen = 0&gt;&gt;
	&lt;&lt;goto &quot;Menu: Status&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="118" name="E press" tags="" position="975,1475" size="100,100">/* Defines the function of pressing the E key. */

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;case &quot;command&quot;&gt;&gt;
			&lt;&lt;if $subject !== null&gt;&gt;
				&lt;&lt;set _id = &quot;#itembtn a&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;actions&quot;&gt;&gt;
			&lt;&lt;if document.getElementById(&quot;crisisLink&quot;)&gt;&gt;
				&lt;&lt;set _id = &quot;#crisisLink a&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;crisis&quot;&gt;&gt;
			&lt;&lt;set _id = &quot;#regularActions a&quot;&gt;&gt;
			&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="119" name="R press" tags="" position="1100,1475" size="100,100">/* Defines the function of pressing the R key. */

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;default&gt;&gt;
			&lt;&lt;if $(&#39;#battlebackbtn&#39;).length &gt; 0&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; &#39;#battlebackbtn a&#39;&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;if passage() == &quot;Menu: Status&quot; &amp;&amp; def $subject&gt;&gt;
		&lt;&lt;if document.getElementById(&quot;cancelbutton&quot;)&gt;&gt;
			&lt;&lt;set _id = &#39;#cancelbutton button&#39;&gt;&gt;
			&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;trigger &#39;click&#39; &#39;#toggle a&#39;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;elseif passage() == &quot;Menu: Equipment&quot; &amp;&amp; def _s&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; &#39;#toggle a&#39;&gt;&gt;
	&lt;&lt;elseif passage() == &quot;Menu: Inventory&quot; &amp;&amp; document.getElementById(&quot;cancelbutton&quot;)&gt;&gt;
		&lt;&lt;set _id = &#39;#cancelbutton button&#39;&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
	&lt;&lt;elseif passage() == &quot;Menu: Bestiary&quot; &amp;&amp; def _display&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; &#39;#toggle a&#39;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; &#39;#menu-return a&#39;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="120" name="A press" tags="" position="1225,1475" size="100,100">/* Defines the function of pressing the A key. */

&lt;&lt;if $inbattle || passage() == &quot;Menu: Status&quot; &amp;&amp; def $subject&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; &#39;#statusback a&#39;&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Bestiary&quot; &amp;&amp; def _display&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; &#39;#lastentry a&#39;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $menu_screen--&gt;&gt;
	&lt;&lt;if $menu_screen &lt; 0&gt;&gt;
		&lt;&lt;set $menu_screen = setup.MENU_OPTIONS.length-1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _menupos = &quot;#menu&quot;+$menu_screen+&quot; a&quot;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _menupos&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="121" name="D press" tags="" position="100,1600" size="100,100">/* Defines the function of pressing the D key. */

&lt;&lt;if $inbattle || passage() == &quot;Menu: Status&quot; &amp;&amp; def $subject&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; &#39;#statusforward a&#39;&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Bestiary&quot; &amp;&amp; def _display&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; &#39;#nextentry a&#39;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $menu_screen++&gt;&gt;
	&lt;&lt;if $menu_screen &gt;= setup.MENU_OPTIONS.length&gt;&gt;
		&lt;&lt;set $menu_screen = 0&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _menupos = &quot;#menu&quot;+$menu_screen+&quot; a&quot;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _menupos&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="122" name="M press" tags="" position="225,1600" size="100,100">/* Defines the function of pressing the M key. */

&lt;&lt;if $muted === true&gt;&gt;
	&lt;&lt;masteraudio unmute&gt;&gt;
	&lt;&lt;set $muted = false&gt;&gt;
	&lt;&lt;replace &quot;#mutebutton&quot;&gt;&gt;&lt;&lt;include &quot;mute button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;masteraudio mute&gt;&gt;
	&lt;&lt;set $muted = true&gt;&gt;
	&lt;&lt;replace &quot;#mutebutton&quot;&gt;&gt;&lt;&lt;include &quot;mute button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="123" name="Shift press" tags="" position="350,1600" size="100,100">/* Defines the function of pressing the Shift key. */

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;case &quot;targeting&quot;&gt;&gt;
			&lt;&lt;if _targetingEnemy === true&gt;&gt;
				&lt;&lt;set _targetingEnemy = false&gt;&gt;
			&lt;&lt;elseif _targetingEnemy === false&gt;&gt;
				&lt;&lt;set _targetingEnemy = true&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;if $(&#39;#target_help&#39;).length &gt; 0&gt;&gt;
				&lt;&lt;replace &#39;#target_help&#39;&gt;&gt;[Hotkeys targeting &lt;&lt;if _targetingEnemy === true&gt;&gt;enemies&lt;&lt;else&gt;&gt;allies&lt;&lt;/if&gt;&gt;. Press Shift to switch targets.]&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="124" name="hotkey definitions" tags="" position="475,1600" size="100,100">&lt;&lt;event keydown&gt;&gt;
	&lt;&lt;which 81&gt;&gt; /* Q pressed */
		&lt;&lt;include &quot;Q press&quot;&gt;&gt;
	&lt;&lt;which 87&gt;&gt; /* W pressed */
		&lt;&lt;include &quot;W press&quot;&gt;&gt;
	&lt;&lt;which 69&gt;&gt; /* E pressed */
		&lt;&lt;include &quot;E press&quot;&gt;&gt;
	&lt;&lt;which 82&gt;&gt; /* R pressed */
		&lt;&lt;include &quot;R press&quot;&gt;&gt;
	&lt;&lt;which 65&gt;&gt; /* A pressed */
		&lt;&lt;include &quot;A press&quot;&gt;&gt;
	&lt;&lt;which 68&gt;&gt; /* D pressed */
		&lt;&lt;include &quot;D press&quot;&gt;&gt;
	&lt;&lt;which 49&gt;&gt; /* 1 pressed */
		&lt;&lt;numKey 0&gt;&gt;
	&lt;&lt;which 50&gt;&gt; /* 2 pressed */
		&lt;&lt;numKey 1&gt;&gt;
	&lt;&lt;which 51&gt;&gt; /* 3 pressed */
		&lt;&lt;numKey 2&gt;&gt;
	&lt;&lt;which 52&gt;&gt; /* 4 pressed */
		&lt;&lt;numKey 3&gt;&gt;
	&lt;&lt;which 53&gt;&gt; /* 5 pressed */
		&lt;&lt;numKey 4&gt;&gt;
	&lt;&lt;which 54&gt;&gt; /* 6 pressed */
		&lt;&lt;numKey 5&gt;&gt;
	&lt;&lt;which 55&gt;&gt; /* 7 pressed */
		&lt;&lt;numKey 6&gt;&gt;
	&lt;&lt;which 56&gt;&gt; /* 8 pressed */
		&lt;&lt;numKey 7&gt;&gt;
	&lt;&lt;which 57&gt;&gt; /* 9 pressed */
		&lt;&lt;numKey 8&gt;&gt;
	&lt;&lt;which 48&gt;&gt; /* 0 pressed */
		&lt;&lt;numKey 9&gt;&gt;
	&lt;&lt;which 16&gt;&gt; /* Shift pressed */
		&lt;&lt;include &quot;Shift press&quot;&gt;&gt;
	&lt;&lt;which 77&gt;&gt; /* M pressed */
		&lt;&lt;include &quot;M press&quot;&gt;&gt;
&lt;&lt;/event&gt;&gt;</tw-passagedata><tw-passagedata pid="125" name="Widget: numKey" tags="widget nobr" position="600,1600" size="100,100">&lt;&lt;widget &quot;numKey&quot;&gt;&gt;
/* Functionality for number hotkeys. By default, used to select characters in selection screens. */
&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; Number.isInteger($args[0]),&quot;ERROR in numKey: key is undefined or non-integer&quot;)&gt;&gt;
&lt;&lt;set _n = $args[0]&gt;&gt;

&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;switch $B.phase&gt;&gt;
		&lt;&lt;case &quot;selection&quot;&gt;&gt;
			&lt;&lt;if def $puppets[_n] &amp;&amp; $puppets[_n] !== null &amp;&amp; $puppets[_n].active &amp;&amp; !$puppets[_n].dead&gt;&gt;
				&lt;&lt;set _id = &quot;#pname&quot;+_n+&quot; a&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;case &quot;targeting&quot;&gt;&gt;
			&lt;&lt;switch $B.targeting&gt;&gt;
				&lt;&lt;case &quot;enemy&quot;&gt;&gt;
					&lt;&lt;if !$enemies[_n].hidden&gt;&gt;
						&lt;&lt;set _party = $enemies&gt;&gt;
						&lt;&lt;set _id = &quot;#ename&quot;&gt;&gt;
					&lt;&lt;/if&gt;&gt;
				&lt;&lt;case &quot;ally&quot;&gt;&gt;
					&lt;&lt;set _party = $puppets&gt;&gt;
					&lt;&lt;set _id = &quot;#pname&quot;&gt;&gt;
				&lt;&lt;case &quot;all&quot;&gt;&gt;
					&lt;&lt;if _targetingEnemy === true&gt;&gt;
						&lt;&lt;set _party = $enemies&gt;&gt;
						&lt;&lt;set _id = &quot;#ename&quot;&gt;&gt;
					&lt;&lt;elseif _targetingEnemy === false&gt;&gt;
						&lt;&lt;set _party = $puppets&gt;&gt;
						&lt;&lt;set _id = &quot;#pname&quot;&gt;&gt;
					&lt;&lt;/if&gt;&gt;
			&lt;&lt;/switch&gt;&gt;
			&lt;&lt;if def _party&gt;&gt;
				&lt;&lt;set _id += _n+&#39; a&#39;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Status&quot; &amp;&amp; ndef $subject&gt;&gt;
	&lt;&lt;set _id = &#39;#&#39;+_n+&#39; a&#39;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
&lt;&lt;elseif passage() == &quot;Menu: Equipment&quot; &amp;&amp; ndef _s&gt;&gt;
	&lt;&lt;set _id = &#39;#&#39;+_n+&#39; a&#39;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="126" name="hotkey info" tags="" position="725,1600" size="100,100">&lt;div class=&quot;hotkey monospace&quot; style=&quot;text-align:left&quot;&gt;[Q] = confirm/advance
[R] = cancel/back
[W] = &lt;&lt;nobr&gt;&gt;&lt;&lt;link &quot;menu&quot;&gt;&gt;
		&lt;&lt;if !$inbattle &amp;&amp; !tags().includes(&quot;nomenu&quot;) &amp;&amp; !tags().includes(&quot;noreturn&quot;) &amp;&amp; !_nomenu&gt;&gt;
			&lt;&lt;set $menu_screen = 0&gt;&gt;
			&lt;&lt;goto &quot;Menu: Status&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/link&gt;&gt;&lt;&lt;/nobr&gt;&gt;
[A] = cycle menu left
[D] = cycle menu right&lt;/div&gt;</tw-passagedata><tw-passagedata pid="127" name="Initiative Model: Ranked Order" tags="nobr" position="850,1600" size="100,100">&lt;&lt;set _initiative = -1&gt;&gt;
/* The -1 is necessary if you want a Speed of 0 to be possible. */
&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead &amp;&amp; !a.noact; })&gt;&gt;
		&lt;&lt;if !_actor.isDone &amp;&amp; _actor.get(&quot;Speed&quot;) &gt; _initiative&gt;&gt;
		/* (!_actor.isDone) prevents us from selecting characters who have already acted this round. They&#39;ll be skipped over, and the next-fastest character will get the initiative. */
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;set _initiative = _actor.get(&quot;Speed&quot;)&gt;&gt;
			/* This sets the current character&#39;s Speed as the new bar to clear. If no one&#39;s faster, no one else will pass the if check above and this character will remain the current subject. If someone else is faster, they&#39;ll become the subject and the _initiative variable will be updated to match their Speed. This ensures that subject status will be granted to the fastest character. */
		&lt;&lt;elseif !_actor.isDone &amp;&amp; _actor.get(&quot;Speed&quot;) == _initiative&gt;&gt;
		/* You&#39;ll need a handler for this case, or else the character with the higher index order will get the initiative in the case of a match. This handler can be anything, including nothing at all. If you want to be nice, you could automatically give the player the initiative in the case of a tie. Here I&#39;ve provided the fairest possible option: a coin flip. */
			&lt;&lt;set _r = random(1,2)&gt;&gt;
			&lt;&lt;if _r == 1&gt;&gt;
				&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject = _actor&gt;&gt;
	&lt;&lt;if subject() instanceof Enemy&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="128" name="Initiative Model: Ranked Order with Variance" tags="nobr" position="975,1600" size="100,100">&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead &amp;&amp; !a.noact; })&gt;&gt;
		&lt;&lt;set _actor.initiative = _actor.get(&quot;Speed&quot;)&gt;&gt;
		&lt;&lt;set _variance = random(-$VARIANCE_BOUND,$VARIANCE_BOUND)&gt;&gt;
		&lt;&lt;set _variance /= 100&gt;&gt;
		/* Twine&#39;s random() function requires integer bounds, but we (presumably) plan to vary characters&#39; Speed stats by a small proportion. We can do this by setting $VARIANCE_BOUND to an integer percentage value (probably in StoryInit) and dividing by 100 to get the decimal value. */
		&lt;&lt;set _actor.initiative += _actor.get(&quot;Speed&quot;) * _variance&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;set _initiative = -1&gt;&gt;
/* The -1 is necessary if you want a Speed of 0 to be possible. */
&lt;&lt;for _i, _party range $actors&gt;&gt;
	&lt;&lt;for _j, _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead &amp;&amp; !a.noact; })&gt;&gt;
		&lt;&lt;if not _actor.isDone and _actor.initiative &gt; _initiative&gt;&gt;
		/* (not _actor.isDone) prevents us from selecting characters who have already acted this round. They&#39;ll be skipped over, and the next-fastest character will get the initiative. */
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;set _initiative = _actor.initiative&gt;&gt;
			/* This sets the current character&#39;s initiative as the new bar to clear. If no one&#39;s faster, no one else will pass the if check above and this character will remain the current subject. If someone else is faster, they&#39;ll become the subject and the _initiative variable will be updated to match their Speed. This ensures that subject status will be granted to the fastest character. */
		&lt;&lt;elseif not _actor.isDone and _actor.initiative == _initiative&gt;&gt;
		/* You&#39;ll need a handler for this case, or else the character with the higher index order will get the initiative in the case of a match. This handler can be anything, including nothing at all. If you want to be nice, you could automatically give the player the initiative in the case of a tie. Here I&#39;ve provided the fairest possible option: a coin flip. */
			&lt;&lt;set _r = random(1,2)&gt;&gt;
			&lt;&lt;if _r == 1&gt;&gt;
				&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject = _actor&gt;&gt;
	&lt;&lt;if subject() instanceof Enemy&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="129" name="Initiative Model: Action Time" tags="nobr" position="1100,1600" size="100,100">/* initiative gain */
/* Note this model assumes everyone&#39;s &quot;initiative&quot; attribute is initialized to 0 at battle start. */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;set _actor.initiative += _actor.get(&quot;Speed&quot;)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative comparison */

&lt;&lt;set _initiative = -1&gt;&gt;
&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;if _actor.initiative &gt; _initiative&gt;&gt;
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;set _initiative = _actor.initiative&gt;&gt;
		&lt;&lt;elseif _actor.initiative == _initiative&gt;&gt;
			&lt;&lt;set _r = random(1,2)&gt;&gt;
			&lt;&lt;if _r == 1&gt;&gt;
				&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject = _actor; subject().initiative = 0&gt;&gt;
	&lt;&lt;if subject() instanceof Enemy&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="130" name="Initiative Model: Action Time with Threshold" tags="nobr" position="1225,1600" size="100,100">/* Note that this assumes everyone&#39;s &quot;initiative&quot; attribute is set to 0 at battle start. */

&lt;&lt;set _threshold = setup.ACTION_THRESHOLD&gt;&gt; /* You would set ACTION_THRESHOLD to some constant in StoryInit. */
&lt;&lt;set _pastThreshold = false&gt;&gt;

/* check for characters already at threshold */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;if _pastThreshold&gt;&gt;
		&lt;&lt;break&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;if _actor.initiative &gt;= _threshold&gt;&gt;
			&lt;&lt;set _pastThreshold = true&gt;&gt;
			&lt;&lt;break&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative gain */

&lt;&lt;for not _pastThreshold&gt;&gt;
	&lt;&lt;for _party range $actors&gt;&gt;
		&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
			&lt;&lt;set _actor.initiative += 20 + 0.2 * _actor.get(&quot;Speed&quot;)&gt;&gt;
			/* This is the Bonfire formula, but you can add your own */
			&lt;&lt;if _actor.initiative &gt;= _threshold&gt;&gt;
				&lt;&lt;set _pastThreshold = true&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative comparison */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;if _actor.initiative &gt; _threshold&gt;&gt;
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;set _threshold = _actor.initiative&gt;&gt;
		&lt;&lt;elseif _actor.initiative == _threshold&gt;&gt;
			&lt;&lt;if def _subj&gt;&gt;
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _subj = _actor&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject = _actor; subject().initiative -= setup.ACTION_THRESHOLD&gt;&gt;
	&lt;&lt;if subject() instanceof Enemy&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="131" name="Initiative Model: Timeline" tags="nobr" position="100,1725" size="100,100">/* Note that you will need to come up with a method for determining everyone&#39;s starting initiative; that is not modeled here. */

&lt;&lt;set _threshold = 0&gt;&gt;
&lt;&lt;set _pastThreshold = false&gt;&gt;

/* check for characters already at threshold */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;if _pastThreshold&gt;&gt;
		&lt;&lt;break&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;if _actor.initiative &lt;= _threshold&gt;&gt;
			&lt;&lt;set _pastThreshold = true&gt;&gt;
			&lt;&lt;break&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative gain */

&lt;&lt;for not _pastThreshold&gt;&gt;
	&lt;&lt;for _party range $actors&gt;&gt;
		&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
			&lt;&lt;set _actor.initiative -= 1&gt;&gt;
			&lt;&lt;if _actor.initiative &lt;= _threshold&gt;&gt;
				&lt;&lt;set _pastThreshold = true&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative comparison */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party.filter(function (a) { return a !== null &amp;&amp; !a.dead; })&gt;&gt;
		&lt;&lt;if _actor.initiative &lt; _threshold&gt;&gt;
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;set _threshold = _actor.initiative&gt;&gt; /* This is only necessary if it is possible to overshoot the threshold */
		&lt;&lt;elseif _actor.initiative == _threshold&gt;&gt;
			&lt;&lt;if def _subj&gt;&gt;
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _subj = _actor&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject = _actor; subject().initiative -= setup.ACTION_THRESHOLD&gt;&gt;
	&lt;&lt;if subject() instanceof Enemy&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="132" name="Ranked Order Preview Model" tags="nobr" position="225,1725" size="100,100">/* Turn preview for the ranked order model. Run this at the start of each round. */

&lt;&lt;set $turn_preview = []&gt;&gt;
&lt;&lt;set _count = 0&gt;&gt;
&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead and not _actor.stunned&gt;&gt;
			&lt;&lt;run _count++&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;for $turn_preview.length &lt; _count&gt;&gt;
	&lt;&lt;set _initiative = -1&gt;&gt;
	&lt;&lt;for _i, _party range $actors&gt;&gt;
		&lt;&lt;for _j, _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead and not _actor.stunned&gt;&gt;
			&lt;&lt;if not $turn_preview.includes(_actor.name) and _actor.initiative &gt; _initiative&gt;&gt;
				&lt;&lt;set _next = _actor.name&gt;&gt;
				&lt;&lt;set _initiative = _actor.initiative&gt;&gt;
			&lt;&lt;elseif not $turn_preview.includes(_actor.name) and _actor.initiative == _initiative&gt;&gt;
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _next = _actor.name&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;run $turn_preview.push(_next)&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* You can then draw from $turn_preview to list the characters. The array is already sorted, so you can just use a for loop to display the characters in the order of their action. Exactly how this is implemented is left up to you. */

/* You will still need to run the regular program to choose the active character thanks to Twine breaking object references. Otherwise, you could just add each _actor to the array and draw from there. */

/* Known bug: in case of equal initiatives, the coin flip may go differently here than it does in the actual selection. */</tw-passagedata><tw-passagedata pid="133" name="Action Time Preview Model" tags="nobr" position="350,1725" size="100,100">&lt;&lt;set $turn_preview = []&gt;&gt;
&lt;&lt;set _preview = clone($actors)&gt;&gt;
/* This is only a simulation, so we make a clone of the current state of $actors to work with. */

&lt;&lt;for _i = 0; _i &lt; $PREVIEW_PROGNOSIS; _i++&gt;&gt;
/* $PREVIEW_PROGNOSIS is how many turns in advance you would like to calculate. I don&#39;t recommend making this very high. */

/* initiative gain */

&lt;&lt;for _party range _preview&gt;&gt;
	&lt;&lt;for _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;set _actor.initiative += _actor.speed&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative comparison */

&lt;&lt;set _initiative = -1&gt;&gt;
&lt;&lt;for _i, _party range _preview&gt;&gt;
	&lt;&lt;for _j, _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;if _actor.initiative &gt; _initiative&gt;&gt;
				&lt;&lt;set _next = _actor&gt;&gt;
				&lt;&lt;set _initiative = _actor.initiative&gt;&gt;
			&lt;&lt;elseif _actor.initiative == _initiative&gt;&gt;
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _next = _actor&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;run $turn_preview.push(_actor)&gt;&gt;
&lt;&lt;set _next.initiative = 0&gt;&gt;

&lt;&lt;/for&gt;&gt;

/* Preview code for threshold model is similar; just update the body code to match. */

/* You MUST run this after every action if it is to be accurate, especially if you have actions that can modify initiative values. It is for this reason that I recommend a low prognosis value, so as to not cause your player&#39;s processor to melt. */</tw-passagedata><tw-passagedata pid="134" name="Timeline Preview Model" tags="nobr" position="475,1725" size="100,100">/* Within the status pane, include this line: */

Ticks until next turn: &lt;&lt;print $actor[0].initiative&gt;&gt;

/* Creating a visual representation (such as in Becoming) will require skill in CSS and is beyond the scope of this help. */</tw-passagedata><tw-passagedata pid="135" name="Widgets: Leveling Up" tags="nobr widget" position="600,1725" size="100,100">&lt;&lt;widget &quot;levelcheck&quot;&gt;&gt;
&lt;&lt;set _keepGoing = true; $LevelUps = []&gt;&gt;
&lt;&lt;for _keepGoing === true&gt;&gt;
	&lt;&lt;set _keepGoing = false&gt;&gt;
	&lt;&lt;for _puppet range $puppets&gt;&gt;
		&lt;&lt;if _puppet !== null&gt;&gt;
			&lt;&lt;if _puppet.level &lt; setup.LEVEL_CAP &amp;&amp; _puppet.xp &gt;= _puppet.XPtoNext()&gt;&gt;
				&lt;&lt;run _puppet.level++; $LevelUps.push(_puppet)&gt;&gt;
				&lt;&lt;set _keepGoing = true&gt;&gt;
				/* This is needed if you want it to be possible for characters to level up multiple times within the same widget call. This ensures the whole check will be done again to check if the puppet&#39;s XP matches the requirement for the next level too. */
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;LevelUp&quot;&gt;&gt;
/* To implement this, you will need to enable the level up code detailed in the story JavaScript. */

&lt;&lt;set $subject = $args[0]&gt;&gt;
&lt;&lt;run getActor(&quot;subject&quot;)&gt;&gt;

&lt;&lt;set _num = 1&gt;&gt;

$subject.name has reached Level &lt;&lt;print $subject.level&gt;&gt;!&lt;br/&gt;

&lt;&lt;for _pn, _rate range $subject.growthRates&gt;&gt;
	&lt;&lt;run $subject.stats[_pn].base += _rate&gt;&gt;
	&lt;&lt;print _pn&gt;&gt; +&lt;&lt;print _rate&gt;&gt; = &lt;b&gt;&lt;&lt;print $subject.getBase(_pn)&gt;&gt;&lt;/b&gt;&lt;br/&gt;
&lt;&lt;/for&gt;&gt;

/* You could also make the growth rate a formula that changes based on level. You could calculate it through a function similar to XPtoNext. */

/* Alternatively, use a stat table with unique returns for each level: */
&lt;&lt;set _return = $subject.StatTable(subject().level)&gt;&gt;
&lt;&lt;if typeof(_return) == &#39;string&#39;&gt;&gt;
	/* If only a string is returned, this assumes it is a stat name, and will increment the stat by a default amount (here, 1). */
	&lt;&lt;run $subject.stats[_return].base += 1&gt;&gt;
	&lt;&lt;print _return&gt;&gt; +1 = &lt;&lt;print $subject.getBase(_return)&gt;&gt;
&lt;&lt;elseif _return instanceof Action&gt;&gt;
	/* If an action is returned, it will be added to the character&#39;s actions. */
	&lt;&lt;run subject().actions.push(_action)&gt;&gt;
&lt;&lt;elseif typeof(_return) == &#39;object&#39;&gt;&gt;
	/* If an object is returned, behaves like growthRates. */
	&lt;&lt;for _pn, _rate range _return&gt;&gt;
		&lt;&lt;if _pn.toLowerCase() == &quot;hp&quot;&gt;&gt;
			&lt;&lt;run subject().maxHP += _rate&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;run $subject.stats[_pn].base += _rate&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;print _pn&gt;&gt; +&lt;&lt;print _rate&gt;&gt; = &lt;b&gt;&lt;&lt;print $subject.getBase(_pn)&gt;&gt;&lt;/b&gt;&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print &quot;ERROR in StatTable: undefined result&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;

&lt;&lt;if ($subject.level % _num) == 0&gt;&gt;
/* This is a handler for if you want to provide a special bonus at certain intervals. For instance, Dungeons &amp; Dragons provides a stat point every 4 levels. This if case will trigger every _num levels. */
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;center&gt;&lt;&lt;button &quot;Continue&quot; &quot;Level Check&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;&lt;/center&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="136" name="Point-buy interface example" tags="nobr nomenu" position="725,1725" size="100,100">/* Presumably the player would get here by clicking a link from a menu passage of some kind. We&#39;ll assume this link set the $subject variable to the character in question. */

&lt;&lt;set $subject = $puppets[0]&gt;&gt;
&lt;&lt;set $subject.statPoints = 3&gt;&gt;

&lt;&lt;set _curr = new Map()&gt;&gt;
&lt;&lt;run _curr.set(&quot;points&quot;,$subject.statPoints)&gt;&gt;

&lt;&lt;for _key, _value range $subject.stats&gt;&gt;
	&lt;&lt;run _curr.set(_key,_value.base)&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;div id=&quot;stats&quot;&gt;
&lt;&lt;include &quot;statblock&quot;&gt;&gt;
&lt;/div&gt;

/* This is for a regular stat point system. For a more complex point-buy system, you&#39;d just use the &quot;getStatCost&quot; function and check stat points/XP against that instead of 0. */

&lt;br/&gt;Leaving this screen will make stat investments permanent!&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;return&gt;&gt;/* Presumably you would have a link back to the menu or whatever here */</tw-passagedata><tw-passagedata pid="137" name="statblock" tags="nobr" position="850,1725" size="100,100">Leveling up $subject.name!&lt;br/&gt;
&lt;br/&gt;
Current stat points: $subject.statPoints / &lt;&lt;print _curr.get(&quot;points&quot;)&gt;&gt;&lt;br/&gt;
&lt;&lt;for _key, _value range $subject.stats&gt;&gt;
&lt;&lt;capture _key, _value&gt;&gt;
	&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _key&gt;&gt;:&lt;/span&gt; _value.base
	&lt;&lt;if $subject.statPoints &gt; 0&gt;&gt;
	[&lt;&lt;link &quot;+&quot;&gt;&gt;
		&lt;&lt;replace &quot;#stats&quot;&gt;&gt;
			&lt;&lt;run _value.base++&gt;&gt;
			&lt;&lt;run $subject.statPoints--&gt;&gt;
			&lt;&lt;include &quot;statblock&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $subject.statPoints &gt; 0 and _value.base &gt; _curr.get(_key)&gt;&gt; / &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $subject.statPoints &lt; _curr.get(&quot;points&quot;) and _value.base &gt; _curr.get(_key)&gt;&gt;
	[&lt;&lt;link &quot;-&quot;&gt;&gt;
		&lt;&lt;replace &quot;#stats&quot;&gt;&gt;
			&lt;&lt;run _value.base--&gt;&gt;
			&lt;&lt;run $subject.statPoints++&gt;&gt;
			&lt;&lt;include &quot;statblock&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
	&lt;br/&gt;
&lt;&lt;/capture&gt;&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="138" name="music info" tags="nobr" position="975,1725" size="100,100">&lt;&lt;if def $music&gt;&gt;
&lt;div style=&quot;text-align:left&quot;&gt;
&lt;div class=&quot;marqueeWrapper&quot;&gt;
    &lt;div style=&quot;margin-right:0.5em&quot;&gt;♪&lt;/div&gt;
    &lt;div id=&quot;marquee&quot;&gt;&lt;span&gt;$music.title&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;span style=&quot;font-size:14px&quot;&gt;by $music.author &lt;&lt;if $music.distributor !== null&gt;&gt;via $music.distributor&lt;&lt;/if&gt;&gt;&lt;/span&gt;
&lt;&lt;if $music.license !== null&gt;&gt;&lt;br/&gt;
&lt;&lt;if $music.license.toLowerCase() == &quot;permission&quot;&gt;&gt;
Used with permission
&lt;&lt;elseif $music.license.toLowerCase() == &quot;public domain&quot;&gt;&gt;
Public Domain
&lt;&lt;else&gt;&gt;
&lt;&lt;set _imgsrc = setup.ImagePath + &quot;CC/&quot; + $music.license + &quot;.png&quot;&gt;&gt;
&lt;&lt;switch $music.license&gt;&gt;
	&lt;&lt;case &quot;CC BY&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by/4.0/&quot;&gt;&gt;
	&lt;&lt;case &quot;CC BY-NC&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by-nc/4.0/&quot;&gt;&gt;
	&lt;&lt;case &quot;CC BY-NC-ND&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;&gt;
	&lt;&lt;case &quot;CC BY-NC-SA&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&gt;
	&lt;&lt;case &quot;CC BY-ND&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by-nd/4.0/&quot;&gt;&gt;
	&lt;&lt;case &quot;CC BY-SA&quot;&gt;&gt;
		&lt;&lt;set _imglink = &quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;&gt;
	&lt;&lt;default&gt;&gt;
		&lt;&lt;set _imglink = &quot;&quot;&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;a @href=_imglink target=&quot;_blank&quot;&gt;&lt;img @src=_imgsrc /&gt;&lt;/a&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;&lt;span id=&quot;mutebutton&quot;&gt;&lt;&lt;include &quot;mute button&quot;&gt;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="139" name="mute button" tags="nobr" position="1100,1725" size="100,100">&lt;&lt;if !$muted&gt;&gt;
	&lt;&lt;set _imgsrc = setup.ImagePath + &quot;ui/volume_on_outline.png&quot;&gt;&gt;
	&lt;img @src=_imgsrc /&gt; &lt;span style=&quot;position:relative; bottom:4px&quot;&gt;&lt;&lt;link &quot;[M]&quot;&gt;&gt;
		&lt;&lt;masteraudio mute&gt;&gt;
		&lt;&lt;set $muted = true&gt;&gt;
		&lt;&lt;replace &quot;#mutebutton&quot;&gt;&gt;&lt;&lt;include &quot;mute button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;		
	&lt;&lt;/link&gt;&gt;&lt;/span&gt;
&lt;&lt;elseif $muted === true&gt;&gt;
	&lt;&lt;set _imgsrc = setup.ImagePath + &quot;ui/volume_off_outline.png&quot;&gt;&gt;
	&lt;img @src=_imgsrc /&gt; &lt;span style=&quot;position:relative; bottom:4px&quot;&gt;&lt;&lt;link &quot;[M]&quot;&gt;&gt;
		&lt;&lt;masteraudio unmute&gt;&gt;
		&lt;&lt;set $muted = false&gt;&gt;
		&lt;&lt;replace &quot;#mutebutton&quot;&gt;&gt;&lt;&lt;include &quot;mute button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;		
	&lt;&lt;/link&gt;&gt;&lt;/span&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="140" name="neutralize phase" tags="nobr" position="1225,1725" size="100,100">/* Not currently implemented; too complex. Preserved for posterity. */

&lt;&lt;if $effects_to_remove &lt;= 0&gt;&gt;
&lt;&lt;set $ready to true&gt;&gt;
&lt;&lt;goto &quot;Confirm Phase&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;&lt;backbtn&gt;&gt;
&lt;&lt;switch $action.name&gt;&gt;
 &lt;&lt;case &quot;Restoration&quot;&gt;&gt;
  &lt;&lt;if $target[0].effects.length = 0&gt;&gt;
   &lt;&lt;print $target[0].name+&quot; has no effects! Go back.\n&quot;&gt;&gt;
  &lt;&lt;else&gt;&gt;
   &lt;&lt;set _count to 0&gt;&gt;
   &lt;&lt;print $target[0].name+&quot;\&#39;s ailments:\n&quot;&gt;&gt;
   &lt;&lt;for _i, _effect range $target[0].effects&gt;&gt;
    &lt;&lt;if _effect.buff is false&gt;&gt;
&lt;&lt;capture _i&gt;&gt;
[[_effect.name|neutralize phase][$removed_effects.push(_i); $effects_to_remove -= 1]]
&lt;&lt;/capture&gt;&gt;
    &lt;&lt;else&gt;&gt;
	 &lt;&lt;set _count++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
   &lt;&lt;/for&gt;&gt;
   &lt;&lt;if _count eq $target[0].effects.length&gt;&gt;
    &lt;&lt;print &quot;...None! Go back.&quot;&gt;&gt;
   &lt;&lt;/if&gt;&gt;
  &lt;&lt;/if&gt;&gt;
 &lt;&lt;case &quot;Neutralize&quot;&gt;&gt;
  &lt;&lt;if $target[0].effects.length = 0&gt;&gt;
   &lt;&lt;print $target[0].name+&quot; has no effects! Go back.\n&quot;&gt;&gt;
  &lt;&lt;else&gt;&gt;
   &lt;&lt;set _count to 0&gt;&gt;
   &lt;&lt;print $target[0].name+&quot;\&#39;s buffs:\n&quot;&gt;&gt;
   &lt;&lt;for _i, _effect range $target[0].effects&gt;&gt;
    &lt;&lt;if _effect.buff is true&gt;&gt;
&lt;&lt;capture _i&gt;&gt;
[[_effect.name|neutralize phase][$removed_effects.push(_i); $effects_to_remove -= 1]]
&lt;&lt;/capture&gt;&gt;
     &lt;&lt;if _i &lt; $target[0].effects.length&gt;&gt;
	  &lt;&lt;print &quot;, &quot;&gt;&gt;
	 &lt;&lt;/if&gt;&gt;
	&lt;&lt;else&gt;&gt;
	 &lt;&lt;set _count++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
   &lt;&lt;/for&gt;&gt;
   &lt;&lt;if _count eq $target[0].effects.length&gt;&gt;
    &lt;&lt;print &quot;...None! Go back.&quot;&gt;&gt;
   &lt;&lt;/if&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="141" name="Menu: Bestiary" tags="menu battle noreturn nobr" position="100,1850" size="100,100">&lt;span id=&quot;content&quot; class=&quot;menu&quot; style=&quot;padding:0&quot;&gt;
&lt;div id=&quot;bestiary&quot;&gt;
	&lt;&lt;include &quot;bestiary-list&quot;&gt;&gt;
&lt;/div&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="142" name="bestiary-list" tags="nobr" position="225,1850" size="100,100">&lt;div class=&quot;bestiary-header&quot;&gt;
BESTIARY&lt;br/&gt;
&lt;span class=&quot;smalltext&quot;&gt;Click an enemy name to see detailed information.&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;bestiary-grid&quot;&gt;
&lt;&lt;for _i, _enemy range $bestiary&gt;&gt;
	/* if even (no remainder from modulo 2), go on right side (column 3), else go on left side (column 1) */
	&lt;&lt;if (_i+1) % 2 === 0&gt;&gt;
		&lt;&lt;set _col = 3&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _col = 1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div class=&quot;bestiary-numbering&quot; @style=&quot;&#39;grid-column:&#39;+_col&quot;&gt;
		&lt;&lt;print _enemy.bestiaryNo&gt;&gt;.
	&lt;/div&gt;
	&lt;div class=&quot;bestiary-entry&quot; @style=&quot;&#39;grid-column:&#39;+(_col+1)&quot;&gt;
		&lt;&lt;if _enemy.encountered&gt;&gt;
			&lt;&lt;set _name = $bestiary.fetch(_enemy.name).access().fullname&gt;&gt;
			&lt;&lt;capture _enemy&gt;&gt;
			&lt;&lt;link &quot;_name&quot;&gt;&gt;
				&lt;&lt;set _display = clone(_enemy); _stScreen = 1&gt;&gt;
				&lt;&lt;replace &quot;#bestiary&quot; t8n&gt;&gt;&lt;&lt;include &quot;bestiary-display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
		&lt;&lt;else&gt;&gt;
			????
		&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/for&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="143" name="bestiary-display" tags="nobr" position="350,1850" size="100,100">&lt;div class=&quot;bestiary-display&quot;&gt;
	&lt;div id=&quot;toggle&quot; class=&quot;bestiary-name&quot;&gt;
		&lt;&lt;set _name = _display.access().fullname&gt;&gt;
		&lt;&lt;link _name&gt;&gt;
			&lt;&lt;unset _display&gt;&gt;
			&lt;&lt;replace &quot;#bestiary&quot; t8n&gt;&gt;&lt;&lt;include &quot;bestiary-list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;div class=&quot;bestiary-display-numbering&quot;&gt;
			#&lt;&lt;print _display.bestiaryNo&gt;&gt;&lt;br/&gt;
			&lt;span id=&quot;lastentry&quot;&gt;
			&lt;&lt;link &quot;⬅&quot;&gt;&gt;
				&lt;&lt;set _display = clone($bestiary.lastEntry(_display.bestiaryNo-1))&gt;&gt;
				&lt;&lt;replace &quot;#bestiary&quot; t8n&gt;&gt;&lt;&lt;include &quot;bestiary-display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;/span&gt;
			&amp;nbsp;
			&lt;span id=&quot;nextentry&quot;&gt;
			&lt;&lt;link &quot;⮕&quot;&gt;&gt;
				&lt;&lt;set _display = clone($bestiary.nextEntry(_display.bestiaryNo-1))&gt;&gt;
				&lt;&lt;replace &quot;#bestiary&quot; t8n&gt;&gt;&lt;&lt;include &quot;bestiary-display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;/span&gt;
		&lt;/div&gt;
	&lt;/div&gt;
	&lt;div class=&quot;bestiary-detail&quot;&gt;
		&lt;div class=&quot;monospace bestiary-form-container&quot;&gt;
		&lt;&lt;if _display.altsKnown&gt;&gt;
			&lt;span class=&quot;bestiary-form-entry&quot;&gt;
				&lt;&lt;set _formName = (setup.enemyData[_display.name].bestiaryName || _display.name)&gt;&gt;
				&lt;&lt;if _display.altSkin === null&gt;&gt;
					&lt;b&gt;&lt;&lt;print _formName&gt;&gt;&lt;/b&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;link &quot;_formName&quot;&gt;&gt;
						&lt;&lt;set _display.altSkin = null&gt;&gt;
						&lt;&lt;replace &quot;#bestiary&quot;&gt;&gt;&lt;&lt;include &quot;bestiary-display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/link&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;/span&gt;
			&lt;&lt;for _pn, _v range _display.altsKnown&gt;&gt;
				&lt;&lt;if _v === true&gt;&gt;
					&lt;span class=&quot;bestiary-form-entry&quot;&gt;
						&lt;&lt;set _formName = (setup.enemyData[_pn].bestiaryName || _pn)&gt;&gt;
						&lt;&lt;if _display.altSkin == _pn&gt;&gt;
							&lt;b&gt;&lt;&lt;print _formName&gt;&gt;&lt;/b&gt;
						&lt;&lt;else&gt;&gt;
							&lt;&lt;capture _pn&gt;&gt;
							&lt;&lt;link &quot;_formName&quot;&gt;&gt;
								&lt;&lt;set _display.altSkin = _pn&gt;&gt;
								&lt;&lt;replace &quot;#bestiary&quot;&gt;&gt;&lt;&lt;include &quot;bestiary-display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
							&lt;&lt;/link&gt;&gt;
							&lt;&lt;/capture&gt;&gt;
						&lt;&lt;/if&gt;&gt;
					&lt;/span&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&amp;nbsp;
		&lt;&lt;/if&gt;&gt;
		&lt;/div&gt;
		&lt;div class=&quot;bestiary-detail-container&quot;&gt;
			&lt;div id=&quot;bestiary-infoblock&quot; class=&quot;monospace&quot;&gt;
				&lt;&lt;include &quot;bestiary infoblock&quot;&gt;&gt;
			&lt;/div&gt;

			&lt;div class=&quot;bestiary-desc&quot;&gt;
				&lt;&lt;print _display.desc&gt;&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&quot;abilities-header&quot;&gt;ABILITIES&lt;/div&gt;
		&lt;div&gt;
			&lt;&lt;print _display.abilityInfo&gt;&gt;
		&lt;/div&gt;

		&lt;div class=&quot;bestiary-defeated-count&quot;&gt;
			Defeated: &lt;&lt;print _display.defeated&gt;&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="144" name="bestiary infoblock" tags="nobr" position="475,1850" size="100,100">&lt;div style=&quot;position:relative&quot;&gt;
	&lt;&lt;switch setup.STATUS_SCREENS.bestiary[_stScreen-1]&gt;&gt;
		&lt;&lt;case &quot;elements&quot;&gt;&gt;
			&lt;&lt;set _title = &quot;elemental affinities&quot;&gt;&gt;
		&lt;&lt;case &quot;ailments&quot;&gt;&gt;
			&lt;&lt;set _title = &quot;ailment tolerances&quot;&gt;&gt;
		&lt;&lt;default&gt;&gt;
			&lt;&lt;set _title = setup.STATUS_SCREENS.bestiary[_stScreen-1]&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
	&lt;div class=&quot;menuactor-special-title&quot;&gt;_title&lt;/div&gt;
	&lt;&lt;if setup.STATUS_SCREENS.bestiary.length &gt; 1&gt;&gt;
	&lt;div class=&quot;cyclebuttons&quot; style=&quot;right:0&quot;&gt;
		&lt;&lt;link &quot;&lt;&quot;&gt;&gt;
			&lt;&lt;set _stScreen--&gt;&gt;
			&lt;&lt;if _stScreen &lt; 1&gt;&gt;
				&lt;&lt;set _stScreen = setup.STATUS_SCREENS.bestiary.length&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;replace &quot;#bestiary-infoblock&quot;&gt;&gt;&lt;&lt;include &quot;bestiary infoblock&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;link &quot;&gt;&quot;&gt;&gt;
			&lt;&lt;set _stScreen++&gt;&gt;
			&lt;&lt;if _stScreen &gt; setup.STATUS_SCREENS.bestiary.length&gt;&gt;
				&lt;&lt;set _stScreen = 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;replace &quot;#bestiary-infoblock&quot;&gt;&gt;&lt;&lt;include &quot;bestiary infoblock&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;switch setup.STATUS_SCREENS.bestiary[_stScreen-1]&gt;&gt;
&lt;&lt;case &quot;stats&quot;&gt;&gt;
	&lt;div style=&quot;display:grid; grid-auto-rows:auto; grid-template-columns: 75% 25%; width:75%&quot;&gt;
		&lt;div&gt;HP:&lt;/div&gt;
		&lt;div style=&quot;text-align:right&quot;&gt;
			&lt;&lt;print _display.get(&quot;hp&quot;)&gt;&gt;
		&lt;/div&gt;
		&lt;&lt;for _k, _v range setup.statInfo&gt;&gt;
			&lt;&lt;if !setup.hiddenStats.includes(_k)&gt;&gt;
				&lt;div style=&quot;text-transform:uppercase&quot;&gt;&lt;&lt;print _k&gt;&gt;:&lt;/div&gt;
				&lt;div style=&quot;text-align:right&quot;&gt;
					&lt;&lt;print _display.get(_k)&gt;&gt;
				&lt;/div&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;case &quot;rewards&quot;&gt;&gt;
	&lt;div style=&quot;display:grid; grid-template-columns: 50% 50%;&quot;&gt;
		&lt;div&gt;
			XP: &lt;&lt;print _display.get(&quot;XP&quot;)&gt;&gt;
		&lt;/div&gt;
		&lt;div&gt;
			GP: &lt;&lt;print _display.get(&quot;GP&quot;)&gt;&gt;
		&lt;/div&gt;
	&lt;/div&gt;&lt;br/&gt;
	&lt;center&gt;ITEM DROPS&lt;/center&gt;
	&lt;&lt;set _itemTable = _display.itemDrops&gt;&gt;
	&lt;&lt;if _itemTable.length &gt; 0&gt;&gt;
		&lt;&lt;for _item, _chance range _itemTable&gt;&gt;
			&lt;&lt;print _item&gt;&gt;&lt;span style=&quot;float:right; font-weight:normal; margin-left:1em&quot;&gt;&lt;&lt;print _chance&gt;&gt;%&lt;br/&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;span style=&quot;color:gray; font-style:italic; font-weight:normal; font-family:Helmet,sans-serif;&quot;&gt;No items.&lt;/span&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;case &quot;elements&quot;&gt;&gt;
	&lt;&lt;for _k, _v range _display.access().elements&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;&lt;/span&gt;
		&lt;span class=&quot;elementdisplay&quot;&gt;
			&lt;&lt;if _display.statsKnown[_k] === true&gt;&gt;
				&lt;&lt;if setup.SOAK&gt;&gt;&lt;&lt;soak _v&gt;&gt; /&lt;&lt;/if&gt;&gt;&lt;div style=&quot;display: inline-block; min-width:45px; text-align:right&quot;&gt;&lt;&lt;res _v&gt;&gt;&lt;/div&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;if setup.SOAK&gt;&gt;?? /&lt;&lt;/if&gt;&gt;&lt;div style=&quot;display: inline-block; min-width:45px; text-align:right&quot;&gt;???%&lt;/div&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;/span&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;case &quot;ailments&quot;&gt;&gt;
	&lt;div style=&quot;width:75%; font-weight:bold&quot;&gt;
	&lt;&lt;for _k, _v range _display.access().tolerances&gt;&gt;
		&lt;&lt;if _v.current != 0&gt;&gt;
			&lt;&lt;if _display.tolerancesKnown[_k] === true&gt;&gt;
				&lt;&lt;print _k&gt;&gt;
				&lt;&lt;tol _v&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;div class=&quot;tolerance&quot; style=&quot;text-align:left&quot;&gt;????&lt;/div&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/switch&gt;&gt;</tw-passagedata><tw-passagedata pid="145" name="Widget: unequipAll" tags="widget nobr" position="600,1850" size="100,100">&lt;&lt;widget &quot;unequipAll&quot;&gt;&gt;
&lt;&lt;link &quot;Unequip All&quot;&gt;&gt;
	&lt;&lt;for _puppet range puppets().concat($Reserve_Puppets).filter(function(p){ return !p.lockEquipment; })&gt;&gt;
		&lt;&lt;run _puppet.unequipAll()&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;goto `passage()`&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="146" name="Menu: Equipment" tags="menu battle noreturn" position="725,1850" size="100,100">&lt;span id=&quot;content&quot; class=&quot;menu&quot;&gt;&lt;&lt;nobr&gt;&gt;
&lt;div id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;
&lt;/div&gt;
&lt;div id=&quot;equipment-list&quot;&gt;
&lt;&lt;include &quot;equipment list&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="147" name="equip manager puppets" tags="nobr" position="850,1850" size="100,100">&lt;&lt;if def $subject&gt;&gt;
	&lt;&lt;set _i = &quot;null&quot;&gt;&gt;
	&lt;&lt;actorDisplay $subject &quot;equipment&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;&lt;for _i, _p range $puppets&gt;&gt;
	&lt;&lt;actorDisplay _p &quot;equipment&quot;&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="148" name="equipment list" tags="nobr" position="975,1850" size="100,100">&lt;&lt;if def $subject &amp;&amp; !$subject.lockEquipment&gt;&gt;
	&lt;br/&gt;
	&lt;div style=&quot;line-height:1.4&quot;&gt;
	&lt;&lt;set _count = 0&gt;&gt;
	&lt;&lt;for _k, _v range inv()&gt;&gt;
		&lt;&lt;if _v.equippable &amp;&amp; _v.stock &gt; 0&gt;&gt;
			&lt;&lt;set _count++&gt;&gt;
			&lt;&lt;if (def $subject &amp;&amp; $subject.checkRestriction(_v)) || ndef $subject&gt;&gt;
				&lt;&lt;set _id = _k.split(&#39; &#39;).join(&#39;_&#39;)&gt;&gt;
				&lt;div @id=&quot;_id&quot;&gt;
				&lt;&lt;print _v&gt;&gt;
				&lt;&lt;capture _v, _id&gt;&gt;
				&lt;&lt;timed 0s&gt;&gt;
				&lt;&lt;if def $subject&gt;&gt;
					&lt;&lt;set _selector = &quot;#&quot;+_id+&quot; .item-name&quot;&gt;&gt;
					&lt;&lt;replace _selector&gt;&gt;
						&lt;&lt;link _v.name&gt;&gt;
							&lt;&lt;run $subject.equip(_v)&gt;&gt;
							&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
							&lt;&lt;replace &quot;#equipment-list&quot;&gt;&gt;&lt;&lt;include &quot;equipment list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
						&lt;&lt;/link&gt;&gt;
					&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;&lt;/timed&gt;&gt;
				&lt;&lt;/capture&gt;&gt;
				&lt;/div&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;if _count == 0&gt;&gt;
	You don&#39;t have any equipment.
	&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
&lt;&lt;elseif def $subject &amp;&amp; $subject.lockEquipment&gt;&gt;
	&lt;br/&gt;
	&lt;i&gt;This character&#39;s equipment can&#39;t be changed.&lt;/i&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;unequipAll&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="149" name="Menu: Formation" tags="menu battle noreturn" position="1100,1850" size="100,100">&lt;div id=&quot;content&quot; class=&quot;menu&quot;&gt;&lt;&lt;nobr&gt;&gt;
&lt;&lt;set $grid = []&gt;&gt;
&lt;&lt;for _r = 0; _r &lt; setup.COLUMN_SIZE; _r++&gt;&gt;
    &lt;&lt;set _row to []&gt;&gt;
    &lt;&lt;for _c to 0; _c &lt; setup.ROW_SIZE; _c++&gt;&gt;
        /* Create the object used to store the default properties of a map cell. */
        &lt;&lt;set _cell to {
            id: (&quot;cell_r&quot; + _r + &quot;_c&quot; + _c),
            contents: null,
            movement: []
        }&gt;&gt;
        &lt;&lt;run _row.push(_cell)&gt;&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;run $grid.push(_row)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _puppet range puppets()&gt;&gt;
	&lt;&lt;set $grid[_puppet.row-1][_puppet.col-1].contents = _puppet&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;liveblock&gt;&gt;
&lt;div id=&quot;puppets&quot; class=&quot;actors grid&quot;&gt;
&lt;&lt;include &quot;formation puppets&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/liveblock&gt;&gt;
&lt;&lt;/nobr&gt;&gt;

Click on a character to select them, then click on another space to move or swap.
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="150" name="ActorBox formation" tags="nobr" position="1225,1850" size="100,100">&lt;div&gt;
	&lt;&lt;if ndef _subj&gt;&gt;
		&lt;&lt;capture _actor&gt;&gt;
		&lt;&lt;link &quot;_actor.name&quot;&gt;&gt;
			&lt;&lt;set _subj = _actor&gt;&gt;
			&lt;&lt;update&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;&lt;elseif _subj !== _actor&gt;&gt;
		&lt;&lt;capture _actor&gt;&gt;
		&lt;&lt;link &quot;_actor.name&quot;&gt;&gt;
			&lt;&lt;set _subj.position = [_actor.row,_actor.col]&gt;&gt;
			&lt;&lt;unset _subj&gt;&gt;
			&lt;&lt;update&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;span class=&quot;actorname&quot; style=&quot;font-weight:bold&quot;&gt;_actor.name&lt;/span&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="151" name="formation puppets" tags="nobr" position="100,1975" size="100,100">&lt;&lt;for _r, _row range $grid&gt;&gt;
	&lt;&lt;for _c, _cell range _row&gt;&gt;
		&lt;&lt;if _cell.contents instanceof Actor&gt;&gt;
			&lt;&lt;actorBox _cell.contents &quot;flex-center&quot; &quot;formation&quot;&gt;&gt;
		&lt;&lt;elseif def _subj&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				&lt;&lt;capture _r, _c, _cell&gt;&gt;
				&lt;&lt;link &quot;[MOVE]&quot;&gt;&gt;
					&lt;&lt;set _subj.position = [_r+1,_c+1]&gt;&gt;
					&lt;&lt;unset _subj&gt;&gt;
					&lt;&lt;update&gt;&gt;
				&lt;&lt;/link&gt;&gt;
				&lt;&lt;/capture&gt;&gt;
			&lt;/div&gt;
		&lt;&lt;else&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				/* no content; empty box */
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;


/*
&lt;div class=&quot;leaderlabel formation-label&quot;&gt;Front Row&lt;/div&gt;
&lt;div class=&quot;frontrowlabel formation-label&quot;&gt;Middle Row&lt;/div&gt;
&lt;div class=&quot;backrowlabel formation-label&quot;&gt;Back Row&lt;/div&gt;
	&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
		&lt;&lt;set _puppet_class = &quot;actor grid&quot;&gt;&gt;
		&lt;div @class=&quot;_puppet_class&quot; @id=&quot;&#39;p&#39;+_i&quot;&gt;
			&lt;&lt;if _puppet !== null&gt;&gt;
				&lt;div style=&quot;display: flex;  justify-content: center;  align-items: center; height: -webkit-fill-available&quot;&gt;
				&lt;span @id=&quot;&#39;pname&#39;+_i&quot;&gt;
				&lt;&lt;if ndef _s&gt;&gt;
					&lt;&lt;capture _i, _puppet&gt;&gt;
					&lt;&lt;link &quot;_puppet.name&quot;&gt;&gt;
						&lt;&lt;set _s = _i&gt;&gt;
						&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;formation puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/link&gt;&gt;
					&lt;&lt;/capture&gt;&gt;
				&lt;&lt;elseif $puppets[_s] !== _puppet&gt;&gt;
					&lt;&lt;capture _i, _puppet&gt;&gt;
					&lt;&lt;link &quot;_puppet.name&quot;&gt;&gt;
						&lt;&lt;set _holder = _puppet&gt;&gt;
						&lt;&lt;set $puppets[_i] = $puppets[_s]; $puppets[_s] = _holder&gt;&gt;
						&lt;&lt;unset _s&gt;&gt;
						&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;formation puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/link&gt;&gt;
					&lt;&lt;/capture&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;span class=&quot;actorname&quot; style=&quot;font-weight:bold&quot;&gt;_puppet.name&lt;/span&gt;
				&lt;&lt;/if&gt;&gt;
				&lt;/span&gt;
				&lt;/div&gt;
			&lt;&lt;elseif _puppet == null&gt;&gt;
				&lt;&lt;if def _s&gt;&gt;
				&lt;div style=&quot;display: flex;  justify-content: center;  align-items: center; height: -webkit-fill-available&quot;&gt;
				&lt;&lt;link &quot;[MOVE]&quot;&gt;&gt;
					&lt;&lt;set _holder = _puppet&gt;&gt;
					&lt;&lt;set $puppets[_i] = $puppets[_s]; $puppets[_s] = _holder&gt;&gt;
					&lt;&lt;unset _s&gt;&gt;
					&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;formation puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
				&lt;/div&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;/div&gt;
	&lt;&lt;/for&gt;&gt;
*/
&lt;&lt;timed 0s&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#puppets.actors.grid&quot;).css({
	  &quot;grid-template-columns&quot;: `repeat(${setup.ROW_SIZE},1fr)`
	});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/timed&gt;&gt;</tw-passagedata><tw-passagedata pid="152" name="Menu: Inventory" tags="menu battle noreturn" position="225,1975" size="100,100">&lt;span id=&quot;content&quot; class=&quot;menu&quot;&gt;&lt;&lt;nobr&gt;&gt;
&lt;&lt;set _filter = &quot;all&quot;&gt;&gt;
&lt;div id=&quot;menu-display&quot; class=&quot;relative&quot;&gt;
&lt;&lt;liveblock&gt;&gt;
&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;
&lt;&lt;/liveblock&gt;&gt;
&lt;/div&gt;
&lt;div id=&quot;itemlist&quot;&gt;
&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="153" name="inventory item list" tags="nobr" position="350,1975" size="100,100">&lt;div style=&quot;display:flex; justify-content:space-evenly;&quot;&gt;
&lt;&lt;if _filter == &quot;all&quot;&gt;&gt;
	&lt;b&gt;All&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;All&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;all&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _filter == &quot;usable&quot;&gt;&gt;
	&lt;b&gt;Usable&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Usable&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;usable&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _filter == &quot;equipment&quot;&gt;&gt;
	&lt;b&gt;Equipment&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Equipment&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;equipment&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;div class=&quot;itemcontainer&quot;&gt;
&lt;&lt;set _p = 2&gt;&gt;
&lt;&lt;for _name, _item range inv()&gt;&gt;
	&lt;&lt;if _filter == &quot;all&quot; || (_filter == &quot;usable&quot; &amp;&amp; _item.usable.includes(&quot;inmenu&quot;)) || (_filter == &quot;equipment&quot; &amp;&amp; _item.equippable)&gt;&gt;
	&lt;&lt;if _p == 1&gt;&gt;
		&lt;&lt;set _p = 2&gt;&gt;
	&lt;&lt;elseif _p == 2&gt;&gt;
		&lt;&lt;set _p = 1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div @class=&quot;&#39;item&#39;+_p&quot;&gt;
	&lt;b&gt;
	&lt;&lt;capture _item&gt;&gt;
	&lt;&lt;link _item.name&gt;&gt;
		&lt;&lt;set _display = _item&gt;&gt;
		&lt;&lt;update&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;/b&gt; &lt;span class=&quot;itemstock&quot;&gt;(_item.stock)&lt;/span&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="154" name="inventory item display" tags="nobr" position="475,1975" size="100,100">&lt;&lt;if ndef _display || _display === null&gt;&gt;
	&lt;div class=&quot;centered&quot; style=&quot;color: gray&quot;&gt;Click on an item to see info&lt;/div&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print _display&gt;&gt;
	&lt;&lt;if _display.usable.includes(&#39;inmenu&#39;) || _display.equippable&gt;&gt;
	&lt;div class=&quot;item-buttons&quot;&gt;
		&lt;&lt;set _b = 0&gt;&gt;
		&lt;&lt;if _display.usable.includes(&#39;inmenu&#39;) &amp;&amp; _display.stock &gt; 0&gt;&gt;
			&lt;&lt;set _b++&gt;&gt;
			&lt;span @id=&quot;&#39;button&#39;+_b&quot;&gt;
				&lt;span id=&quot;usebutton&quot;&gt;
				&lt;&lt;include &quot;inventory use button&quot;&gt;&gt;
				&lt;/span&gt;
			&lt;/span&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if _display.equippable &amp;&amp; _display.stock &gt; 0&gt;&gt;
			&lt;&lt;set _b++&gt;&gt;
			&lt;span @id=&quot;&#39;button&#39;+_b&quot;&gt;
				&lt;span id=&quot;equipbutton&quot;&gt;
				&lt;&lt;include &quot;equip button&quot;&gt;&gt;
				&lt;/span&gt;
			&lt;/span&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if def _event&gt;&gt;
			&lt;span id=&quot;button1&quot;&gt;
				&lt;span id=&quot;cancelbutton&quot;&gt;
				&lt;&lt;include &quot;cancel button&quot;&gt;&gt;
				&lt;/span&gt;
			&lt;/span&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="155" name="equip button" tags="nobr" position="600,1975" size="100,100">&lt;&lt;button &quot;EQUIP&quot;&gt;&gt;
	&lt;&lt;set _event = &quot;equip&quot;&gt;&gt;
	&lt;&lt;update&gt;&gt;
	&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/button&gt;&gt;
&lt;&lt;if _b == 1&gt;&gt;
&lt;span class=&quot;monospace&quot; style=&quot;font-size:85%&quot;&gt;[Q]&lt;/span&gt;
&lt;&lt;elseif _b == 2&gt;&gt;
&lt;span class=&quot;monospace&quot; style=&quot;font-size:85%&quot;&gt;[W]&lt;/span&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="156" name="inventory use button" tags="nobr" position="725,1975" size="100,100">&lt;&lt;button &quot;USE&quot;&gt;&gt;
	&lt;&lt;if _display.instantUse === true&gt;&gt;
		&lt;&lt;run _display.onUse()&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _event = &quot;use&quot;&gt;&gt;
		&lt;&lt;update&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/button&gt;&gt;
&lt;span class=&quot;monospace&quot; style=&quot;font-size:85%&quot;&gt;[Q]&lt;/span&gt;</tw-passagedata><tw-passagedata pid="157" name="inventory cancel button" tags="nobr" position="850,1975" size="100,100">&lt;&lt;button &quot;CANCEL&quot;&gt;&gt;
	&lt;&lt;unset _event&gt;&gt;
	&lt;&lt;update&gt;&gt;
	&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/button&gt;&gt;
&lt;span class=&quot;monospace&quot; style=&quot;font-size:85%&quot;&gt;[R]&lt;/span&gt;</tw-passagedata><tw-passagedata pid="158" name="inventory puppets" tags="nobr" position="975,1975" size="100,100">&lt;&lt;set _HPmeters = []&gt;&gt;
&lt;&lt;set _MPmeters = []&gt;&gt;
&lt;&lt;for _i, _p range puppets().filter(function(p) { return temporary().event != &quot;equip&quot; || (!p.lockEquipment &amp;&amp; p.checkRestriction(temporary().display)); })&gt;&gt;
	&lt;&lt;actorDisplay _p &quot;inventory&quot;&gt;&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="159" name="Menu: Party" tags="menu battle noreturn" position="1100,1975" size="100,100">&lt;span id=&quot;content&quot; class=&quot;menu&quot;&gt;&lt;center style=&quot;font-weight:bold&quot;&gt;ACTIVE PUPPETS&lt;/center&gt;
&lt;&lt;nobr&gt;&gt;
&lt;div class=&quot;actors&quot; id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;party manager puppets&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;center style=&quot;font-weight:bold&quot;&gt;RESERVE PUPPETS&lt;/center&gt;
&lt;&lt;nobr&gt;&gt;
&lt;div class=&quot;actors&quot; id=&quot;reserve&quot;&gt;
&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;

&lt;&lt;unequipAll&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="160" name="party manager puppets" tags="nobr" position="1225,1975" size="100,100">&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
	&lt;&lt;if _puppet !== null&gt;&gt;
	&lt;div class=&quot;actor&quot; @id=&quot;_i&quot; style=&quot;min-width:150px&quot;&gt;
	&lt;center&gt;
	&lt;&lt;capture _i&gt;&gt;
	&lt;&lt;link _puppet.name&gt;&gt;
		&lt;&lt;if def _s&gt;&gt;
			&lt;&lt;run $(&#39;#&#39; + _s).removeClass(&quot;selected&quot;)&gt;&gt;
			&lt;&lt;if _s != _i&gt;&gt;
				&lt;&lt;set _s = _i&gt;&gt;
				&lt;&lt;run $(&#39;#&#39; + _s).addClass(&quot;selected&quot;)&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;unset _s&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set _s = _i&gt;&gt;
			&lt;&lt;run $(&#39;#&#39; + _i).addClass(&quot;selected&quot;)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;run console.log(&quot;i = &quot;+_i); console.log(&quot;s = &quot;+_s)&gt;&gt;
		&lt;&lt;replace &quot;#reserve&quot;&gt;&gt;&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;/center&gt;&lt;br/&gt;
	&lt;&lt;for _k, _v range _puppet.stats&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;:&lt;/span&gt;
		&lt;&lt;statOOB _k _puppet&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="161" name="party manager reserve" tags="nobr" position="100,2100" size="100,100">&lt;&lt;for _j, _puppet range $Reserve_Puppets&gt;&gt;
	&lt;div class=&quot;actor&quot; style=&quot;min-width:150px&quot;&gt;
	&lt;center&gt;
	&lt;&lt;if def _s&gt;&gt;
		&lt;&lt;capture _puppet, _j&gt;&gt;
		&lt;&lt;link _puppet.name&gt;&gt;
			&lt;&lt;run $Reserve_Puppets[_j] = $puppets[_s]&gt;&gt;
			&lt;&lt;set $puppets[_s] = _puppet&gt;&gt;
			&lt;&lt;unset _s&gt;&gt;
			&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;party manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;replace &quot;#reserve&quot;&gt;&gt;&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;&lt;else&gt;&gt;
		_puppet.name
	&lt;&lt;/if&gt;&gt;
	&lt;/center&gt;&lt;br/&gt;
	&lt;&lt;for _k, _v range _puppet.stats&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;:&lt;/span&gt;
		&lt;&lt;statOOB _k _puppet&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/for&gt;&gt;</tw-passagedata><tw-passagedata pid="162" name="Menu: Status" tags="menu battle noreturn" position="225,2100" size="100,100">&lt;span id=&quot;content&quot; class=&quot;menu&quot;&gt;&lt;&lt;nobr&gt;&gt;
&lt;div id=&quot;partydisplay&quot;&gt;
&lt;&lt;include &quot;status party display&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="163" name="menu stat display" tags="nobr" position="350,2100" size="100,100">&lt;&lt;if !setup.hiddenStats.includes(_k)&gt;&gt;
	&lt;&lt;if def setup.statInfo[_k]&gt;&gt;
		&lt;&lt;set _class = &quot;tooltip&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _class = &quot;&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div class=&quot;menuactor-statname&quot;&gt;&lt;span @class=_class&gt;_k&lt;&lt;if def setup.statInfo[_k]&gt;&gt;&lt;span class=&quot;tooltiptext&quot;&gt;&lt;&lt;print setup.statInfo[_k]&gt;&gt;&lt;/span&gt;&lt;&lt;/if&gt;&gt;&lt;/span&gt;&lt;/div&gt;
	&lt;div class=&quot;menuactor-statvalue&quot;&gt;_v.base&lt;/div&gt;
	&lt;&lt;if _v.bonus != 0&gt;&gt;
		&lt;div class=&quot;menuactor-statmod&quot;&gt;
		&lt;&lt;if _v.bonus &gt; 0&gt;&gt;
			@@.green;&lt;&lt;print &quot;\+&quot;+_v.bonus&gt;&gt;@@
		&lt;&lt;elseif _v.bonus &lt; 0&gt;&gt;
			@@.stat-lowered;&lt;&lt;print &quot;-&quot;+_v.bonus&gt;&gt;@@
		&lt;&lt;/if&gt;&gt;
		&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="164" name="status special detail" tags="nobr" position="475,2100" size="100,100">&lt;div style=&quot;position:relative&quot;&gt;
	&lt;&lt;switch setup.STATUS_SCREENS.menu[_stScreen-1]&gt;&gt;
		&lt;&lt;case &quot;elements&quot;&gt;&gt;
			&lt;&lt;set _title = &quot;elemental affinities&quot;&gt;&gt;
		&lt;&lt;case &quot;ailments&quot;&gt;&gt;
			&lt;&lt;set _title = &quot;ailment tolerances&quot;&gt;&gt;
		&lt;&lt;default&gt;&gt;
			&lt;&lt;set _title = setup.STATUS_SCREENS.menu[_stScreen-1]&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
	&lt;div class=&quot;menuactor-special-title&quot;&gt;_title&lt;/div&gt;
	&lt;&lt;if setup.STATUS_SCREENS.menu.length &gt; 1&gt;&gt;
	&lt;div class=&quot;cyclebuttons&quot;&gt;
		&lt;span id=&quot;statusback&quot;&gt;
		&lt;&lt;link &quot;&lt;&quot;&gt;&gt;
			&lt;&lt;set _stScreen--&gt;&gt;
			&lt;&lt;if _stScreen &lt; 1&gt;&gt;
				&lt;&lt;set _stScreen = setup.STATUS_SCREENS.menu.length&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;replace &quot;#menuactor-special&quot;&gt;&gt;&lt;&lt;include &quot;status special detail&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;/span&gt;
		&lt;span id=&quot;statusforward&quot;&gt;
		&lt;&lt;link &quot;&gt;&quot;&gt;&gt;
			&lt;&lt;set _stScreen++&gt;&gt;
			&lt;&lt;if _stScreen &gt; setup.STATUS_SCREENS.menu.length&gt;&gt;
				&lt;&lt;set _stScreen = 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;replace &quot;#menuactor-special&quot;&gt;&gt;&lt;&lt;include &quot;status special detail&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;/span&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;switch setup.STATUS_SCREENS.menu[_stScreen-1]&gt;&gt;
&lt;&lt;case &quot;equipment&quot;&gt;&gt;
	&lt;div style=&quot;margin-left:1em;&quot;&gt;
	&lt;&lt;for _name, _slot range $subject.equipment&gt;&gt;
		&lt;&lt;for _index, _item range _slot&gt;&gt;
			&lt;div class=&quot;menuactor-equipment-slot&quot;&gt;_name&lt;/div&gt;
			&lt;&lt;if _item === null&gt;&gt;&lt;span class=&quot;menuactor-equipment-name&quot;&gt;&amp;nbsp;&lt;/span&gt;
			&lt;&lt;else&gt;&gt;
				&lt;div class=&quot;menuactor-equipment-name&quot;&gt;_item.name&lt;/div&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;case &quot;elements&quot;&gt;&gt;
	&lt;div style=&quot;margin-left:1em; width:75%; font-weight:bold&quot;&gt;
	&lt;&lt;for _k, _v range $subject.elements&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;&lt;/span&gt;
		&lt;span class=&quot;elementdisplay monospace&quot;&gt;&lt;&lt;if setup.SOAK&gt;&gt;&lt;&lt;soak _v&gt;&gt; /&lt;&lt;/if&gt;&gt;&lt;div style=&quot;display: inline-block; min-width:45px; text-align:right&quot;&gt;&lt;&lt;res _v&gt;&gt;&lt;/div&gt;&lt;/span&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;case &quot;ailments&quot;&gt;&gt;
	&lt;div style=&quot;margin-left:1em; width:75%; font-weight:bold&quot;&gt;
	&lt;&lt;for _k, _v range $subject.tolerances&gt;&gt;
		&lt;&lt;if _v.current != 0&gt;&gt;
			&lt;&lt;print _k&gt;&gt;
			&lt;&lt;tol _v&gt;&gt;
			&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/switch&gt;&gt;</tw-passagedata><tw-passagedata pid="165" name="status party display" tags="nobr" position="600,2100" size="100,100">&lt;&lt;if def $subject&gt;&gt;
	&lt;&lt;actorDisplay $subject&gt;&gt;
	&lt;div class=&quot;menuactor-detail&quot;&gt;
		&lt;&lt;if def setup.STATUS_SCREENS.menu &amp;&amp; setup.STATUS_SCREENS.menu.length &gt; 0&gt;&gt;
			&lt;&lt;set _style = &quot;&quot;&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set _style = &quot;border-right: none&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;div class=&quot;menuactor-stats monospace&quot; @style=_style&gt;
		&lt;&lt;for _k, _v range $subject.stats&gt;&gt;
			&lt;&lt;include &quot;menu stat display&quot;&gt;&gt;
		&lt;&lt;/for&gt;&gt;
		&lt;&lt;if def $subject.HPregen &amp;&amp; $subject.HPregen !== null&gt;&gt;
			&lt;div class=&quot;menuactor-statname&quot;&gt;HP regen&lt;/div&gt;
			&lt;div class=&quot;menuactor-statvalue&quot;&gt;&lt;&lt;print $subject.HPregenFlat&gt;&gt; / &lt;&lt;print $subject.HPregenPercent*100&gt;&gt;%&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;/div&gt;
		&lt;&lt;if def setup.STATUS_SCREENS.menu &amp;&amp; setup.STATUS_SCREENS.menu.length &gt; 0&gt;&gt;
		&lt;div id=&quot;menuactor-special&quot;&gt;
			&lt;&lt;include &quot;status special detail&quot;&gt;&gt;
		&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
	&lt;br/&gt;
	&lt;div id=&quot;menuActionList&quot;&gt;
	&lt;&lt;actionListMenu $subject&gt;&gt;
	&lt;/div&gt;
&lt;&lt;elseif ndef $subject&gt;&gt;
	&lt;&lt;set _HPmeters = []&gt;&gt;
	&lt;&lt;set _MPmeters = []&gt;&gt;
	&lt;&lt;for _i, _p range puppets()&gt;&gt;
		&lt;&lt;actorDisplay _p&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="166" name="Widget: actionListMenu" tags="widget nobr" position="725,2100" size="100,100">&lt;&lt;widget &quot;actionListMenu&quot;&gt;&gt;
/* Widget for display of player actions in the menu. */

&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; ($args[0] instanceof Puppet),&quot;ERROR in actionListMenu: no Puppet&quot;)&gt;&gt;
&lt;&lt;set _char = $args[0]; _actions = _char.actions&gt;&gt;
&lt;&lt;if _char.crisis instanceof Array&gt;&gt;
	&lt;div class=&quot;abilities-header&quot;&gt;CRISIS&lt;/div&gt;
	&lt;&lt;for _action range _char.crisis&gt;&gt;
		&lt;&lt;print _action&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;div class=&quot;abilities-header&quot;&gt;ABILITIES&lt;/div&gt;
&lt;&lt;set _filter = &quot;all&quot;&gt;&gt;
&lt;&lt;liveblock&gt;&gt;
&lt;div style=&quot;display:flex; justify-content:space-evenly;&quot;&gt;
&lt;&lt;if _filter == &quot;all&quot;&gt;&gt;
	&lt;b&gt;All&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;All&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;all&quot;; _actions = _char.actions&gt;&gt;
		&lt;&lt;update&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _filter == &quot;usable&quot;&gt;&gt;
	&lt;b&gt;Usable&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Usable&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;usable&quot;; _actions = _char.actions.filter(function (act) { return act &amp;&amp; act.onUse })&gt;&gt;
		&lt;&lt;update&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;&lt;for _action range _actions&gt;&gt;
&lt;&lt;if !_action.invisible&gt;&gt;
	&lt;&lt;set _actionID = &quot;action&quot;+_actions.indexOf(_action)&gt;&gt;
	&lt;div @id=&quot;_actionID&quot; class=&quot;actionDisplay&quot;&gt;
		&lt;&lt;print _action&gt;&gt;
		&lt;&lt;capture _action, _actionID&gt;&gt;
		&lt;&lt;timed 0s&gt;&gt;
		&lt;&lt;if _action.onUse &amp;&amp; !_action.check(_display)&gt;&gt;
			&lt;&lt;set _selector = &quot;#&quot;+_actionID+&quot; .action-name&quot;&gt;&gt;
			&lt;&lt;replace _selector&gt;&gt;
				&lt;&lt;link &quot;_action.name&quot;&gt;&gt;
					&lt;&lt;if _action.instantUse === true&gt;&gt;
						&lt;&lt;run $action = _action; $action.onUse()&gt;&gt;
					&lt;&lt;else&gt;&gt;
						&lt;&lt;set $action = _action&gt;&gt;
						&lt;&lt;replace &quot;#partydisplay&quot;&gt;&gt;
							&lt;&lt;include &quot;action use puppets&quot;&gt;&gt;
						&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/if&gt;&gt;
				&lt;&lt;/link&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if !_action.noDefault &amp;&amp; _char.defaultAction !== _action.name&gt;&gt;
			&lt;&lt;set _selector = &quot;#&quot;+_actionID+&quot; .action-tags&quot;&gt;&gt;
			&lt;&lt;set $(_selector).after($(`&lt;div class=&quot;default-link&quot;&gt;`))&gt;&gt;
			&lt;&lt;set _selector = &quot;#&quot;+_actionID+&quot; .default-link&quot;&gt;&gt;
			&lt;&lt;replace _selector&gt;&gt;
				&lt;&lt;link &quot;[Set as default]&quot;&gt;&gt;
					&lt;&lt;set _char.defaultAction = _action.name&gt;&gt;
					&lt;&lt;update&gt;&gt;
				&lt;&lt;/link&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/timed&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/liveblock&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="167" name="action use puppets" tags="nobr" position="850,2100" size="100,100">&lt;div id=&quot;menu-display&quot; class=&quot;action&quot;&gt;
	&lt;&lt;print $action&gt;&gt;
	&lt;div class=&quot;item-buttons&quot;&gt;
		&lt;div id=&quot;button1&quot;&gt;
			&lt;span id=&quot;cancelbutton&quot;&gt;
			&lt;&lt;button &quot;CANCEL&quot;&gt;&gt;
				&lt;&lt;unset $subject, $action&gt;&gt;
				&lt;&lt;replace &quot;#partydisplay&quot;&gt;&gt;&lt;&lt;include &quot;status party display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/button&gt;&gt;
			&lt;/span&gt;
			&lt;span class=&quot;monospace&quot; style=&quot;font-size:85%&quot;&gt;[R]&lt;/span&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;puppets&quot;&gt;
&lt;&lt;set _HPmeters = []&gt;&gt;
&lt;&lt;set _MPmeters = []&gt;&gt;
&lt;&lt;for _i, _p range puppets()&gt;&gt;
	&lt;&lt;actorDisplay _p &quot;action&quot;&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;/div&gt;</tw-passagedata><tw-passagedata pid="168" name="Widget: actorDisplay" tags="widget nobr" position="975,2100" size="100,100">&lt;&lt;widget &quot;actorDisplay&quot;&gt;&gt;
/* Standard display code for a single character. By default, shows their name and stats on the left, and their equipment on the right. Modifiers can be used to change specific parts.

ARG 0 = character to be displayed
ARG 1 = special case modifier [optional]

Be VERY CAREFUL about labeling your temporary variables. This widget uses a lot of loops, and errors can occur if they overwrite temporary variables used elsewhere. */

&lt;&lt;run console.assert($args[0] instanceof Puppet,&quot;ERROR: No puppet passed to actorDisplay&quot;)&gt;&gt;

&lt;&lt;set _puppet = $args[0]&gt;&gt;
&lt;&lt;set _displayModel = $args[1]&gt;&gt;
&lt;&lt;set _style = &quot;&quot;&gt;&gt;
&lt;&lt;if def _displayModel &amp;&amp; _displayModel !== &quot;standard&quot;&gt;&gt;
	&lt;&lt;set _classMod = &quot; small-display&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _classMod = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if ndef _i&gt;&gt;
	&lt;&lt;set _i = 0&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if _puppet !== null&gt;&gt;
	&lt;div @class=&quot;&#39;menuactor&#39;+_classMod&quot; @id=&quot;_i&quot;&gt;
	/* container for the entire actor box */
		&lt;&lt;switch _displayModel&gt;&gt;
			&lt;&lt;default&gt;&gt;
			/* Default display makes room for a portrait on the left-hand side, if they&#39;re enabled. */
				&lt;&lt;if setup.PORTRAITS === true&gt;&gt;
					&lt;div class=&quot;portrait&quot;&gt;[img[setup.ImagePath+_p.portrait]]&lt;/div&gt;
					&lt;&lt;set _style = &quot;left:96px&quot;&gt;&gt;
				&lt;&lt;/if&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
		&lt;div @class=&quot;&#39;menuactor-nameblock&#39;+_classMod&quot; @style=_style&gt;
		/* container for the left-hand side of the box, typically containing the puppet&#39;s name */
			&lt;div class=&quot;menuactor-name&quot; id=&quot;toggle&quot;&gt;
			/* Container for the puppet&#39;s name. This is a point of interaction in most menus, so there is a switch here for different menu functionalities. */
				&lt;&lt;actorNameLink&gt;&gt;
			&lt;/div&gt; /* close name display */
			&lt;&lt;switch _displayModel&gt;&gt;
				&lt;&lt;case &quot;action&quot; &quot;inventory&quot; &quot;decurse&quot; &quot;equipment&quot;&gt;&gt;
				/* In these menus, the character&#39;s stats are displayed below their name. */
					&lt;div @class=&quot;&#39;menuactor-stats monospace&#39;+_classMod&quot;&gt;
					&lt;&lt;for _k, _v range _puppet.stats&gt;&gt;
						&lt;&lt;include &quot;menu stat display&quot;&gt;&gt;
					&lt;&lt;/for&gt;&gt;
					&lt;/div&gt;
				&lt;&lt;default&gt;&gt;
				/* In the default display, the character&#39;s level is displayed below their name. */
					&lt;div class=&quot;menuactor-level&quot;&gt;LEVEL _puppet.level&lt;/div&gt;
			&lt;&lt;/switch&gt;&gt;
		&lt;/div&gt; /* close name block */
			&lt;&lt;actorRightDisplay&gt;&gt;
	&lt;/div&gt; /* close actor box */
&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="169" name="Widget: actorNameLink" tags="widget nobr" position="1100,2100" size="100,100">&lt;&lt;widget &quot;actorNameLink&quot;&gt;&gt;
/* Switch for different functionalities tied to the character&#39;s name in actorDisplay. */

&lt;&lt;capture _puppet&gt;&gt;
&lt;&lt;switch _displayModel&gt;&gt;
	&lt;&lt;case &quot;inventory&quot;&gt;&gt;
	/* On the inventory screen, characters may be displayed when EQUIPPING or USING items. In both cases, the character name is clicked to perform the relevant function. The inventory screen must be updated afterwards to reflect the change. */
		&lt;&lt;switch _event&gt;&gt;
			&lt;&lt;case &quot;equip&quot;&gt;&gt;
					&lt;&lt;link _puppet.name&gt;&gt;
						&lt;&lt;run _puppet.equip(_display)&gt;&gt;
						&lt;&lt;unset _display&gt;&gt;&lt;&lt;unset _event&gt;&gt;
						&lt;&lt;update&gt;&gt;
						&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/link&gt;&gt;
			&lt;&lt;case &quot;use&quot;&gt;&gt;
					&lt;&lt;link _puppet.name&gt;&gt;
						&lt;&lt;notify &quot;menu&quot; 3s&gt;&gt;&lt;&lt;print _display.onUse(_puppet)&gt;&gt;&lt;&lt;/notify&gt;&gt;
						&lt;&lt;unset _display&gt;&gt;&lt;&lt;unset _event&gt;&gt;
						&lt;&lt;update&gt;&gt;
						&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;/link&gt;&gt;
			&lt;&lt;default&gt;&gt;
				&lt;&lt;print _puppet.name&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
	&lt;&lt;case &quot;action&quot;&gt;&gt;
		&lt;&lt;link _puppet.name&gt;&gt;
			&lt;&lt;notify &quot;menu&quot; 3s&gt;&gt;&lt;&lt;print $action.onUse(_puppet)&gt;&gt;&lt;&lt;/notify&gt;&gt;
			&lt;&lt;unset $subject, $action&gt;&gt;
			&lt;&lt;replace &quot;#partydisplay&quot;&gt;&gt;
				&lt;&lt;include &quot;status party display&quot;&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;&lt;case &quot;decurse&quot;&gt;&gt;
	/* In the decurse menu, the name has no special functionality. Just display it normally. */
		&lt;&lt;print _puppet.name&gt;&gt;
	&lt;&lt;case &quot;equipment&quot;&gt;&gt;
	/* In the equipment menu, the character name serves two functionalities: When the full party is displayed, clicking it will select the character; if a character is selected, clicking it will deselect them and return to the full party display. */
		&lt;&lt;if def $subject&gt;&gt; /* if selector already defined, deselect and refresh screen */
			&lt;&lt;link _puppet.name&gt;&gt;
				&lt;&lt;unset $subject&gt;&gt;
				&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;replace &quot;#equipment-list&quot;&gt;&gt;&lt;&lt;include &quot;equipment list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;else&gt;&gt; /* if no one selected, select this character and refresh screen */
			&lt;&lt;capture _i&gt;&gt;
			&lt;&lt;link _puppet.name&gt;&gt;
				&lt;&lt;set $subject = _puppet&gt;&gt;
				&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;replace &quot;#equipment-list&quot;&gt;&gt;&lt;&lt;include &quot;equipment list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;default&gt;&gt;
	/* In the default display, the character name serves two functionalities: When the full party is displayed, clicking it will select the character; if a character is selected, clicking it will deselect them and return to the full party display. */
		&lt;&lt;if def $subject&gt;&gt;
		/* If _display exists, a character has already been selected. Clicking the name again will deselect the character. */
			&lt;span id=&quot;toggle&quot;&gt;
			&lt;&lt;link &quot;_puppet.name&quot;&gt;&gt;
				&lt;&lt;unset $subject&gt;&gt;
				&lt;&lt;replace &quot;#partydisplay&quot;&gt;&gt;&lt;&lt;include &quot;status party display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;/span&gt;
		&lt;&lt;else&gt;&gt;
		/* If no character is selected, clicking the name will select this character. */
			&lt;span @id=_i&gt;
			&lt;&lt;link &quot;_puppet.name&quot;&gt;&gt;
				&lt;&lt;set $subject = _puppet&gt;&gt;
				&lt;&lt;set _stScreen = 1&gt;&gt;
				&lt;&lt;replace &quot;#partydisplay&quot;&gt;&gt;&lt;&lt;include &quot;status party display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;/span&gt;
		&lt;&lt;/if&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;&lt;/capture&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="170" name="Widget: actorRightDisplay" tags="widget nobr" position="1225,2100" size="100,100">&lt;&lt;widget &quot;actorRightDisplay&quot;&gt;&gt;
/* Branch for determining what is displayed on the right-hand side of the actor display. */

&lt;&lt;if (_displayModel == &quot;inventory&quot; &amp;&amp; _event == &quot;use&quot;) || (ndef _displayModel || _displayModel == &quot;standard&quot; || _displayModel == &quot;action&quot;)&gt;&gt;
/* By default or if we&#39;re using an item on the inventory screen, we want to display HP and MP on the right-hand side. */
	&lt;&lt;set _id = &#39;hp&#39;+_i&gt;&gt;
	&lt;&lt;run _HPmeters.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100% 0.5em&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
	&lt;&lt;set _id = &#39;mp&#39;+_i&gt;&gt;
	&lt;&lt;run _MPmeters.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.MP_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100% 0.5em&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
	&lt;div @class=&quot;&#39;menuactor-hpmpblock&#39;+_classMod&quot;&gt;
		&lt;div class=&quot;hpmp&quot;&gt;
			HP: &lt;span style=&quot;float:right&quot;&gt;
				&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.hp&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxHP&lt;/div&gt;
				&lt;/span&gt;
		&lt;/div&gt;
		&lt;&lt;showmeter _HPmeters[puppets().indexOf(_puppet)] `_puppet.hp / _puppet.maxHP`&gt;&gt;
		&lt;&lt;if setup.SHOW_MP === true&gt;&gt;
			&lt;div class=&quot;hpmp&quot;&gt;
				MP: &lt;span style=&quot;float:right&quot;&gt;
					&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.en&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxEN&lt;/div&gt;
					&lt;/span&gt;
			&lt;/div&gt;
			&lt;&lt;showmeter _MPmeters[puppets().indexOf(_puppet)] `_puppet.en / _puppet.maxEN`&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
&lt;&lt;else&gt;&gt;
/* In all other cases, display equipment on the right-hand side. */
	&lt;div class=&quot;menuactor-equipment small-display&quot;&gt;
	&lt;&lt;for _name, _slot range _puppet.equipment&gt;&gt;
		&lt;&lt;for _subslot, _item range _slot&gt;&gt;
			&lt;div class=&quot;menuactor-equipment-slot&quot;&gt;_name&lt;/div&gt;
			&lt;&lt;equipSlotDisplay _item&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if ndef _displayModel || _displayModel == &quot;standard&quot;&gt;&gt;
/* In the standard display, an additional XP block is displayed to the right of the previous block. */
	&lt;div class=&quot;menuactor-xpblock&quot;&gt;
		&lt;div style=&quot;font-weight:bold&quot;&gt;Experience&lt;/div&gt;
		&lt;div style=&quot;float:right&quot;&gt;_puppet.xp&lt;/div&gt;
		&lt;br/&gt;
		&lt;div style=&quot;font-weight:bold&quot;&gt;To next level&lt;/div&gt;
		&lt;&lt;set _toNext = _puppet.XPtoNext()&gt;&gt;
		&lt;div style=&quot;float:right&quot;&gt;&lt;&lt;if typeof(_toNext) == &#39;number&#39;&gt;&gt;&lt;&lt;print (_toNext-_puppet.xp)&gt;&gt;&lt;&lt;else&gt;&gt;&lt;&lt;print _toNext&gt;&gt;&lt;&lt;/if&gt;&gt;&lt;/div&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="171" name="Widget: equipSlotDisplay" tags="widget nobr" position="100,2225" size="100,100">&lt;&lt;widget &quot;equipSlotDisplay&quot;&gt;&gt;
/* Standardized display for a single instance of character equipment. By default, this displays below the slot name itself. Assume called within actorDisplay, and uses _displayModel for modular functionality.

ARG 0 = equipped item
*/

&lt;&lt;run console.assert($args[0] instanceof Item || $args[0] === null || $args[0] instanceof Filler,&quot;ERROR in equipSlotDisplay: no item passed&quot;)&gt;&gt;

&lt;&lt;set _item = $args[0]&gt;&gt;

&lt;&lt;if _item === null&gt;&gt;&lt;span class=&quot;menuactor-equipment-name&quot;&gt;&amp;nbsp;&lt;/span&gt; /* if slot empty, display blank space */
&lt;&lt;elseif _item instanceof Filler&gt;&gt;&lt;span class=&quot;menuactor-equipment-name&quot;&gt;_item&lt;/span&gt;
&lt;&lt;else&gt;&gt;
	&lt;div class=&quot;menuactor-equipment-name&quot;&gt;_item.name&lt;br/&gt;
	&lt;span class=&quot;action-desc&quot;&gt;_item.info&lt;/span&gt;
	&lt;/div&gt;
	&lt;span class=&quot;unequip-button&quot;&gt;
	&lt;&lt;switch _displayModel&gt;&gt;
	/* Unequip button displayed here. By default, this is an &quot;[X]&quot; link at the far right of the item name. */
		&lt;&lt;case &quot;inventory&quot;&gt;&gt;
		/* no unequip feature; display nothing */
		&lt;&lt;case &quot;decurse&quot;&gt;&gt;
		/* In Decurse, only display unequip if the item is sticky and player can pay the cost. Deduct the cost and refresh the shop screen after click. */
			&lt;&lt;if $currency &gt;= _decurseCost &amp;&amp; !_puppet.lockEquipment &amp;&amp; _item.sticky&gt;&gt;
				&lt;&lt;capture _puppet, _name, _subslot&gt;&gt;
				&lt;&lt;link &quot;[X]&quot;&gt;&gt;
					&lt;&lt;run _puppet.unequip(_name,_subslot,{unsticky:true})&gt;&gt;
					&lt;&lt;set $currency -= _decurseCost&gt;&gt;
					&lt;&lt;update&gt;&gt;
					&lt;&lt;replace &quot;#business-area&quot; t8n&gt;&gt;&lt;&lt;include &quot;decurse-remove&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
				&lt;&lt;/capture&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;default&gt;&gt;
		/* Default is party equipment screen. Only display unequip if the item is not sticky and the puppet does not have locked equipment. Remember to pass the subslot index too for subslot equipment. */
			&lt;&lt;if !_puppet.lockEquipment &amp;&amp; !_item.sticky&gt;&gt;
				&lt;&lt;capture _puppet, _name, _subslot&gt;&gt;
				&lt;&lt;link &quot;[X]&quot;&gt;&gt;
					&lt;&lt;run _puppet.unequip(_name,_subslot)&gt;&gt;
					&lt;&lt;replace &quot;#equipment-list&quot;&gt;&gt;&lt;&lt;include &quot;equipment list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
				&lt;&lt;/capture&gt;&gt;
			&lt;&lt;/if&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
	&lt;/span&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="172" name="menubar" tags="nobr" position="225,2225" size="100,100">&lt;span id=&quot;status&quot;&gt;
&lt;span class=&quot;menunav monospace&quot;&gt;
[A] ↑&lt;br/&gt;
[D] ↓
&lt;/span&gt;
&lt;&lt;for _n, _option range setup.MENU_OPTIONS&gt;&gt;
&lt;&lt;if _n != $menu_screen&gt;&gt;
&lt;&lt;capture _n, _option&gt;&gt;
&lt;span @id=&quot;&#39;menu&#39;+_n&quot;&gt;
&lt;&lt;link _option&gt;&gt;
	&lt;&lt;set $menu_screen = _n&gt;&gt;
	&lt;&lt;print &#39;&lt;&lt;goto \&quot;Menu: &#39;+_option+&#39;\&quot;&gt;&gt;&#39;&gt;&gt;
&lt;&lt;/link&gt;&gt;&lt;/span&gt;&lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;b&gt;_option&lt;/b&gt;
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;
&lt;&lt;/for&gt;&gt;
&lt;span id=&quot;menu-return&quot;&gt;&lt;&lt;longreturn&gt;&gt;&lt;/span&gt;
&lt;div class=&quot;GPdisplay monospace&quot;&gt;&lt;&lt;print setup.CURRENCY_NAME&gt;&gt;: $currency&lt;/div&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="173" name="procure" tags="nobr battle" position="350,2225" size="100,100">/* Old passage for the &quot;Procure&quot; skill, which allowed Rogue and Witch to expend Energy to buy items in battle. It was dummied out before the JavaScript overhaul, so it is unlikely to work in the current version without tweaking.

/* Procure costs use the &quot;cost&quot; attribute of Item objects, defined in the database JS. */

&lt;&lt;set $target = [null,null]&gt;&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;&lt;backbtn&gt;&gt;

&lt;&lt;for _key, _item range $inventory&gt;&gt;
&lt;b&gt;
&lt;&lt;if $subject[0].en &gt;= _item.value&gt;&gt;
&lt;&lt;capture _key, _item&gt;&gt;
&lt;&lt;set _linktext = &quot;Procure &quot;+_key&gt;&gt;
[[_linktext|Confirm Phase][$item_to_procure = _key; $action.cost = _item.value]]
&lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;del&gt;_key&lt;/del&gt;
&lt;&lt;/if&gt;&gt;
&lt;/b&gt;
 (Cost: &lt;&lt;print _item.value&gt;&gt;)&lt;br/&gt;
&lt;&lt;/for&gt;&gt;
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="174" name="Victory" tags="nobr battle" position="475,2225" size="100,100">&lt;&lt;set _XPBars = []; _animationTime = &quot;1s&quot;&gt;&gt;

&lt;center&gt;&lt;div style=&quot;font-size:20pt; font-weight:bold; margin-top:1em; margin-bottom:1em&quot;&gt;+&lt;&lt;print $B.XPreward&gt;&gt; XP&lt;/div&gt;&lt;/center&gt;

&lt;div class=&quot;actors&quot;&gt;
&lt;&lt;for _i, _puppet range puppets()&gt;&gt;
	&lt;&lt;set _id = &#39;p&#39;+_i&gt;&gt;
	&lt;&lt;run _XPBars.push(_id)&gt;&gt;
	&lt;&lt;set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)&gt;&gt;
	&lt;&lt;newmeter _id _value&gt;&gt;
		&lt;&lt;colors cyan cyan black&gt;&gt;
		&lt;&lt;animation _animationTime linear&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;

	&lt;div class=&quot;actor victory&quot;&gt;
	&lt;center style=&quot;text-transform:uppercase; font-weight:bold&quot;&gt;_puppet.name&lt;/center&gt;
	LEVEL &lt;span @id=&quot;&#39;lv&#39;+_i&quot;&gt;_puppet.level&lt;/span&gt;
	&lt;&lt;showmeter _XPBars[_i] _value&gt;&gt;
	&lt;center @id=&quot;&#39;lvlupmsg&#39;+_i&quot;&gt;&amp;nbsp;&lt;/center&gt;
	&lt;/div&gt;

	&lt;&lt;set _multiplier = 1&gt;&gt;
	&lt;&lt;set _puppet.xp += Math.round($B.XPreward * _multiplier)&gt;&gt;
	&lt;&lt;set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)&gt;&gt;
	&lt;&lt;updatemeter _XPBars[_i] _value&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;/div&gt;

&lt;&lt;set $currency += $B.moneyReward&gt;&gt;
&lt;center style=&quot;margin-top:1em;&quot;&gt;&lt;div style=&quot;display:inline-block; width:50%; font-size:20pt; text-align:left&quot;&gt;&lt;&lt;print setup.CURRENCY_NAME&gt;&gt; &lt;span style=&quot;float:right&quot;&gt;$B.moneyReward&lt;/span&gt;&lt;/div&gt;&lt;/center&gt;

&lt;&lt;set _itemDrops = []&gt;&gt;
&lt;&lt;for _enemy range $B.kills&gt;&gt;
	&lt;&lt;for _item, _chance range _enemy.itemDrops&gt;&gt;
	/* Assumes itemDrops is an object with property names of items corresponding to a number between 1 and 100 equal to the % chance of the item being dropped. */
		&lt;&lt;if typeof(_item) == &#39;string&#39; &amp;&amp; typeof(_chance) == &#39;number&#39;&gt;&gt;
			&lt;&lt;set _r = random(1,100)&gt;&gt;
			&lt;&lt;if _r &lt;= _chance&gt;&gt;
				&lt;&lt;run inv().addItem(_item); _itemDrops.push(_item)&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _itemDrops.length &gt; 0&gt;&gt;
	&lt;center style=&quot;margin-top:1em;&quot;&gt;
	&lt;div style=&quot;font-size:20pt; font-weight:bold&quot;&gt;DROPS:&lt;/div&gt;
	&lt;span class=&quot;itembox&quot; style=&quot;width:30%&quot;&gt;
	&lt;&lt;for _item range _itemDrops&gt;&gt;
		&lt;b&gt;&lt;&lt;print _item&gt;&gt;&lt;/b&gt;&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/span&gt;
	&lt;/center&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;timed _animationTime&gt;&gt;
	&lt;&lt;for _i, _puppet range puppets()&gt;&gt;
		&lt;&lt;if _puppet.xp &gt;= _puppet.XPtoNext()&gt;&gt;
			&lt;&lt;set _id = &quot;#lv&quot;+_i&gt;&gt;
			&lt;&lt;replace _id&gt;&gt;&lt;span style=&quot;font-weight:bold&quot;&gt;&lt;&lt;print (_puppet.level+1)&gt;&gt;&lt;/span&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;set _id = &quot;#lvlupmsg&quot;+_i&gt;&gt;
			&lt;&lt;replace _id&gt;&gt;&lt;span style=&quot;font-weight:bold; color:cyan&quot;&gt;LEVEL UP!&lt;/span&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;levelcheck&gt;&gt;
	&lt;&lt;timed 3s&gt;&gt;
		&lt;&lt;goto &quot;Level Check&quot;&gt;&gt;
	&lt;&lt;/timed&gt;&gt;
&lt;&lt;/timed&gt;&gt;</tw-passagedata><tw-passagedata pid="175" name="Level Check" tags="nobr battle" position="600,2225" size="100,100">&lt;&lt;if $LevelUps.length &gt; 0&gt;&gt;
	&lt;&lt;set _p = $LevelUps.shift()&gt;&gt;
	&lt;center&gt;&lt;&lt;LevelUp _p&gt;&gt;&lt;/center&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;goto $B.destination&gt;&gt;
	&lt;&lt;endofbattle&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="176" name="Defeat" tags="" position="725,2225" size="100,100">You lost! You can add a special defeat message here.

&gt;[[Retry this battle|Preparation]]
&gt;[[Return|Start]]

&lt;&lt;endofbattle&gt;&gt;</tw-passagedata><tw-passagedata pid="177" name="Installation" tags="text" position="850,2225" size="100,100">&lt;b&gt;IMPORTANT NOTE: Another RPG Engine uses ES6 components and may not function on all browswers. Google Chrome and Firefox should work, but other browsers may not. If you encounter errors, make sure you are using the most current version of your browser.&lt;/b&gt;

Another RPG Engine contains a lot of components. To use them all together, you will need a special compiler.

I use &lt;a href=&quot;http://www.motoslave.net/tweego/&quot; target=&quot;_blank&quot;&gt;Tweego&lt;/a&gt;, which has an installer &lt;a href=&quot;https://github.com/ChapelR/tweego-installer&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. &lt;b&gt;Note the instructions regarding &lt;code&gt;StoryData&lt;/code&gt; if you do not wish to use Twine to create your project.&lt;/b&gt;

Once you have everything set, you can open your comand prompt (search &quot;cmd&quot; in Windows) and use the &quot;tweego&quot; command to compile Twine stories. If you place your story file in a folder with JavaScript, CSS, and twee files, and target that folder with the &quot;tweego&quot; command, they will all be bundled together. The default download package has already lumped these into a &quot;src&quot; folder for you.

The &quot;src&quot; folder is grouped into the following subfolders:
* {{{javascript}}}, for JavaScript files
** {{{core}}}, for core files necessary for the engine&#39;s function
** {{{custom}}}, for user-defined elements such as character definitions
* {{{macros-additional}}}, third-party SugarCube macros not included in the default SugarCube package
* {{{passages-core}}}, for Twee files necessary for the engine&#39;s function
* {{{passages-custom}}}, for optional mods and your own Twee files
* {{{stylesheets}}}, for CSS stylesheets

In the final product, everything will become part of the same story. However, there are a few rules that you must keep in mind:

&lt;b&gt;If there is a conflict in the data between two story files&lt;/b&gt;, such as passages with the same names, &lt;b&gt;the last file compiled will overwrite the first.&lt;/b&gt; Tweego will compile files in the same order they are seen in the directory, which generally means in alphabetical order. Fortunately, &quot;passages-custom&quot; comes after &quot;passages-core&quot;, so any unique passages you make will overwrite the defaults.

However, &lt;b&gt;be careful if you have any passages with the same names&lt;/b&gt;. If anything in the engine gets overwritten, the whole thing could break. This probably won&#39;t be a problem for most passages, but &lt;b&gt;be aware that the engine uses the special passages StoryInit, PassageReady, and PassageDone.&lt;/b&gt; You will likely want to use these passages for your own purposes in your story, so make sure there is no conflict in the core files.

Another resource you may find helpful is &lt;a href=&quot;https://www.johnayliff.com/works.html&quot; target=&quot;_blank&quot;&gt;a SugarCube language definition for Notepad++&lt;/a&gt;, by John Ayliff. SugarCube does not have a default language definition in Twine, so this may be helpful for organizing your code. Click on &quot;save link as&quot;, save the file anywhere on your computer, and import the file under Language -&gt; User Defined Language in Notepad++. If you use a different coding environment, there is also &lt;a href=&quot;https://github.com/otommod/twee-sugarcube.vim&quot; target=&quot;_blank&quot;&gt;a .vim version&lt;/a&gt; by otommod.

The engine uses ChapelR&#39;s custom SugarCube macros, the documentation for which can be found &lt;a href=&quot;https://twinelab.net/custom-macros-for-sugarcube-2/#/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.

&lt;b&gt;Summary:&lt;/b&gt;
* Download Tweego &lt;a href=&quot;http://www.motoslave.net/tweego/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. If you can&#39;t follow the directions, use the installer &lt;a href=&quot;https://github.com/ChapelR/tweego-installer&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.
* You can compile multiple story and twee files at once, but later conflicts will overwrite earlier ones.
* Store customized engine passages in passages-custom to avoid conflicts.</tw-passagedata><tw-passagedata pid="178" name="Additional Features" tags="text info" position="975,2225" size="100,100">This passage will discuss non-essential RPG features with only skeletal implementations in the default engine, but which may be of interest. This will contain rather advanced discussion of code and will build on the principles discussed in the design passage, so it is recommended you read [[Documentation|Documentation (Advanced)]] and [[Design]] first.

&lt;h1&gt;Table of Contents&lt;/h1&gt;
&gt;&lt;a href=&quot;#flow&quot;&gt;Battle Flow and Turn Order&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#flow.1&quot;&gt;Method 1: Ranked Order&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#flow.1.a&quot;&gt;Adding Variance&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#flow.2&quot;&gt;Method 2: Action Time&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#flow.2.a&quot;&gt;Action Time with Threshold&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#flow.3&quot;&gt;Method 3: Timeline&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#flow.3.a&quot;&gt;Duel (One-Character) Systems&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#flow.4&quot;&gt;Transparency&lt;/a&gt;
&gt;&lt;a href=&quot;#progress&quot;&gt;Progression and Leveling Up&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#progress.levels&quot;&gt;Levels&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#progress.levels.1&quot;&gt;Calculating XP Requirements&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#progress.levels.2&quot;&gt;What Do Levels Do?&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#progress.levels.code&quot;&gt;Implementation&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#progress.pointbuy&quot;&gt;Point-Buy&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#progress.pointbuy.code&quot;&gt;Implementation&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#progress.equip&quot;&gt;Equipment-Based Progression&lt;/a&gt;
&gt;&lt;a href=&quot;#battlegrid&quot;&gt;Battle Grid&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#battlegrid.1&quot;&gt;Setup&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#battlegrid.2&quot;&gt;Features&lt;/a&gt;
&gt;&lt;a href=&quot;#missMechanics&quot;&gt;Misses and Critical Hits&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#misses&quot;&gt;Accuracy and Misses&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#crits&quot;&gt;Critical Hits&lt;/a&gt;
&gt;&lt;a href=&quot;#bestiaryDocs&quot;&gt;Bestiary/Enemy Encyclopedia&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#bestiaryClass&quot;&gt;Bestiary Class&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#bestiaryEntryClass&quot;&gt;BestiaryEntry Class&lt;/a&gt;
&gt;&lt;a href=&quot;#crisis&quot;&gt;Crisis/Limit Breaks&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#crisis.code&quot;&gt;Implementation&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#crisis.stash&quot;&gt;Stash&lt;/a&gt;

&lt;h2 id=&quot;flow&quot;&gt;Battle Flow and Turn Order&lt;/h2&gt;
In &lt;i&gt;Cartoon Battle&lt;/i&gt;, everyone can take their turns in any order, and each party&#39;s turn happens all at once. This system is very simple to implement and balance: everyone gets the same number of actions and acts at the same rate. I recommend it to novice developers for this reason.

This is not the only way to structure turn order, however. Many RPGs include a &quot;speed&quot; or &quot;agility&quot; stat that makes some characters act before others.

&lt;h3 id=&quot;flow.1&quot;&gt;Method 1: Ranked Order&lt;/h3&gt;
The simplest way to implement this is to have everyone act in order of decreasing Speed. So, for instance, if we have three characters with 10, 5, and 4 Speed and an enemy with 9 Speed, every round will go in the order of Character A - Enemy - Character B - Character C. If we boost the enemy to 11 speed, they&#39;d now go before any player characters, which could make them quite tricky! Under this model, everyone would still get the same number of turns -- after each round, we&#39;d just repeat the queue. This means balancing actions is still fairly simple. However, we do gain added complexity by fixing characters&#39; positions in the turn order -- especially if there are actions that can assist or set up other characters&#39; abilities, such as buff and debuff effects. Players will need to construct their strategy around the turn order instead of being able to change when it suits them. Assuming a gradual increase in stats over the course of the game, players are also encouraged to increase their Speed to act before enemies and gain the advantage.

Below is an example of how to implement this system in SugarCube:

First, we will need to place every battling character into one array. In the default system, enemies and player characters are completely separate. One method that would work would be to create an &lt;i&gt;array of arrays&lt;/i&gt; that links both enemy and player arrays into one object. That would look like this:
{{{
&lt;&lt;set $actors = [$puppets,$enemies]&gt;&gt;
}}}
If you run a {{{for}}} loop over {{{$actors}}}, you can iterate over both enemy and player parties at once -- as well as potential other parties, if you want to design complex multi-front battles.

Then you&#39;d want to use the code in the &quot;Initiative Model: Ranked Order&quot; passage, which is copied here:
{{{
&lt;&lt;set _initiative = -1&gt;&gt;
/* The -1 is necessary if you want a Speed of 0 to be possible. */
&lt;&lt;for _i, _party range $actors&gt;&gt;
	&lt;&lt;for _j, _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead and not _actor.stunned&gt;&gt;
		/* If you have more paralysis effects, you&#39;ll need to add each here. Consider adding a convenient &quot;can&#39;t act&quot; attribute flipped by all of them if this becomes prohibitive.
			&lt;&lt;if not _actor.isDone and _actor.speed &gt; _initiative&gt;&gt;
			/* (not _actor.isDone) prevents us from selecting characters who have already acted this round. They&#39;ll be skipped over, and the next-fastest character will get the initiative. */
				&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;set _initiative = _actor.speed&gt;&gt;
				/* This sets the current character&#39;s Speed as the new bar to clear. If no one&#39;s faster, no one else will pass the if check above and this character will remain the current subject. If someone else is faster, they&#39;ll become the subject and the _initiative variable will be updated to match their Speed. This ensures that subject status will be granted to the fastest character. */
			&lt;&lt;elseif not _actor.isDone and _actor.speed == _initiative&gt;&gt;
			/* You&#39;ll need a handler for this case, or else the character with the higher index order will get the initiative in the case of a match. This handler can be anything, including nothing at all. If you want to be nice, you could automatically give the player the initiative in the case of a tie. Here I&#39;ve provided the fairest possible option: a coin flip. */
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;if _subj[0] == $actors.indexOf($puppets)&gt;&gt;
		&lt;&lt;set $subject = [$puppets[_j],&quot;$puppets[&quot;+_j+&quot;]&quot;]&gt;&gt;
	&lt;&lt;elseif _subj[0] == $actors.indexOf($enemies)&gt;&gt;
		&lt;&lt;set $subject = [$enemies[_j],&quot;$enemies[&quot;+_j+&quot;]&quot;]&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		(You should write an error message here.)
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
(This is far more complicated than it needs to be because Twine does not preserve object references. In a proper coding engine we could just {{{
&lt;&lt;set $subject = _actor&gt;&gt;
}}} within the loop and be done with it, but Twine necessitates the second section.)

Note that this assumes a character&#39;s Speed stat will never go below 0.

You can make this a widget, or another passage that is run after every character&#39;s turn. Presumably, you would also modify the &quot;Battle!&quot; passage to only display commands for the active subject, with a handler in case the enemy has the active turn (probably forwarding the player to another passage for the enemy turn).

&lt;h4 id=&quot;flow.1.a&quot;&gt;Adding Variance&lt;/h4&gt;
Unfortunately, the above model has a weakness: Speed has a binary, rather than variable, effect. With stats such as Attack and Defense, every point matters, because it contributes to a numerical value. But once you have more Speed than the enemy, there&#39;s no benefit to gaining more Speed. This can lead to Speed losing value compared to other stats, and making Speed-focused characters weaker overall.

Some games patch this problem by making the rules less rigid: instead of being determined by the absolute Speed values every time, initiative is  instead determined through a random formula influenced by the Speed stat. Some games, such as &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, can use quite variable formulas, but for this example I will model a simpler one, varying characters&#39; Speed stats by a certain percentage of their base values.

In SugarCube, you could implement this feature like so:
{{{
&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead and not _actor.stunned&gt;&gt;
			&lt;&lt;set _actor.initiative = _actor.speed&gt;&gt;
			&lt;&lt;set _variance = random(-$VARIANCE_BOUND,$VARIANCE_BOUND)&gt;&gt;
			&lt;&lt;set _variance /= 100&gt;&gt;
			/* Twine&#39;s random() function requires integer bounds, but we (presumably) plan to vary characters&#39; Speed stats by a small proportion. We can do this by setting $VARIANCE_BOUND to an integer percentage value (probably in StoryInit) and dividing by 100 to get the decimal value. */
			&lt;&lt;set _actor.initiative += _actor.speed * _variance&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
You can then use the same code as in the previous section, except you would compare {{{_initative}}} to {{{_actor.initiative}}} instead of {{{_actor.speed}}}.

As an example, let us say we set {{{$VARIANCE_BOUND}}} to 10. This would give {{{_variance}}} a random value from anywhere between -10 and 10. We then convert it into a decimal, making it a random value between -.1 and .1. We then take {{{_actor.initiative}}}, which is initialized at the same value as {{{_actor.speed}}}, and add a fraction of {{{_actor.speed}}} to get the character&#39;s final initiative value. The size and sign of the fraction is determined by {{{_variance}}}.

If the character had 100 Speed, their initiative value could be anywhere between 90 and 110. This means a character with 90 Speed could beat them in the turn order, if they rolled high and the 100 Speed character rolled low. However, the 100 Speed character would still get the first turn more often than not. Additionally, a character with 81 Speed would never beat them in turn order even if they got the maximum bonus and the 100 Speed character got the maximum penalty: {{{81 + (81*0.1) = 89.1}}} is less than {{{100 + (100*-0.1) = 90}}}.

You can add more randomness by increasing the variance bound.

This variance makes a Speed focus a more optimal gameplay decision: even if you&#39;re fast, more Speed increases the chance you&#39;ll get the initiative, rather than ceasing to matter once you get 1 point more than your opponent.

I, personally, hate this method with a burning passion, because I feel turn order is too important of a thing to leave up to chance, and makes it nigh-impossible for the player to implement long-term strategy if they cannot predict the turn order.

Some games feel this still leaves Speed a suboptimal stat, and have it influence other aspects of battle as well, such as accuracy, evasion, and critical hit rates. (These features are not in the default engine because I despise them, but I may include a tutorial on implementing them if there is demand.)

&lt;h3 id=&quot;flow.2&quot;&gt;Method 2: Action Time&lt;/h3&gt;
If you&#39;ve played any &lt;i&gt;Final Fantasy&lt;/i&gt; game after &lt;i&gt;Final Fantasy III&lt;/i&gt;, or any game made in RPG Maker 2003, you will be familiar with this system. (Yes, even &lt;i&gt;Final Fantasy X&lt;/i&gt;.)

The most familiar form, seen in the examples I mentioned, is an odd method of merging turn-based RPGs with reaction-based action games: characters have gauges that fill up in real time, and characters can take an action when it&#39;s full. Usually this process pauses while you choose your action, but sometimes you have to choose quick while enemies are still getting turns.

Such a real-time, image-based system is obviously not suited for Twine. You could theoretically do it with {{{&lt;&lt;timed&gt;&gt;}}} and {{{&lt;&lt;repeat&gt;&gt;}}} macros, maybe...? But your time would almost certainly be better spent in another environment entirely.

What I&#39;ve described is just an abstraction, though. If we look at the variables underneath, we can create a similar system even in our static Twine.

First, we&#39;re going to increment a separate &quot;initiative&quot; attribute based on some formula. The formula can include anything, including random variance, but for the purposes of this example let&#39;s just make the increment equal to the Speed stat:
{{{
&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;for _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;set _actor.initiative += _actor.speed&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
We then use a modified form of our code from &lt;a class=&quot;noExternal&quot; href=&quot;#flow.1&quot;&gt;Method 1&lt;/a&gt;:
{{{
&lt;&lt;set _initiative = -1&gt;&gt;
&lt;&lt;for _i, _party range $actors&gt;&gt;
	&lt;&lt;for _j, _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;if _actor.initiative &gt; _initiative&gt;&gt;
				&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;set _initiative = _actor.initiative&gt;&gt;
			&lt;&lt;elseif _actor.initiative == _initiative&gt;&gt;
				&lt;&lt;set _r = random(1,2)&gt;&gt;
				&lt;&lt;if _r == 1&gt;&gt;
					&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;if _subj[0] == $actors.indexOf($puppets)&gt;&gt;
		&lt;&lt;set $subject = [$puppets[_j],&quot;$puppets[&quot;+_j+&quot;]&quot;]&gt;&gt;
	&lt;&lt;elseif _subj[0] == $actors.indexOf($enemies)&gt;&gt;
		&lt;&lt;set $subject = [$enemies[_j],&quot;$enemies[&quot;+_j+&quot;]&quot;]&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		(You should write an error message here.)
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set $subject[0].initiative = 0&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
This assumes every character&#39;s &quot;initiative&quot; attribute is set to 0 at the start of battle.

To keep things simple, the current subject&#39;s initiative is set to 0 when they take their turn. In this code, this automatically happens as soon as they&#39;re selected; you may want to make this happen in the action phase instead, if you want some actions to drain initiative by different amounts. Maybe there&#39;s a &quot;wait&quot; option that only halves it, for instance?

The main difference here is that we do not ignore characters who have acted in the round already: if someone gains more initiative, they can get more turns than another character. This effectively eliminates the concept of &quot;rounds&quot; entirely; characters will just keep taking turns, in no fixed order.

This system will be functionally similar to Method 1 when there is little difference between characters&#39; Speed stats. For example, let&#39;s look at a battle where Character A has 11 Speed, Enemy B has 10 Speed, and Character C has 9 Speed:

Initiative at turn 0:
A = 11
B = 10
C = 9

A gets the turn. Their initiative goes to 0.

Initiative at turn 1:
A (1 turn) = 11
B (0 turns) = 20
C (0 turns) = 18

B gets the turn. Their initiative goes to 0.

Initiative at turn 2:
A (1 turn) = 22
B (1 turn) = 10
C (0 turns) = 27

C gets the turn. Their initiative goes to 0.

Initiative at turn 3:
A (1 turn) = 33
B (1 turn) = 20
C (1 turn) = 9

A gets the turn.

Initiative at turn 4:
A (2 turns) = 11
B (1 turn) = 30
C (1 turn) = 18

B gets the turn.

Initiative at turn 5:
A (2 turns) = 22
B (2 turns) = 10
C (1 turn) = 27

C gets the turn. Notice that the initiative values are identical to those on turn 2: we&#39;ve completed a loop. The characters will continue taking turns in this pattern, which is identical to the pattern in Method 1: characters will act in order of descending Speed, and then repeat.

But that was when the Speed values only differed by 1. Let&#39;s look at what happens with bigger differences: A now has 30, B now has 20, and C now has 10.

Initiative at turn 0:
A = 30
B = 20
C = 10

A gets the turn.

Initiative at turn 1:
A (1 turn) = 30
B (0 turns) = 40
C (0 turns) = 20

B gets the turn.

Initiative at turn 2:
A (1 turn) = 60
B (1 turn) = 20
C (0 turns) = 30

A gets the turn. But wait! C hasn&#39;t gotten a single turn, but A has now moved twice! That&#39;s the key difference in an action time system: faster characters will get more turns total, instead of everyone getting the same number of actions. This is much, &lt;i&gt;much&lt;/i&gt; harder to balance. If A gets twice as many turns as B, they&#39;ve effectively doubled all their stats by only doubling one: even if all their other stats are the same as B&#39;s, they&#39;re attacking twice as often, defending twice as often, using utility skills twice as often. If Method 1 undervalued Speed, action time &lt;i&gt;overvalues&lt;/i&gt; it -- Speed can come to dominate all other stats, because more turns are almost always more desirable than fewer but stronger turns. This can be mitigated in a subtractive defense system where more attacks don&#39;t necessarily correlate with more results, but is exacerbated by skills that don&#39;t depend on other stats, such as most status effects.

You can still balance this through careful tweaking of the formulas -- maybe initiative gain is only half Speed, for instance -- but it&#39;s not a task I recommend for novice developers. It&#39;s much easier to include this sort of &quot;multi-turn&quot; functionality through specific actions you can control directly. For example, in &lt;i&gt;Cartoon Battle&lt;/i&gt; Rogue&#39;s basic attack hits twice, but is weaker than the other basic attacks.

&lt;h4 id=&quot;flow.2.a&quot;&gt;Action Time with Threshold&lt;/h4&gt;
If you&#39;re interested in more accurately modeling the version seen in &lt;i&gt;Final Fantasy&lt;/i&gt;, you can choose turns based on whose initiative crosses a &quot;finish line&quot; first. &lt;i&gt;Bonfire&lt;/i&gt; uses this method, and its algorithm is explained &lt;a href=&quot;http://bonfire-game.wikia.com/wiki/Turn_Order&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. Implementation in SugarCube would look something like this:
{{{
&lt;&lt;set _threshold = $ACTION_THRESHOLD&gt;&gt; /* You would set $ACTION_THRESHOLD to some constant in StoryInit. */
&lt;&lt;set _pastThreshold = false&gt;&gt;

/* check for characters already at threshold */

&lt;&lt;for _party range $actors&gt;&gt;
	&lt;&lt;if _pastThreshold&gt;&gt;
		&lt;&lt;break&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;if _actor.initiative &gt;= _threshold&gt;&gt;
				&lt;&lt;set _pastThreshold = true&gt;&gt;
				&lt;&lt;break&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative gain */

&lt;&lt;for not _pastThreshold&gt;&gt;
	&lt;&lt;for _party range $actors&gt;&gt;
		&lt;&lt;for _actor range _party&gt;&gt;
			&lt;&lt;if not _actor.dead&gt;&gt;
				&lt;&lt;set _actor.initiative += 20 + 0.2 * _actor.speed&gt;&gt;
				/* This is the Bonfire formula, but you can add your own */
				&lt;&lt;if _actor.initiative &gt;= _threshold&gt;&gt;
					&lt;&lt;set _pastThreshold = true&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

/* initiative comparison */

&lt;&lt;for _i, _party range $actors&gt;&gt;
	&lt;&lt;for _j, _actor range _party&gt;&gt;
		&lt;&lt;if not _actor.dead&gt;&gt;
			&lt;&lt;if _actor.initiative &gt; _threshold&gt;&gt;
				&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;set _threshold = _actor.initiative&gt;&gt;
			&lt;&lt;elseif _actor.initiative == _threshold&gt;&gt;
				&lt;&lt;if def _subj&gt;&gt;
					&lt;&lt;set _r = random(1,2)&gt;&gt;
					&lt;&lt;if _r == 1&gt;&gt;
						&lt;&lt;set _subj = [_i,_j]&gt;&gt;
					&lt;&lt;/if&gt;&gt;
				&lt;&lt;else&gt;&gt;
					&lt;&lt;set _subj = [_i,_j]&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if ndef _subj&gt;&gt;
(You should write an error message here.)
&lt;&lt;else&gt;&gt;
	&lt;&lt;if _subj[0] == $actors.indexOf($puppets)&gt;&gt;
		&lt;&lt;set $subject = [$puppets[_j],&quot;$puppets[&quot;+_j+&quot;]&quot;]&gt;&gt;
	&lt;&lt;elseif _subj[0] == $actors.indexOf($enemies)&gt;&gt;
		&lt;&lt;set $subject = [$enemies[_j],&quot;$enemies[&quot;+_j+&quot;]&quot;]&gt;&gt;
		&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		(You should write an error message here.)
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set $subject[0].initiative -= $ACTION_THRESHOLD&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
To show an example of what this would look like, we&#39;ll use the fastest enemy in &lt;i&gt;Bonfire&lt;/i&gt;, the Bladewolf, which has 70 Speed; the fastest hero in &lt;i&gt;Bonfire&lt;/i&gt;, Assassin, who starts with 40 Speed; and the slowest hero in &lt;i&gt;Bonfire&lt;/i&gt;, Knight, who starts with 15 Speed.

Turn 1:
B: 34 - 68 - &lt;b&gt;102&lt;/b&gt;
A: 28 - 56 - 84
K: 23 - 46 - 69

Bladewolf gets the turn, and loses 100 initiative. Bladewolf has taken &lt;b&gt;1 turn.&lt;/b&gt;

Turn 2:
B: 02 - 36
A: 84 - &lt;b&gt;112&lt;/b&gt;
K: 69 - 92

Assassin gets the turn. Turn order so far is &lt;b&gt;B, A&lt;/b&gt;.

Turn 3:
B: 36 - 70
A: 12 - 40
K: 92 - &lt;b&gt;115&lt;/b&gt;

Knight gets the turn. Turn order so far is &lt;b&gt;B, A, K&lt;/b&gt;.

Turn 4:
B: 70 - &lt;b&gt;104&lt;/b&gt;
A: 40 - 68
K: 15 - 38

Turn order so far is &lt;b&gt;B, A, K, B&lt;/b&gt;.

Turn 5:
B: 04 - 38 - 72
A: 68 - 96 - &lt;b&gt;124&lt;/b&gt;
K: 38 - 61 - 84

Turn order so far is &lt;b&gt;B, A, K, B, A&lt;/b&gt;.

Turn 6:
B: 72 - 106
A: 24 - 52
K: 84 - &lt;b&gt;107&lt;/b&gt;

Knight will get the turn, then Bladewolf. Turn order so far is &lt;b&gt;B, A, K, B, A, K, B&lt;/b&gt;.

Turn 8:
B: 06 - 40 - 74 - 108
A: 52 - 80 - 98 - &lt;b&gt;126&lt;/b&gt;
K: 07 - 30 - 53 - 76

Assassin will get the turn, then Bladewolf. Turn order so far is &lt;b&gt;B, A, K, B, A, K, B, A, B&lt;/b&gt;. Bladewolf lapped Knight after 9 turns.

Compared to straight highest-wins initiative:

Turn 1:
B: &lt;b&gt;34&lt;/b&gt;
A: 28
K: 23

Turn order: &lt;b&gt;B&lt;/b&gt;.

Turn 2:
B: 34
A: &lt;b&gt;56&lt;/b&gt;
K: 46

Turn order: &lt;b&gt;B, A&lt;/b&gt;.

Turn 3:
B: 68
A: 28
K: &lt;b&gt;69&lt;/b&gt;

Turn order: &lt;b&gt;B, A, K&lt;/b&gt;.

Turn 4:
B: &lt;b&gt;102&lt;/b&gt;
A: 56
K: 23

Turn order: &lt;b&gt;B, A, K, B&lt;/b&gt;.

Turn 5:
B: 34
A: &lt;b&gt;84&lt;/b&gt;
K: 46

Turn order: &lt;b&gt;B, A, K, B, A&lt;/b&gt;.

Turn 6:
B: 68
A: 28
K: &lt;b&gt;69&lt;/b&gt;

Turn order: &lt;b&gt;B, A, K, B, A, K&lt;/b&gt;. Notice that this distribution is identical to that of turn 3, which means we have entered a stable loop. Bladewolf will never lap Knight in this scenario.

The key difference here is that the simple method always resets initiative to 0 when the subject takes a turn no matter how much they accumulated, but the threshold method allows initiative to carry over if the threshold is overshot. This gives greater weight to differences in Speed stats and makes stable loops less likely. However, designing the correct threshold is itself a challenge; if we were to use a straight gain = Speed formula, anyone with 100 Speed would be able to take turns continuously! The threshold method is best suited to slow gain formulas with less dependence on stats, for this reason. You could also make the threshold flexible, such as tying it to three times the fastest or slowest character&#39;s gain rate, but this runs an even greater risk of making stat differences get out of hand.

&lt;h3 id=&quot;flow.3&quot;&gt;Method 3: Timeline&lt;/h3&gt;
Characters&#39; turns are placed at certain points in a timeline. When time advances to their point, they take their turn, and are then placed at another point.

This method is similar to action time, but works in reverse in terms of algorithm: we have everyone&#39;s initiative values count &lt;i&gt;down&lt;/i&gt;, and characters take their turns when it hits 0.

We&#39;d first need some way of creating an initial turn order. For now, let&#39;s assume whoever has the highest Speed stat goes first, and everyone lower than them goes 1 &quot;tick&quot; later for every point of Speed difference. So with characters of Speed 10, 8, 5, and 4, our starting timeline would look like this:
{{{
[A]-[B]--[C][D]
}}}
where dashes are empty ticks.

From here, A would take an action and be placed at a later point in the timeline. This determination could be based on Speed, but it&#39;s more commonly based on action; some actions will require the characters to wait longer before they can act again. For instance, attacking with a heavy greatsword might push a character back 6 ticks, while attacking with a knife only pushes them back 4. Maybe casting a spell only pushes them back 3 ticks, but requires 2 additional ticks of wind-up time while they chant the incantation, during which time they may be vulnerable.

After their action, A would be placed ahead in the timeline, and the timeline would advance; everyone&#39;s initiative would go down by 1. There&#39;s no one in the next tick space, so we&#39;d skip it and run another iteration until the next character appears, in this case, B. They&#39;d take an action, then get pushed ahead to a new slot. The battle would continue like this.

To implement this system, you&#39;d do something very similar to an &lt;a class=&quot;noExternal&quot; href=&quot;#flow.2.a&quot;&gt;action time with threshold&lt;/a&gt; system. Only the threshold value and incrementor system would need to be changed. An example model is provided in the &quot;Initiative Model: Timeline&quot; passage.

This is a fairly intuitive system, and superb if you want a battle system based around timing and actions with variable speeds. This system meshes well with features such as charged attacks and delayed effects, as those features can be placed in tick squares as well. However, it&#39;s a lot to keep track of, and all the balance problems associated with an action time system still apply. You&#39;ll also have to come up with your own system for initial turn order, as I can&#39;t think of a good one off the top of my head. (Make a separate &quot;initiative&quot; stat that&#39;s either fixed for every character or can only be increased rarely, maybe?)

I took this system from &lt;i&gt;Exalted&lt;/i&gt;, a fantasy tabletop RPG that&#39;s very different from the popular &lt;i&gt;Dungeons and Dragons&lt;/i&gt;. &lt;i&gt;Exalted&lt;/i&gt;&#39;s system is massively more complicated than the simple model I&#39;ve outlined here, but could be a good jumping-off point for you to design your own system. &lt;i&gt;Exalted&lt;/i&gt; players often bemoan how hard it is to keep track of all the variables at play, but that&#39;s no problem for a computer!

&lt;i&gt;Exalted&lt;/i&gt; fan Jye Nicolson created &lt;a href=&quot;https://mengtzu.github.io/exalted/sakuya.html&quot; target=&quot;_blank&quot;&gt;a tutorial game&lt;/a&gt; using JavaScript, if you would like to see how the system works in action. Because Twine operates in JavaScript, the game plays very similarly!

&lt;h4 id=&quot;flow.3.a&quot;&gt;Duel (One-Character) Systems&lt;/h4&gt;
Some RPGs, or just some parts of some RPGs, forgo a party system and only give you one player character for battles. From a narrative standpoint this can be very cool: a climactic one-on-one duel with the hero&#39;s personal nemesis! But from a gameplay perspective, it often falls flat, because a big part of RPG gameplay is the synergy between multiple characters and actions. If you and the enemy are just trading blows, your options are much more limited; you (usually) can&#39;t heal and attack at the same time, for instance.

A timeline system works very well for fixing these issues. If the player can act multiple times for every action of the enemy&#39;s, you can still have tactics and synergy even with only one character. Perhaps there is a puzzle-like mechanic of matching different attacks to different enemies or guard states and you must carefully time your actions to attack and defend, almost simulating a more action-focused game? It&#39;s something worth considering if you want to use a duel system.

Noteworthy examples:
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://store.steampowered.com/app/418190/Helens_Mysterious_Castle/&quot; target=&quot;_blank&quot;&gt;Helen&#39;s Mysterious Castle&lt;/a&gt;&lt;/i&gt; is an example of an action-adventure-like system. You can choose various weapons on your turn, and each has a different speed, attack, defense value. Strategy consists of timing your attacks so that you attack when the enemy is weak and shield yourself when the enemy is attacking.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/8032/&quot; target=&quot;_blank&quot;&gt;Red Syndrome&lt;/a&gt;&lt;/i&gt; is a simpler example: all enemies must wait multiple turns between actions, creating a system where you have several turns to prepare for a coming onslaught.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;flow.4&quot;&gt;Transparency&lt;/h3&gt;
If you use a turn ordering system, it&#39;s beneficial if you can show the turn order to the player. This will allow them to plan in advance by understanding when, say, they need to guard against an enemy&#39;s attack or when they should buff a certain character.

Doing this in a ranked order system is very simple: instead of running the selector every time a new character&#39;s turn comes up, make an array of all the characters in descending initiative order every round. You can display the array somewhere in the battle screen, and run through it as the round progresses.

Timeline systems are also fairly straightforward: you can display everyone&#39;s initiative as &quot;ticks until next action&quot; in their status pane or elsewhere. Ideally, with enough knowledge of CSS, you could create a visual representation showing everyone&#39;s placement in the timeline.

Action time systems are a little trickier. You&#39;d need to simulate another round of initiative gain and use that to determine the next actor. This is both algorithmically difficult and processor-intensive to do for more than one or two predictions, so don&#39;t worry if you can&#39;t give the player an extended prognosis. This will be even tricker if you have skills that alter speed stats or initiative values, as you&#39;ll have to redo the prediction every time that happens.

Simplistic models of these preview systems are proposed in the &quot;preview model&quot; passages, found next to the initiative model passages. However, they are untested, and may not be suitable for all your needs. You can tweak them as necessary.

&lt;i&gt;Final Fantasy X&lt;/i&gt; has an extremely robust preview system, with an extended prognosis and real-time feedback whenever an ability that would affect the turn order is used. You can try mimicking it if you -- and your processor -- are feeling ambitious!

&lt;h2 id=&quot;progress&quot;&gt;Progression and Leveling Up&lt;/h2&gt;
Leveling up is traditionally one of the core features of the RPG. As you win battles or complete tasks, you will gain experience points that will eventually award you a new level, increasing your stats and giving you access to new abilities. This gives the player a sense of progress throughout the game, and also allows the designer to introduce new mechanics and tactical complexity at a gradual pace, ensuring that the player can become familiar with every one of their tools before they&#39;re given a new one. And, let&#39;s be honest -- it&#39;s just fun to watch numbers go up.

However, even if you&#39;ve played RPGs before, you&#39;ve probably never stopped to think about how, exactly, these features are designed. Exactly how does the game calculate how many experience points you need to get to the next level? Exactly how does the game calculate how to increase your stats on a level up?

As with everything in this list, the answer is, &quot;It depends on what experience you, the designer, want to cultivate!&quot; However, that&#39;s easier said than done. Progression mechanics are some of the hardest things to design and balance, because they have impacts throughout the entire game. You should also understand that leveling up isn&#39;t the only way to accomplish this! We&#39;ll discuss alternative progression methods as well, such as point-buy and equipment-based systems.

You may notice that &lt;i&gt;Cartoon Battle&lt;/i&gt; doesn&#39;t feature any progression mechanics. That&#39;s because implementing and balancing this is actually very tricky! You will need to plan very far ahead, and balance your game not only for one state but for situations where the player&#39;s capabilities will change over time.

For further reading, see the video &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=Ae_zvm0-CQU&amp;list=PL8K0_g1wdQepKF0a8eh_4dhhivcSrSKyO&amp;index=20&quot; target=&quot;_blank&quot;&gt;What Makes a Good Level Up System?&lt;/a&gt;&quot; by Design Doc, which provides another designer&#39;s opinions on the progression systems discussed here.

&lt;h3 id=&quot;progress.levels&quot;&gt;Levels&lt;/h3&gt;
We&#39;ll start with the one you&#39;re likely most familiar with: Characters gain experience points, or XP, from succeeding at gameplay challenges (often killing monsters, but possibly also solving puzzles, navigating conversations, or completing quests). When a character&#39;s XP reaches a certain value, they level up and gain increments to various stats. They may gain new abilities as well, but &lt;a class=&quot;noExternal&quot; href=&quot;#progress.skills&quot;&gt;that is another discussion entirely&lt;/a&gt;.

Predetermined levels, where the player has no control over the bonuses of a level up, are common in Japanese-style RPGs such as &lt;i&gt;Dragon Quest&lt;/i&gt;. (Western RPGs such as &lt;i&gt;Baldur&#39;s Gate&lt;/i&gt; tend to favor a more open-ended format where levels will give the player some choice over their desired bonus, but that is discussed under &lt;a class=&quot;noExternal&quot; href=&quot;#progress.pointbuy&quot;&gt;point-buy systems&lt;/a&gt;.) This method requires the least engagement from the player, as most of the decisions -- when their characters will get stronger and by how much -- are made for them, with all the pros and cons that implies. This method is probably the easiest to balance, as it is easy to predict a player&#39;s capability at a given point in the game when their progression is fixed. However, it also means you&#39;ll have to plan out every character&#39;s progression yourself, which can be a big task!

You should be able to identify two important design questions here: &lt;b&gt;How much XP do characters need to level up?&lt;/b&gt; and &lt;b&gt;What are the exact benefits of a level up?&lt;/b&gt; There is a potential third question, related to the first, which is what situations will provide XP and how much.

&lt;h4 id=&quot;progress.levels.1&quot;&gt;Calculating XP Requirements&lt;/h4&gt;
You could, in theory, design unique XP requirement values for every single level. However, this is not what most games do, and it is not recommended. It&#39;s much easier to design a formula that will generate XP requirements for every level automatically.

The simplest scenario would be no variable formula at all: every level requires the same amount of XP. However, this doesn&#39;t make much sense as a design principle. If you&#39;re guaranteed a level up every time you, say, kill 10 of the enemies in the starting area, yet each level makes you stronger, you&#39;ll kill enemies faster and gain levels faster with each level up, all without even needing to leave the starting area. This model is sometimes viable in certain RPGs with &quot;elastic&quot; difficulty, where enemies have their own levels and become stronger with the player characters, maintaining the same relative difficulty no matter the player&#39;s level. However, this is rather complicated to implement, and not the playstyle most RPGs aim for.

You might think the best method would be a linear scale: If going from level 1 to level 2 requires 1000 XP, then from 2 to 3 requires 2000 and from 3 to 4 requires 3000, etc. This can work, but it still tends to make leveling too rapid and players too complacent. To really force players to move on to harder challenges, you need an &lt;b&gt;exponential&lt;/b&gt; scale, meaning the difference &lt;i&gt;of&lt;/i&gt; the difference in XP requirements becomes greater with every level.

As an example, here is the XP formula for &lt;i&gt;Dungeons and Dragons 3rd Edition&lt;/i&gt;:

&lt;div class=&quot;formula&quot;&gt;XP to next level = 500 * (level ^ 2) - 500 * level&lt;/div&gt;
(Technically, this function is quadratic, not exponential, but the principle still applies.)

Here&#39;s what that looks like graphically:

[img[setup.ImagePath + &quot;documentation/levels1.PNG&quot;]]

Notice that this growth curve is extremely steep; we can&#39;t even see the XP requirement for the maximum level, 20, without extending the Y-axis. After only 4 levels, the XP requirement is 10 times that of level 2.

This is because, in &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, every level is intended as a rare and major accomplishment. You might only gain one or two levels during a &quot;chapter&quot; of the story, and you&#39;re unlikely to go all the way from level 1 to level 20 in anything but the longest campaigns. &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; also provides the bulk of its XP rewards through major, one-time accomplishments, such as completing quests, rather than many repetitive actions such as killing individual monsters. A steep formula such as this encourages players to focus on big actions such as pursuing side quests, and rewards close engagement with the world to find such opportunities.

You tend to see steep formulas like these in Western RPGs, which are more directly based on &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, than in Japanese-style RPGs such as &lt;i&gt;Dragon Quest&lt;/i&gt;. Twine&#39;s structure is actually well-suited to the style of a Western RPG, so this formula may be worth considering.

On the opposite end of the scale, we have the &quot;medium fast&quot; XP formula from &lt;i&gt;Pokemon&lt;/i&gt;. Different Pokemon use different formulas, but this one is the most common:

&lt;div class=&quot;formula&quot;&gt;XP to next level = (level ^ 3)&lt;/div&gt;
Or graphically:

[img[setup.ImagePath + &quot;documentation/levels2.PNG&quot;]]

This curve is &lt;i&gt;much&lt;/i&gt; shallower. While the first formula exceeded our graph&#39;s bounds almost immediately, we can fit 20 levels on this scale no problem. (There&#39;s no trickery here: the axes have the same scaling as before.)

The reason for this is quite simple: In &lt;i&gt;Pokemon&lt;/i&gt;, level ups are meant to be frequent. Not only is the max level (100) much higher than in D&amp;D, but as a monster-collecting game, you are encouraged to raise a large number of &quot;party members&quot;. Players are supposed to vary their team and swap out Pokemon over the course of the game. To incentivize this, the game has to make it easy for lower-level Pokemon to catch up if they&#39;ve been off the team for a while. Thus, low XP requirements.

Shallow formulas are common in Japanese-style RPGs, which tend to make levels more frequent but less individually significant. This incentivizes the player to pursue many small-scale actions that result in incremental rewards, rather than big jumps. You should pick this formula if you want a &quot;grindy&quot; game designed around repetitive actions with frequent payouts.

You don&#39;t strictly need a formula at all: it&#39;s also possible to use a lookup table with unique values for every single level. But a formula is probably a good starting point if you&#39;re new to designing these mechanics.

It should be noted that this is all a &lt;i&gt;gross&lt;/i&gt; oversimplification that only scratches the surface of this topic. Things get vastly more complicated if you want more nuance, such as different leveling rates for different characters (older versions of D&amp;D did this, making wizards require more XP per level because they got more out of levels), or elastic leveling where the difference between the hero and enemy&#39;s levels affects the payout (useful for discouraging grinding and catching up low-level characters). You&#39;ll need to ask around (and learn some math) if you want to tweak your leveling mechanics for something particular. I&#39;d recommend starting by looking up the mechanics from your favorite games -- famous ones such as &lt;i&gt;Dragon Quest&lt;/i&gt;, &lt;i&gt;Pokemon&lt;/i&gt;, and &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; are usually well-documented. Break them down by thinking about what you liked and disliked about them, and work from there.

&lt;h4 id=&quot;progress.levels.2&quot;&gt;What Do Levels Do?&lt;/h4&gt;
So say a character has leveled up. What happens now, exactly? Generally, the character&#39;s stats are supposed to increase. But by how much?

Some games make stat gains random. I hate this with the intensity of a thousand burning suns and will speak no more of it here. Go to &lt;a href=&quot;http://howtomakeanrpg.com/a/how-to-make-an-rpg-levels.html&quot;&gt;How to Make an RPG&lt;/a&gt; if you wish to pursue this heathen practice.

If you wish to be &lt;i&gt;sensible&lt;/i&gt; and make your stat gains totally deterministic, then like XP gain, there are two ways to do this: either through a formula, or by manually setting stats for every level through a lookup table. To effectively design the latter you will need to understand the former, so that&#39;s what I will discuss.

The principles for designing a stat growth formula will depend, obviously, on what those stats do and the progression you want to see over the course of the game. In some games, even a single point of a stat can be significant, while in others, stats only have a noticeable effect at high values. You&#39;re going to want to review your damage formula and anything else stats might affect, such as status effects and &lt;a class=&quot;noExternal&quot; href=&quot;#flow&quot;&gt;turn order&lt;/a&gt;. There is also the matter of &quot;power creep&quot;, discussed in the damage formula section: you likely want things to get bigger and flashier as the game progresses, but by how much? Do you want average attack damage to increase at a gradual, linear rate, or at an exponential one that makes the endgame feel like a totally different world than the beginning? This will also be influenced by the XP gain model you&#39;re using: if levels are rare, you will probably want them to provide big gains, while if levels are frequent, you will probably want smaller gains per level.

If you want to preserve character specializations, you&#39;ll also want these formulas to be different for different characters. A wizard should probably gain Defense more slowly than Magic, for instance.

RPG Maker has default formulas for calculating stat growth of various character archetypes, though I cannot find good documentation for this. If you would like to devise your own, I recommend starting with a small-scale game where each stat point matters, and making stat gains very small. This will be easier to test and balance, as even small changes will have highly visible effects. Learning from example is harder here, as most commercial RPGs use random stat gains. If it works for them and you don&#39;t want to bother with complex math you could consider trying it I GUESS.

More atypical arrangements have been devised by some games. You could make stat growth dependent on one or more other variables, as seen with &lt;i&gt;Pokemon&lt;/i&gt;&#39;s IV and EV values. (That&#39;s detailed &lt;a href=&quot;https://bulbapedia.bulbagarden.net/wiki/Statistic#Determination_of_stats&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;, for the curious.) You could also decrease the influence of stats by making level a factor in gameplay formulas that use stats, maybe only increasing stats rarely or through other means. This is particularly useful for player-determined stat growth systems, as it gives you a general power level to expect for balance testing, even if the player uses a build you hadn&#39;t thought of.

&lt;h4 id=&quot;progress.levels.code&quot;&gt;Implementation&lt;/h4&gt;
Skeleton code for levels and growth tables are included but not detailed in the story JavaScript at the end of the &quot;Puppet&quot; class definition. To actually implement a level up feature, you&#39;d create a widget or another passage that checks the character&#39;s current XP against the next level&#39;s requirement, and run it whenever a character gets XP. (To save yourself time, you could even make it part of the same code that gives a character XP.) Within this function, you&#39;d determine the stat gains through your formulas or through a lookup table, and do the same to find the XP requirement for the next level.

(A word of warning if you&#39;re using a lookup table: while the most intuitive method is to have the lookup value correspond to the &lt;i&gt;absolute&lt;/i&gt; stat values you want at that level, if you have events that change base stats through means other than leveling, the lookup table will overwrite those changes! You will have to either store those changes through a separate value, or make the lookup table point to increments instead of absolute values.)

Example widgets for this implementation are provided in the &quot;Widgets: Leveling Up&quot; passage.

&lt;h3 id=&quot;progress.pointbuy&quot;&gt;Point-Buy&lt;/h3&gt;
This is an alternate form of stat progression used by several RPGs, including famous franchises like &lt;i&gt;Shin Megami Tensei&lt;/i&gt; and tabletop RPGs like &lt;i&gt;Exalted&lt;/i&gt;. Instead of stats being automatically incremented at fixed rates, the player is given control over which attributes they want to improve. You can combine this with a regular leveling system, with every level up giving one or more stat points, or allow players to spend XP on stat upgrades directly.

(If you do the former, however, it&#39;s recommended you don&#39;t make the number of points per level up divisible by the total number of stats. A lot of players will want to give the same amount of points to all stats just because that&#39;s the simplest option. You&#39;ll get more engagement if you force them to make a choice.)

This system is popular for the freedom it gives to players, but it can be very difficult to balance due to the many stat arrangements possible as the game progresses. If you design challenges assuming players will add points in a specific arrangement and then a specific player creates a build you didn&#39;t expect, the player could have a very hard time. You&#39;ll need to do a lot of balance testing to ensure it isn&#39;t possible for the player to push themselves into a corner. Ideally, no build should be universally better than another; the player should be allowed to choose a build based on their preferred playstyle, not bite their nails over if they&#39;ve made the objectively best option.

Some games that use this system allow the player to undo their investments and reconfigure their build. This eliminates the possibility of locking the player into a non-viable build, but potentially eliminates some strategic depth as well. It can be a purposeful design decision to make certain builds more optimal in certain situations and less optimal in others; if the player can just respec to find the optimal build in every situation, the game might become too easy or too uniform. However, you may like this idea as a &quot;puzzle&quot; aspect, forcing the player to think about the optimal allocation of their resources for difficult challenges.

One possible drawback to this system is the elimination of character specialties. Characters in RPGs typically have differing stat layouts that lead to different roles. However, if the player has total control over characters&#39; stat layouts, these specialties can disappear; there&#39;s nothing stopping them from putting all the wizard&#39;s points into Strength or all the fighter&#39;s into Intelligence. Sometimes it can be fun to see how these non-standard builds play out, but sometimes you do want to keep a role fixed. You could enforce this through a &quot;soft&quot; method by giving characters or classes fixed capabilities that draw on specific stats, encouraging players to invest in certain stats over others. (If a fighter can&#39;t use magic, for instance, there&#39;s no reason to increase their Magic Attack even if you technically can.) Alternatively, you could use a &quot;hard&quot; method of making certain stat improvements cost more for certain characters. It might actually be a good idea to pump up the wizard&#39;s Defense, but if that costs twice as many stat points as improving Magic, you won&#39;t be able to do it as often. Alternatively, you could make stat improvements small compared to initial stats -- this makes it hard for low stats to &quot;catch up&quot; with high ones even if there is no cost weighting.

The other thing you&#39;ll need to watch out for is whether or not it&#39;s possible to get everyone to perfect stats eventually. If everyone can be fully maxed out, that&#39;s the end goal players will shoot for -- and at that point, everyone&#39;s the same! (&lt;i&gt;Final Fantasy X&lt;/i&gt; famously had this issue, where the advancement grid was shared by everyone, allowing characters to gain the exact same stats and skills as other characters if they leveled up enough.) It&#39;s easy enough to fix this if you don&#39;t want it -- as you&#39;d define a level cap in a leveling system, you can create a cap on either stat totals or number of stat purchases -- though you&#39;ll probably want to make this clear to the player! You could also make experience points a limited resource.

This system has a lot of potential variations, so it&#39;s worth looking at lots of different games that use it. You can have fun tradeoff mechanics by making &quot;stat experience&quot; useful for other things as well -- most commonly, the mechanic is framed as paying a trainer to improve your skills, which means you have to choose between items and stat improvement when deciding how to spend your money.

&lt;h4 id=&quot;progress.pointbuy.code&quot;&gt;Implementation&lt;/h4&gt;
Combining this feature with a level up system is easy: just add a &quot;stat point&quot; attribute to the Puppet class and increment it on level up. Then you just have to add another passage/menu where players can spend them. (Note that you will need to save the total points accumulated in a separate attribute from the character&#39;s spendable points if you want to provide a respec option.)

The passage &quot;Point-buy interface example&quot; provides an example of how you might implement this in a menu.

A &quot;free buy&quot; system is a little trickier, but is fundamentally similar to the code used to calculate XP requirements for levels: you would create a widget or JavaScript function to calculate the XP cost, and pass it the necessary variables. It&#39;s recommended you make XP costs increase at higher stat values, just as levels have increasing XP requirements. You could make every improvement increase the cost of all future improvements, or make it a function of the current stat only. The latter method disincentivizes overspecialization and encourages players to spread out their improvements. As with a stat-points-by-level-up system, you would need to record total XP separately if you want to enable a respec system. You might also want to make the cost growth dependent on &lt;i&gt;upgraded&lt;/i&gt; rather than &lt;i&gt;total&lt;/i&gt; stats, which would necessitate another variable for storage.

An example of such a calculation function is provided in the story JavaScript as a method function of the Puppet class.

&lt;i&gt;Bonfire&lt;/i&gt; has an example of a point-buy system: though heroes level up within individual game stages, they restart at level 1 whenever they start a new stage. The only way to permanently improve their stats is to buy upgrades with gold accumulated from journeys. A chart of the upgrade costs is &lt;a href=&quot;http://bonfire-game.wikia.com/wiki/Upgrading_Heroes&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;, though no clear function has been derived; it is likely a complex piecewise function, or a lookup table of unique values.

&lt;h3 id=&quot;progress.equip&quot;&gt;Equipment-Based Progression&lt;/h3&gt;
Most RPGs feature an equipment system of some kind in addition to levels. In effect, this can create two simultaneous paths of power progression: you can improve your abilities both by leveling up and by buying better equipment.

I mentioned in [[the design page|Design]] that I tend not to like this model, as it feels redundant: not only does the player usually improve equipment through the exact same methods as you improve levels -- killing monsters and doing quests usually give you both XP and money -- but equipment often conveys the same benefits as level ups (stat boosts, more damage, etc.). What this means is that not only are you never forced to choose between levels and equipment, there wouldn&#39;t be much significance to the choice even if you were.

To avoid this problem, I recommend giving equipment and levels categorically distinct contributions to the character. They shouldn&#39;t improve power in exactly the same way all the time. This can be seen in &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, where levels tend to grant qualitative changes -- additional actions to take, bonus to circumstantial situations, etc. -- while equipment is one of the only ways to obtain quantitative improvements, such as better damage and armor. This can make choosing between gold and XP a meaningful choice that forces the player to think about exactly how they want to improve their character. That kind of engagement typically makes for a more enjoyable experience, so it&#39;s something you should shoot for.

Some games go even farther, and make equipment the &lt;i&gt;only&lt;/i&gt; method of power progression. Under this model, there are no levels or inherent bonuses: all your growth comes from finding better equipment. Want stronger attacks? Get a better weapon, or you&#39;re out of luck. This can create an interesting effect where your characters are completely modular, especially if you make equipment govern &lt;i&gt;actions&lt;/i&gt; as well. At any point, you can completely reinvent a character, swapping their capabilities with another. Such games typically give characters some unique stat or ability differences to avoid making them completely interchangeable, but the system will still be highly mutable.

One potential downside of this system is that it can remove the incentives from normal gameplay, if you adopt a jRPG model of many mundane, grindy tasks. Even if you reward players with money with which to buy more equipment, players will typically hit a ceiling very quickly and find themselves with nothing to spend it on until they reach the next area with better equipment. This can shatter the Skinner-box action-to-reward mentality that many games run on, and leave players feeling bored and frustrated. On the other hand, this may be better for more narrative-driven experiences that revolve around a small number of set-piece challenges.

Additionally, this method must be balanced more carefully than usual, due to something obvious but often overlooked: If players start with no equipment at all, they will hit what feels like a ceiling as soon as they fill all their slots. Where before everything was an absolute improvement, now they must make tradeoffs to progress further. You will have to structure your game carefully such that equipment continues to improve at a consistent rate, and that this is communicated to the player. For this reason, this system tends to be better suited to shorter games where this issue will not become as pronounced.

Narratively, this is an effective way to convey a sense of realism. In real life, people don&#39;t just magically get tougher, stronger, and faster by being really good at something; the skills obtained through training and practice tend to pale in comparison to the advantages of getting better weapons and technology. Outsourcing all the player&#39;s power to something else reminds them of that fragility, especially if you do something cruel like letting enemies steal or destroy their items. This can be very good for an RPG in a modern setting, or one with a strong focus on technology.

Notable examples:
* &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5904/&quot; target=&quot;_blank&quot;&gt;Czarina Must Die!&lt;/a&gt;&lt;/i&gt; tends to run into the problems I outlined towards the end; it unfortunately uses random encounters &lt;i&gt;as well as&lt;/i&gt; quickly making equipment purchased with money obsolete, giving the player little incentive to fight monsters.
* &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/4526/&quot; target=&quot;_blank&quot;&gt;Wine &amp; Roses&lt;/a&gt;&lt;/i&gt; and some of the other games in the same &quot;genre&quot; by the same developer use equipment for both stat and skill advancement. Inherent bonuses sometimes feature as well, but they are rare and minor in comparison.
* &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5132/&quot; target=&quot;_blank&quot;&gt;In Search of Immortality&lt;/a&gt;&lt;/i&gt; uses a very literal approach: all equipment is just literally a stat boost, with stronger boosts dropped by monsters as you progress.

&lt;h3 id=&quot;progress.statgrind&quot;&gt;Stat Grinding&lt;/h3&gt;
There is another progression method known as &quot;activity-based leveling&quot; or, more colloquially, &quot;stat grinding&quot;. The premise of stat grinding is that, unlike with experience levels, which give you across-the-board improvements at intervals, you improve your stats or skills individually by performing actions related to them. For example, attacking with a weapon may improve your skill with that weapon type, or getting hit might improve your defense score.

This approach can feel a lot more &quot;realistic&quot; than experience levels, as it&#39;s much closer to how you improve skills in real life. It can also provide more organic gameplay and character progression, as characters will naturally get better at whatever playstyle you prefer to use for them. It can be fun to start with a party of very similar &quot;blank slate&quot; characters and watch them diverge based on how you use them, and also adds replay value when every character has so many potential builds. (Note that you don&#39;t &lt;i&gt;need&lt;/i&gt; for every character to start the same, though! Especially in multi-character setups, you can still encourage growth in one direction or another by making it easier or harder for certain characters to improve skills.)

In practice, however, this approach has a lot of problems and pitfalls. Optimum play under this system often turns out to be unintutive and highly bizarre. An infamous example is from &lt;i&gt;Finaly Fantasy II&lt;/i&gt;, where players were incentivized to attack their own characters to gain HP bonuses. Depending on how broad the system and statistics are, this can also encourage tedious and repetitive actions; another infamous example is players constantly jumping to improve their acrobatics skill in &lt;i&gt;The Elder Scrolls&lt;/i&gt;. Even aside from this, issues of scale crop up: How does a developer encourage the player to move on to stronger enemies, if the rewards of battle are based on the player&#39;s actions and not the difficulty of the encounter? Experience levels can easily deal with this problem by progressively increasing experience requirements and rewards, but with stat grinding the solutions are less obvious.

One solution is indeed to make stats and skills function just like levels, with increasing experience requirements for each improvement. This is the method used by &lt;i&gt;The Elder Scrolls&lt;/i&gt; series. However, the details of this can be complicated. Do you want different stats to have different experience curves? What about different gain rates? How do you determine how much experience to give per action? If you keep the hit-to-kill ratio constant throughout the game -- as you probably should -- then surely stat improvement will slow down as the player takes the same number of actions per battle but requires more actions to level up? &lt;a class=&quot;noExternal&quot; href=&quot;#progress.levels.1&quot;&gt;All the questions and calculations you have to make for experience levels&lt;/a&gt; will now have to be made for &lt;i&gt;every single stat&lt;/i&gt;. This can be a daunting task!

Another method is to still use levels behind the scenes. This is the method used by &lt;i&gt;Final Fantasy II&lt;/i&gt;: Every enemy is assigned a hidden &quot;rank&quot; statistic that is added to the experience points awarded for every action in battle. The experience reward is, in turn, &lt;i&gt;decreased&lt;/i&gt; by the rank of the skill used (weapon or spell), requiring the player to fight stronger enemies to improve their skills. In this system, every skill level requires the same amount of experience to improve; it is the experience per action that changes to create a progression curve.

If you plan to use this system, I recommend looking at examples of games that have tried it before. Observe their strengths, pitfalls, and different methods of implementation. This is a very delicate and finnicky system, and will require a lot of care to balance properly. One area in particular I&#39;d recommend looking into is the problem of defensive stats: Stat grinding works well for actions that the player can make directly, such as attacks, but invites difficult questions when it comes to passive abilities. Unless you use something like [[an aggro system|Design]], the player has no control over who gets hit by attacks -- unless, of course, they attack their own characters, which is nonsensical. And even if you do have an aggro system, placing fragile characters away from danger can actually be a bad idea, as it prevents them from ever getting tougher, leaving them increasingly vulnerable to area attacks and the like. (This was another infamous problem with &lt;i&gt;Final Fantasy II&lt;/i&gt;, and in large part why the friendly fire method of training was necessary.) &lt;i&gt;The Elder Scolls&lt;/i&gt; sidesteps this issue by divorcing HP gain from the standard stat grinding model and instead granting the player an automatic bonus after they have improved enough skills; I would recommend doing something similar.

Notable examples:
* &lt;i&gt;The Elder Scrolls&lt;/i&gt; is one of the most famous RPGs of this type. Though the very first game used standard experience levels, later games used a stat grinding system based around gameplay-relevant skills. The series has extensive fan documentation via &lt;a href=&quot;http://en.uesp.net/wiki/Main_Page&quot; target=&quot;_blank&quot;&gt;its wiki&lt;/a&gt;, with pages detailing the advancement mechanics for the &lt;a href=&quot;http://en.uesp.net/wiki/Daggerfall:Leveling_and_Skills&quot; target=&quot;_blank&quot;&gt;second&lt;/a&gt;, &lt;a href=&quot;http://en.uesp.net/wiki/Morrowind:Skills&quot; target=&quot;_blank&quot;&gt;third&lt;/a&gt;, &lt;a href=&quot;http://en.uesp.net/wiki/Oblivion:Increasing_Skills&quot; target=&quot;_blank&quot;&gt;fourth&lt;/a&gt;, and &lt;a href=&quot;http://en.uesp.net/wiki/Skyrim:Leveling&quot; target=&quot;_blank&quot;&gt;fifth&lt;/a&gt; games in the series.
* &lt;i&gt;Final Fantasy II&lt;/i&gt; and its spritual successor, the &lt;i&gt;SaGa&lt;/i&gt; series, are famous jRPG examples of this type. The mechanics are documented fairly comprehensively &lt;a href=&quot;https://guides.gamercorner.net/ffii/systems/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. Note that statistic improvements were very different (and much simpler) than skill and spell improvements, with actions simply giving the character a random chance of improving the stat by 1 point.
* &lt;i&gt;Pokemon&lt;/i&gt;, though primarily an experience level system, uses a form of this. Pokemon have an &quot;Effort Value&quot; (sometimes called &quot;stat experience&quot; by players) associated with each stat that is used to calculate the effective stat through &lt;a href=&quot;https://bulbapedia.bulbagarden.net/wiki/Statistic#Formula&quot; target=&quot;_blank&quot;&gt;a complicated formula&lt;/a&gt;. In addition to each stat having a maximum possible Effort Value, the &lt;i&gt;total&lt;/i&gt; Effort Value points a Pokemon can have is also limited, creating a specialized distribution of stats. However, unlike most stat grinding systems, stat experience is gained not by performing relevant actions, but by defeating enemy Pokemon. Like many mechanics in &lt;i&gt;Pokemon&lt;/i&gt;, almost none of this is explained to the player in the game and the whole system is very opaque, a fact that has generated much frustration among players. Don&#39;t be like &lt;i&gt;Pokemon&lt;/i&gt;: be clear and transparent if you use a system like this.

&lt;h3 id=&quot;progress.fixed&quot;&gt;Fixed or Story-Based Progression&lt;/h3&gt;
Some games take the control out of the player&#39;s hands, and provide improvements only at fixed points in the game. You may only gain a new ability or stat boost after beating a boss, reaching the next area, or progressing the story.

This is a very direct way of implementing a progression system, but also a bare-bones one. A big benefit of an experience and leveling system is that the player will always gain a tangible reward for engaging with the game; take that away, and they may just feel like the game&#39;s challenges are a waste of time. (Of course, you should be making your game intrinsically rewarding to play &lt;i&gt;anyway&lt;/i&gt; -- if you can kill a player&#39;s motivation by taking away an extrinsic reward, you&#39;re not making a very fun game.) It does, however, give the designer immense control over the player&#39;s experience. You don&#39;t have to worry about a player being over- or underleveled, or picking a weird build; you know exactly what state they&#39;ll be in going into every battle. Used well, this method can therefore be used to craft tighter and more complex challenges, and to ensure no player is left behind.

Some games will mix this concept with more standard progression systems. For instance, the game may use a leveling system for most of its mechanics, but the player may also be given a special ability for reaching a certain point in the story. You can also strike a compromise of still allowing the player control over their progression by making experience points a limited resource only awarded at certain benchmarks in the game.

Equipment-based progression is often a subtle form of this, as better equipment usually can&#39;t be obtained until the player progresses in the game.

This method can work well for narrative-heavy RPGs that revolve around a small number of set-piece battles rather than many less significant encounters, and can even be used to tie the gameplay and story together by justifying the characters&#39; improvement through in-story beats. I also recommend some form of this for RPGs with puzzle-like encounters that are balanced assuming the player has access to a specific ability.

Notable examples:
* &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/6554/&quot; target=&quot;_blank&quot;&gt;Null Regrets&lt;/a&gt;&lt;/i&gt; and &lt;i&gt;&lt;a href=&quot;https://laburatory.itch.io/lgd&quot; target=&quot;_blank&quot;&gt;Long Gone Days&lt;/a&gt;&lt;/i&gt; both eschew levels entirely and award new skills only after clearing chapters of the story. However, this has led to the criticism that players feel little point in fighting non-critical battles.
* Games from the developer Craze, such as &lt;a href=&quot;https://rpgmaker.net/games/4526/&quot; target=&quot;_blank&quot;&gt;Wine &amp; Roses&lt;/a&gt;, use a non-linear form of this. There is no leveling system, but every battle rewards the player with a specific new ability or powerup. The choice of what fights to tackle and when give the player immense control over their progression despite its fixed nature, making the game feel similar to a Metroidvania.
* &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Torment:_Tides_of_Numenera&quot; target=&quot;_blank&quot;&gt;Torment: Tides of Numenera&lt;/a&gt;&lt;/i&gt; makes experience points a limited resource. They are primarily gained by completing quests and advancing the story, but players can also gain a few points by finding secrets in the world. You can comfortably reach the max level if you are diligent at completing quests, but your specific capabilities are determined by the choices you made at each level up.

&lt;h3 id=&quot;progress.skills&quot;&gt;Skill Progression&lt;/h3&gt;
Most RPGs don&#39;t just improve characters&#39; stats as the game progresses; they provide the player with new abilities as well. Fighters gain new feats such as Power Attack, wizards gain new spells, rogues gain new skill points, and so on. This is crucial for keeping the player engaged, as it makes the game and the player&#39;s experience evolve in complexity over time.

However, there is the question of how fast you introduce new abilities, what abilities you introduce, and if you want a creeping power curve of stronger abilities over time. If you give the player too many abilities too quickly, they will be overwhelmed, and individual abilities won&#39;t have time to shine. If you dole out abilities too slowly, players may lose interest and find the game repetitive.

You should generally gate more complex abilities behind later progression markers. This is why many RPGs either start you with fighter-type characters or with only a few basic spells. The player needs time to master the basic mechanics of the game before they can be introduced to new twists like limited resources, elemental weaknesses, and status effects. In turn, give the player time to get used to each new mechanic before introducing them to another.

One particular quirk of skill progression, especially in jRPGs, is that mage-type characters tend to have their effectiveness tied to specific skills more than their stats. You might start the game with access to Fire 1, then later, you learn Fire 2, which is identical in function but stronger. This is most easily handled by pairing a constant damage value with a smaller stat damper (see the damage formula section in [[Design]]), such as &lt;i&gt;C + (A/2) * a.magic - B * b.mdf&lt;/i&gt;, where A is the stat coefficient for regular attacks. A large &lt;i&gt;C&lt;/i&gt; constant will make a spell very powerful initially, but it will wane in usefulness as enemies gain more HP, and the smaller stat coefficient on Magic Attack will prevent stats from making up the difference. In comes Fire 2, with the same formula but a larger constant, and your mage is back in power... until enemies get stronger again.

This method is reasonable when magic functions as a limited resource. Typically, characters gain more magic points or spell charges as they level up, so you become able to use the same spells more often. It wouldn&#39;t make sense for a spell you can use 3 times to be just as effective when you can use it 6 times, as that would trivialize battles. You need a way for spells to wane in effectiveness as they become cheaper to the player.

However, this approach is widely disliked by modern gamers, because it leads to a lot of spells that you&#39;ll never use after a certain point. Once you get Fire 2, there&#39;s no reason to use Fire 1 again -- it&#39;s just a useless entry taking up space in your skill menu. Western RPGs based on &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; avoid this problem by allowing all spells to keep up with the caster&#39;s power level -- even basic spells will gain bonuses as you level up, keeping them competitive even at higher levels. However, this can lead to a new problem of making mages overpowered, because they&#39;re improving their old abilities &lt;i&gt;while also&lt;/i&gt; gaining new abilities at the same time, leading to exponential power growth.

The tiered spell approach is effective, but it&#39;s also lazy. I encourage you to come up with more creative solutions. Maybe &lt;i&gt;don&#39;t&lt;/i&gt; let the player increase their MP, keeping their spells-per-dungeon ratio constant throughout the game? Maybe make dungeons longer or harder, necessitating the use of more spells even though they&#39;re just as useful throughout? You could also try making skill upgrades purely qualitative, rather than quantitative -- a new option like a status effect or another element, but nothing strictly better than what the player already has access to.

&lt;h2 id=&quot;battlegrid&quot;&gt;Battle Grid&lt;/h2&gt;
In the default engine, the placement and order of characters in a party doesn&#39;t matter. You can stack as many characters into the party as you want, but they&#39;ll all exist in a nebulous space where everyone is equally vulnerable to attacks and every enemy is in reach.

This is a nicely simple model, but not all RPGs use it. Some RPGs make space and positioning matter.

You&#39;re probably most familiar with this in the form of &quot;tactical RPGs&quot; like &lt;i&gt;Final Fantasy Tactics&lt;/i&gt; or &lt;i&gt;Fire Emblem&lt;/i&gt;, where battles take place on huge maps, characters can move a limited distance per turn, and attack range may be limited. Something &lt;i&gt;that&lt;/i&gt; complex is beyond the scope of the engine at the moment (though you may be interested in &lt;a href=&quot;https://sinisterdesign.net/products/telepath-tactics/&quot; target=&quot;_blank&quot;&gt;Telepath Tactics&lt;/a&gt;), but something of more moderate complexity can be enabled with the {{{BATTLE_GRID}}} variable.

&lt;h3 id=&quot;battlegrid.1&quot;&gt;Setup&lt;/h3&gt;
This is gonna get complicated, because it involves &lt;i&gt;\*shudder\*&lt;/i&gt; graphic design. We&#39;re going to have to first build a graphical representation of the grid for our webpage. Let&#39;s look at how that&#39;s done in the {{{battle grid.css}}} file:
{{{
.actors.grid {
  display: grid;
  justify-items: center;
  align-items: center;
  row-gap: 1em;
  width: 100%;
  height: auto;
}

.actors.grid.large {
	grid-template: repeat(2,1fr) / repeat(3,1fr);
}

.actor.grid {
  position: relative;
  width: 140px;
  min-height: 96px;
}

.actor.large {
	grid-column: 1 / 4;
	grid-row: 1 / 3;
	width: 100%;
	height: 192px;
	padding: 0;
	display: flex;
	flex-direction: column;
	text-align: center;
	justify-content: center;
	align-items: center;
}
}}}
You may recall from the actor setup notes in [[Documentation|Documentation (Advanced)]] that we added &quot;grid&quot; classes to the actors and their containers when {{{BATTLE_GRID}}} was enabled. Here, you can see how that class changes the display.
{{{
.actor.grid {
  position: relative;
  width: 140px;
  min-height: 96px;
}
}}}
We also need to modify the {{{actor}}} elements. This map is much more rigid than the standard display, so we can&#39;t have actor boxes stretching or shrinking based on their content; we need to fix them to a set width. &lt;b&gt;The width of these elements and the width of the {{{#content}}} element are going to determine how many columns your battle grid can span.&lt;/b&gt; By default, you can comfortably fit only 3 columns into the 640px-wide {{{#content}}} area. (You may do the math and think that &lt;code&gt;640 / 140 =&lt;/code&gt; 4 columns, but that&#39;s not accounting for padding and other spacing that&#39;s included in these elements.) If you want more columns, you will need to either expand the width of {{{#content}}} or shrink the size of the {{{actor}}} boxes.

The {{{large}}} class is the battle grid&#39;s equivalent of the {{{full}}} class in the normal display, a way to make enemy boxes bigger and more impressive-looking. By default, this is set to a defined size: 3 columns and 2 rows, spanning the full width of the container and the height of two actor boxes. Note that this assumes &quot;large&quot; enemies are the only characters on their map, as the class modifies the {{{actors}}} container itself. You may adjust this to suit your needs.

Savvy readers may notice at this point that we haven&#39;t set any dimensions (rows and columns) for our grid yet. The reason for that is because we want the grid to be able to shrink and expand to suit the user&#39;s needs, rather than fixing it to one set of dimensions. To define the dimensions, we go to {{{user storyinit}}}:
{{{
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;set setup.ROW_SIZE = 3&gt;&gt;
	&lt;&lt;set setup.COLUMN_SIZE = 3&gt;&gt;
	&lt;&lt;set setup.STATUS_SCREENS.menu.push(&quot;Formation&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
When you enable the battle grid, you also need to define the length of your rows and columns. By default, that&#39;s set to 3 each, the maximum width that can fit comfortably in the default display. These variables will be used for several functions relating to the grid, including the construction of the grid itself.

The next step is to create a representation of our grid as a data structure. This will be a two-dimensional array with elements corresponding to each cell in the grid. This is defined as &quot;battle grid setup&quot; in the {{{Battle Grid.tw}}} file.
{{{
&lt;&lt;set $puppetGrid = []&gt;&gt;
&lt;&lt;for _r = 0; _r &lt; setup.COLUMN_SIZE; _r++&gt;&gt;
    &lt;&lt;set _row to []&gt;&gt;
    &lt;&lt;for _c to 0; _c &lt; setup.ROW_SIZE; _c++&gt;&gt;
        /* Create the object used to store the default properties of a map cell. */
        &lt;&lt;set _cell to {
            id: (&quot;cell_r&quot; + _r + &quot;_c&quot; + _c),
            contents: null,
            movement: []
        }&gt;&gt;
        &lt;&lt;run _row.push(_cell)&gt;&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;run $puppetGrid.push(_row)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _puppet range puppets()&gt;&gt;
  &lt;&lt;set $puppetGrid[_puppet.row-1][_puppet.col-1].contents = _puppet&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;set $enemyGrid = []&gt;&gt;
&lt;&lt;for _r = 0; _r &lt; setup.COLUMN_SIZE; _r++&gt;&gt;
    &lt;&lt;set _row to []&gt;&gt;
    &lt;&lt;for _c to 0; _c &lt; setup.ROW_SIZE; _c++&gt;&gt;
        /* Create the object used to store the default properties of a map cell. */
        &lt;&lt;set _cell to {
            id: (&quot;cell_r&quot; + _r + &quot;_c&quot; + _c),
            contents: null,
            movement: []
        }&gt;&gt;
        &lt;&lt;run _row.push(_cell)&gt;&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;run $enemyGrid.push(_row)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _enemy range enemies()&gt;&gt;
  &lt;&lt;set $enemyGrid[_enemy.row-1][_enemy.col-1].contents = _enemy&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
We must create two grids, one for the puppets and one for the enemies. Each cell is populated with additional metadata, and each character is assigned to the {{{contents}}} property of the cell determined by their {{{row}}} and {{{col}}} values, which we have hopefully set before the battle.

Let&#39;s look at how to set up the grid in {{{actorlist}}}.
{{{
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;include &quot;grid actorlist enemies&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	(...)
}}}
Every section in {{{actorlist}}} includes this branch to split the functionality of the passage into grid and non-grid sections. The grid sections are defined in {{{Battle Grid.tw}}}, and look like this:
{{{
&lt;&lt;for _r, _row range $enemyGrid&gt;&gt;
	&lt;&lt;for _c, _cell range _row&gt;&gt;
		&lt;&lt;if _cell.contents instanceof Actor&gt;&gt;
			&lt;&lt;actorBox _cell.contents&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
				/* no content; empty box */
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
This code iterates over the grid object (rather than the party, as in the normal {{{actorlist}}}) and creates an actor box whenever it detects the cell is populated with an {{{Actor}}} object. Otherwise, we display an empty box with the {{{empty}}} class to denote a blank tile.

Now that all the elements exist, we still need to make sure they appear in the right position. By default, CSS grids will populate themselves in the order elements are created, left to right and top to bottom. That won&#39;t necessarily correspond to where the characters are supposed to be, so to make sure of that, we include this code in {{{actorBox}}}:
{{{
&lt;&lt;set _style = &quot;&quot;&gt;&gt;
&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
  &lt;&lt;set _class += &quot; grid&quot;&gt;&gt;
  &lt;&lt;set _style += _actor.gridArea&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
{{{gridArea}}} is an {{{Actor}}} property that returns the CSS property {{{grid-area}}} with the relevant row and column values taken from the character&#39;s {{{row}}} and {{{col}}} properties. This ensures the character will appear exactly where we want them to.

...But we still haven&#39;t defined our grid dimensions! That comes at the end of the passage, here:
{{{
&lt;&lt;timed 0s&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#enemies .actors.grid&quot;).css({
	  &quot;grid-template-columns&quot;: `repeat(${setup.ROW_SIZE},1fr)`
	});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/timed&gt;&gt;
}}}
This code runs raw JavaScript code. This code finds the {{{actors}}} container using jQuery, then modifies its {{{grid-template-columns}}} attribute to define a number of equally-spaced columns equal to {{{ROW_SIZE}}}. (We have to place it in the seemingly-pointless {{{&lt;&lt;timed 0s&gt;&gt;}}} macro because elements do not exist on the page untill all code has run and the passage has finished rendering. If we tried executing this code outside of a {{{&lt;&lt;timed&gt;&gt;}}}, it would tell use the element doesn&#39;t exist. But code within {{{&lt;&lt;timed&gt;&gt;}}} blocks execute after the passage has rendered, so with a delay of 0 we can use them to instantly modify an element on the page just after it&#39;s rendered. See &lt;a href=&quot;http://www.motoslave.net/sugarcube/2/docs/#macros-dom-warning&quot; target=&quot;_blank&quot;&gt;the SugarCube documentation&lt;/a&gt; for more info.)

In effect, most of the work has been done for you here. You only need to plug in values for {{{ROW_SIZE}}} and {{{COLUMN_SIZE}}}, and extend the width of {{{#content}}} if you want wider battle grids... &lt;i&gt;if&lt;/i&gt; you restrict yourself to perfectly rectangular battle grids. If you want an uneven grid with protrusions or holes, that&#39;s going to take more work. You will likely need to define both a custom grid and custom placement for your actors (via the {{{grid-rows}}} and {{{grid-columns}}} attributes).

For more information on how to use grids, see &lt;a href=&quot;https://css-tricks.com/snippets/css/complete-guide-grid/&quot; target=&quot;_blank&quot;&gt;this guide by CSS-Tricks&lt;/a&gt;.

&lt;h3 id=&quot;battlegrid.2&quot;&gt;Features&lt;/h3&gt;
So now that we have our grid, how do we use it for gameplay?

You can potentially use the grid for a lot of things. By default, the only thing it does is allow characters in higher rows to guard lower ones. The code for this can be found in the {{{Hitlist}}} class definition in {{{targeting.js}}}.
{{{
static guardCheck (target) {
	if (setup.BATTLE_GRID === true
		&amp;&amp; !V().action.ranged
		&amp;&amp; (subject().id.charAt(0) !== target.id.charAt(0))) {

		console.assert(target instanceof Actor,`ERROR in guardCheck: target must be Actor`);
		var newTarget = target;

		// Search for character immediately in front of this one (same column, row - 1)
		newTarget = target.ownParty.find(function (a) { return a &amp;&amp; a.col === this.col &amp;&amp; a.row === this.row - 1 },target);
		if (newTarget instanceof Actor &amp;&amp; !newTarget.guardBreak) {
			newTarget = Hitlist.guardCheck(newTarget);
		} else {
			newTarget = target;
		}
		return newTarget;
	} else {
		return target;
	}
}
}}}
This function takes the target object, and checks to see if there&#39;s any character directly in front of them (same column position, row position minus one). If there&#39;s no such character, the function will return {{{undefined}}}, and we&#39;ll know that we can just continue with the original target. If we &lt;i&gt;do&lt;/i&gt; find a guarding character, we need to reassign them as the new target (provided they don&#39;t have the {{{guardBreak}}} attribute).

&lt;i&gt;But wait!&lt;/i&gt; What if that guarding character is, in turn, guarded by &lt;i&gt;another&lt;/i&gt; character in the next row up? To account for that, we have to call {{{guardCheck}}} &lt;i&gt;again&lt;/i&gt; on the new target. This technique -- calling the same function within itself -- is called &lt;i&gt;recursion&lt;/i&gt; in programming, and allows us to perform iterative logic similarly to loops. Just like loops, we have to be careful not to create infinite recursions -- in this case, that is handled by the fact we will eventually run out of rows, at which point we are guaranteed to return a fixed value and end the recursion chain.

{{{guardCheck}}} is run both in the default targeting logic and when determining valid targets in the targeting phase.
{{{
&lt;&lt;if _cell.contents instanceof Actor&gt;&gt;
	&lt;&lt;actorBox _cell.contents&gt;&gt;
&lt;&lt;elseif $B.phase == &quot;move&quot; &amp;&amp; def $subject&gt;&gt;
	&lt;div class=&quot;actor grid flex-center empty&quot;&gt;
		&lt;&lt;capture _r, _c, _cell&gt;&gt;
		&lt;&lt;link &quot;[MOVE]&quot;&gt;&gt;
			&lt;&lt;set &lt;&lt;set $subject.position = [_r+1,_c+1]&gt;&gt;
			&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;/div&gt;
}}}
We also want a way to move our characters around on the battle grid. That happens here, in a branch of {{{grid actorlist puppets}}}. If the {{{phase}}} of the battle is &quot;move&quot;, empty tiles will generate a link that moves the selected puppet to that tile, and replaced their existing tile with a null. By default, this doesn&#39;t take up an action; players can move around all they want during their turn.

There are also additional action functions that interact with the grid, {{{massAttack}}} and {{{pushAttack}}}. The former can target small portions of the grid (rows, columns, or a + shape), and the latter can forcibly move characters around the grid.

This is just one of many features you can use with the battle grid. You may want to have it interact with threat targeting by giving characters in higher rows more starting threat or have them gain more per attack. By default, characters in the back rows can still attack freely, but you could restrict them to ranged attacks, as is the case in &lt;i&gt;Final Fantasy II&lt;/i&gt;. Other &lt;i&gt;Final Fantasies&lt;/i&gt; take a softer approach, with back-row characters merely gaining a bonus to defense at the expense of melee attack damage. &lt;i&gt;Radiant Historia&lt;/i&gt; uses push attacks as a core gameplay mechanic, with the ability to force multiple enemies into the same square and damage all of them with a single attack. Try experimenting!

&lt;h2 id=&quot;missMechanics&quot;&gt;Misses and Critical Hits&lt;/h2&gt;
Once upon a time there was a wargame called &lt;i&gt;Chainmail&lt;/i&gt;, which used random dice rolls as a method of combat resolution. This game served as the basis for the role-playing game &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, which inherited its dice-based mechanics. Seemingly every computer RPG is based, in some way, on &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, and they all unthinkingly copied its mechanics too, including, for some godforsaken reason, the random dice-roll mechanics.

In &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, to perform an attack, you must roll a 20-sided die. If the result of the roll compares favorably to the target&#39;s Armor Class stat, your attack hits! Otherwise, it misses. As a little bonus, if you roll a 20 on your attack, you can deal a critical hit, which can do a number of things depending on the system but usually involves a multiplier on your final damage result. This is typically counterbalanced by a roll of 1 equating to a &quot;critical miss&quot; or &quot;critical failure&quot; that automatically misses regardless of other modifiers and may do other nasty things to the attacker.

&lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, in turn, formed the backbone of the first computer RPGs, which were copied by the next generation of computer RPGs and on and on until this mechanic became so entrenched in the genre that no one bothered to question it anymore. So now we get to see &quot;miss&quot; and &quot;critical hit!&quot; messages in our modern RPGs too, all because an old wargame wanted to add a little randomness to its mechanics. Here I&#39;ll teach you how to be a mindless &lt;i&gt;D&amp;D&lt;/i&gt; copycat too.

Disclaimer: I hate this mechanic with the intensity of a thousand burning suns. I find it infuriating in every RPG I have ever played and I do not believe it adds any depth to gameplay whatsoever, at least in this extreme form. When your player cannot reliably predict the results of their actions -- when you take control away from them -- it violates one of the fundamental tenets of game design, the principle of consistent action-and-response. Players can succeed or fail your challenges not as a consequence of their actions, but by factors completely outside of their control. I consider this a bad thing. But other people, apparently, disagree, so I have grudgingly implemented this feature so that I can faithfully claim my engine can do everything RPG Maker can. However, it is turned off by default and I implore you to keep it that way unless you have a very, very good reason to do otherwise.

For more on this topic and how to use randomness responsibility, see the video &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=dwI5b-wRLic&quot; target=&quot;_blank&quot;&gt;The Two Types of Random in Game Design&lt;/a&gt;&quot; by Game Maker&#39;s Toolkit.

&lt;h3 id=&quot;misses&quot;&gt;Accuracy and Misses&lt;/h3&gt;
If you look at &quot;Damages and Formulas&quot;, you&#39;ll see this widget at the top:
{{{
&lt;&lt;widget &quot;accuracyCheck&quot;&gt;&gt;
(...)
&lt;&lt;include &quot;accuracy formula&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
It&#39;s called at the start of {{{&lt;&lt;echoDamage&gt;&gt;}}}, after the protection check but before damage calculation or anything else.

The accuracy formula is offloaded to another passage so you can modify it without having to fuss with the code of the entire &quot;Damage and Formulas&quot; file. By default, I used a formula roughly based on &lt;i&gt;Pokemon&lt;/i&gt;&#39;s:
{{{
&lt;&lt;if $action.accuracy === true&gt;&gt;
	&lt;&lt;set _hit = true&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _acc = $action.accuracy&gt;&gt;
	&lt;&lt;if subject().stats.hasOwnProperty(&quot;Accuracy&quot;)&gt;&gt;
		&lt;&lt;set _acc = Math.max(_acc + (subject().get(&quot;Accuracy&quot;)-100),setup.MIN_ACCURACY)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _target.stats.hasOwnProperty(&quot;Evasion&quot;)&gt;&gt;
		&lt;&lt;set _acc = Math.max(_acc - _target.get(&quot;Evasion&quot;),setup.MIN_ACCURACY)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _toHit = random(1,100)&gt;&gt;
	&lt;&lt;if _toHit &lt;= _acc&gt;&gt;
		&lt;&lt;set _hit = true&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _hit = false&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The first thing you should notice here is that accuracy is a property of the action itself. You can set a default value in StoryInit (by default this is {{{true}}}) for all actions if you don&#39;t want to define one for each action individually.

If the {{{accuracy}}} property contains the Boolean {{{true}}}, the accuracy check is completely bypassed. We mark {{{_hit}}} as {{{true}}} and that&#39;s all. This value is used for &quot;always accurate&quot; attacks that bypass the following check:
{{{
&lt;&lt;set _acc = $action.accuracy&gt;&gt;
&lt;&lt;if subject().stats.hasOwnProperty(&quot;Accuracy&quot;)&gt;&gt;
	&lt;&lt;set _acc = Math.max(_acc + (subject().get(&quot;Accuracy&quot;)-100),setup.MIN_ACCURACY)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _target.stats.hasOwnProperty(&quot;Evasion&quot;)&gt;&gt;
	&lt;&lt;set _acc = Math.max(_acc - _target.get(&quot;Evasion&quot;),setup.MIN_ACCURACY)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Though these stats do not exist in the default engine, I&#39;ve included handling for &quot;Accuracy&quot; and &quot;Evasion&quot; modifiers. (Note that the {{{hasOwnProperty()}}} check ensures this will only be done if the correct stats exist, so don&#39;t worry about problems if you don&#39;t want to use those stats.) I use a simple adjustment formula based on percentile values: The attack gains accuracy equal to the attacker&#39;s accuracy stat offset by 100 (so if they had an accuracy stat of 120%, they would gain 20% accuracy; if they had a stat of 80%, they would lose 20% accuracy, etc.) and loses accuracy equal to the target&#39;s evasion stat. (In both cases, we do a common-sense check to bound the accuracy value against {{{MIN_ACCURACY}}}, to avoid weird things like negative accuracy values and in case you don&#39;t want it to be possible to reduce accuracy to 0% or something.)

Note that these modifers mean &lt;b&gt;an accuracy value of 100 does not guarantee a hit&lt;/b&gt;. Accuracy penalties and evasion stats can reduce the attack&#39;s accuracy and cause it to still miss. This is why we need a different value to denote attacks that are truly always accurate.
{{{
&lt;&lt;set _toHit = random(1,100)&gt;&gt;
&lt;&lt;if _toHit &lt;= _acc&gt;&gt;
	&lt;&lt;set _hit = true&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _hit = false&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We then do a simple percentile roll. If we roll under the adjusted accuracy value, the attack hits; otherwise, it misses. We record the result in the {{{_hit}}} variable. (Note that due to the boundary values picked for the {{{random()}}} call, an accuracy of 0 will always miss.)
{{{
&lt;&lt;if _hit === false&gt;&gt;
	&lt;&lt;print setup.MISS_MESSAGE&gt;&gt;
&lt;&lt;elseif _hit === true&gt;&gt;
(proceed as normal)
}}}
It&#39;s then up to you what you want to do with a missed hit. By default, this code runs in {{{&lt;&lt;echoDamage&gt;&gt;}}}, printing the miss message and nothing else.

One thing you should note is that, by default, magical attacks (denoted by a {{{useSpecial}}} property of 1) cannot miss. This is consistent with most console RPGs (but not &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;!). This is probably because making the player waste not only a turn but a limited resource was considered too much of a dick move even for old-school game designers, and they were right.

The reason I hate this mechanic is because I feel the variance in result is too high. A missed attack is a complete nullification of your action; it is possible to make no progress in the battle at all no matter how many actions you take, if you are very unlucky and keep missing. (And don&#39;t even get me started on enemies whose &quot;gimmick&quot; is having high evasion.) I can understand, in principle, there being some benefits to preventing the player from getting too complacent, but maybe be a little bit nicer about it? I played one RPG where missed attacks did half damage instead of none, the conceit being that the attack struck a glancing blow instead of missing completely. Try something like that and see how it plays. (You could even play with it further by providing equipment or other modifiers that change the proportion of graze damage. Perhaps you have a weapon that does low base damage but loses less damage on a miss, for a weaker but more reliable attack? Be inventive! Don&#39;t just mindlessly copy &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; like every designer before you!)

&lt;h3 id=&quot;crits&quot;&gt;Critical Hits&lt;/h3&gt;
Missed hits are sometimes &quot;balanced&quot; by their inverse, critical hits. Critical hits typically do greater damage than a normal hit, and may have other properties like inflicting an injury.

Like with accuracy, the formula is wrapped in a widget and offloaded to another passage for modularity purposes. My default critical formula is very similar to the accuracy formula:
{{{
&lt;&lt;set _critChance = $action.critRate&gt;&gt;
&lt;&lt;set _toCrit = random(1,100)&gt;&gt;
&lt;&lt;if subject().stats.hasOwnProperty(&quot;Skill&quot;)&gt;&gt;
  &lt;&lt;set _critChance += subject().get(&quot;Skill&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _toCrit &lt;= _critChance&gt;&gt;
  &lt;&lt;print setup.CRIT_MESSAGE+&quot; &quot;&gt;&gt;
  &lt;&lt;set $dmg *= $action.critMultiplier&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Like with accuracy, critical rate is an action property but has a default value you can set in StoryInit. (And just like how magic can&#39;t miss, by default it can&#39;t crit either.) If you&#39;ve defined a stat called &quot;Skill&quot; for the attacker, its value is added to the action&#39;s percentile critical chance, and then we do a percentile roll against the result. (Most RPGs call the stat with this function &quot;Luck&quot;, but if you haven&#39;t caught on by now, I really hate luck, so I call it &quot;Skill&quot; just out of spite.) If a hit is critical, its damage is multiplied by {{{critMultiplier}}}, another action property that has a default value (1.5 by default).
{{{
&lt;&lt;if !$B.phase &amp;&amp; $dmg &gt; 0&gt;&gt;
	&lt;&lt;critCheck&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Note that, because critical hits directly modify the damage value, this check is called in {{{&lt;&lt;damageCalc&gt;&gt;}}}, not {{{&lt;&lt;echoDamage&gt;&gt;}}}, which in turn is only called if the attack passes its accuracy check. (Note that passing the &quot;nocalc&quot; argument to {{{&lt;&lt;echoDamage&gt;&gt;}}} will also bypass the call to {{{&lt;&lt;damageCalc&gt;&gt;}}} and thus the critical hit check.) This check is placed at the very end of {{{&lt;&lt;damageCalc&gt;&gt;}}}, after all other factors have been calculated.

I&#39;ve included some common-sense checks to gate the critical check. We only want criticals to be calculated when the attack is actually performed (in the action phase), not as part of the damage preview in the confirm phase. We track battle phase with the {{{phase}}} property of the battle object, and it is set to {{{null}}} during the action phase, which evaluates to a falsy value; thus, {{{!$B.phase}}} ensures critical checks can only occur during the action phase. I have also decided that if the damage is absorbed (less than 0) due to elemental factors, the attack can&#39;t be critical. You can change this if you wish.

You can do a lot more with critical hits than just a damage multiplier. &lt;i&gt;Pokemon&lt;/i&gt; lets critical hits bypass stat modifiers; similarly, RPG Maker VX has critical hits ignore defense. Several jRPGs like &lt;i&gt;Final Fantasy&lt;/i&gt; have their &quot;Luck&quot; stat increase not just your critical chance, but also your critical multiplier. Our old friend &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; famously has several critical hit tables that involve rolling again to see what type of gruesome injury you inflict, which can incur additional penalties from stat debuffs to instant death.

If you do use critical hits, I implore you to consider this question: Do enemies get them too? You can run into problems if you do. Players usually have healing skills and enemies usually don&#39;t, so RPGs often have a health asymmetry. Enemies tend to have much more health than player characters, because they are not expected to heal, so their health has to last them the whole battle. Player characters, meanwhile, are expected to operate on a cycle of healing after taking hits, so they can usually only survive a comparatively small number of hits from the enemy. If you&#39;re too incautious with your critical mechanics, you can make your enemies&#39; damage variance far too large, potentially oneshotting characters who would otherwise be able to survive several hits. This can, like excessive miss rates, edge the game into Roulette territory, making it too frustrating.

&lt;h2 id=&quot;bestiaryDocs&quot;&gt;Bestiary/Enemy Encyclopedia&lt;/h2&gt;
RPGs are games that handle a lot of data. Players will want to know their enemies&#39; statistics just as much as their characters&#39;, either to better formulate strategy or just out of curiosity. This is particularly helpful the more complex your battle system is and the more moving parts it has. Some information, like affinities for rare elements or chance-based item drops, may be opaque or non-obvious from just one encounter.

More and more RPGs provide this feature in some capacity: the GameBoy Advance remakes for &lt;i&gt;Final Fantasy&lt;/i&gt; I-VI added a menu option for reviewing the statistics of every enemy encountered; third-party RPG Maker scripts provide a similar functionality; western RPGs usually feature a broad encyclopedia of gameplay and setting information that includes enemies; and &lt;i&gt;Pokemon&lt;/i&gt;&#39;s Pokedex is one of the most famous examples, where filling out the encyclopedia was actually the goal of the game. In light of this, I decided it was a feature worth adding in version 1.21 of this engine.

We need separate classes for both the bestiary itself and the individual entries. This is similar to the {{{Inventory}}} and {{{Item}}} classes (see the relevant section in [[Documentation|Documentation (Advanced)]]). These classes are {{{Bestiary}}} and {{{BestiaryEntry}}}. Both of them can be found within the {{{database-enemies.js}}} file, below the {{{Enemy}}} class definition.

&lt;h3 id=&quot;bestiaryClass&quot;&gt;Bestiary Class&lt;/h3&gt;
{{{
window.Bestiary = class Bestiary extends Array
}}}
We want the ability to easily sort, manipulate, and iterate over the bestiary, so {{{Bestiary}}} is made a subclass of {{{Array}}}, a default object class that contains many useful functions such as {{{sort}}}.
{{{
for (let [name,enemy] of Object.entries(setup.enemyData)) {
	if (typeof(enemy.bestiaryNo) == &quot;number&quot;) {
		this.push(new BestiaryEntry(name,enemy));
	}
}
this.sort(function (a,b) { return a.bestiaryNo - b.bestiaryNo});
}}}
The constructor then automatically reads through the enemy database and adds a new entry for each one. This is done automatically, so you don&#39;t need any arguments to create a working {{{Bestiary}}} object, just a working enemy database. Once the bestiary is fully populated, it&#39;s sorted by {{{bestiaryNo}}}, short for &quot;bestiary number&quot;, a variable defined in the enemy&#39;s database entry. This gives you control over what order enemies are displayed in your bestiary; for instance, you probably want enemies the player will encounter early to appear at the start of the bestiary, and you may wish to group similar enemies together, as with &lt;i&gt;Pokemon&lt;/i&gt;&#39;s evolution lines.
{{{
if (typeof(enemy.bestiaryNo) == &quot;number&quot;)
}}}
Note this conditional. Some database entries, such as alternate form definitions, may not be intended as full entries, or you may just want to keep certain special enemies hidden from the player. You can do this either by giving them a nonnumber value {{{bestiaryNo}}}, or by not giving them one at all. Entries will only be added to the bestiary if the enemy has a valid {{{bestiaryNo}}}.

{{{Bestiary}}} also has a number of method functions, most of them very simple shortenings of {{{Array}}} functions. The {{{fetch}}} function allows us to quickly grab a bestiary entry by name without having to know its index value, and the {{{encountered}}} function returns an array of only the entries the player has encountered. {{{nextEntry}}} and {{{lastEntry}}} simply search over the bestiary and return the next encountered enemy; this is used for menu navigation.

&lt;h3 id=&quot;bestiaryEntryClass&quot;&gt;BestiaryEntry Class&lt;/h3&gt;
The {{{BestiaryEntry}}} class contains all information about the enemy relevant to the bestiary.
{{{
this.name = name;
this.encountered = false;
this.defeated = 0;
this.statsKnown = {
	&quot;hp&quot;: false,
	&quot;gp&quot;: false,
	&quot;xp&quot;: false
};
this.tolerancesKnown = {};
}}}
Above is the main part of {{{BestiaryEntry}}}&#39;s constructor. It has a {{{name}}} property matching the enemy&#39;s address in the enemy database, a Boolean flag for whether or not the enemy has been encountered by the player, a counter for how many enemies the player has defeated, and a list of the enemy&#39;s statistics. This list allows you to control how much information you want to reveal to the player and when; perhaps they only learn the enemy&#39;s statistics when they beat one, or when they use a scanning ability, or when they add it to their Pokedex. It may also enhance gameplay to not reveal an enemy&#39;s elemental affinities right off the bat, and instead force players to learn them by testing specific attacks on the enemy.

(Tolerances are listed in a separate object for reasons relating to their eventual front-end display.)
{{{
if (enemy.stats !== undefined) {
	for (let stat in enemy.stats) {
		this.statsKnown[stat] = false;
	}
}
if (setup.ELEMENT_LIST !== undefined) {
	setup.ELEMENT_LIST.forEach(function (elmn) {
		this.statsKnown[elmn] = false;
	},this);
	this.elementData = this.access().elements;
}
if (enemy.tolerances !== undefined) {
	for (let tolerance in enemy.tolerances) {
		this.tolerancesKnown[tolerance] = false;
	}
}
}}}
By default, {{{statsKnown}}} only contains markers for the enemy&#39;s hit points, monetary reward, and experience points, stats that every enemy is assumed to have. This section populates it with additional stats that may be more custom to your game: core stats, elemental affinities, and ailment tolerances.
{{{
if (enemy.alts !== undefined) {
	this.altSkin = null;
	this.altsKnown = {};
	enemy.alts.forEach(function (alt) {
		this.altsKnown[alt] = false;
	},this);
}
}}}
Finally, we have a section for alternate forms: Versions of the same enemy that, while not warranting a completely separate entry, may still be significant enough to list. This may be different stages of a boss, such as Rose Quartz&#39;s three stages in &lt;i&gt;Cartoon Battle&lt;/i&gt;, or the regional variants of Pokemon. If you want to include these, you will need to create an {{{alt}}} property in the enemy&#39;s database entry that looks like this:
{{{
&quot;alts&quot;: [&quot;Rose 2&quot;,&quot;Rose 3&quot;]
}}}
That is to say, an array containing string names for each alt form, corresponding to other entries in the database. (This means that alt forms will also need database entries, but should &lt;i&gt;not&lt;/i&gt; have {{{bestiaryNo}}}s, or else they will be made completely separate entries in the bestiary.)
{{{
get data () {
	return (setup.enemyData[this.altSkin] || setup.enemyData[this.name]);
}
}}}
You may notice that {{{BestiaryEntry}}}&#39;s getter for the {{{data}}} property is different than for other objects. This is to allow for easy access to alt form data. If the {{{BestiaryEntry}}} is wearing a valid {{{altSkin}}} property, the alt form&#39;s data is grabbed instead. Otherwise, we default to the standard entry.
{{{
get baseData () {
	return setup.enemyData[this.name];
}
}}}
However, complicating this issue is that some alt forms exist but do not have valid entries for certain data, because I didn&#39;t have the bestiary in mind when I designed them. Oops! This workaround lets you bypass that and take data directly from the base form when necessary.
{{{
access () {
	return new Enemy(this.name);
}
}}}
{{{BestiaryEntry}}} contains this method function, which may seem odd but is actually quite useful. {{{BestiaryEntry}}} contains a lot of data, but it doesn&#39;t contain all the functions and processing found in a real, live {{{Enemy}}} object. For complicated cases, we may need to grab the data from an {{{Enemy}}} object instead of the database entry; for example, if we need some processing performed in {{{Enemy}}}&#39;s constructor or one of its getter functions. &lt;b&gt;Note that creating a whole new object is a computation-intensive process, so try not to overuse this function.&lt;/b&gt;

{{{bestiaryEntry}}} also contains several getter functions for things like the enemy&#39;s database entry and in-game description. To get specific stats, however, we need something more complicated:
{{{
get (stat) {
	if (this.statsKnown[stat] === true) {
		let s = stat.toLowerCase();
		if (s == &#39;hp&#39; || s == &#39;gp&#39; || s == &#39;xp&#39;) {
			return (this.data[s] || this.baseData[s] || 0);
		} else if (setup.ELEMENT_LIST.includes(s)) {
			return this.elementData[s];
		} else {
			let statData = (this.data.stats || this.baseData.stats);
			if (typeof(statData) == &#39;object&#39;) {
				return (statData[stat] || this.baseData.stats[stat]);
			} else {
				console.log(&quot;ERROR in BestiaryEntry.get(): database entry has no stat object&quot;);
				return;
			}
		}
	} else {
		return &quot;???&quot;;
	}
}
}}}
We need to pass the name of the stat we want to this function. If the stat isn&#39;t known to the player (the corresponding flag in {{{statsKnown}}} is not {{{true}}}), we should just return a generic &quot;unknown&quot; message, by default a simple string of three question marks. Otherwise, we will use an {{{if}}} statement to create branching functionality that allows us to find the correct stat in the enemy&#39;s database entry. HP, GP, and XP have single properties with unique names, making them straightforward to access; but because elemental affinities and core stats are stored in sub-containers, we need to cover them under separate branches.
{{{
else if (setup.ELEMENT_LIST.includes(s)) {
	return this.elementData[s];
}}}
Elemental affinities are much more complicated that other stats, and we need the processing of a live {{{Enemy}}} object to get everything we need from them. Fortunately, this was handled in the constructor already, storing the post-processed data in this {{{elementData}}} property.
{{{
let statData = (this.data.stats || this.baseData.stats);
if (typeof(statData) == &#39;object&#39;) {
	return (statData[stat] || this.baseData.stats[stat]);
} else {
	console.log(&quot;ERROR in BestiaryEntry.get(): database entry has no stat object&quot;);
	return;
}
}}}
With core stats, we have to be careful: Because it&#39;s possible for a database entry to have no {{{stats}}} property (if they are an alt form, for instance), we need to grab that first to make sure it&#39;s in the format we want -- in this case, a generic object. If it is, all is well, but if not, we need to log an error.

(Note the dual use of {{{data}}} and {{{baseData}}} here. We check {{{data}}} first, but if that turns up an {{{undefined}}}, we can fall back on {{{baseData}}}, which should always have a fully-populated database entry.)

&lt;h2 id=&quot;crisis&quot;&gt;Crisis/Limit Breaks&lt;/h2&gt;
&lt;&lt;nobr&gt;&gt;
&lt;center&gt;
&lt;figure&gt;
	&lt;img @src=&quot;setup.ImagePath+&#39;documentation/LBexample.PNG&#39;&quot; /&gt;
	&lt;figcaption&gt;
	&lt;span style=&quot;font-size:10pt&quot;&gt;(Screenshot from &lt;i&gt;Final Fantasy VII&lt;/i&gt;, from the Final Fantasy Wiki)&lt;/span&gt;
	&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;&lt;&lt;/nobr&gt;&gt;
The term &quot;Limit Break&quot; was an idea popularized by the video game &lt;i&gt;Final Fantasy VII&lt;/i&gt;. In that game, characters filled up a &quot;limit&quot; guage as they took damage, and when it was full, they could unleash a powerful special attack. Later &lt;i&gt;Final Fantasy&lt;/i&gt; games would continue to iterate on the concept, most notably the Overdrive mechanic of &lt;i&gt;Final Fantasy X&lt;/i&gt;, which also allowed characters to fill up the guage through other methods.

This is a popular mechanic in RPGs, largely because it provides an opportunity to see cool, flashy, cinematic moves that make the player feel awesome and powerful. For that reason, I chose to add support for the feature in version 1.23, calling it &quot;Crisis&quot; as an homage to &lt;i&gt;Last Scenario&lt;/i&gt;.

Limit breaks create an interesting paradox: You get stronger the closer you are to losing. This can help modulate the difficulty of your battles by allowing players to bounce back if they&#39;re decimated by an enemy attack. You do have to be careful with this, though: if it&#39;s too easy to charge up limit breaks, players will be able to trivialize a lot of fights even if they aren&#39;t at the intended level of strength or skill. It may even unintentionally incentivize players to be slightly weaker than the intended benchmarks so they can pull off more limit breaks. &lt;i&gt;Final Fantasy VII&lt;/i&gt; itself addressed this problem by resetting the limit guage when a character was KO&#39;d, ensuring that characters had to be tough enough to at least survive the enemy&#39;s attacks; however, many other games leave limit progress intact on KO.

An important variable to define is what proportion of HP characters need to lose before they can pull off a limit break. Most &lt;i&gt;Final Fantasy&lt;/i&gt; games actually require characters to take significantly more than their maximum HP in damage, requiring the use of healing abilities for a successful charge. For example, in &lt;i&gt;Final Fantasy X&lt;/i&gt;, a character taking their maximum HP in damage will only charge their limit guage by 30%. This is a good principle if you plan to emphasize teamwork and synergy in your battle system, as it requires characters to work together and support each other in order to use the system to its fullest. This can also be a good way to modulate the frequency of limit breaks in the first place.

(Of course, if you plan to have no or limited healing, this won&#39;t be possible. This is why the engine&#39;s default crisis modulator is extremely generous, only requiring characters to take 70% of their maximum HP in damage. Since there&#39;s no healing, this means characters can only use their crisis ability once; but in a system with healing, the same crisis modulator may allow them to pull off crisis abilities near-constantly.)

However, you need not constrain yourself to only thinking about limit breaks in terms of desperation attacks. You can let the player charge the meter through any behavior you wish, and this is in fact a great way to incentivize players to play the way you want them to. &lt;i&gt;Final Fantasy X&lt;/i&gt; notably gave characters multiple methods of charging, with each being unlocked over the course of the game after the character had performed a number of actions related to the method. In this way, players were given more control over how to customize their characters: they could let a strong warrior character charge limit by inflicting damage or killing enemies, or turn dangerous situations into opportunities with modes that charged limit when characters were alone or in critical health.

&lt;i&gt;Radiant Historia&lt;/i&gt; provides a more focused example: The characters&#39; equivalent of a limit break guage charges when characters combo long strings of attacks together. This combo mechanic is a core feature of &lt;i&gt;Radiant Historia&lt;/i&gt;&#39;s battle system and the game becomes much more fun once you understand it, but most jRPG players may not give it much thought; by tying it to the cool, flashy limit break attacks, it draws the players&#39; attention and encourages them to master it.

You can even introduce an interesting resource tradeoff by making limit break progress useful for other abilities as well. In &lt;i&gt;Alter A.I.L.A. Genesis&lt;/i&gt;, characters gain progress towards a powerful, ultimate attack every time they use a basic ability, but these progress points can themselves be used for other special abilities. This adds an interesting new dimension to battles, as you must make tradeoffs between using a moderately powerful ability immediately or waiting to build up to a stronger one.

This ties into one final point: An interesting quirk of the original limit break system is that it cost no Magic Points or any other type of limited resource, unlike other strong abilities like spells. This made limit breaks even more powerful and enticing than they already were. This makes a degree of sense, since they are still limited by the limit guage itself, but it also ran the risk of making them overpowered. Tip the balance too far, and limit breaks can end up reducing tactical depth by turning the optimal strategy into just waiting to use them over and over again. (This was, in fact, a common criticism of &lt;i&gt;Alter A.I.L.A. Genesis&lt;/i&gt;.) You need not be limited by this mold; you can make limit breaks cost energy, MP, or some other resource to constrict their use and force the player to think about them more carefully.

Like everything else, if you choose to use limit breaks in your game, use them with thought and care, not just because they seem cool or because other games did it first.

&lt;h3 id=&quot;crisis.code&quot;&gt;Implementation&lt;/h3&gt;
The default engine settings support a straightforward, &lt;i&gt;Final Fantasy&lt;/i&gt; style of limit breaks. First, we have to give the characters these actions in the first place:
{{{
class Puppet extends Actor{
	constructor(name){
	(...)
			this.crisis = [];
			if (this.data.crisis instanceof Array) {
				for (let n of this.data.crisis) {
					this.crisis.push(new Action(n));
				}
			} else if (typeof(this.data.crisis) == &quot;string&quot;) {
				this.crisis.push(new Action(this.data.crisis));
			}
}}}
In the Puppet constructor, we create an array property called {{{crisis}}} and fill it with Crisis actions, just like we do for regular actions. You can give characters either a single Crisis action or a list by adding it to their database entry. (Crisis actions themselves are created just like any other action, their database entries contain the &quot;crisis&quot; property.)
{{{
[Q] = basic action
&lt;&lt;if subject().lastAction !== null&gt;&gt; | [W] = last action (&lt;&lt;print subject().lastAction&gt;&gt;)&lt;&lt;/if&gt;&gt;
&lt;&lt;if subject().crisis instanceof Array &amp;&amp; subject().crisis.length &gt; 0&gt;&gt; |
	&lt;&lt;if subject().crisisPoints &gt;= 100&gt;&gt;
		&lt;&lt;set _style = &quot;font-weight:bold&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _style = &quot;color:gray&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;span @style=_style&gt; [E] = &lt;&lt;crisisLink&gt;&gt;&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then, on the action list screen, we add this segment after the standard hotkey notifications (for basic and last actions) to allow players to access their characters&#39; Crisis abilities.
{{{
&lt;&lt;if subject().crisis instanceof Array &amp;&amp; subject().crisis.length &gt; 0&gt;&gt;
}}}
This clause ensures the Crisis toggle will only appear if the character has Crisis actions in the first place. If their {{{crisis}}} property doesn&#39;t exist or is unpopulated, nothing will display here. (This means that if you don&#39;t want to have Crisis abilities in your game, you can just not set them and the player will never know -- puppets will still have the {{{crisis}}} property, but it will be empty and thus fail this check.)
{{{
&lt;&lt;if subject().crisisPoints &gt;= 100&gt;&gt;
	&lt;&lt;set _style = &quot;font-weight:bold&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _style = &quot;color:gray&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span @style=_style&gt; [E] = &lt;&lt;crisisLink&gt;&gt;&lt;/span&gt;
}}}
We then add a little bit of style to the notification itself. If the player can use a Crisis (their {{{crisisPoints}}} are at 100%), we&#39;ll bold the link to draw their attention; if not, we&#39;ll gray it out so it&#39;s less obtrusive.
{{{
&lt;&lt;widget &quot;crisisLink&quot;&gt;&gt;
&lt;&lt;if typeof($args[0]) == &quot;string&quot;&gt;&gt;
	&lt;&lt;set _text = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _text = &quot;Crisis&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span id=&quot;crisisLink&quot;&gt;
&lt;&lt;link _text&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;crisis actions&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;
}}}
The {{{&lt;&lt;crisisLink&gt;&gt;}}} widget itself is straightforward: It&#39;s just a link that displays the puppet&#39;s crisis actions when clicked. If you want to use a different term than &quot;Crisis&quot;, you can also pass alternate text to the widget and that will be displayed instead.
{{{
&lt;&lt;if $args.includes(&quot;crisis&quot;)&gt;&gt;
	&lt;&lt;set _actions = _char.crisis&gt;&gt;
}}}
The &quot;crisis actions&quot; passage is functionally identical to the standard &quot;actions&quot; passage, the only difference being that it iterates over Crisis actions rather than regular actions. That&#39;s accomplished through this little handler in {{{&lt;&lt;actionList&gt;&gt;}}}.

From here, the Crisis action can be handled like any other and reuses much of the same code, though we have to add some additional checks to account for the new resource:
{{{
window.actionStandardCheck = function actionStandardCheck (action) {
	return (...) (action.crisis &amp;&amp; subject().crisisPoints &lt; 100);
}

[action effects]
&lt;&lt;if $action.crisis &amp;&amp; def subject().crisisPoints&gt;&gt;
	&lt;&lt;set subject().crisisPoints = 0&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The selection link is disabled if the character&#39;s Crisis points aren&#39;t at 100%, and Crisis points are reset to 0 after use.

To give characters Crisis points, we add this passage to the end of {{{&lt;&lt;echoDamage&gt;&gt;}}}:
{{{
&lt;&lt;if Number.isInteger(_target.crisisPoints) &amp;&amp; $dmg &gt; 0&gt;&gt;
  &lt;&lt;switch _target.crisisMode&gt;&gt;
    &lt;&lt;default&gt;&gt;
      &lt;&lt;set _target.crisisPoints += Math.round(($dmg/_target.maxhp)*100*_target.crisisFactor)&gt;&gt;
  &lt;&lt;/switch&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The default formula is very simple, based on &lt;i&gt;Final Fantasy X&lt;/i&gt;&#39;s formula for Stoic mode: Crisis points gained are equal to the proportion of max HP taken in damage multipled by a modulator variable. The default Crisis factor is 10/7, meaning characters will fill their Crisis points when they have taken 70% of their max HP in damage, but you can specify unique values for different characters.

You can also see functionality here for alternate Crisis modes a la &lt;i&gt;Final Fantasy X&lt;/i&gt;, but no others are implemented at this time.

&lt;h3 id=&quot;crisis.stash&quot;&gt;Stash&lt;/h3&gt;
Rogue&#39;s &quot;Stash&quot; Crisis ability is particularly complicated, so I will cover it here.
{{{
&quot;Stash&quot;: {
	&quot;crisis&quot;: true,
	&quot;phase&quot;: &quot;Stash Phase&quot;,
	&quot;info&quot;: `Use an item for free.`,
	&quot;desc&quot;: `Rogue may have kept a few of the party&#39;s items tucked away for themselves. But now that the chips are down, they&#39;ve got to use everything at their disposal!`,
	&quot;preview&quot;: null
}
}}}
If you look at Stash&#39;s database entry (shown here), you&#39;ll find it&#39;s very minimal. This is because, unlike other actions, Stash is never meant to be directly used. Its only purpose is to provide the player something to click on, at which point they will be forwarded to a submenu to choose the actual action they will use that turn.

The Stash Phase can be viewed in {{{Battle Phases.tw}}}, but it is essentially identical to the action list menu. The key lies in an additional attribute we add to Rogue during character generation:
{{{
&quot;specialInit&quot;: function (actor) {
	(...)
	actor.stash = [
		new ItemAction(&quot;Panacea&quot;),
		new ItemAction(&quot;Bottled Chi&quot;),
		new ItemAction(&quot;Adrenaline&quot;),
		new ItemAction(&quot;Stoneskin&quot;),
		new ItemAction(&quot;Nootropic&quot;),
		new ItemAction(&quot;Stimulant&quot;),
		new ItemAction(&quot;Powdered Glass&quot;),
		new ItemAction(&quot;Grenade&quot;),
		new ItemAction(&quot;Flamethrower&quot;),
		new ItemAction(&quot;Gas Bomb&quot;),
		new ItemAction(&quot;Flashbang&quot;),
		new ItemAction(&quot;Calamity Bomb&quot;)
	];
	actor.stash.forEach(function (item) {
		item.free = true;
		item._crisis = true;
	});
}
}}}
The {{{stash}}} array is a list of the actions the player can choose from in the Stash Phase. If the character doesn&#39;t have a {{{stash}}} attribute, you&#39;ll get an error message and the code will shut down before it starts. Since we&#39;re only interested in the action and not the items themselves, we can just use {{{ItemAction}}}s here.

Note that the stash list has no correlation to the player&#39;s actual inventory, and in fact I cut out all the minor status cures that would be redundant with the Panacea. This gives you more control over the stash list, perhaps allowing the player to unlock additional items as they level up.
{{{
&lt;&lt;if subject() instanceof Puppet &amp;&amp; $action instanceof ItemAction &amp;&amp; !$action.free&gt;&gt;
	&lt;&lt;print $inventory.decItem($action.name)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
However, this runs into a little problem, here in the action phase. If the action was an {{{ItemAction}}}, we&#39;re supposed to remove the corresponding item from the player&#39;s inventory -- but the whole point of Stash is that it&#39;s not supposed to do that!
{{{
actor.stash.forEach(function (item) {
	item.free = true;
	item._crisis = true;
});
}}}
That is the purpose of this additional code. It runs through the {{{stash}}} array and modifies every action to have the {{{free}}} attribute, which will bypass the item decrement check. We also need to make them behave as Crisis abilities by flagging their {{{_crisis}}} attribute -- otherwise, they wouldn&#39;t reset the user&#39;s Crisis points!

These are the additional factors you&#39;ll need to add in order for Stash to work. The principles you learned here can also be generalized to other types of submenu abilities.</tw-passagedata><tw-passagedata pid="179" name="Anim Test" tags="nobr" position="1100,2225" size="100,100">&lt;&lt;set $scenario = &quot;gf1&quot;&gt;&gt;
&lt;&lt;include &quot;Preparation&quot;&gt;&gt;
&lt;&lt;set $subject = $puppets[0]&gt;&gt;
&lt;&lt;set $subject.en = 10&gt;&gt;
&lt;&lt;set $target = $enemies[1]&gt;&gt;
&lt;&lt;if $subtest.includes(&quot;dark&quot;)&gt;&gt;
	&lt;&lt;set $B.style = &quot;dark&quot;&gt;&gt;
	&lt;&lt;addclass &quot;html&quot; &quot;dark&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $subtest == &quot;Antidote&quot; || $subtest == &quot;Grenade&quot;&gt;&gt;
	&lt;&lt;set _action = new ItemAction($subtest)&gt;&gt;
	&lt;&lt;run $puppets[0].addEffect(&quot;Poisoned&quot;,{power: 1, weight: 1, noPopup: true})&gt;&gt;
	&lt;&lt;set $target = $puppets[0]&gt;&gt;
&lt;&lt;elseif $subtest == &quot;block&quot;&gt;&gt;
	&lt;&lt;set $enemies[1].addEffect(&quot;Bubble&quot;,{power: 1, noPopup: true})&gt;&gt;
	&lt;&lt;set _action = new Action(&quot;Flurry&quot;)&gt;&gt;
&lt;&lt;elseif $subtest == &quot;Thorns&quot;&gt;&gt;
	&lt;&lt;run $enemies[1].addEffect(&quot;Thorns&quot;,{power: 1, noPopup: true})&gt;&gt;
	&lt;&lt;set _action = new Action(&quot;Sword&quot;)&gt;&gt;
&lt;&lt;elseif $subtest == &quot;death&quot;&gt;&gt;
	&lt;&lt;run target().hp = 50; target().displayHP = 50&gt;&gt;
	&lt;&lt;set _action = new Action(&quot;Knife&quot;)&gt;&gt;
&lt;&lt;elseif $subtest.includes(&quot;regen&quot;)&gt;&gt;
	&lt;&lt;set subject().HPregenFlat = 5; target().HPregenFlat = -5&gt;&gt;
	&lt;&lt;set _action = new Action(&quot;Knife&quot;)&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _action = new Action($subtest)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;actionLink _action&gt;&gt;
&lt;&lt;goto &quot;Anim Test Live&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="180" name="Anim Test Live" tags="nobr" position="1225,2225" size="100,100">&lt;&lt;if $subtest.includes(&quot;regen&quot;)&gt;&gt;
	&lt;&lt;endOfRound $enemies&gt;&gt;
	&lt;&lt;newTurn $puppets&gt;&gt;
	&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;include &quot;action phase&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="181" name="Changelog" tags="text" position="100,2350" size="100,100">/*&lt;h3&gt;Version 4.01&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Full support for the &quot;timeline&quot; turn model. See documentation for details, or Experiment 03 for a live example. New &lt;code&gt;Action&lt;/code&gt; properties &lt;code&gt;recoveryTime&lt;/code&gt; and &lt;code&gt;waitTime&lt;/code&gt; have been added to work with the new system.&lt;/li&gt;
&lt;li&gt;A new variable, &lt;code&gt;TURN_MODEL&lt;/code&gt;, can now be set in &lt;code&gt;StoryInit&lt;/code&gt; to determine the turn model you want to use. Currently, only the free-action model and the timeline model are functional.&lt;/li&gt;
&lt;/ul&gt;

*/&lt;h3&gt;Version 4.00&lt;/h3&gt;
&lt;b&gt;Changes introduced in this version are incompatible with previous versions&lt;/b&gt; due to changing the names of essential passages and variables. Apologies, but these changes will vastly improve usability going forward.
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;isDone&lt;/code&gt; property has been renamed to &lt;code&gt;active&lt;/code&gt; &lt;b&gt;and its logic has been flipped&lt;/b&gt;, e.g. situations that would have set &lt;code&gt;isDone&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; now set &lt;code&gt;active&lt;/code&gt; to false. Apologies for any problems this causes, but it will make code clearer going forward for other initiative models.&lt;/li&gt;
&lt;li&gt;Battle passages have been renamed for greater clarity and consistency. &quot;Battle!&quot; is now &quot;Player Phase&quot;, &quot;end of round&quot; is now &quot;RoundEnd&quot;, and all phases are now capitalized.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;endOfRound&lt;/code&gt; widget has been renamed to &quot;endTurn&quot; for consistency with &lt;code&gt;newTurn&lt;/code&gt;. The existing &lt;code&gt;endturn&lt;/code&gt; widget has been renamed to &quot;endRound&quot; for clarity.&lt;/li&gt;
&lt;li&gt;Code used in &lt;code&gt;newTurn&lt;/code&gt; and &lt;code&gt;endTurn&lt;/code&gt; have been compartmentalized into additional widgets to reduce code redundancy. This will also allow you to more easily implement these features in other contexts.&lt;/li&gt;
&lt;li&gt;Characters will no longer regenerate HP if they are under a &lt;code&gt;healBlock&lt;/code&gt; effect.&lt;/li&gt;
&lt;li&gt;Energy stats have been made default properties of the &lt;code&gt;Actor&lt;/code&gt; constructor, but they will only be defined if an &lt;code&gt;en&lt;/code&gt; property is defined in the corresponding database entry. Default values can also be provided through the &lt;code&gt;setup&lt;/code&gt; variables &lt;code&gt;MAX_EN&lt;/code&gt; and &lt;code&gt;EN_REGEN&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Energy regeneration has been added as part of the core &lt;code&gt;newTurn&lt;/code&gt; widget. If you want to opt out, simply delete &lt;code&gt;MAX_EN&lt;/code&gt; in your custom StoryInit section.&lt;/li&gt;
&lt;li&gt;New action function: &lt;code&gt;cancelAction&lt;/code&gt;. It will remove the target&#39;s readied action if they have one.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;noENregen&lt;/code&gt;: Similar to &lt;code&gt;healBlock&lt;/code&gt;, it will return &lt;code&gt;true&lt;/code&gt; if the character has an effect with the same property, and will disable Energy regeneration in &lt;code&gt;newTurn&lt;/code&gt;. It will also return &lt;code&gt;true&lt;/code&gt; if the character is &lt;code&gt;dead&lt;/code&gt; or has no &lt;code&gt;en&lt;/code&gt; property. The core effects &quot;Winded&quot; and &quot;Petrified&quot; have been modified to use this property.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interruptGuard&lt;/code&gt;: Checks if character has an effect with the same property. If true, protects against &lt;code&gt;cancelAction&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Corresponding property getters have been added to the &lt;code&gt;Effect&lt;/code&gt; class.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Action execution code has been compartmentalized for greater modularity. Pre-action code can now be found under the &lt;code&gt;preAction&lt;/code&gt; passage, and post-action code under the &lt;code&gt;postAction&lt;/code&gt; passage. &lt;code&gt;custom end of action effects&lt;/code&gt; has been renamed &lt;code&gt;postAction custom&lt;/code&gt; for readability and consistency with other custom passages.&lt;/li&gt;
&lt;li&gt;Selecting an action now forwards the player to an &quot;Action Handler&quot; passage instead of directly to the action phase. This allows you to perform pre-processing and rerouting before executing the action itself. Currently, it exists to check for actions with &lt;code&gt;waitTime&lt;/code&gt; under the timeline model, and otherwise forwards the player straight to the action phase.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; property: &lt;code&gt;base&lt;/code&gt;. This is a flat value added to an action&#39;s damage output, and is 0 by default.&lt;/li&gt;
&lt;li&gt;Default damage formulas have been adjusted to incorporate &lt;code&gt;base&lt;/code&gt; damage, and a new formula has been added that just uses base damage with no other fluff.&lt;/li&gt;
&lt;li&gt;Action tooltips have been redone with snazzy images to convey important information. Images were taken from The Noun Project, with attributions listed on the game&#39;s page.&lt;/li&gt;
&lt;li&gt;The damage formula &lt;code&gt;switch&lt;/code&gt; now converts the input to lower case before reading it. This avoids potential errors arising from mixed case.&lt;/li&gt;
&lt;li&gt;Stat names have been standardized as part of a &lt;code&gt;STAT_NAMES&lt;/code&gt; object, which is part of &lt;code&gt;setup&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Stat minimums and maximums have been implemented. These can be defined in StoryInit as part of the &lt;code&gt;STAT_MIN&lt;/code&gt; and &lt;code&gt;STAT_MAX&lt;/code&gt; objects. Returned stat values will be clamped between these two values.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;If exceptions are necessary, such as e.g. the Forsaken effect, a new &lt;code&gt;Actor&lt;/code&gt; property has been added: &lt;b&gt;&lt;code&gt;noMinimum&lt;/code&gt;&lt;/b&gt;. This is initialized as an empty array for all new Actors, and will ignore &lt;code&gt;STAT_MIN&lt;/code&gt; for any stat names included within. In the core code, Forsaken has been modified to use this property instead of a &lt;code&gt;forsaken&lt;/code&gt; flag.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Shorthand functions have been created for accessing &lt;code&gt;STAT_NAMES&lt;/code&gt;, &lt;code&gt;STAT_MIN&lt;/code&gt;, and &lt;code&gt;STAT_MAX&lt;/code&gt;. See &lt;code&gt;support_functions.js&lt;/code&gt; for details.&lt;/li&gt;
&lt;li&gt;The functionality of the &quot;Protector&quot; effect has now been generalized to a property, &quot;&lt;code&gt;guard&lt;/code&gt;&quot;, that can be enabled in effect definitions. If &lt;code&gt;true&lt;/code&gt;, the target of the ability will be flagged as protected by the subject.&lt;/li&gt;
&lt;li&gt;Instead of manually checking in both damage and effects, protection is now checked only once, in the &quot;action effects&quot; passage before an action is executed.&lt;/li&gt;
&lt;li&gt;Accuracy, shield, and multiple hit logic have been changed. An action&#39;s &lt;code&gt;act&lt;/code&gt; function is now executed once for every &lt;code&gt;hit&lt;/code&gt; property (default 1), and accuracy and shields are checked on every iteration. As a result, the &lt;code&gt;multihit&lt;/code&gt; action function has been depreciated.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;Spread and noRedundant behavior have been changed to Action properties instead.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;finisher&lt;/code&gt;: Function that executes only on the final hit of an action. Emulates &lt;code&gt;multihit&lt;/code&gt;&#39;s previous rule for extensions (running only after all hits have been executed). Note that this finisher occurs &lt;b&gt;instead of&lt;/b&gt; the regular &lt;code&gt;act&lt;/code&gt; function.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onMiss&lt;/code&gt;: Function that excecutes if an action misses. Increase the risk to your reward. Perhaps if your character attempts a bombastic jumping attack but misses, they land poorly and sprain an ankle?&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Fixed an error in &lt;code&gt;Effect.calculatePower&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.07.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed an error in &lt;code&gt;hasEquipped&lt;/code&gt; that prevented it from returning the correct value if a match was found early.&lt;/li&gt;
&lt;li&gt;Fixed additional areas where the &lt;code&gt;target&lt;/code&gt; function could accidentally be overwritten. &lt;code&gt;target&lt;/code&gt;, &lt;code&gt;subject&lt;/code&gt;, and &lt;code&gt;action&lt;/code&gt; functions have been changed to constants, hopefully ending this problem once and for all.&lt;/li&gt;
&lt;li&gt;Fixed an error that occurred when effects had a target separate from the effect&#39;s recipient (such as Protector). Targets should now work correctly again.&lt;/li&gt;
&lt;li&gt;Fixed an error in &quot;highest attack&quot; targeting logic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.07.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Streamlined the implementation of &lt;code&gt;restrictedTo&lt;/code&gt; in equippable items. You no longer need to define a &lt;code&gt;restrictedTo&lt;/code&gt; and handlers will account for invalid values. Additionally, there is now a shorthand getter for &lt;code&gt;restrictedTo&lt;/code&gt; that lets you avoid going through &lt;code&gt;equippable&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Simplified the inventory menu code to use the &lt;code&gt;update&lt;/code&gt; macro for updating the item display rather than manual &lt;code&gt;replace&lt;/code&gt; commands.&lt;/li&gt;
&lt;li&gt;Added grid position as a constructor argument for &lt;code&gt;Actor&lt;/code&gt;s. If you pass a two-element array after the name, their position will be initialized to the given coordinates.&lt;/li&gt;
&lt;li&gt;Tweaked the logic in &lt;code&gt;guardCheck&lt;/code&gt; so that it can be used even when an active action is unset.&lt;/li&gt;
&lt;li&gt;You can now change the names of the Attack, Defense, and Special stats without needing to alter any code: just set the &lt;code&gt;AttackName&lt;/code&gt;, &lt;code&gt;DefenseName&lt;/code&gt;, and &lt;code&gt;SpecialName&lt;/code&gt; variables in &lt;code&gt;StoryInit&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.07&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; functions:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;replenishUses&lt;/code&gt;: Fully refills the uses of all actions possessed by the character that match the passed &lt;code&gt;name&lt;/code&gt; argument.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Effect&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;healBlock&lt;/code&gt;: Prevents the afflicted character from being healed by healing skills.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Items&#39; &lt;code&gt;value&lt;/code&gt; property will now accept a function as a value.&lt;/li&gt;
&lt;li&gt;Fixed an oversight that prevented actions&#39; &lt;code&gt;preview&lt;/code&gt; properties from working correctly if they were defined as arrays.&lt;/li&gt;
&lt;li&gt;There are now redundant getters for the capitalized versions of the &quot;xp&quot; and &quot;gp&quot; properties to prevent confusion.&lt;/li&gt;
&lt;li&gt;Fixed an error that occurred in some action functions as a result of &lt;code&gt;findTarget&lt;/code&gt; erroneously overwriting the &lt;code&gt;target&lt;/code&gt; function.&lt;/li&gt;
&lt;li&gt;Fixed an error that occurred if a target was undefined when &lt;code&gt;addEffect&lt;/code&gt; was called.&lt;/li&gt;
&lt;li&gt;Fixed an error that would cause healing abilities with custom formulas to produce glitch values.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.06&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;noReflection&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt;, the action will not trigger damage reflection unless the target has the &lt;code&gt;absreflect&lt;/code&gt; property.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Equipment will now print their character restrictions in their default &lt;code&gt;toString&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;itemDrop&lt;/code&gt; widget now displays items with the default &lt;code&gt;toString&lt;/code&gt; format.&lt;/li&gt;
&lt;li&gt;Item boxes displayed in &lt;code&gt;itemDrop&lt;/code&gt; now have no limits on their height. This is governed through the &quot;infield&quot; class, which you can find in &lt;code&gt;stylesheets-core/menu/shared.css&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Items&#39; default &lt;code&gt;toString&lt;/code&gt; will no longer display null descriptions.&lt;/li&gt;
&lt;li&gt;Fixed an error in the &lt;code&gt;massAttack&lt;/code&gt; function that prevented it from working correctly.&lt;/li&gt;
&lt;li&gt;Tweaked the way battle interruptions work to accommodate for the modular order of action display components. The passage &quot;battle interruptions&quot; is now run at the very start of any action, and the spot where it was previously run is now a &lt;code&gt;div&lt;/code&gt; element with the id &quot;interrupt&quot;. To populate it, target the id with a &lt;code&gt;replace&lt;/code&gt; macro in &quot;battle interruptions&quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.05&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;numAdjacent&lt;/code&gt;: Returns the number of other characters in the area specified by the passed argument. Useful for AI code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guarded&lt;/code&gt;: Returns &lt;code&gt;true&lt;/code&gt; if the character is guarded by another character in the battle grid.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;The &quot;guarded&quot; property used by the &quot;Guarded&quot; status effect has been renamed to &lt;code&gt;areaImmune&lt;/code&gt; to avoid conflicts.&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Enemy&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;actionsThisTurn&lt;/code&gt;: Returns the enemy&#39;s list from the &lt;code&gt;actionsThisTurn&lt;/code&gt; object in the battle controller.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;delayHold&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt;, character will be unable to act while the delayed action is charging.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delayMessage&lt;/code&gt;: Returns a message to be displayed at the top of rounds if the user is charging a delayed action. Set to &lt;code&gt;null&lt;/code&gt; to display no message.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Delayed actions are now stored as &lt;code&gt;Action&lt;/code&gt; objects rather than just their name. This is to more easily facilitate the behavior described above. The &lt;code&gt;setupAction&lt;/code&gt; property is still a string.&lt;/li&gt;
&lt;li&gt;Equipment can now cover multiple slots! Your dreams of giving your characters two-handed swords and three-piece suits can now be realized. To do this, define the item&#39;s &lt;code&gt;slot&lt;/code&gt; property as a &lt;code&gt;Set&lt;/code&gt; of the slots you want the item to cover rather than a string. A new item, the &quot;Zweihander&quot;, has been added to the item database as an example. &lt;i&gt;Credit to A Friendly Irin for providing this code.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;Fixed an error in &lt;code&gt;Enemy&lt;/code&gt;&#39;s &lt;code&gt;validTarget&lt;/code&gt; function that prevented the guard check clause from behaving correctly.&lt;/li&gt;
&lt;li&gt;Fixed an error that prevented &lt;code&gt;actorBox&lt;/code&gt; from being used outside of battle due to it calling for the battle controller even when it didn&#39;t exist.&lt;/li&gt;
&lt;li&gt;Removed the extra dead space between item entries in the equipment list.&lt;/li&gt;
&lt;li&gt;Items in the equipment list are now displayed with the &lt;code&gt;Item&lt;/code&gt; object&#39;s &lt;code&gt;toString&lt;/code&gt; function for consistency with other items.&lt;/li&gt;
&lt;li&gt;Effects&#39; &lt;code&gt;addText&lt;/code&gt; and &lt;code&gt;removeText&lt;/code&gt; now take the entire character object as an argument, rather than just their name. This allows for more customizable messages.&lt;/li&gt;
&lt;li&gt;Fixed a typo in the damage reflection code that prevented it from working correctly.&lt;/li&gt;
&lt;li&gt;Updated the included Chapel macros bundle to be compatible with SugarCube 2.35.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.04&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;position&lt;/code&gt;: When invoked, it returns the character&#39;s cell in the grid; when set, it adjusts their &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;col&lt;/code&gt; values and swaps the contents of the destination cell.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadBearing&lt;/code&gt;: Boolean. If a load-bearing character is defeated, the battle ends regardless of the state of their team members.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uncounted&lt;/code&gt;: Boolean. Uncounted characters are not counted towards the victory and defeat counters, and do not need to be defeated to end an encounter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasEffect&lt;/code&gt;: Returns Boolean based on if the character has the named effect. Can also test for multiple effects by passing an array (but will return &lt;code&gt;true&lt;/code&gt; if the actor has &lt;i&gt;any&lt;/i&gt; of the named effects).&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Movement code has been simplified to take advantage of the &lt;code&gt;position&lt;/code&gt; property.&lt;/li&gt;
&lt;li&gt;Victory handler code has been tweaked; instead of instantly moving to victory or defeat screens if their conditions are met, they are added to a &lt;code&gt;_destinationQueue&lt;/code&gt; variable. After all the code is done, the player will be forwarded to the first element in &lt;code&gt;_destinationQueue&lt;/code&gt; if one exists. This should avoid issues with &lt;code&gt;goto&lt;/code&gt; pileups.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;Special deaths are also added to this queue, and will now take priority over the standard victory destinations.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;&lt;code&gt;pushAttack&lt;/code&gt; should now work with the new battle grid code.&lt;/li&gt;
&lt;li&gt;The code for displaying the actor box container has now been compartmentalized into a passage, &lt;code&gt;Actor Box Container&lt;/code&gt;, if customization without changing the surrounding actor box code is desired.&lt;/li&gt;
&lt;li&gt;Enemies now have setters for &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;gp&lt;/code&gt; properties.&lt;/li&gt;
&lt;li&gt;The code for the &lt;code&gt;Bestiary&lt;/code&gt; class has been split into a separate file.&lt;/li&gt;
&lt;li&gt;The code for battle widgets and setup has been split into a separate file, &lt;code&gt;Battle Setup.tw&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The code for each hotkey has been compartmentalized into its own passage for greater modularity.&lt;/li&gt;
&lt;li&gt;Adjusted the code for &lt;code&gt;healCalc&lt;/code&gt; to make use of an action&#39;s &lt;code&gt;formula&lt;/code&gt; property, if it has one, as well as compartmentalizing the default healing formula into a separate passage.&lt;/li&gt;
&lt;li&gt;The action info popup now has a high z-index value, preventing it from being obscured by other page elements.&lt;/li&gt;
&lt;li&gt;Added a new targeting parameter, &quot;no effect&quot;. If included, the action will preferentially target characters that don&#39;t already have any of the action&#39;s effects (as specified in the &lt;code&gt;effects&lt;/code&gt; property). This parameter is present for both ally and enemy targeting.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addEffect&lt;/code&gt; now records whether the effect was applied (and what blocked it, if not) as a property, &lt;code&gt;effectApplied&lt;/code&gt;, of the calling &lt;code&gt;Actor&lt;/code&gt; object. &lt;code&gt;effectApplied&lt;/code&gt; is an object with effect names as keys and return values from &lt;code&gt;testEffect&lt;/code&gt; as values.&lt;/li&gt;
&lt;li&gt;Added event triggers on several common battle functions, in case you want to tie special events to them. Current events are:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:puppet-selected&lt;/code&gt;: triggered on puppet selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:act-selected&lt;/code&gt;, &lt;code&gt;:rest-selected&lt;/code&gt;, &lt;code&gt;:item-selected&lt;/code&gt;, and &lt;code&gt;:move-selected&lt;/code&gt;: triggered on selection of the respective command&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:action-selected&lt;/code&gt;: triggered on action selected (also works if selected via hotkey)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:action-performed&lt;/code&gt;: triggered when action performed by puppet&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:target-selected&lt;/code&gt;: triggered on target selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:endturn-run&lt;/code&gt;: triggered upon execution of end-turn code.&lt;/li&gt;&lt;/ul&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.03&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;The battle grid has been redone.&lt;/b&gt; Positioning is now determined by manually-set &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;col&lt;/code&gt; values rather than the index of the character. This means you don&#39;t have to fill parties with &lt;code&gt;null&lt;/code&gt; entries anymore!&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;Code for displaying characters in the battle grid is now stored in a separate file, &lt;code&gt;Battle Grid.tw&lt;/code&gt;, to keep the main code uncluttered.&lt;/li&gt;
&lt;li&gt;Additionally, the broken &quot;move&quot; command has been fixed.&lt;/li&gt;
&lt;li&gt;Empty tiles are now styled with dotted borders rather than solid ones to make them less obtrusive.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;The &lt;code&gt;noself&lt;/code&gt; check for ally-targeting abilities now checks the target&#39;s &lt;code&gt;id&lt;/code&gt; rather than its &lt;code&gt;name&lt;/code&gt;. This will prevent glitches in the case of a party having multiple characters with the same name.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; property: &lt;code&gt;canTargetDead&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the action can target dead characters. This is useful for revival skills and the like.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;The &quot;Actor Box&quot; widget has been slightly tweaked to enable this function. &quot;Actor Box Name&quot; is now used for the display of dead character names as well, and has a priority branch that will bypass all others if the character is dead and the battle phase is not in targeting.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;The &quot;last action&quot; functionality should work again.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Effect&lt;/code&gt; property: &lt;code&gt;guardBreak&lt;/code&gt;. Effects with this property will prevent the victim from guarding characters (if you are using a battle map). There is a corresponding getter in &lt;code&gt;Actor&lt;/code&gt;, which will also return &lt;code&gt;true&lt;/code&gt; if the character is &lt;code&gt;dead&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;During the targeting phase, hovering over a viable target will now highlight them and any targets affected by the action&#39;s area of effect, if it has one.&lt;/li&gt;
&lt;li&gt;You will no longer get an error if the handler for saving &lt;code&gt;lastAction&lt;/code&gt; fails to find the action in the subject&#39;s actions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.02&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The gameplay effects of an action are now calculated before the text description is rendered. This allows you to customize the text based on variable results of the action, e.g. whether or not the attack missed. The &lt;code&gt;_hit&lt;/code&gt; variable is now passed to &lt;code&gt;actText&lt;/code&gt; to facilitate this.&lt;/li&gt;
&lt;li&gt;The item display box in the menu now has a fixed height; item descriptions that exceed the height will generate a scrollbar. This will prevent UI elements from jumping around.&lt;/li&gt;
&lt;li&gt;Using items or actions from the menu will now generate a brief notification informing the player of the results. This notification is taken from the return value of the &lt;code&gt;onUse&lt;/code&gt; function.&lt;/li&gt;
&lt;li&gt;Stylesheet files for the party menu and for battle layout have been split into separate files and grouped into a single folder each.&lt;/li&gt;
&lt;li&gt;The code for individual screens of the party menu have been split off into their own twee files.&lt;/li&gt;
&lt;li&gt;The &quot;Example&quot; enemy will no longer accidentally be given a bestiary entry.&lt;/li&gt;
&lt;li&gt;You can now filter character actions to only usable ones in the menu.&lt;/li&gt;
&lt;li&gt;Puppets will now display their HP/MP values instead of their equipment when being selected for an in-menu action.&lt;/li&gt;
&lt;li&gt;Fixed a bug where pressing R while using an action from the menu would cause the action to be performed on the first puppet in the party. There is now a cancel button included in the action display, and pressing R will trigger it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.01&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Target and subject variables have now been decoupled from the battle controller &lt;code&gt;B&lt;/code&gt;. This allows more flexible usage of functions and widgets that call for interactions between characters, but may cause problems with existing code. Report any bugs.&lt;/li&gt;
&lt;li&gt;Equipment slots are now always occupied by arrays, instead of only those with multiple subslots. This should result in no functional change, but allows me to clean up equipment functions by not having to account for branching functionalities. &lt;b&gt;Note that this update will generate errors with existing games that used previous versions.&lt;/b&gt; You will need to update your characters&#39; equipment slots to match the new standards.&lt;/li&gt;
&lt;li&gt;Default and last actions are now stored as strings rather than full Action objects. &lt;b&gt;This update will cause errors with existing games that store these variables as Actions.&lt;/b&gt; Make sure to update existing savefiles if you update to this version.&lt;/li&gt;
&lt;li&gt;The widget &lt;code&gt;actionlist&lt;/code&gt; has been split into &lt;code&gt;actionListBattle&lt;/code&gt; and &lt;code&gt;actionListMenu&lt;/code&gt;, for the different displays of actions in and out of battle.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Action&lt;/code&gt;s, &lt;code&gt;ItemAction&lt;/code&gt;s, and &lt;code&gt;Item&lt;/code&gt;s now have unique &lt;code&gt;toString&lt;/code&gt; functions that determine a standardized display for each. &lt;code&gt;actionList&lt;/code&gt; and &lt;code&gt;itemList&lt;/code&gt; have been restructured to take advantage of this function, making it much simpler and easier to use. (To customize the action display, attach a custom &lt;code&gt;toString&lt;/code&gt; to the &lt;code&gt;Action&lt;/code&gt; prototype.)&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;The widget &lt;code&gt;actionInfo&lt;/code&gt; has been removed, as it is now redundant with this feature.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Action&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;invisible&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt;, the action will not be displayed in the action list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onApply&lt;/code&gt; and &lt;code&gt;onRemove&lt;/code&gt;: Function as the corresponding properties for &lt;code&gt;Effect&lt;/code&gt;s and &lt;code&gt;Item&lt;/code&gt;s. Useful for keeping track of passive abilities, and other side-effects if you want to have modular actions. However, currently there&#39;s no in-built functionality for this in the party menu.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onUse&lt;/code&gt;: Functions as the corresponding property for &lt;code&gt;Item&lt;/code&gt;s. Rudimentary GUI has been added in the party menu code, but is untested. Report any bugs.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toleranceDamage&lt;/code&gt;: Determines the number of tolerance points the action will remove if it applies an effect.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hits&lt;/code&gt;: Determines the number of hits in a multi-hit attack. (This is now automatically read by the &lt;code&gt;multihit&lt;/code&gt; function as a default.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;effects&lt;/code&gt;: Array of strings; lists the effects the action will apply. (This is now automatically read by the &lt;code&gt;applyEffect&lt;/code&gt; and &lt;code&gt;removeEffect&lt;/code&gt; functions as a default.)&lt;/li&gt;
&lt;li&gt;The checks for action link availability. The freefloating functions have been removed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preview&lt;/code&gt; has been revamped: In the absence of a custom function, it will construct an appropriate preview automatically based on the action&#39;s properties, e.g. if &lt;code&gt;weight&lt;/code&gt; exists, it will provide a damage prediction.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;Item&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;instantUse&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt;, will cause the item&#39;s &lt;code&gt;onUse&lt;/code&gt; function to be executed immediately when selected, instead of selecting a target first.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stackSize&lt;/code&gt;: Integer determining the maximum number of copies that can be stored in an inventory.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Character HP can no longer be reduced below 1 by negative HP regeneration.&lt;/li&gt;
&lt;li&gt;Added customization passages for &lt;code&gt;endOfRound&lt;/code&gt; and &lt;code&gt;refreshPuppets&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Renamed the variables &lt;code&gt;lastingDamage&lt;/code&gt;, &lt;code&gt;reviveAfterBattle&lt;/code&gt;, and &lt;code&gt;actionRefillAfterBattle&lt;/code&gt; to all be properties of one object, &lt;code&gt;afterBattleRecovery&lt;/code&gt;. &lt;code&gt;refreshPuppets&lt;/code&gt; has been tweaked to make more sensible use of this object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshPuppets&lt;/code&gt; now automatically removes effects with &lt;code&gt;ULTIMATESTICKY&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endofbattle&lt;/code&gt; now runs its custom passage &lt;i&gt;before&lt;/i&gt; &lt;code&gt;refreshPuppets&lt;/code&gt;. This is useful if you need to alter a variable used in &lt;code&gt;refreshPuppets&lt;/code&gt;, such as &lt;code&gt;afterBattleRecovery&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Puppet&lt;/code&gt; and &lt;code&gt;Enemy&lt;/code&gt; objects now have an additional function: &lt;code&gt;validTarget&lt;/code&gt;. This determines whether they can be selected by the player in the targeting phase, and replaces the massive clunky blocks of logical expressions previously used for this determination.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; properties:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;shieldHits&lt;/code&gt;: Returns the total number of hits remaining on shield effects possessed by the character.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decTol&lt;/code&gt; now takes an additional argument for the number of points to reduce the tolerance by (defaults to 1).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;testEffect&lt;/code&gt; and &lt;code&gt;testRemoval&lt;/code&gt;, which test if a given effect can be applied or removed, effectively. These are used to construct previews.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New &lt;code&gt;setup&lt;/code&gt; variables:&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;STATUS_BUTTON&lt;/code&gt;: Text to be displayed to create the status buttons.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCALE_NAMES&lt;/code&gt;: Set to &lt;code&gt;true&lt;/code&gt; to scale actor names to the width of the actor boxes, as specified in &lt;code&gt;scaledTextDiv&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Fixed a bug in &lt;code&gt;BestiaryEntry.revealAll&lt;/code&gt;. It will now reveal tolerances correctly.&lt;/li&gt;
&lt;li&gt;Finally caught up with the modern era and made a repository for the project on GitHub. A link is now provided in the sidebar.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 3.00&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Targeting logic has been overhauled. It is now handled through functions rather than widgets, and certain adjustments such as Firefly have been automated.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;A &lt;code&gt;Hitlist&lt;/code&gt; class has been defined to facilitate this. It is an array that takes a set of targets and tracks the chance of selection for each. Smart targeting effects have been placed in a method function, &lt;code&gt;addFactors&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added several additional smart targeting clauses.&lt;/li&gt;
&lt;li&gt;Added an additional targeting factor: &quot;Wallflower&quot;. This functions as the inverse of Firefly, halving the chance of being targeted.&lt;/li&gt;
&lt;li&gt;Firefly and Wallflower adjustment factors can now be modified through the &lt;code&gt;setup&lt;/code&gt; variables &lt;code&gt;FIREFLY_FACTOR&lt;/code&gt; and &lt;code&gt;WALLFLOWER_FACTOR&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added support for enemies being affected by loss-of-control effects.&lt;/li&gt;
&lt;li&gt;The functionality of &lt;code&gt;threatTarget&lt;/code&gt; is now automatically provided by the &lt;code&gt;Hitlist&lt;/code&gt; constructor.&lt;/li&gt;
&lt;li&gt;Default calculation for threat values has been cut by 100, to better sync with other targeting adjustments. This includes &lt;code&gt;THREAT_DECAY&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guardCheck&lt;/code&gt; and &lt;code&gt;protectionCheck&lt;/code&gt; are now static methods of &lt;code&gt;Hitlist&lt;/code&gt; and are automatically called whenever the &lt;code&gt;returnTarget&lt;/code&gt; method of &lt;code&gt;Hitlist&lt;/code&gt; is used.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Actors now have getters for their own party and the opposing party, because I got sick of having to write that out manually.&lt;/li&gt;
&lt;li&gt;The getter for &lt;code&gt;targetMod&lt;/code&gt; has been altered to automatically return relevant mods for the action. For example, piercing moves will add &lt;code&gt;pierce&lt;/code&gt; and debuff-inflicting moves will add &lt;code&gt;effect&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;effectCount&lt;/code&gt; now takes an argument that will exclude sticky effects.&lt;/li&gt;
&lt;li&gt;AI logic functions have been moved from &lt;code&gt;database-enemies&lt;/code&gt; to a new file, &lt;code&gt;logic-functions.js&lt;/code&gt;.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;The functionality of &lt;code&gt;dispelTarget&lt;/code&gt; has been adapted into the logic function &lt;code&gt;dispelCheck&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A new logic function, &lt;code&gt;cureCheck&lt;/code&gt;, has been created. This is the ailment version of &lt;code&gt;dispelCheck&lt;/code&gt;, for enemies that use curative moves.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;New Effect property: &lt;code&gt;threat&lt;/code&gt;. This is the value checked by &lt;code&gt;dispelCheck&lt;/code&gt; and &lt;code&gt;cureCheck&lt;/code&gt;, rather than just a straight count. This allows you to weight certain effects more highly. By default, all effects have a threat of 1, except for Blessing and Curse, which have 3. Effects with indefinite durations have their threat doubled, and effects with definite durations have their threat increased by the duration over 4.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;multihit&lt;/code&gt; function has been slightly altered to avoid using widgets. It now lacks the potential for spread functionality; use &lt;code&gt;multihitCustom&lt;/code&gt; for that.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;immortal&lt;/code&gt;, &lt;code&gt;large&lt;/code&gt;, and &lt;code&gt;maskhp&lt;/code&gt; are now canonized as official &lt;code&gt;Actor&lt;/code&gt; properties; you can assign them to database entries without needing to go through &lt;code&gt;specialInit&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Created setters for &lt;code&gt;Action&lt;/code&gt; properties to make them easier to edit. You&#39;ll no longer need to preface your properties with underscores.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Actor&lt;/code&gt; property: &lt;code&gt;lastDmg&lt;/code&gt;. This tracks the amount of damage the character inflicts with their attacks. It is reset at the start of every battle and every turn. This can be used for additional targeting logic, e.g. prioritizing the most dangerous character.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;Effect&lt;/code&gt; property: &lt;code&gt;unique&lt;/code&gt;. This prevents multiple instances of the effect from existing in a party. A handler for dealing with this functionality has been added to &lt;code&gt;addEffect&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;I have started cleaning up enemy database entries by defining their actions in the action database, which will make them significantly less messy. These actions are defined in the &lt;code&gt;enemy-actions.js&lt;/code&gt; file in the &lt;code&gt;custom&lt;/code&gt; folder; it is separate from the &lt;code&gt;database-actions&lt;/code&gt; file to keep that file clean. Currently, only Dipper and Mabel are done.&lt;/li&gt;
&lt;li&gt;Existing effects and enemies have been split off into core files, as actions are.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.05&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;removeEffect&lt;/code&gt; now defaults to &quot;all&quot; if no effect type is specified.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.04&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The action database is now separated into two files: &lt;code&gt;core-actions.js&lt;/code&gt; is located in the &lt;code&gt;core&lt;/code&gt; folder and contains the actions used by the default puppets; &lt;code&gt;database-actions.js&lt;/code&gt; in the &lt;code&gt;custom&lt;/code&gt; folder lets you expand the database with additional actions. This is useful if you use the core actions in your game and need to update them without overwriting your custom actions.&lt;/li&gt;
&lt;li&gt;A stylesheets folder has been added to &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;custom&lt;/code&gt; folders, and stylesheets have been separated appropriately.&lt;/li&gt;
&lt;li&gt;The effect manager file has been moved to &lt;code&gt;core&lt;/code&gt;. If you need to overwrite it with a custom version, a new file has been including in &lt;code&gt;custom&lt;/code&gt; with instructions on how to do so.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addEffect&lt;/code&gt;&#39;s duration parameter changed from &lt;code&gt;time&lt;/code&gt; to &lt;code&gt;dur&lt;/code&gt; for consistency with actions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.03.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a bug where the player could not be forwarded to the victory destination because &lt;code&gt;endofbattle&lt;/code&gt; was run before &lt;code&gt;goto&lt;/code&gt;, destroying the destination variable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.03.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a positioning glitch with the action info popup.&lt;/li&gt;
&lt;li&gt;Fixed a bug in Salvation and Assault.&lt;/li&gt;
&lt;li&gt;Fixed several text glitches in the descriptions and previews of actions that added effects.&lt;/li&gt;
&lt;li&gt;Setting toggles are now tied to &lt;code&gt;setup&lt;/code&gt; rather than story variables, meaning they will be tied to the game file itself rather than specific save files.&lt;/li&gt;
&lt;li&gt;Streamlined the code governing Off Your High Horse and turned it into an action function, &lt;code&gt;removeLastEffect&lt;/code&gt;. This should hopefully remove any loop errors that occurred when using it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;justdmg&lt;/code&gt; has been alterned to return a function rather than a string, to enable better chaining. &lt;b&gt;However, this means that it must be assigned to Action properties with a function call, rather than as a variable.&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.03&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The height of the battle pane will now scale with the window height.&lt;/li&gt;
&lt;li&gt;Rearranged the folder structure to better differentiate core and custom code.&lt;/li&gt;
&lt;li&gt;Characters will now only appear dead after an attack has finished.&lt;/li&gt;
&lt;li&gt;Character boxes will no longer display the status button during the damage readout.&lt;/li&gt;
&lt;li&gt;Added new Actor method: &lt;code&gt;effectCount&lt;/code&gt;. It will return the number of instances of the named effect the character possesses. This can also be used to count all effects of a certain category (buffs, ailments, holds, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.02&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a glitch where enemies would not be flagged dead the first time their HP reached 0 if animations were enabled. (This has in turn created a glitch where enemies are flagged dead before the killing blow finishes animating, but that is more minor and I will deal with it later.)&lt;/li&gt;
&lt;li&gt;Example entries for actions, effects, items, puppets, and enemies have been added to the default databases. These entries have the most relevant attributes for each class enumerated and set to their default values. You can copy and work off this entry to make your own entries more easily.&lt;/li&gt;
&lt;li&gt;Effect database entries are now denoted with double rather than single quotes, for consistency with the other databases.&lt;/li&gt;
&lt;li&gt;Implemented proper support for delayed actions, including for enemies. You can now have any action set up a delayed action by using the &lt;code&gt;setupAction&lt;/code&gt; and &lt;code&gt;setupDelay&lt;/code&gt; properties, which provide the name and delay time of the delayed action, respectively. Additional code in &lt;code&gt;newTurn&lt;/code&gt; and &lt;code&gt;specialcheck&lt;/code&gt; will automatically keep track of queued actions and execute them when ready. (Note that &lt;code&gt;specialcheck&lt;/code&gt; is a custom passage; if you&#39;ve already defined your own custom special checks, copy the new data carefully.) Enemy turn logic has been slightly altered to allow for enemies to perform delayed actions while dead; tell me if this causes any unforeseen weirdness.&lt;/li&gt;
&lt;li&gt;New Action property: &lt;code&gt;targetMethod&lt;/code&gt;. This allows you to set a custom targeting method for enemy and delayed actions. It is called on enemy turns immediately after their action is selected, and defaults to &lt;code&gt;randomTarget&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Respawn proportion can now be set individually for each character, through the &lt;code&gt;respawnHP&lt;/code&gt; property. It will still default to &lt;code&gt;RESPAWN_HP&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A respawn stat will now always be set for characters, even if it is not defined in their database entry. By default it will be 0, and respawn checks have been adjusted accordingly to ignore characters with a respawn of 0.&lt;/li&gt;
&lt;li&gt;Added new Actor methods: &lt;code&gt;statRaised&lt;/code&gt; and &lt;code&gt;statLowered&lt;/code&gt;, which return a Boolean if the relevant stat is greater than or less than its base, respectively.&lt;/li&gt;
&lt;li&gt;Several puppet actions have had their texts rewritten to work with other pronouns.&lt;/li&gt;
&lt;li&gt;Removed a text glitch that ocurred when using an item in battle.&lt;/li&gt;
&lt;li&gt;The rest action will now remove Winded instead of Knocked Down, as intended.&lt;/li&gt;
&lt;li&gt;Hitting an Off-Balance character should no longer cause an error.&lt;/li&gt;
&lt;li&gt;It should no longer be possible for dead characters to gain non-persistent effects.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.01&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;New action properties: &lt;code&gt;enemyCD&lt;/code&gt; and &lt;code&gt;nameCD&lt;/code&gt;. These values will be automatically read to set the values of an enemy&#39;s cooldown Map when actions are executed. They default to the action&#39;s &lt;code&gt;cooldown&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; properties, but they can set to custom values if desired.&lt;/li&gt;
&lt;li&gt;Continuing in the theme of &quot;features I implemented embarassingly late&quot;, player actions will now decrement cooldown at the start of a round.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.00.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HP cost will now be automatically deducted when using HP-consuming skills.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 2.00&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Added a new file in &lt;code&gt;javascript/custom&lt;/code&gt;: &lt;code style=&quot;font-weight:bold&quot;&gt;mods.js&lt;/code&gt;. This file is designed as a catch-all for any miscellaneous code the user wants to add to the JavaScript. It consists of a function, &lt;code&gt;customMods&lt;/code&gt;, which is run at the end of StoryInit. (This placement is to ensure any relevant &lt;code&gt;setup&lt;/code&gt; variables are defined first.) Currently, the code for Puppets&#39; Energy- and Crisis-related attributes have been moved there, along with &lt;code&gt;XPtoNext&lt;/code&gt; and &lt;code&gt;initialThreat&lt;/code&gt;. This way, you can easily modify the specific functions you need without needing to edit the class definition.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;addeffect&lt;/code&gt; widget has been depreciated, and its code has been moved to &lt;code&gt;Actor.addEffect&lt;/code&gt;.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;&quot;effect adder custom blocks&quot; has been depreciated, and its functionality is now handled through properties of Effect objects: &lt;code&gt;block&lt;/code&gt;, &lt;code&gt;blockCondition&lt;/code&gt;, and &lt;code&gt;blockText&lt;/code&gt;. Block effects now have a &lt;code&gt;priority&lt;/code&gt; attribute as well to determine the order in which they resolve.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;applyEffect&lt;/code&gt; has been completely redone to better mesh with this change. It is now much simpler and is only capable of applying unmodified effects to a single target. For more complicated behavior, just use &lt;code&gt;addEffect&lt;/code&gt; directly.&lt;/li&gt;
&lt;li&gt;Actions have been edited to comply with the above change. Let me know if any bugs occur.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;&lt;code&gt;Puppet.getStatCost&lt;/code&gt; has been depreciated.&lt;/li&gt;
&lt;li&gt;Indirect damage will no longer trigger shield effects.&lt;/li&gt;
&lt;li&gt;EN cost is now deducted before actions execute, rather than after. This also allows Focus to work as intended without any additional code.&lt;/li&gt;
&lt;li&gt;Effect duration is now capped at a number specified by &lt;code&gt;DURATION_MAX&lt;/code&gt;, set as part of &lt;code&gt;setup&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Shield effects should now block status ailments. Additionally, if a damaging attack is blocked or dodged, status effects inflicted by the attack will also be blocked.&lt;/li&gt;
&lt;li&gt;Future applications of the same effect will now add to the effect&#39;s duration instead of resetting it.&lt;/li&gt;
&lt;li&gt;Fixed a glitch in Thorns (and any similar effects) where the original target would still take damage. Shield effects that inflict damage on someone else should no longer have data bleed leading to unusual behavior.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.27&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deathMessage&lt;/code&gt; can now be defined as a database property.&lt;/li&gt;
&lt;li&gt;Equipment slots can now be defined in &lt;code&gt;StoryInit&lt;/code&gt;, through the variable &lt;code&gt;DEFAULT_EQUIP_SLOTS&lt;/code&gt;, or as a database property, instead of being hardcoded in the Actor constructor.&lt;/li&gt;
&lt;li&gt;Added a new support function, &lt;code&gt;resetAnimation&lt;/code&gt;, that can be used to reset an animation mid-play. This function has been used to tweak hit animations such that shaking popups now take the same amount of time as non-shaking popups, hopefully reducing the time spent waiting for long multi-hit attacks to resolve.&lt;/li&gt;
&lt;li&gt;The delay between popups can now be adjusted through the &lt;code&gt;ANIM_DELAY&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;Removed the &quot;effect adder synonyms&quot; passage. Functionality is now handled through a &lt;code&gt;synonym&lt;/code&gt; property for Effects. If you define a &lt;code&gt;synonym&lt;/code&gt;, the effect will be synced to that tolerance during tolerance calculation.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uncontrollable&lt;/code&gt;, &lt;code&gt;untargetable&lt;/code&gt;, and &lt;code&gt;shield&lt;/code&gt; effects now operate the same way as &lt;code&gt;hold&lt;/code&gt; effects, preventing unexpected overwrites.&lt;/li&gt;
&lt;li&gt;Actors&#39; &lt;code&gt;addEffect&lt;/code&gt; and &lt;code&gt;removeEffect&lt;/code&gt; functions have been compartmentalized into a separate file, &lt;code&gt;effect-manager.js&lt;/code&gt;, for easier customization of effect logic.&lt;/li&gt;
&lt;li&gt;Animations can now be toggled on and off through the settings menu.&lt;/li&gt;
&lt;li&gt;Link color preferences should now work correctly again.&lt;/li&gt;
&lt;li&gt;Knocked Down puppets should be unable to act again.&lt;/li&gt;
&lt;li&gt;Damage-over-time messages will no longer display if the victim is defeated.&lt;/li&gt;
&lt;li&gt;Counterattacks and mark attacks should now animate correctly. They are also now handled on their own passage, rather than appended to the previous action.&lt;/li&gt;
&lt;li&gt;&quot;custom end of action effects&quot; now runs as part of &quot;action effects&quot;. &lt;code&gt;markAttack&lt;/code&gt; and &lt;code&gt;hunterCheck&lt;/code&gt; have also been moved to &quot;custom end of action effects&quot;.&lt;/li&gt;
&lt;li&gt;Counter logic has been offloaded to its own passage for modularity purposes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.26.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Health meters will no longer break if the player refreshes during a battle. Refreshing can still cause other problems, though, so try not to do it.&lt;/li&gt;
&lt;li&gt;Removed the &quot;enemy holds&quot; passage and replaced it with a &lt;code&gt;priority&lt;/code&gt; property for effects. Effects are now sorted by &lt;code&gt;priority&lt;/code&gt; to determine the correct hold effect to resolve.&lt;/li&gt;
&lt;li&gt;Fixed a bug where, in the case that a character was under multiple hold effects, removing just one effect would remove their &lt;code&gt;noact&lt;/code&gt; property and allow them to act again. This has been corrected by defining a new property for effects, &lt;code&gt;hold&lt;/code&gt;, and defining a getter function for &lt;code&gt;noact&lt;/code&gt; in &lt;code&gt;Actor&lt;/code&gt; that returns whether or not the character&#39;s effects contain a hold effect.&lt;/li&gt;
&lt;li&gt;Gaining Alert from losing Stunned will no longer generate a popup.&lt;/li&gt;
&lt;li&gt;Enemies will no longer generate a popup when righting themselves from Knocked Down.&lt;/li&gt;
&lt;li&gt;Puppets will no longer generate a popup by curing their ailments via Struggle or Rest.&lt;/li&gt;
&lt;li&gt;Puppets will no longer generate a popup at the start of battle for any ailments removed at the end of the previous battle.&lt;/li&gt;
&lt;li&gt;Protector and damage-over-time effects should work correctly again.&lt;/li&gt;
&lt;li&gt;HP regeneration will now be communicated via popups at the start of every round.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.26&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Documentation has now been split into &quot;Basic&quot; and &quot;Advanced&quot; sections. The &quot;Basic&quot; section should hopefully help people with less coding experience get into the engine more easily.&lt;/li&gt;
&lt;li&gt;Top-of-round effects should no longer trigger multiple times if an enemy uses an instant action as their first action.&lt;/li&gt;
&lt;li&gt;Indirect damage will no longer create popup messages.&lt;/li&gt;
&lt;li&gt;Puppets will no longer gain EN after every enemy turn.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;actorBox&lt;/code&gt; is now in its own file, &quot;Widgets (Actor Box)&quot;, and each of its elements has been made modular.&lt;/li&gt;
&lt;li&gt;Tightened restrictions on &lt;code&gt;uses&lt;/code&gt;, &lt;code&gt;cooldown&lt;/code&gt;, and &lt;code&gt;warmup&lt;/code&gt; attributes in the &lt;code&gt;Action&lt;/code&gt; constructor; they will now only be applied if they are integers.&lt;/li&gt;
&lt;li&gt;You can now specify an &lt;code&gt;action&lt;/code&gt; property for entries in the item database if you wish for their associated action to be different than their name.&lt;/li&gt;
&lt;li&gt;Removed &lt;code&gt;DoT&lt;/code&gt; and &lt;code&gt;Protector&lt;/code&gt; subclasses, as they were unnecessary. Their special attributes are now handled by an additional catchall argument to the &lt;code&gt;Effect&lt;/code&gt; constructor.&lt;/li&gt;
&lt;li&gt;Removed the &quot;lastaction mods&quot; passage and replaced it with the &quot;saveMod&quot; property for actions. If you want to save a different action, assign a name to its {{{saveMod}}} property.&lt;/li&gt;
&lt;li&gt;Added documentation for animation code.&lt;/li&gt;
&lt;li&gt;Revised the installation instructions for clarity.&lt;/li&gt;
&lt;li&gt;Fixed dummy links in the documentation headers and restored the external link icons for external links.&lt;/li&gt;
&lt;li&gt;Reduced the line height of text in the documentation passages for easier reading and less dead space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.25&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Battle animations! Nothing fancy, but actor boxes will now shake and produce damage value popups during action phases. You can turn them off by disabling the &lt;code&gt;ANIMATIONS&lt;/code&gt; flag in &lt;code&gt;StoryInit&lt;/code&gt;.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;As a consequence of the above, enemy actions now occur one at a time, instead of all at once. Tell me if this produces any bugs for you.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;&lt;code&gt;damageCalc&lt;/code&gt; will now only attempt to append element messages if the relevant setup variable exists.&lt;/li&gt;
&lt;li&gt;Fixed a bug in the number hotkey code.&lt;/li&gt;
&lt;li&gt;In-battle actor display is now standardized through a widget, &lt;code&gt;actorBox&lt;/code&gt;. This should make modifying the default display easier.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;The documentation has been updated to document this feature.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Actor boxes for dead characters are now aligned to the top of the flex container, and their height is restricted to only the height of the character&#39;s name.&lt;/li&gt;
&lt;li&gt;Dead characters now display a † (dagger) symbol in place of the status button.&lt;/li&gt;
&lt;li&gt;Fixed a bug that prevented &lt;code&gt;oncePerTurn&lt;/code&gt; actions from deactivating correctly.&lt;/li&gt;
&lt;li&gt;Fixed a bug that would allow illegal actions to be performed through the last action button under some circumstances.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.24.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newturn&lt;/code&gt; and &lt;code&gt;endofround&lt;/code&gt; have been renamed to &lt;code&gt;newTurn&lt;/code&gt; and &lt;code&gt;endOfRound&lt;/code&gt; for clarity.&lt;/li&gt;
&lt;li&gt;Effect decay messages are now lumped into one box per character.&lt;/li&gt;
&lt;li&gt;Effect decay messages have now been standardized into one widget, &lt;code&gt;decayMessage&lt;/code&gt;, which is called in both &lt;code&gt;newTurn&lt;/code&gt; and &lt;code&gt;endOfRound&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newTurn&lt;/code&gt; has been modified to also work with enemy parties, and is now called in the enemy phase.&lt;/li&gt;
&lt;li&gt;Console asserts have been added to &lt;code&gt;newTurn&lt;/code&gt; and &lt;code&gt;endOfRound&lt;/code&gt; to enforce proper behavior.&lt;/li&gt;
&lt;li&gt;Prone characters will no longer count towards the automatic turn end counter. This is to prevent a glitch where if all puppets were knocked down, the player would never get an opportunity to right them.&lt;/li&gt;
&lt;li&gt;Actions that cost 0 EN will now display their cost again. Crisis actions will only display a cost if it is greater than 0.&lt;/li&gt;
&lt;li&gt;Updated documentation to reflect changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.24&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Rogue now has a special Crisis that allows them to use any battle item for free. Try it out and see if it breaks anything.&lt;/li&gt;
&lt;li&gt;Tweaked Crisis display code so that it will no longer display if no Crisis abilities are specified in the puppet&#39;s database entry.&lt;/li&gt;
&lt;li&gt;You can now set specific Crisis factors for individual puppets. They will still default to &lt;code&gt;CRISIS_FACTOR&lt;/code&gt; if unset.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;Rogue now has a larger Crisis factor than other puppets: they will max their Crisis guage after losing 40% of their health.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;&lt;code&gt;passagejump&lt;/code&gt; actions will now forward the player to the passage specified by the &lt;code&gt;passagejump&lt;/code&gt; attribute, consistent with the documentation for the &lt;code&gt;passagejump&lt;/code&gt; getter.&lt;/li&gt;
&lt;li&gt;Created an &lt;code&gt;actionCheck&lt;/code&gt; function that condenses all the action checks into one call.&lt;/li&gt;
&lt;li&gt;The last action notifier will now be greyed out if the action is unusable.&lt;/li&gt;
&lt;li&gt;Fixed a bug related to the W hotkey.&lt;/li&gt;
&lt;li&gt;Added discussion and documentation for the Crisis feature.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.23.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Realized widgets couldn&#39;t be clobbered, so every widget is now in its own passage. If you wish to replace a widget with a custom version, just make a new passage with the same name in the &lt;code&gt;passages-unique&lt;/code&gt; folder and it&#39;ll be replaced.&lt;/li&gt;
&lt;li&gt;Database and class definitions have been partitioned into different files and folders for easier updating. You can now update the core JavaScript files without overwriting your custom databases.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;statInfo&lt;/code&gt; and &lt;code&gt;hiddenStats&lt;/code&gt; definitions moved to StoryInit.&lt;/li&gt;
&lt;li&gt;Fixed a bug that was causing &lt;code&gt;actionLink&lt;/code&gt; to fail in certain circumstances.&lt;/li&gt;
&lt;li&gt;The Q hotkey should no longer trigger the &quot;end turn&quot; button.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.23.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a typo that was causing the effect adder to fail.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.23&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; &quot;limit break&quot; abilities! Puppets will fill up a Crisis bar as they take damage, and can unleash a powerful ability when it&#39;s full.&lt;/li&gt;
&lt;li&gt;Prettified end-of-round messages. They now display in the style of actions instead of plain text.&lt;/li&gt;
&lt;li&gt;Added handlers for indirect damage (e.g. damage-over-time) to &lt;code&gt;echoDamage&lt;/code&gt;. Indirect damage will ignore most checks such as damage reflection, off-balance, and counters.&lt;/li&gt;
&lt;li&gt;Damage-over-time damage is now handled through &lt;code&gt;echoDamage&lt;/code&gt; rather than manually.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;decay&lt;/code&gt; function for Effects will now always return something, and will return an empty string if the effect didn&#39;t expire.&lt;/li&gt;
&lt;li&gt;You can now pass a puppet as an argument to &lt;code&gt;actionList&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &quot;struggle&quot; and &quot;rest&quot; commands will now correctly remove their respective statuses.&lt;/li&gt;
&lt;li&gt;Fixed a bug in the &quot;massAttack&quot; actions and previews.&lt;/li&gt;
&lt;li&gt;Hunter and counter checks are now hardcoded into the main battle passages. The widgets governing Mark and Hunter attacks have been offloaded to their own passage, &quot;Widgets (Special Attacks)&quot; for easier modularity.&lt;/li&gt;
&lt;li&gt;Piercing attacks will now use the lower of the target&#39;s Defense and the stat minimum, instead of always using the latter. This allows them to gain the benefit from negative Defense.&lt;/li&gt;
&lt;li&gt;Special deaths should no longer be skipped by the auto-endturn function.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B.specialmsg&lt;/code&gt; has been changed to a temporary variable. Now you will no longer need to reset it when your special message has finished.&lt;/li&gt;
&lt;li&gt;Cleaned up action display code. The various tests have been condensed into functions, found in the support functions file.&lt;/li&gt;
&lt;li&gt;The clunky check for whether Sacrifice was used on the current turn has now been turned into a general feature: actions with the &lt;code&gt;oncePerTurn&lt;/code&gt; property will gain a &lt;code&gt;used&lt;/code&gt; property after use and cannot be used again until it is cleared, which occurs on &lt;code&gt;newturn&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The clunky check for Sacrament and Blaspheny&#39;s prior element requirement has been turned into a general function, &lt;code&gt;actionElementCheck&lt;/code&gt; in support functions.&lt;/li&gt;
&lt;li&gt;Energy regeneration is now a property of puppets rather than a system constant. This allows you to make puppets with different regeneration values.&lt;/li&gt;
&lt;li&gt;Actions that cost 0 EN will no longer display a cost value in the actions menu.&lt;/li&gt;
&lt;li&gt;The compressed action info box will now direct the player to hover over actions when nothing is selected.&lt;/li&gt;
&lt;li&gt;There is now an option to remove ULTIMATESTICKY effects within battle. Simply assign a value of &quot;ultimate&quot; to the &lt;code&gt;unsticky&lt;/code&gt; argument.&lt;/li&gt;
&lt;li&gt;Fixed a rare bug where rounding errors could cause damage to erroneously be considered absorbed.&lt;/li&gt;
&lt;li&gt;Removed outdated reference images from the documentation.&lt;/li&gt;
&lt;li&gt;Self-inflicted status ailments should now bypass Chi Shield, as intended.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.22.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a bestiary-related bug that would occur when an enemy was struck with an element or ailment.&lt;/li&gt;
&lt;li&gt;Fixed a bug in Sacrament and Blasphemy.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.22&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; You can now give characters an &lt;code&gt;onHit&lt;/code&gt; function that will execute whenever they are struck by damage. Note that this is separate from damage reflection.&lt;/li&gt;
&lt;li&gt;Several action functions have been restructured to use a single &lt;code&gt;args&lt;/code&gt; argument, the properties of which make up the rest of the arguments. This will make it much easier to contruct action functions, as you can omit irrelevant arguments entirely and clearly label every argument you need. However, I may not have converted all existing actions to the new format correctly, so tell me if you encounter any bugs.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chiCheck&lt;/code&gt; has been renamed to &lt;code&gt;effectCheck&lt;/code&gt;, and can now check for any effect.&lt;/li&gt;
&lt;li&gt;Fixed a bug with the &quot;any&quot; modifier in &lt;code&gt;randomTarget&lt;/code&gt; and added support for enemies being affected by loss-of-control effects as well.&lt;/li&gt;
&lt;li&gt;The code for the Bubble and Thorns effects have been generalized to work with other effects. The code now checks if the target of an attack has a &quot;shielded&quot; flag, then searches their effects for an effect with a &quot;shield&quot; flag and runs its &quot;onHit&quot; function.&lt;/li&gt;
&lt;li&gt;Fixed a bug in &lt;code&gt;splashDamage&lt;/code&gt; that created an extra blank line.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.21.3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Rearranged the conditional checks in &lt;code&gt;callEncounter&lt;/code&gt; so that the bestiary update loop is only run if the bestiary is defined.&lt;/li&gt;
&lt;li&gt;There is now a preview function for healing actions.&lt;/li&gt;
&lt;li&gt;Items now have a getter for &lt;code&gt;special&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The enemy status display should no longer throw error messages.&lt;/li&gt;
&lt;li&gt;Enemy names should now display properly during the targeting phase.&lt;/li&gt;
&lt;li&gt;Fixed a bug in &lt;code&gt;randomTarget&lt;/code&gt; that caused problems when a party array was passed as an argument. It is now passed as a string instead.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.21.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Added a section on the design of story-based/fixed progression.&lt;/li&gt;
&lt;li&gt;Added a section on the design of skill progression.&lt;/li&gt;
&lt;li&gt;Slightly edited the design sections to provide some more information and resources.&lt;/li&gt;
&lt;li&gt;Added a return-home link at the bottom of info pages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.21.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The bestiary now flags every enemy as encountered (allowing them to appear in the bestiary) on game load.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gp&lt;/code&gt; and &lt;code&gt;xp&lt;/code&gt; properties are now in lowercase, for standardization with &lt;code&gt;hp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The code for formation and bestiary menu entries have been offloaded to separate twee files.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;encountered&lt;/code&gt; flag for bestiary entries is now flipped in &lt;code&gt;callEncounter&lt;/code&gt; instead of the &lt;code&gt;Enemy&lt;/code&gt; constructor.&lt;/li&gt;
&lt;li&gt;Added documentation for the bestiary in Additional Features.&lt;/li&gt;
&lt;li&gt;Fixed a glitch that prevented bestiary objects from reviving correctly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.21&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Bestiary/enemy encyclopedia. The code for its construction can be found in &lt;code&gt;database-enemies.js&lt;/code&gt;. The bestiary provides highly modular function, with tracking for masking/revealing every single stat, if desired. You can observe it for yourself in a new menu option.&lt;/li&gt;
&lt;li&gt;Further compartmentalized the actor display code.&lt;/li&gt;
&lt;li&gt;The getter for enemies&#39; &lt;code&gt;fullname&lt;/code&gt; attribute will now default to their regular name. This has allowed for some streamlining of the battle display.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.20&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Added a sticky item for you to test yourself. Start a new game and you&#39;ll find three mysterious rings in your inventory. Try them on and see what happens!&lt;/li&gt;
&lt;li&gt;Also added a decurse station to let you remove sticky equipment. Pay the cleric 1 GP to appraise an unknown item or to remove a cursed item you&#39;ve foolishly stuck on yourself.&lt;/li&gt;
&lt;li&gt;Fiddled with a few &lt;code&gt;Item&lt;/code&gt; properties:
  &lt;ul&gt;&lt;li&gt;&lt;code&gt;info&lt;/code&gt; and &lt;code&gt;desc&lt;/code&gt; can now be dynamically modified based on the Item&#39;s properties just like with Actions.&lt;/li&gt;
  &lt;li&gt;You can now give Items a &lt;code&gt;fakeName&lt;/code&gt; property, which will display in place of its real name until the item&#39;s &lt;code&gt;known&lt;/code&gt; attribute is flipped to &lt;code&gt;true&lt;/code&gt;. This is handy for hiding cursed items from the player.&lt;/li&gt;
  &lt;li&gt;To facilitate the above, Items&#39; database pointer is now a separate property, &lt;code&gt;id&lt;/code&gt;, from its display name. Use &lt;code&gt;id&lt;/code&gt; for any code operations that require drawing from the database, and &lt;code&gt;name&lt;/code&gt; for any time the item&#39;s name is being displayed to the player.&lt;/li&gt;
  &lt;li&gt;Renamed the &lt;code&gt;cost&lt;/code&gt; property to &quot;value&quot; to avoid confusion with Actions&#39; &lt;code&gt;cost&lt;/code&gt; property. &lt;b&gt;Any custom code made in previous versions will need to be updated accordingly.&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;You can now unequip items from the equipment screen without selecting a specific character again.&lt;/li&gt;
&lt;li&gt;Sticky items can no longer be removed by replacing them with equipment from the same slot.&lt;/li&gt;
&lt;li&gt;As part of the above, sticky equipment can no longer be removed with the &lt;code&gt;unequip&lt;/code&gt; function by default. Pass an &lt;code&gt;unsticky&lt;/code&gt; property to the &lt;code&gt;mods&lt;/code&gt; argument to do so.&lt;/li&gt;
&lt;li&gt;The equipment and inventory lists now have their own scrollbars, so you won&#39;t lose track of your selection when you&#39;re scrolling through long lists anymore.&lt;/li&gt;
&lt;li&gt;The item shop (and the new decurse station) now use &lt;code&gt;live&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; to display your item points, for neatness.&lt;/li&gt;
&lt;li&gt;Cleaned up some of the HTML in the menu screens. Several elements that were hardcoded are now defined as CSS classes, and the display code for actor blocks has been condensed into one widget with modular functionality. &lt;b&gt;This required changing some widget names, so custom menu code made in previous versions may be incompatible.&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setInv&lt;/code&gt; is now called in &lt;code&gt;user storyinit&lt;/code&gt;. A blank inventory is still automatically initialized in StoryInit.&lt;/li&gt;
&lt;li&gt;Fixed a bug in the inventory screen that stopped hotkeys from working if an item was selected after using or equipping another item.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.19&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Accessibility features added: You can now change the default font to OpenDyslexic for easier reading with dyslexia, and change the link color if you have a condition that makes it difficult to pick out blue. &lt;b&gt;If you have one of these conditions, please tell me if these options are helpful and suggest changes if they are not.&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Tweaked the link mouseover color to be a bit less bright.&lt;/li&gt;
&lt;li&gt;Finally fixed the weird background color glitching when selecting input fields. It should now display black text on a white background, like everything else in the bleached style.&lt;/li&gt;
&lt;li&gt;Changed the input field for spell costs to &lt;code&gt;numberbox&lt;/code&gt; for ease of use.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.18&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Equipment locking. If you set the &lt;code&gt;lockEquipment&lt;/code&gt; attribute on a Puppet, the player will be unable to change their equipment. Note that you can still alter their equipment through manual &lt;code&gt;equip&lt;/code&gt; and &lt;code&gt;unequip&lt;/code&gt; executions.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;Specific equipment can also be locked. If its &lt;code&gt;sticky&lt;/code&gt; attribute is truthy, you can put it on, but you can&#39;t take it off! Perfect for cursed items and the like.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;The equip-from-inventory screen is now neater, with characters who can&#39;t equip the selected item not appearing at all.&lt;/li&gt;
&lt;li&gt;Color of Defeat is now restricted to Artist, purely for ease of testing the restriction mechanic.&lt;/li&gt;
&lt;li&gt;It should no longer be possible to bypass an equipment restriction by equipping the item from the inventory screen.&lt;/li&gt;
&lt;li&gt;Character names should no longer disappear when listed in the inventory screen.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkRestriction&lt;/code&gt; has been reversed, and is now called on an Actor with an Item as an argument. The Item-centric version still exists, but will be depreciated.&lt;/li&gt;
&lt;li&gt;You can now hide specific core stats, preventing them from being displayed in the menu or status pane. To do so, add the stat name to the &lt;code&gt;setup.hiddenStats&lt;/code&gt; variable in &lt;code&gt;stat class.js&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Renamed the &lt;code&gt;inv&lt;/code&gt; variable to &lt;code&gt;inventory&lt;/code&gt; for clarity. The shorthand &lt;code&gt;inv()&lt;/code&gt; still works.&lt;/li&gt;
&lt;li&gt;Moved the definition for &lt;code&gt;V&lt;/code&gt; to support functions.&lt;/li&gt;
&lt;li&gt;Reorganized the code for the party menu to be a bit easier to use. Stat display code is now standardized to one template passage, and &lt;code&gt;equipmentlist&lt;/code&gt; is now a passage rather than a widget.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.17&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Miss chance and critical hits, even though I hate them. Default rates are defined in StoryInit, and custom rates can be defined in an action&#39;s definition. See the &lt;code&gt;accuracyCheck&lt;/code&gt; and &lt;code&gt;critCheck&lt;/code&gt; widgets added to &quot;Damage and Formulas&quot; for more details. By default, these are turned off (set to always-accurate and 0% respectively).&lt;/li&gt;
&lt;li&gt;Added support for attacks with mulitple elements. To do this, assign an array of element names (as strings) to the action&#39;s &lt;code&gt;element&lt;/code&gt; property. Set the &lt;code&gt;AVERAGE_ELEMENTS&lt;/code&gt; variable in StoryInit to determine if you want the calculation to average each element, or to just find the best one.&lt;/li&gt;
&lt;ul&gt;&lt;li&gt;To demonstrate this new feature, Artist has gained four new attacks with multi-element properties.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;Improved the getter for Actions&#39; &lt;code&gt;element&lt;/code&gt; property. It will now log an error if the element is not in the element list, and it will return &lt;code&gt;null&lt;/code&gt; if an illegal datatype was assigned to the property.&lt;/li&gt;
&lt;li&gt;Renamed the &lt;code&gt;invisible&lt;/code&gt; property of Actions to &lt;code&gt;silent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Element messages no longer have hardcoded trailing spaces. The trailing space is now automatically added to all element messages in &lt;code&gt;damageCalc&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Renamed the &lt;code&gt;min_dmg&lt;/code&gt; variable with ALLCAPS for consistency with other constant variables.&lt;/li&gt;
&lt;li&gt;Renamed &lt;code&gt;call&lt;/code&gt; to &lt;code&gt;callEncounter&lt;/code&gt; for clarity.&lt;/li&gt;
&lt;li&gt;You can now specify the splash damage cut value and provide an extension for &lt;code&gt;grenade&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grenade&lt;/code&gt; renamed to &lt;code&gt;splashDamage&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added specification notes to Action properties.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.16.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Moved the encounters database to passages-unique.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randomtarget&lt;/code&gt;, &lt;code&gt;echodamage&lt;/code&gt;, &lt;code&gt;damagecalc&lt;/code&gt;, &lt;code&gt;addeffect&lt;/code&gt;, and &lt;code&gt;dispeltarget&lt;/code&gt; have been renamed with camelCaps for better consistency and clarity.&lt;/li&gt;
&lt;li&gt;Renamed the &lt;code&gt;cure&lt;/code&gt; function to &lt;code&gt;removeEffect&lt;/code&gt; and added modifiers to specify removal of ailments only, buffs only, or all effects.&lt;/li&gt;
&lt;li&gt;It is now possible to pass an &quot;all&quot; selector to targeting functions, which will cause the action to affect all characters on the battlefield (puppets and enemies).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Actor.removeEffect&lt;/code&gt; now has an argument that enables the removal of all instances of a stackable effect.&lt;/li&gt;
&lt;li&gt;Debuff cure items now remove all instances of their respective debuffs.&lt;/li&gt;
&lt;li&gt;Fixed a bug in the effect of Canned Air.&lt;/li&gt;
&lt;li&gt;Fixed several bugs in &lt;code&gt;removeEffect&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Tweaks made to &lt;code&gt;Actor.removeEffect&lt;/code&gt; and &lt;code&gt;Effect.decay&lt;/code&gt; for more consistent line spacing.&lt;/li&gt;
&lt;li&gt;Several tweaks made to action functions to enable better chaining.&lt;/li&gt;
&lt;li&gt;Several actions have been rewritten to use action functions instead of the original custom code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.16&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Shock cures. It is now possible for direct damage to cure certain status effects. Add a &quot;shock&quot; property value to the status effect to enable this. It can be either &lt;code&gt;true&lt;/code&gt; for a guaranteed cure every time, or an integer value between 1 and 100 equal to the chance of cure &lt;s&gt;if you&#39;re a filthy randomizer&lt;/s&gt;. None of the default effects use this feature at the present time.&lt;/li&gt;
  &lt;ul&gt;&lt;li&gt;As a corollary, you can now set a &lt;code&gt;noShock&lt;/code&gt; property for actions if you do not wish for them to trigger shock cures.&lt;/li&gt;&lt;/ul&gt;
&lt;li&gt;File extensions have been converted from &lt;code&gt;.twee&lt;/code&gt; to &lt;code&gt;.tw&lt;/code&gt; to enable compatibility with Atom&#39;s SugarCube interpreter. Hopefully this will not cause problems.&lt;/li&gt;
&lt;li&gt;Updated documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.15.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Moved the puppets definition from the default &lt;code&gt;StoryInit&lt;/code&gt; to the custom passage.&lt;/li&gt;
&lt;li&gt;Updated documentation for changes to the effect adder.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.15.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed an error that prevented actions with &lt;code&gt;displayname&lt;/code&gt; from working as intended.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.15&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Turn exchange. If this variable is set in &lt;code&gt;StoryInit&lt;/code&gt;, an enemy will automatically act after every player action. This is useful if you don&#39;t want players ganging up on enemies.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; You can now set any action as a puppet&#39;s default action in the status menu, provided it does not have the &lt;code&gt;noDefault&lt;/code&gt; property.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; You can now customize the appearance of your save game displays! See the documentation and the &lt;code&gt;saves-modifier.js&lt;/code&gt; file for details.&lt;/li&gt;
&lt;li&gt;There is now a link to the party menu on the sidebar, in case the hotkeys don&#39;t work.&lt;/li&gt;
&lt;li&gt;The commands menu will no longer continue to display after selecting a command. This should hopefully make playing with the mouse a little easier.&lt;/li&gt;
&lt;li&gt;The functionality of number hotkeys has been moved to a widget, &lt;code&gt;numKey&lt;/code&gt;, and can be found in &lt;code&gt;Widgets (Misc)&lt;/code&gt;. This will allow you to change the behavior of all number keys by just altering one block of code.&lt;/li&gt;
&lt;li&gt;The &quot;last action&quot; notification in battle now says what the last action is, and does not display at all if there isn&#39;t one.&lt;/li&gt;
&lt;li&gt;The action list display has been revamped. By default, it now displays only the action names and their EN cost, with additional information appearing on mouseover. (For mobile users, you can return to the old display through an option in the Settings menu.) Additionally, the action list is now contained to a fixed height, and gains a scrollbar if the text exceeds that height. (This should prevent it from overflowing the viewport on most monitors.) This can be changed by modifying the &lt;code&gt;actionList&lt;/code&gt; ID in &lt;code&gt;battle display.css&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fixed some unterminated class and function expressions.&lt;/li&gt;
&lt;li&gt;Fixed several bugs in the action functions that used &lt;code&gt;findTarget&lt;/code&gt;. They should now work more intuitively, and you no longer need to wrap them in a double-function call on the database end.&lt;/li&gt;
&lt;li&gt;Protector should work again.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.14.3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed an error in &lt;code&gt;applyEffect&lt;/code&gt;. Single-target actions should no longer hit the whole party.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addEffect&lt;/code&gt; will now generate an error message if no arguments are passed to it.&lt;/li&gt;
&lt;li&gt;Knocked Down applications should no longer create an error.&lt;/li&gt;
&lt;li&gt;Knocked Down should now correctly &lt;i&gt;decrease&lt;/i&gt; Defense, instead of increasing it.&lt;/li&gt;
&lt;li&gt;Fixed some text glitches in the previews of &quot;struggle&quot; and &quot;rest&quot; actions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;actions_this_turn&lt;/code&gt; should no longer generate an error when an enemy uses an ally-targeting skill.&lt;/li&gt;
&lt;li&gt;Exclusive effects should now be properly applied again.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.14.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is no longer possible to set an action&#39;s uses to more than its max uses.&lt;/li&gt;
&lt;li&gt;Fixed a naming error in the function for resetting action cooldown. Cooldowns should be correctly reset now.&lt;/li&gt;
&lt;li&gt;Added &lt;a href=&quot;https://daneden.github.io/animate.css/&quot; target=&quot;_blank&quot;&gt;animate.css&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The background music now requires the user to click a link instead of playing automatically.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.14.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The engine is now completely independent of Twine! The &lt;code&gt;StoryData&lt;/code&gt; passage is now used to store necessary project data. Remember to edit it when making your own project. (Remove the &lt;code&gt;StorySettings&lt;/code&gt; passage to generate your own IFID.)&lt;/li&gt;
&lt;li&gt;Removed &lt;code&gt;Effect Adder-modded&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fixed several errors in the effect adder and the &lt;code&gt;Action.displayname&lt;/code&gt; getter.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.14&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Loss-of-control effects. These effects will force your puppets to attack randomly at the start of a round, like &quot;berserk&quot; or &quot;confusion&quot; effects in most RPGs. There are now three new effects in the effect database to let you test this for yourself: &quot;Hatred&quot; forces the puppet to attack enemies, &quot;Charmed&quot; forces the puppet to attack its allies (potentially including itself), and &quot;Confusion&quot; can make the puppet target anyone on the field.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Battle grids. You can now display parties in a 3-by-3 grid on the battlefield. By default, characters in higher rows will guard lower ones, protecting them from direct attacks; you can implement other features as well. Set the &lt;code&gt;BATTLE_GRID&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; in StoryInit to enable this feature, but mind the instructions in the documentation. An additional menu pane for altering the formation of your characters has also been added. Helper functions have been added to &lt;code&gt;1_support-functions.js&lt;/code&gt; to assist, allowing you to easily call parties excluding empty slots. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Cooldown! You can now set a cooldown (and warmup) property for actions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enemytarget&lt;/code&gt; has been tweaked for compatibility with loss-of-control effects. As it can now be called by puppets as well, it has been renamed &lt;code&gt;randomTarget&lt;/code&gt; for clarity.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echoDamage&lt;/code&gt; has been tweaked to avoid triggering counters and damage reflection if an attacker targets itself with an attack.&lt;/li&gt;
&lt;li&gt;Mark and Hunter attacks will no longer trigger if the hunter is uncontrollable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshPuppets&lt;/code&gt; will now automatically remove sticky effects.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;trigger&lt;/code&gt; property has been tweaked: It is now designed as a function that returns &lt;code&gt;true&lt;/code&gt; if the counter should trigger, offloading functionality into the specific counters themselves. By default, it now returns &lt;code&gt;true&lt;/code&gt;, meaning an undefined trigger will always activate the counter.&lt;/li&gt;
&lt;li&gt;Added new &lt;code&gt;formula&lt;/code&gt; property for actions, allowing users to specify unique damage formulas.&lt;/li&gt;
&lt;li&gt;Added new &lt;code&gt;useSpecial&lt;/code&gt; property for actions. This is a number between 0 and 1 that determines the proportion of base damage affected by the Special stat as opposed to the Attack stat. By default, this is set to 1 for attack items. See the updated &lt;code&gt;damageCalc&lt;/code&gt; function for details.&lt;/li&gt;
&lt;li&gt;Actors&#39; stat getter function now returns 0 if the stat could not be found. This ensures that your game will run smoothly with the new damage calculation code even if you do not use the Special stat.&lt;/li&gt;
&lt;li&gt;Offloaded the special functionality for Exacerbate and Downfall into functions tied to the actions themselves. This, combined with the &lt;code&gt;useSpecial&lt;/code&gt; functionality, has made the &quot;damageCalc special actions&quot; passage obsolete, and it has been removed.&lt;/li&gt;
&lt;li&gt;Cleaned up the action getters by making the lookup with &lt;code&gt;displayname&lt;/code&gt; part of the basic &lt;code&gt;actionData&lt;/code&gt; getter instead of manually inserting it into each getter.&lt;/li&gt;
&lt;li&gt;Defined a &quot;wait&quot; action for enemies that allows them to delay their turn until later in the priority order.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;actions_this_turn&lt;/code&gt; is now a property of the battle controller, and tracks the actions of &lt;i&gt;all&lt;/i&gt; the enemies during the round, not just the current enemy. This allows you to have enemies react to other enemies&#39; behavior.&lt;/li&gt;
&lt;li&gt;New widget: &lt;code&gt;populateEnemies&lt;/code&gt;. This allows you to more quickly generate enemy parties by just passing the names of each enemy. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;massAttack&lt;/code&gt; has been improved with support for row, column, and adjacent attacks if the battle grid is enabled.&lt;/li&gt;
&lt;li&gt;Added new &lt;code&gt;pushAttack&lt;/code&gt; action function that moves characters on the battle grid.&lt;/li&gt;
&lt;li&gt;Added getters for Actors&#39; row and column locations.&lt;/li&gt;
&lt;li&gt;Support functions such as &lt;code&gt;getActor&lt;/code&gt; have been split into a separate file, &lt;code&gt;1_support-functions.js&lt;/code&gt;. Several functions for the aiding of battle grids have been added, plus a function that converts numbers to words.&lt;/li&gt;
&lt;li&gt;The status pane now scrolls vertically with the user&#39;s viewport.&lt;/li&gt;
&lt;li&gt;Fixed a problem with some of Cleric&#39;s abilities.&lt;/li&gt;
&lt;li&gt;Status buttons now have a small left margin to give them a buffer against long character names.&lt;/li&gt;
&lt;li&gt;Fixed an error in &lt;code&gt;playMusic&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.13.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Getters for Effects have been remade with greater specificity. It is now possible to override Boolean flags with &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &quot;persistent&quot; property for effects is now split into &lt;code&gt;persistAfterDeath&lt;/code&gt; and &lt;code&gt;persistAfterBattle&lt;/code&gt; for greater modularity. &lt;code&gt;refreshPuppets&lt;/code&gt; now only removes effects that do not &lt;code&gt;persistAfterBattle&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Effect.decay&lt;/code&gt; should now be able to remove sticky effects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshPuppets&lt;/code&gt; now only refills action uses if the &lt;code&gt;actionRefillAfterBattle&lt;/code&gt; variable is &lt;code&gt;true&lt;/code&gt;. By default, it is set to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deathcheck&lt;/code&gt; will now remove sticky effects from defeated characters.&lt;/li&gt;
&lt;li&gt;Added links to SugarCube language definitions and Chapel&#39;s custom macros in the installation help page.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.13.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Added a section in Design discussing targeting systems.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endofbattle&lt;/code&gt; now unsets the battle controller and the enemy party variable to reduce overhead.&lt;/li&gt;
&lt;li&gt;Added &lt;code&gt;fight&lt;/code&gt;, &lt;code&gt;playMusic&lt;/code&gt;, and &lt;code&gt;clearMusic&lt;/code&gt; macros (thanks to A Friendly Irin for providing this code), and the &lt;code&gt;typewriter&lt;/code&gt; macro to &lt;code&gt;Widgets (General)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addItem&lt;/code&gt; now has a handler preventing item stacks from going over an &lt;code&gt;ITEM_MAX&lt;/code&gt; variable. By default, this is set to 9.&lt;/li&gt;
&lt;li&gt;Added the &lt;code&gt;itemDrop&lt;/code&gt; macro from &lt;i&gt;Cartoon Battle&lt;/i&gt;. Sorry, I thought I already added this one!&lt;/li&gt;
&lt;li&gt;Implemented support for enemy item drops.&lt;/li&gt;
&lt;li&gt;The variable names for struggle cost, berserker factor, and defender factor have been changed to allcaps for consistency with other constant variables.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LevelUps&lt;/code&gt; is now initialized to an empty array in &lt;code&gt;StoryInit&lt;/code&gt;. This should prevent later errors.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshPuppets&lt;/code&gt; has been moved back to the default end of battle code, but has been given additional handlers if lasting damage is desired.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deathcheck&lt;/code&gt; now adds the entire enemy object to the &lt;code&gt;kills&lt;/code&gt; array, instead of just the name. This will allow you to access more attributes of defeated enemies as desired.&lt;/li&gt;
&lt;li&gt;The info text for Defender now correctly refers to the defend factor, not the berserk factor.&lt;/li&gt;
&lt;li&gt;Updated documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.13&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Aggro targeting! There is now a system for making enemies preferentially target characters based on how much damage they&#39;ve inflicted. Set the &lt;code&gt;THREAT_TARGETING&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;StoryInit&lt;/code&gt; to activate it. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;&lt;b&gt;NEW FEATURE:&lt;/b&gt; Limited-use actions. You can now define an action as having a hard limit of uses per battle. By default uses are refilled after battle, but you can change this if you wish. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;enemytarget&lt;/code&gt; widget has been streamlined and modified to incorporate threat targeting.&lt;/li&gt;
&lt;li&gt;The name of your game&#39;s currency can now be set in &lt;code&gt;StoryInit&lt;/code&gt; and will display any time currency is referenced. By default, the name is &quot;GP&quot;.&lt;/li&gt;
&lt;li&gt;Added getters for assigning XP and GP rewards to enemies.&lt;/li&gt;
&lt;li&gt;Added getters for &lt;code&gt;growthRates&lt;/code&gt; and &lt;code&gt;StatTable&lt;/code&gt; for Puppets.&lt;/li&gt;
&lt;li&gt;Added a getter and setter for the &lt;code&gt;dead&lt;/code&gt; property that automatically resets respawn and threat values when appropriate.&lt;/li&gt;
&lt;li&gt;Added a Puppet method function: &lt;code&gt;hasAction&lt;/code&gt;. This checks if the Puppet has an action of the given name.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deathcheck&lt;/code&gt; now adds defeated enemies&#39; XP and GP rewards to the battle total.&lt;/li&gt;
&lt;li&gt;Puppets now have kill and defeat counters that are incremented in &lt;code&gt;deathcheck&lt;/code&gt;. They aren&#39;t currently displayed anywhere, but they&#39;re there if you want to use them.&lt;/li&gt;
&lt;li&gt;The party menu now displays the player&#39;s GP.&lt;/li&gt;
&lt;li&gt;Implemented a more robust victory handler. The victory screen now displays XP and GP rewards, displays the effects of any level ups, and auto-forwards the player to a passage that can be specified in the encounter definition but defaults to the passage the battle was entered from. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;The default level up handler is now neater and more robust.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;levelRate&lt;/code&gt;, &lt;code&gt;growthRates&lt;/code&gt;, and &lt;code&gt;StatTable&lt;/code&gt; have been changed to database properties, accessed through Puppet getter functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endofbattle&lt;/code&gt; now sets a flag recording that the encounter was fought. You can access these flags through the &lt;code&gt;encounters&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deathcheck&lt;/code&gt; will now remove effects only if they &lt;i&gt;aren&#39;t&lt;/i&gt; persistent, not only if they are.&lt;/li&gt;
&lt;li&gt;The check for legal action use has been moved from the hotkey code into the {{{&lt;&lt;actionLink&gt;&gt;}}} macro directly.&lt;/li&gt;
&lt;li&gt;The Q key now triggers the link in the confirm phase rather than just forwarding the player to the action phase. This is useful if you want the confirm link to perform additional code.&lt;/li&gt;
&lt;li&gt;The code for &lt;code&gt;actionList&lt;/code&gt; now looks a bit neater.&lt;/li&gt;
&lt;li&gt;Fixed a broken link in Design.&lt;/li&gt;
&lt;li&gt;Updated documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.12&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;NEW CHARACTER:&lt;/b&gt; The Artist. This character was created purely to explore the elemental affinities system, and is not intended to be balanced. Try them out on the Mystery Twins!&lt;/li&gt;
&lt;li&gt;Actors have now been converted to a database structure. This should make runtime more efficient and facilitates the construction of in-game lists such as a Pokedex or bestiary.&lt;/li&gt;
&lt;li&gt;Implemented &quot;advance turn&quot; functionality that allows you to space out enemy turns within a round. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;Implemented support for &quot;ambush&quot; encounters where the enemy takes the first round.&lt;/li&gt;
&lt;li&gt;Implemented support for &quot;full-round&quot; enemy actions that take up all of the enemy&#39;s remaining attacks, as well as a corresponding getter function in the Action class.&lt;/li&gt;
&lt;li&gt;Implemented support for damage reflection. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;Implemented support for counterattacks. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;Implemented support for puppet respawns.&lt;/li&gt;
&lt;li&gt;Added a new Stat subclass, &lt;code&gt;FillStat&lt;/code&gt;. This class is for stats that contain both a current and maximum value that can be exhausted and refilled, such as tolerances.&lt;/li&gt;
&lt;li&gt;Rehauled action functions with greater functionality and documentation. In particular, the &lt;code&gt;massAttack&lt;/code&gt; function can now function as a vanilla area-of-effect attack. &lt;b&gt;Note the warning in the new &lt;code&gt;findTarget&lt;/code&gt; function.&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Added a &lt;code&gt;heal&lt;/code&gt; function, for those weirdos who want players to be able to recover HP.&lt;/li&gt;
&lt;li&gt;You can now mask the stats of enemies in the status screen by flagging a &lt;code&gt;maskstats&lt;/code&gt; attribute.&lt;/li&gt;
&lt;li&gt;Main stats are now kept in a generic object, not a Map. This should make them more accessible in code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setHP&lt;/code&gt; depreciated; the &lt;code&gt;hp&lt;/code&gt; property now has a proper getter and setter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;damageCalc&lt;/code&gt; now accepts a custom target like &lt;code&gt;echoDamage&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added several additional getters for Action objects.&lt;/li&gt;
&lt;li&gt;Implemented a getter and setter for the &lt;code&gt;en&lt;/code&gt; property that bounds it between 0 and &lt;code&gt;maxen&lt;/code&gt;. This allowed for the removal of the loop that otherwise accomplished this in PassageReady.&lt;/li&gt;
&lt;li&gt;Implemented a new method function for &lt;code&gt;Actors&lt;/code&gt;: &lt;code&gt;hasEquipped&lt;/code&gt;. This will return &lt;code&gt;true&lt;/code&gt; if the character has the equipment specified in the argument. (Thanks to A Friendly Irin for providing this code.)&lt;/li&gt;
&lt;li&gt;Moved the code for displaying player commands to its own passage for greater modularity.&lt;/li&gt;
&lt;li&gt;Offloaded elemental hit messages to a variable defined in {{{StoryInit}}} so users can more easily modify them.&lt;/li&gt;
&lt;li&gt;Hunter counterattacks will now only trigger once for enemies that take multiple actions in the default code.&lt;/li&gt;
&lt;li&gt;Prone characters should be able to be selected again.&lt;/li&gt;
&lt;li&gt;Fixed a glitch that prevented buffs from displaying their removal message.&lt;/li&gt;
&lt;li&gt;Elemental immunities should now actually result in 0 damage rather than the minimum damage value.&lt;/li&gt;
&lt;li&gt;Actions should no longer be disabled if a character has 0 HP and is somehow still acting unless the action has a defined &lt;code&gt;hpcost&lt;/code&gt; value.&lt;/li&gt;
&lt;li&gt;Added a section in Design explaining HP and hit-to-kill ratios.&lt;/li&gt;
&lt;li&gt;Updated documentation to reflect changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.11.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Enemy attack order can now be customized.&lt;/b&gt; Instead of enemies always acting in index order, you can give them a &lt;code&gt;priority&lt;/code&gt; property to determine who acts in what order. Enemies will act in ascending priority value. Enemies will still act in index order by default.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hunterCheck&lt;/code&gt; now resets the active target, subject, and action back to the originals after the counter is finished. Additionally, support for enemy hunters and multiple hunters within each party has been added.&lt;/li&gt;
&lt;li&gt;The call to &lt;code&gt;hunterCheck&lt;/code&gt; now takes place in &quot;custom end of action effects&quot;, for greater modularity and to facilitate enemy hunters.&lt;/li&gt;
&lt;li&gt;Support for enemy instant actions has been added: If an enemy uses an action with the &lt;code&gt;instant&lt;/code&gt; property flagged to &lt;code&gt;true&lt;/code&gt;, it will not end their turn. Obviously, be careful to avoid infinite loops with this.&lt;/li&gt;
&lt;li&gt;Enemies with multiple attacks will no longer continue to act if they die or are stunned in the middle of their turn.&lt;/li&gt;
&lt;li&gt;New property for effects: &lt;b&gt;&lt;code&gt;persistent&lt;/code&gt;&lt;/b&gt;. If flagged &lt;code&gt;true&lt;/code&gt;, the effect will persist even after the character is defeated.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.11&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Redid the getter functions for Boolean attributes of actions. They are now more robust, and will correctly return &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if you set the override property to that value.&lt;/li&gt;
&lt;li&gt;Added a new getter for actions: &lt;code&gt;displayname&lt;/code&gt;. This is used for when you want the name that displays in the action list to be different than the name given in the code. (Thanks to A Friendly Irin for providing this.)&lt;/li&gt;
&lt;li&gt;The mute button now uses icons rather than the word &quot;MUTE&quot;. These icons were taken from &lt;a href=&quot;https://material.io/&quot; target=&quot;_blank&quot;&gt;Material Design&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Battle styling is now tied to a string variable, &lt;code&gt;B.style&lt;/code&gt;, rather than Booleans. If you enter a string for &lt;code&gt;B.style&lt;/code&gt;, the page will gain that class.&lt;/li&gt;
&lt;li&gt;Battle styling code has now been moved to the main &quot;Preparation&quot; passage.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;justeffect&lt;/code&gt; and &lt;code&gt;dmgandeffect&lt;/code&gt; have been condensed into one function, &lt;code&gt;applyEffect&lt;/code&gt;. The code has been reworked to more easily accommodate applying multiple effects at once: just pass an array of names to the &quot;type&quot; parameter instead of a single string. Additionally, a new parameter has been added that can be flagged to make the applied effects pierce tolerance.&lt;/li&gt;
&lt;li&gt;New action function: &lt;b&gt;&lt;code&gt;multihitCustom&lt;/code&gt;&lt;/b&gt;. This function makes it easier to implement more complex multi-hit abilities. Look at the action functions code to see it in full.&lt;/li&gt;
&lt;li&gt;New helper function: &lt;b&gt;&lt;code&gt;deadCount&lt;/code&gt;&lt;/b&gt;. This returns the number of puppets currently flagged dead. It is located in 0_config.js.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.10.4&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;So apparently, all this time I forgot to make enemy protectors actually protect people. This has now been corrected.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.10.3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Status effects will no longer use an incorrect plural for their remaining duration if the duration is only 1 turn.&lt;/li&gt;
&lt;li&gt;Ending a dark-styled battle will no longer result in a &quot;flicker&quot; before transfering to the next passage. (Thanks to A Friendly Irin for figuring this one out.)&lt;/li&gt;
&lt;li&gt;Re-applying an effect should no longer produce a blank line.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.10.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed a bug in the command functionality from the 1.09 update. Command buttons should no longer link you to the wrong characters&#39; actions.&lt;/li&gt;
&lt;li&gt;It is now once again possible to target allies with ally-targeting skills.&lt;/li&gt;
&lt;li&gt;Updated the link to the Tweego installer in the installation guide. It should hopefully link to a valid page now.&lt;/li&gt;
&lt;li&gt;Steven should no longer generate an error when he&#39;s defeated.&lt;/li&gt;
&lt;li&gt;The Crystal Gems will now protect Steven as they do in &lt;i&gt;Cartoon Battle&lt;/i&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.10.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Modified &lt;code&gt;addEffect&lt;/code&gt; for better readability and versatility. It will now bypass the power calculation branches if you do not use the Special stat in your game, preventing potential glitches. It has also been changed to a proper skeleton model with specific &lt;i&gt;Cartoon Battle&lt;/i&gt; elements removed, though this means it is overwritten by a modified version in passages-unique that will have to be removed if you want to make changes.&lt;/li&gt;
&lt;li&gt;The quit button is now displayed in battle again. It is now tied to &lt;code&gt;actorlist puppets&lt;/code&gt; rather than &lt;code&gt;commands&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Added the championship enemies to the enemy database, if you&#39;d like to see how their AI was constructed.&lt;/li&gt;
&lt;li&gt;Removed some console logs in the code that were left over from testing.&lt;/li&gt;
&lt;li&gt;Updated documentation to reflect changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.10&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HP regeneration and elemental affinities now have support for both flat and percent-based attributes. Status screens have been updated to display both types, but if you don&#39;t plan to use flat rates, you can hide them from the display by modifying the &lt;code&gt;SOAK&lt;/code&gt; and &lt;code&gt;FLAT_REGEN&lt;/code&gt; variables in StoryInit. &lt;b&gt;You will need to remake any Actor objects for earlier saves to be compatible with this update.&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Added new Actor method functions:&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;regenHP&lt;/code&gt;: Runs flat and proportional regeneration simultaneously.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getElement&lt;/code&gt;: Allows you to specify whether you are getting the flat or porportional elemental affinity. You may also leave the second argument blank to get the raw object.&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;The Map versions of &lt;code&gt;addMod&lt;/code&gt; and &lt;code&gt;removeMod&lt;/code&gt; now include support for an additional argument specifying whether the mod should be applied to flat or proportional.&lt;/li&gt;
&lt;li&gt;Items now use object cloning for &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;toJSON&lt;/code&gt;. This should correct a bug with unequipping stacked accessories negating the mods from all accessories.&lt;/li&gt;
&lt;li&gt;Menu widgets have been moved to the &lt;code&gt;party menu.twee&lt;/code&gt; file for easier reference. The previous file has been renamed to &lt;code&gt;Widgets (Misc)&lt;/code&gt; and contains widgets for status pane displays.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.09.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addEffect&lt;/code&gt; now works when passed an effect name, not just an Effect object. You can use it just like the Effect constructor: name first, then duration, then power.&lt;/li&gt;
&lt;li&gt;Fixed a potential error that could occur if &lt;code&gt;chain&lt;/code&gt; attempted to run with an undefined target, subject, or actor.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.09&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Rehauled battle character displays.&lt;/b&gt; It should now be possible to have party sizes extend to multiple lines without issue. The command panes will no longer be displayed in the initial battle map; instead, you will select a character by clicking on their name or pressing their hotkey, and the party display will be collapsed to just them and their command pane. Done/Stunned notifications will now display at the bottom of the actor boxes instead of in the command panes.&lt;/li&gt;
&lt;li&gt;The cancel button is now R, to avoid interference with the E key also being the item command hotkey.&lt;/li&gt;
&lt;li&gt;During the targeting phase, the party not being targeted will now be hidden from view.&lt;/li&gt;
&lt;li&gt;The battle map is now hidden during the command phase.&lt;/li&gt;
&lt;li&gt;New feature: &lt;b&gt;automatic turn ending&lt;/b&gt;. Enable this in the settings menu to end your turn automatically when all characters have acted.&lt;/li&gt;
&lt;li&gt;Fixed a text glitch in Focus.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08.5&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UI text should now display correctly even if the default text color has been changed through in-game modifications.&lt;/li&gt;
&lt;li&gt;Effects with no removal text will no longer force the player to click through the end-of-round passage.&lt;/li&gt;
&lt;li&gt;Actions now have a getter for the &lt;code&gt;nosave&lt;/code&gt; property.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08.4&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The default add and remove text for effects should now display correctly.&lt;/li&gt;
&lt;li&gt;Protector should no longer create an error message on removal.&lt;/li&gt;
&lt;li&gt;Actions that disallow self-targeting should now work correctly; the property has been renamed to &lt;code&gt;noself&lt;/code&gt; for greater clarity, and an appropriate getter has been added.&lt;/li&gt;
&lt;li&gt;The setup for the damage formula type and min stat values has been moved to the custom StoryInit section; if that assignment is in the default, min stat values won&#39;t auto-update if you change the formula in the custom StoryInit.&lt;/li&gt;
&lt;li&gt;Added a &lt;code&gt;RESPAWN_HP&lt;/code&gt; variable you can set in StoryInit. This will determine the proportion of HP a respawned character revives at. By default, it is set to 1.&lt;/li&gt;
&lt;li&gt;Moved the special checks passage to passages-unique.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;actionLink&lt;/code&gt; now works for items as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08.3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Moved hotkey definitions to their own passage for greater modularity and neatness of code.&lt;/li&gt;
&lt;li&gt;The call to the Special stat for item usage in the damage formula has been moved to &quot;damageCalc custom factors&quot; for greater modularity, in case you don&#39;t want items to use the Special stat (or don&#39;t want to have a Special stat at all).&lt;/li&gt;
&lt;li&gt;The code that runs when selecting an action has been outsorced to a widget, &lt;code&gt;actionLink&lt;/code&gt;. This widget is now called for both the link itself and the hotkey shortcuts for actions, enforcing consistency between the two.&lt;/li&gt;
&lt;li&gt;Action&#39;s &lt;code&gt;toJSON&lt;/code&gt; now clones the entire object instead of creating a new object with just the name. This is useful if you want unique action properties to persist.&lt;/li&gt;
&lt;li&gt;Fixed a typo in Battle Phases. Targeting should now work correctly if an enemy is both untargetable and a martyr.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08.2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Equipping a new item to a filled equipment slot will now replace the last subslot rather than the first. I felt this was more intuitive.&lt;/li&gt;
&lt;li&gt;Mass status effect abilities now assign the current target to &lt;code&gt;$target&lt;/code&gt;. This helps if you want to do something that depends on that.&lt;/li&gt;
&lt;li&gt;The action phase no longer checks to see if {{{$action.act()}}} evaluates to &lt;code&gt;null&lt;/code&gt;. This was causing a problem where the &lt;i&gt;entire&lt;/i&gt; function was being run in the check, not just evaluating the result. Actions were effectively run twice if they contained anything before the &lt;code&gt;return&lt;/code&gt; statement. If you want the box to disappear, you will need to set the &lt;code&gt;act&lt;/code&gt; property itself to &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It is now possible to equip multiple items of the same type. Puppets now have 2 Accessory slots, and you can test this functionality for yourself with the new &quot;Color of Defeat&quot; item.&lt;/li&gt;
&lt;li&gt;The unequip buttons have been removed from the full party view due to the discovery of a bug involving them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.08&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Actions and effects have now been converted to Flyweight format. This leads to a few changes in how certain attributes are defined; see documentation for details.&lt;/li&gt;
&lt;li&gt;Constants such as &lt;code&gt;$STATUS_SCREENS&lt;/code&gt; have been changed to attributes of &lt;code&gt;setup&lt;/code&gt;. This will allow changes to persist through game version changes.&lt;/li&gt;
&lt;li&gt;Stat mods have been completely redone, such that changes to equipment will now correctly carry over between save game version changes. (Thanks to Akjosch for helping me with this.) &lt;b&gt;This change is likely not compatible with previous versions unless you completely remake your &lt;code&gt;Actor&lt;/code&gt; objects.&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;The menu screens no longer have a border. I felt this was more aesthetically pleasing.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;unequip&lt;/code&gt; function must now be explicitly passed a &lt;code&gt;destroy&lt;/code&gt; value of &lt;code&gt;true&lt;/code&gt; to destroy equipment, instead of any truthy value.&lt;/li&gt;
&lt;li&gt;The Status pane of the party menu now uses a widget, &lt;code&gt;statusDisplay&lt;/code&gt;, to display the common portion of the normal and detailed status displays. The widget can be found in &lt;code&gt;Widgets (Menu)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.07&lt;/h3&gt;
* &lt;b&gt;The party menu has been rehauled to include the full functionality expected of a typical RPG!&lt;/b&gt;
** Added a status screen that shows the party&#39;s HP, MP, and experience levels. Clicking on one character will provide detailed stat, equipment, and ability information.
*** The detailed status screens are tied to the {{{$STATUS_SCREENS}}} variable, which has been changed to a generic object with two attributes to distinguish between the status screens visible in the menu and the status screens visible in battle. &lt;b&gt;If you have already made a project with an earlier version of the engine, you will need to update this variable in your {{{onLoad()}}} function to avoid errors in existing save games.&lt;/b&gt;
*** Stat objects now contain tooltips that explain what the stat does. These can be seen in the detailed status pane.
** Added an inventory screen that lists all inventory items and allows you to view detailed information about each.
** The equipment screen has been redesigned to give a nicer appearance more consistent with the new status screen. The unequip buttons now have consistent positions, as well.
** The menu navbar has now been changed to a vertical display on the right, instead of a horizontal display across the top. This frees up more room for the status screens.
** You can add additional screens modularly by adding entries to the {{{$MENU_OPTIONS}}} variable. &lt;b&gt;If you have already made a project with an earlier version of the engine, you will need to update this variable in your {{{onLoad()}}} function to avoid errors in existing save games.&lt;/b&gt;
* Music can now be muted and unmuted with the M key.
* A peppy theme tune now plays while navigating the help file to show off the sidebar music display. Don&#39;t worry -- you can mute it with the newly-added hotkey if you prefer silence!
* Added an entry on designing the AI for &lt;i&gt;Cartoon Battle&lt;/i&gt;&#39;s Bonnibel in the documentation section.
* Added a note about damping in divisive damage systems in the design section.
* Fixed a typo that created a fatal error in the level up data for puppets.
* Changed the way status screen customization works to be more modular. Cycling is now tied to the length of the {{{$STATUS_SCREENS}}} array, and the displayed pane is based on the content of the array element rather than hardcoded to specific {{{$stScreen}}} values.
* The structure of the item database has been reworked to incorporate Flyweight design principles. This should hopefully speed up the game. (Thanks to Akjosch for help with this.)

&lt;h3&gt;Version 1.06.4&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;custom end of action effects&lt;/code&gt; is now called at the end of enemy actions, not just player actions. This allows you to have events related to enemy actions as well.&lt;/li&gt;
&lt;li&gt;Added a default music display in the UI bar should you wish to use it. Remember to properly attribute your media if you are using it under a Creative Commons license.&lt;/li&gt;
&lt;li&gt;Protector SHOULD now be removed when the protected character dies, for real this time, probably, maybe, or possibly this bug will continue to be the bane of my existence. We&#39;ll find out.&lt;/li&gt;
&lt;li&gt;Enemies will no longer perform glitched actions if all puppets are dead when they attempt to find a target.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.06.3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed the party selection glitch. You can no longer add an extra puppet to the active party by double-clicking on an active puppet.&lt;/li&gt;
&lt;li&gt;Changed the party selection screen to display the reserve in the main pane instead of the sidebar.&lt;/li&gt;
&lt;li&gt;Respawn mechanics added. If you give a character a &lt;code&gt;respawn&lt;/code&gt; value at creation, it will be decremented every round. When it hits 0, the character will be revived in &lt;code&gt;endofround&lt;/code&gt;. By default, characters are revived to full HP, but this can be changed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endofbattle&lt;/code&gt; now has a modular component. The calls to &lt;code&gt;refreshPuppets&lt;/code&gt; and &lt;code&gt;restock&lt;/code&gt; have been moved there to more easily remove them if they are undesired.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newturn&lt;/code&gt; now has a modular component. The code for Energy regeneration has been moved there to more easily enable switching to a different type of resource system.&lt;/li&gt;
&lt;li&gt;Passage jump actions now work correctly.&lt;/li&gt;
&lt;li&gt;Tweaked the actor blocks slightly. Their borders are now twice as thick; only the borders are highlighted upon selection; and the selection color is now a darker blue. This will hopefully result in selection looking less garish, especially in dark-themed passages.&lt;/li&gt;
&lt;li&gt;Action phase modularity is now more robust; the components will now be hidden both in the case that the value is &lt;code&gt;null&lt;/code&gt; &lt;i&gt;and&lt;/i&gt; in the case that the value is a function that evaluates to &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The checks for Protector and Martyr in the targeting logic have been compartmentalized into their own widgets.&lt;/li&gt;
&lt;li&gt;Added documentation on delayed attacks.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.06.2&lt;/h3&gt;
* New circumstantial modifiers for enemies:
** &lt;b&gt;hidden:&lt;/b&gt; If you flag this attribute, the enemy won&#39;t get a stat block generated in &lt;code&gt;actorlist&lt;/code&gt;, making it invisible to the player. Note that this means there is no way to target it, either. Hidden enemies are not excluded from the victory condition check, so if you use this, you should make a special victory condition or give the player some way to damage the enemy.
** &lt;b&gt;immortal:&lt;/b&gt; If you flag this attribute, the enemy will not die when they are killed. They&#39;ll still produce a death message, but their &quot;dead&quot; flag will not be flipped to &lt;code&gt;true&lt;/code&gt;. This is useful if you want to replicate a feature like the final battle of &lt;i&gt;EarthBound&lt;/i&gt;, where the enemy cannot be defeated through normal means.
** &lt;b&gt;fakedeath:&lt;/b&gt; If you flag this attribute, the enemy will not take an action during their turn (even to say they are stunned), as if they were defeated. Effect decay will still occur as normal, however. This is useful if you want certain enemies to &quot;play dead&quot; or just if you want them to skip turns.
* Defeated enemies will now produce no death message if you set their &lt;code&gt;deathMessage&lt;/code&gt; attribute to &lt;code&gt;null&lt;/code&gt;.
* The &lt;code&gt;removeEffect&lt;/code&gt; function now has a shortcut for removing a specific type of effect. If you pass it a string rather than an effect object, it will remove the first effect whose name matches the string. Note that this only removes the first instance it finds, so it won&#39;t clear multiple instances of stackable effects.
* You can now use actions to move the player to a new passage by setting the &lt;code&gt;passagejump&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; and setting the &lt;code&gt;phase&lt;/code&gt; attribute to the name of the desired passage. This is useful if you want to incorporate passage mechanics into your battles, such as allowing characters to interact with the objects in a room to produce changes to the battle.

&lt;h3&gt;Version 1.06.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Removed Chapel&#39;s cycles system due to its potential to cause a fatal error.&lt;/li&gt;
&lt;li&gt;Added hotkey support for all-targeting abilities.&lt;/li&gt;
&lt;li&gt;Added a hotkey for party menu access, though the party menu is rudemantary at the moment.&lt;/li&gt;
&lt;li&gt;Last action is now remembered upon selection, not just use. This should hopefully ease the pain of the Back button booting you all the way back to the start of selection.&lt;/li&gt;
&lt;li&gt;Enemy reverse display is now handled through a battle variable, allowing it to be tracked more easily.&lt;/li&gt;
&lt;li&gt;The special handler for Focus&#39; cost reduction has now been moved to custom end of action effects, to prevent conflicts if you want to create your own action named &quot;Focus&quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.06&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Hotkeys are in!&lt;/b&gt; Use the number keys to select characters, the Q key to confirm, and the E key to cancel.&lt;/li&gt;
&lt;li&gt;The story title area now displays white text as part of the default formatting style, making it easier to read with the dark UI bar. If you want to lighten the UI bar, such as with the normal Bleached style, you will probably want to change this.&lt;/li&gt;
&lt;li&gt;Displaying the confirm phase is now optional. This can be toggled in the Settings menu.&lt;/li&gt;
&lt;li&gt;Difficulty settings also moved to the Settings menu.&lt;/li&gt;
&lt;li&gt;Piercing attacks now set effective defense to 1 instead of 0 if the {{{$formula}}} variable reads &quot;divisive&quot;. This avoids a division by zero error in a divisive defense formula.&lt;/li&gt;
&lt;li&gt;Special death handling no longer adds a special death passage to the queue if it is already in the queue; this should prevent the player being forced to see the special death passage multiple times if the enemy is killed through a multi-hit attack or other circumstance that triggers &lt;code&gt;deathcheck&lt;/code&gt; multiple times.&lt;/li&gt;
&lt;li&gt;Fixed the enemy Martyr bug: If an enemy martyr exists, you still have to select them in the targeting phase, but they will be the only viable target. (Additionally, this means you can no longer bypass Martyr with skills that target all characters -- you can still target allies, but the martyr will be the only possible enemy target.)&lt;/li&gt;
&lt;li&gt;Martyr now overrides untargetable protection for enemies, as it does for player characters.&lt;/li&gt;
&lt;li&gt;You can now select protected enemies as targets, though their protector will still cover them. This encourages players to pay attention to who&#39;s protecting whom!&lt;/li&gt;
&lt;li&gt;Protector now displays the name of the protector&#39;s charge in the info box.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.05.1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Added documentation for health bars and the item shop.&lt;/li&gt;
&lt;li&gt;Enemy health bars will now be correctly mapped to the number of enemies, rather than the number of puppets.&lt;/li&gt;
&lt;li&gt;Enemy health bars are now a slightly darker red. (I felt the default red looked too garish next to the default green.)&lt;/li&gt;
&lt;li&gt;Enemy and player health bar colors are now variables set in StoryInit.&lt;/li&gt;
&lt;li&gt;Enemy status buttons should no longer display for defeated enemies.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.05&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The engine now comes bundled with &lt;a href=&quot;https://twinelab.net/custom-macros-for-sugarcube-2/&quot; target=&quot;_blank&quot;&gt;Chapel&#39;s custom macros.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Relatedly, the battle interface now displays health bars! If you prefer the old look, you can set &lt;code&gt;$SHOW_HEALTHBARS&lt;/code&gt; to false.&lt;/li&gt;
&lt;li&gt;Created an interface for an item shop! It&#39;s a little rudementary at the moment, but it is functional.&lt;/li&gt;
&lt;li&gt;Restructured the version updating and save config code. It should hopefully work correctly now.&lt;/li&gt;
&lt;li&gt;The HP display will now be hidden if you flag an enemy&#39;s &lt;code&gt;maskhp&lt;/code&gt; attribute. Additionally, the &lt;code&gt;healing&lt;/code&gt; attribute has been renamed to &lt;code&gt;showMaxHP&lt;/code&gt; for clarity.&lt;/li&gt;
&lt;li&gt;Added additional modularity in &lt;code&gt;damageCalc&lt;/code&gt;: The damage formula definition is now a separate passage, as are handlers for actions with special behavior, such as Exacerbate and Downfall.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.04&lt;/h3&gt;-beta
&lt;ul&gt;
&lt;li&gt;Retweaked the handling for subjects and targets &lt;i&gt;again&lt;/i&gt;. They now get the ID value from the current subject/target object itself instead of storing it as a separate variable, which removes the need to call &lt;code&gt;getActor()&lt;/code&gt; manually.&lt;/li&gt;
&lt;li&gt;The battle passages have been tweaked to support additional modularity. Code for altering the actor list in special cases is now outsourced to another passage that can be edited separately from the main display code; the &quot;Preparation&quot; passage now calls to a separate passage for custom modifications; the Effect Adder outsources protection checks to a separate passage; and you can now set which status screens display in StoryInit.&lt;/li&gt;
&lt;li&gt;Targeting AI now includes handlers for bypassing untargetable and protection clauses. Simply pass &quot;ignore untargetable&quot; or &quot;ignore protection&quot; as arguments to the widget, and those characters will be made viable targets.&lt;/li&gt;
&lt;li&gt;Spread attacks now bypass untargetability, as in &lt;i&gt;Bonfire&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;The effect adder should now correctly identify when it&#39;s passed a number for effect power.&lt;/li&gt;
&lt;li&gt;The battle controller now checks if an item was used during the round, if that&#39;s something you want enemies to react to.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SacrificeUsed&lt;/code&gt; is now a property of the battle controller, for consistency.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;$power&lt;/code&gt; variable, used for constructing effects, has been changed to use a temporary variable instead.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;victorycheck&lt;/code&gt; is now run in the enemy phase. This accounts for the rare case where the player is defeated through damage over time; previously, &lt;code&gt;victorycheck&lt;/code&gt; was only run during the player&#39;s turn, so the enemy turn would still play out even if everyone was already defeated.&lt;/li&gt;
&lt;li&gt;Minor tweak, but it &lt;i&gt;really&lt;/i&gt; bugged me: boss names are no longer misaligned with their HP display in the boss box. The display is still misaligned relative to the whole box because the status button still throws off the centering, but this is less noticeable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.03&lt;/h3&gt;-beta
&lt;ul&gt;
&lt;li&gt;The handling for the &lt;code&gt;$subject&lt;/code&gt;, &lt;code&gt;$target&lt;/code&gt;, and &lt;code&gt;$actor&lt;/code&gt; variables has been redone to be more intuitive and allow for easier tracking of the original objects. Thanks to Discord member &lt;b&gt;Akjosch&lt;/b&gt; for help and directions. See documentation for details.&lt;/li&gt;
&lt;li&gt;Enemy cooldown logic is now more intuitive: They will be able to use attacks when the cooldown &lt;i&gt;is&lt;/i&gt; zero, rather than requiring the cooldown to be negative. This means that the value you give to a cooldown will now be equal to the number of turns before it can be used again.&lt;/li&gt;
&lt;li&gt;Fixed a bug with status effects that had entangled tolerance values (such as Curse and Forsaken). Tolerances should now be reduced and reset correctly.&lt;/li&gt;
&lt;li&gt;Puppets are now revived as part of &lt;code&gt;refreshPuppets&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dispel targeting will now correctly check against the threshold value when targeting a martyr.&lt;/li&gt;
&lt;li&gt;Additionally, Martyr, Defender, and Berserker will no longer count towards the threshold check.&lt;/li&gt;
&lt;li&gt;Protector should now be correctly removed if the protected character dies, but I have not tested this. Please report any problems you encounter.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.02&lt;/h3&gt;-beta
&lt;ul&gt;
&lt;li&gt;The default damage constant has been doubled to 80; this should speed up battles significantly. (Keep in mind DoT effects use the same constant.)&lt;/li&gt;
&lt;li&gt;There is now support for enemies taking multiple actions per turn. Set the &lt;code&gt;noAttacks&lt;/code&gt; attribute in an enemy object if you wish to use it. As this is a new feature, it may result in unforseen problems; please report any bugs you find.&lt;/li&gt;
&lt;li&gt;There is now support for modifying the CSS of battles. See documentation for details. A &quot;dark&quot; format that returns to the default SugarCube style is provided in the CSS files.&lt;/li&gt;
&lt;li&gt;The default style has been changed to a modified form of the Bleached style. The background is slightly less bright, links are easier to see on the white background, and UI messages will now be more readable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.01&lt;/h3&gt;-beta
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;massAttack&lt;/code&gt; function will now default to the action variable&#39;s duration if no duration is passed as an argument.&lt;/li&gt;
&lt;li&gt;Fixed a typo that prevented Berserker from being applied properly.&lt;/li&gt;
&lt;li&gt;Dispel abilities (Restoration/Neutralize/Cleanse) should now work correctly.&lt;/li&gt;
&lt;li&gt;Added a &quot;user-defined variables&quot; passage to be included in StoryInit. You can now keep your own StoryInit functionality completely separate from the engine&#39;s code, instead of needing to juggle multiple StoryInit files.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 1.0&lt;/h3&gt;-beta
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Equipment is in!&lt;/b&gt; Party Picker updated with a page for equipment and a corresponding GUI. Make sure to grab the new and updated CSS files so they display properly.&lt;/li&gt;
&lt;li&gt;New widget: &lt;code&gt;equipmentlist&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;New function &lt;code&gt;unequipAll&lt;/code&gt; added to Actor class.&lt;/li&gt;
&lt;li&gt;Items now consume 2 Energy when used.&lt;/li&gt;
&lt;li&gt;Fixed a bug that allowed you to add extra characters to your party through the party picker.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;actionList&lt;/code&gt; updated to display passive abilities when out of battle.&lt;/li&gt;
&lt;li&gt;HP regeneration implemented. Puppets and enemies will both regain a percentage of their max HP based on their &lt;code&gt;HPregen&lt;/code&gt; attribute at the start of their turns. You can play with this by equipping the &quot;Color of Growth&quot; item.&lt;/li&gt;
&lt;li&gt;Effect descriptions are no longer bolded, and effect names are no longer underlined.&lt;/li&gt;
&lt;li&gt;Updated documentation for new features.&lt;/li&gt;
&lt;li&gt;Updated this changelong to display in reverse chronological order.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Version 0.99&lt;/h3&gt;-beta
* &lt;code&gt;Inventory&lt;/code&gt; objects now revive correctly, and &lt;code&gt;Item&lt;/code&gt; objects will no longer be revived as &lt;code&gt;ItemActions&lt;/code&gt;.
* Battle flow now works through &lt;code&gt;replace&lt;/code&gt; macros instead of passage jumps. This should speed up battles considerably.
* Defeated characters will now have their command menus hidden instead of displaying an ugly blank box.
* Added a &lt;code&gt;longreturn&lt;/code&gt; widget using the functionality described in the SugarCube v2 documentation.

&lt;h3&gt;Version 0.95&lt;/h3&gt;
* Custom objects are now serializable, with custom &lt;code&gt;clone()&lt;/code&gt; and &lt;code&gt;toJSON()&lt;/code&gt; functions. &lt;code&gt;Actor&lt;/code&gt;, &lt;code&gt;Action&lt;/code&gt;, and &lt;code&gt;Inventory&lt;/code&gt; are revived to exact copies of their old versions, while &lt;code&gt;Item&lt;/code&gt; and &lt;code&gt;Effect&lt;/code&gt; are revived to new versions using only their name ID. This allows changes made to the database to be incorporated when loading saves from an earlier version.
** A section on this has been added to the documentation.
* Rehauled inventory. It now functions like a Map, meaning you can just call up the item name to find something instead of using the &lt;code&gt;find&lt;/code&gt; widget.
* Equipment is in, but untested. It &lt;i&gt;should&lt;/i&gt; work, but no promises.
* &lt;code&gt;effectmanager&lt;/code&gt; and &lt;code&gt;removeEffect&lt;/code&gt; have been made obsolete by applying equipment logic to status effects. Effects now apply their changes through instance functions called on application and removal and defined in the effect database. Method functions for adding and removing effects have been added to the Actor class to facilitate this. Call them with a &lt;code&gt;print&lt;/code&gt; statement to get the add/removal text, or use a &lt;code&gt;run&lt;/code&gt; statement to mask it.
** Damage-over-time calculations are also now handled through instance methods defined in the effect database. Pass the character to the effect&#39;s &lt;code&gt;damage()&lt;/code&gt; function to calculate how much damage they take. The function returns the damage value, so pair it with a &lt;code&gt;set $dmg =&lt;/code&gt; to store it or a &lt;code&gt;print&lt;/code&gt; to show the value (such as in the status pane).
*** The messages displayed when DoT is triggered have also been tied to effect definitions.
* setTol and getTol changed for more clarity and to facilitate modular changes from equipment. Setter is now both relative and absolute: if a tolerance doesn&#39;t exist, it will create one, and if a tolerance does exist, it&#39;ll add the passed value. Immunity is now handled through a third attribute that can be set by passing a Boolean for a value.
* Modified spell effects are now handled through the &lt;code&gt;spellMod()&lt;/code&gt; attribute function rather than the &quot;spell check&quot; passage; see documentation for details.
* Added Actor method functions: setHP and setMaxHP.
* Status effect previews now provide the duration of the effect.
* Effect database link added to the documentation.
* Enemy AoE attacks that mimic player attacks will now target the player&#39;s party instead of the enemies.
* Corrected a key/value mixup in &lt;code&gt;decCD()&lt;/code&gt;. Enemy cooldown should now work correctly.
* Enemy actions will no longer produce an error if they fail to find a target. (Thanks to Reddit user itaigreif for finding this.)
* Corrected a subjective/objective mixup in the pronoun object.
* Stat and elemental affinity displays are now right-justified for a more consistent appearance.
* All passages excepting the landing have been exported to twee files, because I got sick of having to wade through Twine 2 to edit things. Enjoy Ctrl+F.
* Fixed a typo in &lt;code&gt;deathcheck&lt;/code&gt; that caused a fatal error.
* Fixed several mixups in surrender logic. Surrendering enemies should now work correctly.

&lt;h3&gt;Version 0.9&lt;/h3&gt;
* Massive rehaul. Actions, puppets, enemies, items, and effects now properly defined in database JavaScript files. Many widgets offloaded to JavaScript functions, and battle passage code tweaked for greater modularity. Actions now display fully consistently with special formatting that looks much neater and more professional.
* Added support for elemental affinities and status effect tolerance.
* Passages moved further down in the story map to hopefully prevent overlapping of story files when importing the engine through compilers.

&lt;h3&gt;Version 0.57&lt;/h3&gt;
* New puppets added: the Archer, the Cleric, and the Witch! These are all specialists with 50 in one stat and 20 in both others. Anyone who felt the battles took too long should try out Archer. They have not been balance-tested at all, so do tell of any hilarious gamebreaking situations you encounter.
* Action text added for all actions, and restructured the passage so it displays more consistently. A few other things have also been tidied behind the scenes to hopefully make the code easier to use.

&lt;h3&gt;Version 0.56&lt;/h3&gt;
* New puppet added: the Bard! They are a jack-of-all-trades character designed to exploit the stackability of basic debuffs. I have not balance-tested them at all so please try them out.
* Relatedly: party member swap functionality is in! I plan to tweak it later but it currently works as long as your characters aren&#39;t modified in any way between swaps. (Thanks to greyelf for helping me with the visual elements.)
* Martyr is now removed if someone else uses it at the same time.
* Stun wearing off will no longer trigger an infinite loop.
* Tweaked the way some passages and widgets worked for more modularity and readability.

&lt;h3&gt;Version 0.55&lt;/h3&gt;
* Completely rehauled the way stats are formatted: they are now all bound to a single Map object with sub-attributes for base values and temporary modifiers. Getter and setter functions added to enable easy access to these values.
* Effect manager now only runs when necessary instead of all the time! This will probably save your processor a lot of grief.
* Relatedly, Protector SHOULD finally behave properly.
* Documentation updated to reflect changes.
* Added new passage for discussing implementation of extra features.
* Added information about level up mechanics, and added example implementation for both standard level up mechanics and a point-buy system.

&lt;h3&gt;Version 0.54&lt;/h3&gt;
* Added difficulty settings! Hard mode is the original targeting model. Easy mode will disable smart targeting altogether. Medium mode will still have smart targeting, but vulnerable characters will only get preferential chances of being targeted rather than being the only possible targets. Documentation will be updated when time permits.

&lt;h3&gt;Version 0.53.1&lt;/h3&gt;
* Design notes on status effects and battle flow added.
* Model passages added to enable use of different battle flow systems.

&lt;h3&gt;Version 0.53&lt;/h3&gt;
* Documentation actually updated to reflect changes.

&lt;h3&gt;Version 0.52.1&lt;/h3&gt;
* Streamlined some things in backend to be more readable. Effect adder now filters by attribute like the effect manager does, and if statements in story JavaScript changed to switches. I think I fixed all bugs created by this change, but do tell me if you encounter anything.
* Pronouns added as attributes in the &quot;Actor&quot; class to make system text easier, like I alluded to in earlier versions of the documentation. Constructor must now take a gender (as a single uppercase character, F/M/N) as its final argument.
* Documentation updated to reflect changes.

&lt;h3&gt;Version 0.52&lt;/h3&gt;
* Stat mod glitch should be fixed.
* Alert application now produces no message, as intended.

&lt;h3&gt;Version 0.51&lt;/h3&gt;
* Protector no longer causes an error in PassageDone, and should be removed properly if the protected character dies.

&lt;h3&gt;Version 0.5&lt;/h3&gt;
* Initial release.</tw-passagedata><tw-passagedata pid="182" name="Design" tags="text info" position="225,2350" size="100,100">RPGs are pretty complicated games, and require a lot of thought in even their most basic elements. Here I&#39;ll discuss the reasoning that went into the choices I made when designing the engine, and some potential alternatives.

A look at the game &lt;i&gt;&lt;a href=&quot;http://bonfire-game.wikia.com/wiki/Bonfire_Game_Wiki&quot; target=&quot;_blank&quot;&gt;Bonfire&lt;/a&gt;&lt;/i&gt; and the elements listed in its wiki may be instructive, as I purposefully designed the engine to emulate it in many aspects. The program RPG Maker VX Ace is also worth a look, as it has great transparency and modularity in many of its core design principles, as well as a community of designers you can use as a resource. For further reading, you could check out the website &lt;a href=&quot;http://howtomakeanrpg.com&quot; target=&quot;_blank&quot;&gt;How To Make an RPG&lt;/a&gt;, which touches on these topics and others. The YouTube series &lt;a href=&quot;https://www.youtube.com/channel/UCqJ-Xo29CKyLTjn6z2XwYAw&quot; target=&quot;_blank&quot;&gt;Game Maker&#39;s Toolkit&lt;/a&gt; may also be worth viewing, though it is much more general in the topics it covers.

&lt;h1&gt;Table of Contents&lt;/h1&gt;
&gt;&lt;a href=&quot;#dmgform&quot;&gt;The Damage Formula&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.basic&quot;&gt;The Basics&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.damper&quot;&gt;Damping&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.defenses&quot;&gt;Subtractive vs. Divisive Defense&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.special&quot;&gt;Special Attacks and Weighting&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmgform.special.1&quot;&gt;Lumped Weighting&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmgform.special.2&quot;&gt;Specific Weighting&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmgform.special.3&quot;&gt;Adding Constants&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmgform.special.4&quot;&gt;Skill Progression&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.htk&quot;&gt;HP and hit-to-kill ratios&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.random&quot;&gt;Randomness and Variance&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dmgform.exta&quot;&gt;Additional Reading&lt;/a&gt;
&gt;&lt;a href=&quot;#abilities&quot;&gt;Designing Abilities&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#abilities.basic&quot;&gt;Before you begin, what are your regular commands?&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#abilities.resources&quot;&gt;Resources and Game Balance&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#abilities.resources.mana&quot;&gt;Mana Points (Limited Resource)&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#abilities.resources.sta&quot;&gt;Stamina (Renewable Resource)&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#abilities.resources.cd&quot;&gt;Cooldown&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#abilities.resources.recoil&quot;&gt;Recoil/Blowback&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#abilities.elements&quot;&gt;Elemental Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#abilities.heal&quot;&gt;Healing&lt;/a&gt;
&gt;&lt;a href=&quot;#items&quot;&gt;Item Design&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#items.consumable&quot;&gt;Consumables&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#items.equipment&quot;&gt;Equipment&lt;/a&gt;
&gt;&lt;a href=&quot;#effects&quot;&gt;Status Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.control&quot;&gt;Hold Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.loss&quot;&gt;Loss-of-control / Uncontrollable Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.statmod&quot;&gt;Stat Modification Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.dot&quot;&gt;Damage Over Time&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.death&quot;&gt;Instant Death Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.protect&quot;&gt;Effect Protection&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.player&quot;&gt;Can players use them?&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.extra&quot;&gt;Noteworthy Examples&lt;/a&gt;
&gt;&lt;a href=&quot;#targeting&quot;&gt;Targeting and AI&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targeting.smart&quot;&gt;Smart Targeting&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targeting.aggro&quot;&gt;Aggro Systems&lt;/a&gt;

&lt;h2 id=&quot;dmgform&quot;&gt;The Damage Forumla&lt;/h2&gt;
The basic structure of an RPG is that characters exchange attacks, inflicting damage to wear down their opponent&#39;s HP. Well, how do we determine what those numbers will be? What scale are we operating on -- do you want the average attack to throw around numbers in the double digits, triple, quadruple? Most games have some sort of &quot;attack&quot; stat that increases damage, and a &quot;defense&quot; stat that mitigates it, but how exactly do we want them to interact?

The answer depends on you! Small changes to the damage formula can lead to big impacts in how the game plays and how the player interacts with it. The formula I designed for &lt;i&gt;Cartoon Battle&lt;/i&gt;, and thus the default formula in this engine, looks like this:

&lt;div class=&quot;formula&quot;&gt;DMG = (setup.base + (setup.damper * a.atk)) * (weight) - (setup.damper * b.def)&lt;/div&gt;
In this section, I&#39;ll go over each part of the formula, and give you examples of some alternative formulas you can use if you want a different type of game.

&lt;h3 id=&quot;dmgform.basic&quot;&gt;The Basics&lt;/h3&gt;
The most obvious damage formula is simply Attack minus Defense:

&lt;div class=&quot;formula&quot;&gt;DMG = a.atk - b.def&lt;/div&gt;
However, we run into a problem: if B&#39;s Defense is equal to or greater than A&#39;s Attack, the attack will do no damage at all. Most RPGs like to have all their stats operate on the same scale, but if you want attacks to do meaningful damage, you will have to consistently make Defense lower than Attack across the board. Maybe you&#39;re okay with that, but assuming you&#39;re not, how might we fix the problem?

Here&#39;s what &lt;i&gt;Bonfire&lt;/i&gt;, and this engine, do:

&lt;div class=&quot;formula&quot;&gt;DMG = C + (a.atk - b.def)&lt;/div&gt;
C here stands for &quot;constant&quot;. It&#39;s a flat number that&#39;s the same for every attack. You can think of it as what you want your &lt;b&gt;basic damage&lt;/b&gt; to be: how much damage attacks should do on average. If A&#39;s Attack and B&#39;s Defense are exactly equal -- so, if an average attacker hits an average defender -- the attack will do C damage. This makes it very easy to determine the scale of your battles: if you want big numbers, you can make C something like 200 or 1000; if you want small numbers, you can make C something like 10 or 20. &lt;i&gt;Bonfire&lt;/i&gt;&#39;s constant is 20; this engine&#39;s is 40 by default.

RPG Maker VX Ace takes a different approach:

&lt;div class=&quot;formula&quot;&gt;DMG = a.atk * 4 - b.def * 2&lt;/div&gt;
This also creates positive damage values for equal Attack and Defense values. If A has 10 Attack and B has 10 Defense, the attack will do 20 damage. The scale of this formula is less immediately clear, but you can still get a pretty good handle on it through careful adjustment of your characters&#39; Attack and Defense stats.

However, a big part of RPGs is leveling up, isn&#39;t it? Over the course of the game, your characters will get stronger and their stats will get bigger. This means you also have to consider how your damage formulas will &lt;i&gt;scale&lt;/i&gt; at higher values.

Let&#39;s level up the characters in our example a bunch. A now has 50 attack and is fighting a monster with 50 Defense. What does the damage look like now?

With my formula, it&#39;s the same:

&lt;div class=&quot;formula&quot;&gt;40 + (10 - 10) = 40 DMG&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;40 + (50 - 50) = 40 DMG&lt;/div&gt;
But now look at RPG Maker&#39;s formula:

&lt;div class=&quot;formula&quot;&gt;10*4 - 10*2 = 20 DMG&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;50*4 - 50*2 = &lt;b&gt;100 DMG&lt;/b&gt;&lt;/div&gt;
That&#39;s five times as much damage as before, even though the difference between stats is still the same! What happened? Scaling. Attack gets multiplied by a value of 4, while Defense only gets multiplied by a value of 2. That means that every point of Attack will count twice as much as every point of Defense. Even if the two stats are the same, bigger numbers will lead to a bigger result. You can still make this balanced, but you will need to increase HP as well to compensate for the higher average damage.

This is actually likely what you want! Most RPGs make everything get bigger over time, including HP and damage values. That&#39;s a big part of the fun for most people: bigger numbers make the player feel like they&#39;re progressing and getting more powerful. If they get bigger stats and the end result still looks the same, they might be disappointed. RPG Maker assumes you plan to scale everything up over time, and makes its formula account for that.

&lt;i&gt;Bonfire&lt;/i&gt; is a rare RPG that doesn&#39;t work this way. Nobody&#39;s HP changes as the game progresses, so damage values are meant to stay relatively constant. &lt;i&gt;Cartoon Battle&lt;/i&gt; doesn&#39;t have progression mechanics at all, so I opted for the more intuitive &lt;i&gt;Bonfire&lt;/i&gt;-style formula. An equal-scaling formula is better if you want your RPG to focus on a small number of tactical battles that don&#39;t scale up over time.

Note that these features aren&#39;t mutually exclusive! You can absolutely combine constants and variable weights. Something like...

&lt;div class=&quot;formula&quot;&gt;DMG = 40 + (a.atk * 4 - b.def * 2)&lt;/div&gt;
...is also a valid option, and in fact that exact formula is used by RPG Maker as well, for something special we&#39;ll discuss later.

&lt;h3 id=&quot;dmgform.damper&quot;&gt;Damping&lt;/h3&gt;
If you&#39;re afraid scaling might make damage values change too much too fast, you can add a &lt;b&gt;damper&lt;/b&gt; to your formula. This is a value between 0 and 1 you can apply to your stat terms to make them scale at a slower rate. This might look like:

&lt;div class=&quot;formula&quot;&gt;DMG = C + D * (a.atk - b.def)&lt;/div&gt;
To use a real example, &lt;i&gt;Bonfire&lt;/i&gt; uses a damper of 0.6, so its complete formula looks like this:

&lt;div class=&quot;formula&quot;&gt;DMG = 20 + 0.6 * (a.atk - b.def)&lt;/div&gt;
This means a character&#39;s Attack or Defense stats will need to change by 1.7 to change the final damage by 1 point. This will make stats have a smaller impact over time and/or compared to the constant value. You may want to do this if you want numbers to creep upward at a slower rate, or if you want stat modifiers (such as from equipment or status effects) to have less of an effect. As discussed in the next section, small changes in stats can have huge effects if you aren&#39;t careful!

In a &lt;a class=&quot;noExternal&quot; href=&quot;#dmgform.defenses&quot;&gt;divisive defense system&lt;/a&gt;, you would use a power instead, such as:

&lt;div class=&quot;formula&quot;&gt;DMG = (a.atk/b.def) ** 0.6&lt;/div&gt;
(Note that the {{{**}}} operator is not compatible with all browsers. For greater reliability, use the {{{Math.pow()}}} function.)

Be careful with this, though -- powers can lead to unpredictable results at extreme ranges! I don&#39;t recommend using large or small powers unless you want huge damage variance.

You can also change the damper to an amplifier by giving it a value greater than 1, if you want to make your formula more volatile instead.

&lt;h3 id=&quot;dmgform.defenses&quot;&gt;Subtractive vs. Divisive Defense&lt;/h3&gt;
So far we&#39;ve been looking at what happens when everyone&#39;s stats are equal. But what if they&#39;re different? You might want a character who&#39;s a heavy hitter, or an enemy who&#39;s designed to be easily defeated. Let&#39;s look at what happens when it&#39;s 20 Attack vs. 10 Defense, using RPG Maker&#39;s formula:

&lt;div class=&quot;formula&quot;&gt;20 * 4 - 10 * 2 = 60 DMG&lt;/div&gt;
Woah! We only doubled the Attack value, but that came out to &lt;b&gt;three times&lt;/b&gt; as much damage! What happened here?

The answer is that we used &lt;b&gt;subtractive defense&lt;/b&gt;. When damage is based on an absolute difference between stats, small changes can have big effects, and the end result is highly dependent on characters&#39; stats. To simplify things a bit, let&#39;s assume we&#39;re using a simple {{{a.atk - b.def}}} formula. When a.atk is 11 and b.def is 10, that&#39;s 1 damage. When a.atk is 12, that&#39;s 2 damage. Even though the stat changed by a mere 1 point, the damage was doubled. A small change now lets you beat the enemy twice as fast.

With large variance between character&#39;s stats, such as you often see in RPGs with specialized roles, this can get out of control really fast. Against an enemy with high defense, weak or even average characters might be nearly useless while strong characters are barely affected.

Subtractive formulas are well-suited to games where stat differences are very important, and strategy will depend heavily on things that affect that, such as equipment or status effects. Players will need to pay close attention to every character&#39;s capabilities, and match up strong attackers to strong defenders in order to progress at all.

Subtractive formulas tend to be relatively unintuitive. The same change in stats isn&#39;t reflected with the same change in the final result, and players can flounder helplessly against high-defense enemies if they don&#39;t know what they&#39;re doing. It asks more of your players and requires them to engage deeply with the mechanics and mathematics.

This may be the design philosophy you want; it was when I made &lt;i&gt;Cartoon Battle&lt;/i&gt;, which is why this was the formula I used. But what if you want something a bit easier for the player to understand?

In that case, you want &lt;b&gt;divisive defense&lt;/b&gt;. This takes the form {{{DMG = a.atk/b.def}}}. Under this system, stat changes are reflected intuitively: doubling Attack will always double your damage, and doubling Defense will always halve your damage.

Like with subtractive formulas, you can combine this with constants and weights, such as:

&lt;div class=&quot;formula&quot;&gt;DMG = C + D * [(W * a.atk)/b.def]&lt;/div&gt;
Though this formula is more intuitive for the player, it&#39;s unfortunately trickier to design, and requires additional knowledge of mathematics and algebra. Note that Defense can never be 0 with this formula: if it is, you will get a division by zero error! Similarly, a negative Defense value will just turn damage negative and mess up the whole formula, unlike the intuitive result it generates with subtractive defense. (I recommend thinking of some way to make negative Defense act as a multiplier instead of a divisor if you want to preserve that functionality.) You will need handlers for these special cases, or careful checks to ensure they never appear.

One divisive formula that scales relatively well is:

&lt;div class=&quot;formula&quot;&gt;DMG = 4 * a.atk ^ 2 / (a.atk + b.def)&lt;/div&gt;
As always, you can also combine these principles to create a formula with both a subtractive and divisive term.

A more detailed discussion of the pros and cons can be found on the RPG Maker community forums &lt;a href=&quot;https://rpgmaker.net/forums/topics/14545/?post=635978#post635978&quot;&gt;here&lt;/a&gt;. The example divisive formula is taken from there.

&lt;h3 id=&quot;dmgform.special&quot;&gt;Special Attacks and Weighting&lt;/h3&gt;
The game won&#39;t be terribly interesting if all you can use are regular attacks, right? Most RPGs have special skills that do more damage than usual. This means you&#39;re going to need different formulas for those.

&lt;h4 id=&quot;dmgform.special.1&quot;&gt;Lumped Weighting&lt;/h4&gt;
The simplest method is to just multiply the whole formula by a weight value, like so:

&lt;div class=&quot;formula&quot;&gt;DMG = [20 + 0.4 * (a.atk - b.def)] * W&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;DMG = (4 * a.atk - 2 * b.def) * W&lt;/div&gt;
&lt;i&gt;Bonfire&lt;/i&gt; uses this method. This is probably the most intuitive option: if you want a special attack to do more or less damage, it&#39;ll be scaled by the exact amount you want in all situations; the skill will behave fundamentally the same as a regular attack, as the scaling factor doesn&#39;t interact with any stats directly.

&lt;h4 id=&quot;dmgform.special.2&quot;&gt;Specific Weighting&lt;/h4&gt;
However, predictability can be boring. Maybe you want an attack to behave differently in different sitations. Let&#39;s look at what happens if you apply the weight to a term within the equation, rather than over the whole thing:

&lt;div class=&quot;formula&quot;&gt;DMG = W * a.atk - b.def&lt;/div&gt;
Using RPG Maker&#39;s formula as an example, let&#39;s make a skill that behaves like {{{5 * a.atk - 2 * b.def}}}. With 10 Attack and 10 Defense, that&#39;s {{{50 - 20 = 30}}}, a 50% improvement over the basic attack damage of 20. In other words, that&#39;s the same effect as if we had applied a weight of 1.5. This remains constant across scale-up, provided there remains no difference between the Attack and Defense values.

However, let&#39;s test this with 10 Attack and 5 Defense. The basic attack would do {{{40 - 10 =}}} 30 damage, and the special attack would do {{{50 - 10 =}}} 40 damage. Now the improvement is 33%, not 50%.

What if we go in the opposite direction, 10 Attack vs. 15 Defense? The basic attack does {{{40 - 30 =}}} 10 damage, and the special attack does {{{50 - 30 =}}} 20 damage, a 100% increase!

The effectiveness of special attacks weighted through this method, like everything in a subtractive system, is heavily dependent on the difference in stats. A special attack will yield a greater effect against a tough opponent than a weak one. This isn&#39;t very intuitive mathematically, but it is logically: against an armored foe, you can break through using a stronger attack.

This method is good if you want a battle system based around the use of the correct skills. It turns battles into a puzzle of sorts: the same skill has varying usefulness in different situations, and the challenge can be in figuring out which skills to use when. This is the design principle I wanted for &lt;i&gt;Cartoon Battle&lt;/i&gt;, which is why I used this method.

(Note that my formula weights the constant and the attack value as a lumped term. I recommend doing this if you use a constant; I initially tried weighting the attack value only, but the constant ended up dominating the equation and making all attacks very similar.)

&lt;h4 id=&quot;dmgform.special.3&quot;&gt;Adding Constants&lt;/h4&gt;
So far I&#39;ve only mentioned multiplication, but we&#39;re forgetting something even simpler: addition! Just add an extra constant to the attack, and it&#39;ll be stronger by that exact amount, no extra fuss needed. RPG Maker uses this method for its default magic formula, which looks like this:

&lt;div class=&quot;formula&quot;&gt;DMG = 150 + 2 * a.mat - 2 * b.mdf&lt;/div&gt;
If you use a scaling formula like RPG Maker&#39;s, the constant will gradually become less impressive over time as the damage from the typical attack increases. This method is therefore ideal for a skill you only want to be useful for a certain period of time, perhaps to help the player at the beginning before you force them to transition to other tactics.

&lt;h4 id=&quot;dmgform.special.4&quot;&gt;Skill Progression&lt;/h4&gt;
Actually, RPG Maker in particular uses another trick to ensure constant-type skills become obsolete. Let&#39;s take a closer look at that formula:

&lt;div class=&quot;formula&quot;&gt;DMG = 150 + 2 * a.mat - 2 * b.mdf&lt;/div&gt;
Notice something different? The constant isn&#39;t the only thing that changed: the weight on the attacking stat changed too. Every point of Magic Attack only adds 2 points of damage, while regular attacks get 4 points of damage for every point of Attack.

Let&#39;s look at how that scales. With offensive stats at 20 vs. defensive stats at 10:

&lt;div class=&quot;formula&quot;&gt;PHYSICAL: 80 - 20 = 60&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;MAGICAL: 150 + 40 - 20 = 170&lt;/div&gt;
Wow -- that&#39;s nearly three times as much damage! That magic spell&#39;s going to look pretty awesome to a player with those stats. But let&#39;s say they gain a few levels, and now it&#39;s 65 vs. 55:

&lt;div class=&quot;formula&quot;&gt;PHYSICAL: 260 - 110 = 150&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;MAGICAL: 150 + 130 - 110 = 170&lt;/div&gt;
Now it&#39;s not looking so great -- still better than a regular attack, but only by a little. Let&#39;s level them up some more, so now they&#39;re at 100 vs. 90:

&lt;div class=&quot;formula&quot;&gt;PHYSICAL: 400 - 180 = 220&lt;/div&gt;
&lt;div class=&quot;formula&quot;&gt;MAGICAL: 150 + 200 - 180 = 170&lt;/div&gt;
Now the regular attack is actually &lt;i&gt;stronger&lt;/i&gt; than the spell! In fact, the spell hasn&#39;t improved &lt;i&gt;at all&lt;/i&gt; -- it&#39;s just as strong as it was at the beginning! What gives?

The key is that the scaling factor was changed, so that Magic Attack was now on equal footing with Magic Defense. In the regular damage formula, more Attack means more damage even if the difference between offense and defense doesn&#39;t change. If the same scaling was used, magic would always be that much stronger than the regular attack; but with the scaling factor cut, wizards have to work twice as hard to keep up with fighters.

This may sound terribly unfair, but a lot of RPGs use it. You may have noticed yourself if you&#39;ve played a lot of RPGs that magic-users seem to get less impressive as time goes on. That&#39;s because in most RPGs, you&#39;re not intended to use the same spell you get at the beginning all the way through to the end. Instead of getting stronger by improving their stats, wizards are intended to get stronger by getting better spells. Just when the Fire 1 spell is falling behind, give your wizards Fire 2, the same spell but with a bigger constant, and they&#39;ll be back on top.

It&#39;s a difficult balance, though, and a lot of games miss the mark. You often run into issues at the endgame, where you run out of new skills but keep getting stat boosts. Is the last tier of magic good enough to keep casters competitive? Even if you can keep them on par with fighters, if casters need to spend resources like MP and fighters don&#39;t, fighters may still come out on top. But you don&#39;t want to overdo it and make the final spells so strong they make stats meaningless, either.

Personally, I&#39;m not a big fan of this method. Just about the only RPG I felt accomplished it adequately was &lt;i&gt;&lt;a href=&quot;http://site.scfworks.com/?page_id=8&quot; target=&quot;_blank&quot;&gt;Last Scenario&lt;/a&gt;&lt;/i&gt;, itself an RPG Maker game.

You may notice I didn&#39;t bother adding magic stats in the default engine at all. I, personally, don&#39;t actually see the point in a split; most RPGs nowadays give special attacks to fighters too, and once you do that there&#39;s not really a functional difference. As will be discussed later, I think there are better ways of making mages tactically distinct from fighters.

&lt;h3 id=&quot;dmgform.htk&quot;&gt;HP and hit-to-kill ratios&lt;/h3&gt;
Damage is only one half of the equation. How do you balance HP along with it?

As you approach this question, you may be missing the forest for the trees. The exact numbers don&#39;t really matter; they can be basically anything. Observe:

&lt;div style=&quot;display:flex; width:auto; align-items:center; justify-content:space-evenly&quot;&gt;[img[setup.ImagePath + &quot;documentation/HP_PaperMario.PNG&quot;]][img[setup.ImagePath + &quot;documentation/HP_DragonQuest.PNG&quot;]][img[setup.ImagePath + &quot;documentation/HP_FinalFantasy.PNG&quot;]]&lt;/div&gt;
RPGs can have wildly varying HP values. These screenshots (from &lt;i&gt;Paper Mario&lt;/i&gt;, &lt;i&gt;Dragon Quest V&lt;/i&gt;, and &lt;i&gt;Final Fantasy VII&lt;/i&gt;, respectively) show a variance of over a hundredfold across three different examples -- yet all of them are critically acclaimed, well-balanced games. How is this possible, and how should you choose your own HP values?

The answer is to look not at the HP values themselves, but &lt;i&gt;the number of attacks it takes to defeat a character&lt;/i&gt;, or &lt;b&gt;hit-to-kill ratio&lt;/b&gt;. This is an extension of a general principle of game design: Ratio of action to response. How many times does a player have to perform a certain action before they achieve a desired outcome? This is the truly basic unit of game design, and it is a crucial one. Too low and the game may be too easy, too high and the player might get bored and frustrated by feeling that their actions accomplish nothing.

HP and damage design are therefore two sides of the same coin. Let us revisit our three examples, but look for &lt;i&gt;damage&lt;/i&gt; values instead:

&lt;div style=&quot;display:flex; width:auto; align-items:center; justify-content:space-evenly&quot;&gt;[img[setup.ImagePath + &quot;documentation/DMG_PaperMario.PNG&quot;]][img[setup.ImagePath + &quot;documentation/DMG_DragonQuest.PNG&quot;]][img[setup.ImagePath + &quot;documentation/DMG_FinalFantasy.PNG&quot;]]&lt;/div&gt;
That 7000 HP might look like a lot, but at 2800 damage per attack, you&#39;ll be down in only three hits! Mario, despite his paltry 20 HP, can actually take an additional hit if the average attack does 5 damage. &lt;i&gt;Dragon Quest&lt;/i&gt;&#39;s 88 damage would be overkill against Mario and insignificant against a &lt;i&gt;Final Fantasy VII&lt;/i&gt; character, but provides a reasonable hit-to-kill ratio of 4 in its native setting.

This is the measure that you should consider when designing player characters and enemies. I would recommend starting with a general scale for either HP or damage -- what do you want the average attack damage to be, or the average starting HP? -- and then fill the other based on your desired hit-to-kill ratio. &lt;a href=&quot;https://rpgmaker.net/forums/topics/11883/?post=414635#post414635&quot; target=&quot;_blank&quot;&gt;RPG developer Craze recommends a HTK of 8-12 for player characters&lt;/a&gt;, with lower numbers obviously resulting in a more defensive/healing-heavy strategy. To make it easier, you may choose to remove the issue of scaling through a damage formula such as &lt;i&gt;Bonfire&lt;/i&gt;&#39;s and keep HP constant throughout the game. In &lt;i&gt;Bonfire&lt;/i&gt;, for example, all player characters are fixed at 100 HP, with enemies classed into clear &quot;tiers&quot; that each share an HP value.

Notably, I did &lt;i&gt;not&lt;/i&gt; do this math for &lt;i&gt;Cartoon Battle&lt;/i&gt;, which is what resulted in battles being too slow to begin with. I initially gave characters ten times the HP of &lt;i&gt;Bonfire&lt;/i&gt; but only twice the damage, which of course resulted in hit-to-kill ratios that were far too high and just made battles a slog. Learn from my mistake! Plan out how long you want battles to be and how durable you want characters to be, and make sure your numbers align with your desired results.

Note that all of this interacts with &lt;a class=&quot;noExternal&quot; href=&quot;#abilities.heal&quot;&gt;healing&lt;/a&gt; and [[stat growth|Additional Features]] as well. You may balance the numbers well for one snapshot of gameplay, but can you maintain it through the whole course of the game?

&lt;h3 id=&quot;dmgform.random&quot;&gt;Randomness and Variance&lt;/h3&gt;
Predictability can be boring. Sometimes, you want a little randomness in attack outcomes.

This isn&#39;t really my wheelhouse, but you can read about how to do this in the documentation for JavaScript&#39;s {{{Math.random()}}} function: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random

See also the &quot;Misses and Critical Hits&quot; section of [[Additional Features]].

&lt;h3 id=&quot;dmgform.exta&quot;&gt;Additional Reading&lt;/h3&gt;
It&#39;s also possible to use other variables, such as level, as factors in damage formulas. Check out &lt;a href=&quot;https://bulbapedia.bulbagarden.net/wiki/Damage#Damage_calculation&quot;&gt;&lt;i&gt;Pokemon&lt;/i&gt;&#39;s damage formula&lt;/a&gt; if you&#39;d like to see one that&#39;s really complex! For more resources, an RPG Maker community thread with more technical explanations on how to make more complex formulas can be found &lt;a href=&quot;https://rpgmakermv.co/threads/damage-formulas-101-mv-edition.2172/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.

&lt;h2 id=&quot;abilities&quot;&gt;Designing Abilities&lt;/h2&gt;
An RPG is boring if you can only do one thing. You should think about what options you want to give the player. I&#39;m not just talking about different kinds of damage formulas, anymore. The sky&#39;s the limit, here. Does that seem overwhelming? Let&#39;s go over some basic design principles to ground you a little.

&lt;h3 id=&quot;abilities.basic&quot;&gt;Before you begin, what are your regular commands?&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/command_example.JPG&quot;]]

If you&#39;ve played any RPG before, chances are you&#39;re familiar with having these four options in battle: ATTACK, MAGIC, DEFEND, ITEM. Some games add or subtract a few commands, but this is the basic setup used by RPG Maker, &lt;i&gt;Dragon Quest&lt;/i&gt;, &lt;i&gt;Final Fantasy&lt;/i&gt;, and many others. The above image is from &lt;i&gt;Dragon Quest VI&lt;/i&gt;.

Before we design abilities, we&#39;re going to need to break apart this fundamental model -- because, contrary to popular belief, it&#39;s not the only one you can use! It&#39;s not the model used by the default engine, and I&#39;ll explain why.

First, notice how all of these actions have a positive effect. The player will accomplish &lt;i&gt;something&lt;/i&gt; during their turn. Even DEFEND, commonly seen as a &quot;skip turn&quot; option, helps protect the character against the next attack.

If you&#39;ve played &lt;i&gt;Cartoon Battle&lt;/i&gt;, I hope you learned not to take that for granted! I replaced it with an action that really does do nothing. This wasn&#39;t just because I wanted to make things harder for the player, but because I wanted to turn defending into a special role. Only Fighter can defend themselves and others. By limiting the player&#39;s options in this way, I hoped to make them take notice of it, and learn how to use it tactically.

The second thing to notice here is that ATTACK and MAGIC are separate. Why is that, exactly? MAGIC includes the ability to inflict damage. Could we not lump them together? The distinction is typically that attacking is always free while magic requires the use of a resource, but this isn&#39;t always the case. There are RPGs that make even regular attacks consume resources, and have special skills that are free.

There are really two main reasons for this distinction, one historical and one practical. Early computer RPGs were inspired by &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; and similar tabletop RPGs, where not every character had access to magic; under the rules, magic was a solidly distinct action from regular attacks. It&#39;s mostly fallen out of favor as a design practice now, but this principle carried over into many early computer RPGs, where certain classes or characters couldn&#39;t use magic at all.

The other reason is that the player always needs a means to advance the game, and that means inflicting damage. Characters could run out of spells or have their magic disabled, so splitting ATTACK off entirely was an easy way to ensure the player always, in theory, had a means of completing the battle. (There is also, as touched upon in &lt;a class=&quot;noExternal&quot; href=&quot;#dmgform.special.4&quot;&gt;the damage formula section&lt;/a&gt;, the matter of different stats being used for magic; though this distinction has been almost completely lost in modern times, as physical skills are commonplace in RPGs now.)

But oh, why should we be so generous? What if we want to be really mean and give the player no free rides? There&#39;s nothing requiring you to make a basic attack a guarantee. You can, if you really want to, force the player to interact with the game through skills alone.

This is what I did in &lt;i&gt;Cartoon Battle&lt;/i&gt;: I folded ATTACK into MAGIC to create the ACT command. Every character does still have a &quot;basic attack&quot; of sorts, but by doing it this way I got to personalize it for each character, and give them all subtly different behaviors. I believe this leads to a richer design, with more options for the player and personality for the characters. It also makes it possible for the player to be unable to attack at all if they mismanage their resources, creating a more punishing environment that encourages planning and forethought.

This is key, though, and something to be discussed later: I didn&#39;t make actions consume nonrenewable resources. Energy for actions continually regenerates, so even if the player can get themselves into a sticky situation, they can&#39;t ever get into a state where the battle is totally unwinnable.

There are cases when it makes sense for ATTACK to be separate, such as if skills consume limited resources and/or players are not meant to use them often. But I encourage you to think about what purpose you want to use it for, and if it&#39;s better off folded into general actions.

ITEM could theoretically be folded into ACT too, if we really want to compact this. But generally, there are reasons to keep it separate, as in most RPGs items do behave significantly different than skills. You could always just not feature items at all, too, if they&#39;re too much of a hassle.

So: when desigining abilities, first free yourself of assumptions. Think about what your player&#39;s most basic options are going to be, and what functionalities you want to make an ability or a regular command.

&lt;h3 id=&quot;abilities.resources&quot;&gt;Resources and Game Balance&lt;/h3&gt;
Typically, there&#39;s some reason why players can&#39;t just use their best abilities all the time. If they could win every battle by just using the same ability over and over, that wouldn&#39;t make for a very interesting game. Most games implement a number of ways of restricting the use of special abilities, often by tying them to some kind of resource. We&#39;ll discuss a few of the more common methods below.

&lt;h4 id=&quot;abilities.resources.mana&quot;&gt;Mana Points (Limited Resource)&lt;/h4&gt;
This is probably the one you&#39;re most familiar with: special abilities consume a limited resource, typically one that&#39;s not easy to restore. This most commonly takes the form of MP, or Mana/Magic/Moxie/whatever Points. Skills consume MP, which can be restored by resting, often available only in certain locations. Like many RPG mechanics, this is a holdover from &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, which had an even more literal system: wizards had a fixed number of spells they could cast per day. (The very first &lt;i&gt;Final Fantasy&lt;/i&gt; actually used this system! MP did not become commonplace until around the Super Nintendo era.)

The idea behind this system is &lt;i&gt;&lt;b&gt;resource management&lt;/b&gt;&lt;/i&gt;. You enter a dungeon with a certain number of spells, and you have to figure out how to use them appropriately as you progress. You could use up all your MP to quickly dispatch your first encounter, but that could leave you helpless against the next one. The player is encouraged to think ahead and use their skills efficiently so as not to waste MP.

Unfortunately, this design principle has been rather forgotten in modern times, to the point that later games like &lt;i&gt;Final Fantasy XIII&lt;/i&gt; eschew MP entirely. Most RPGs are now designed as a series of tactical set piece battles, with regular encounters being little more than filler before the boss fight. You know that full heal you always get right before the boss? You&#39;re not supposed to get that! &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; and the early &lt;i&gt;Final Fantasies&lt;/i&gt; threw you into boss fights in whatever state the dungeon had left you, which meant every battle mattered in terms of managing your resources. To make matters worse, most RPGs have items that can restore MP, so even if you do run out all you need to do is pop one of your zillion Ethers and you can go right back to slinging spells. This all makes MP virtually meaningless: you&#39;re free to trivialize normal fights with strong skills, and even in long battles where you may run out of MP, it&#39;ll only take one turn for you to get back on track.

Now, there&#39;s nothing wrong with focusing on tactical set pieces over strategical resource management. Some games eliminate resource management entirely by making sure you go into every battle at full strength. However, you should consider that if you do want your game to be more tactical, MP might not be the best system to use.

In sum: MP is best for games based on strategic, long-term resource management. To get the most out of it, you probably shouldn&#39;t give players enough that they can use skills all the time, or make it easy to restore. Perhaps consider removing the possibility of in-battle MP restores?

Implementing this system is quite easy: just add an {{{mp}}} attribute to the &quot;Actor&quot; or &quot;Puppet&quot; class in the story JavaScript, or use the current {{{en}}} attribute and change the battle coding to make it behave like a limited resource.

Some examples of games that use this system well (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5751/&quot; target=&quot;_blank&quot;&gt;Soul Sunder&lt;/a&gt;&lt;/i&gt;, a survival horror RPG where even regular attacks consume MP&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5904/&quot; target=&quot;_blank&quot;&gt;Czarina Must Die&lt;/a&gt;&lt;/i&gt;, which has no in-battle restores&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shin_Megami_Tensei:_Devil_Survivor&quot; target=&quot;_blank&quot;&gt;Shin Megami Tensei: Devil Survivor&lt;/a&gt;&lt;/i&gt;, which gives players very limited MP but makes magic an integral part of the battle system&lt;/li&gt;
&lt;li&gt;Though it&#39;s not an RPG, the first &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Resident_Evil_(1996_video_game)&quot; target=&quot;_blank&quot;&gt;Resident Evil&lt;/a&gt;&lt;/i&gt; and other survival horror games can give you a good idea of what resource management gameplay looks like.&lt;/li&gt;
&lt;li&gt;It may also be instructive to check out the core rulebooks for different editions of &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Editions_of_Dungeons_%26_Dragons&quot; target=&quot;_blank&quot;&gt;Dungeons &amp; Dragons&lt;/a&gt;&lt;/i&gt;. Later editions are often accused of being too much like video games, which is actually good for your purposes! However, the earlier editions (1-3) are the ones with greater focus on resource management and long-term strategy. 1st edition &lt;i&gt;D&amp;D&lt;/i&gt; was also the primary inspiration for the original jRPGs &lt;i&gt;Dragon Quest&lt;/i&gt; and &lt;i&gt;Final Fantasy&lt;/i&gt;, so many design philosophies that are now baked into the genre have their start there.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;abilities.resources.sta&quot;&gt;Stamina (Renewable Resource)&lt;/h4&gt;
Some RPGs that prefer a more tactical focus use this system instead: a more limited, controllable resource that changes as the battle progresses.

The simplest form is a resource that regenerates automatically over time. &lt;i&gt;Cartoon Battle&lt;/i&gt; uses this system: you gain enough Energy points to use a basic attack every round, but to use a more advanced ability you will need to save up. This system is more intuitive and elastic than MP; it is easier to plan out how to allocate your resources, and you&#39;re never trapped in a situation where you&#39;re simply out of options, at least not for long.

There are variations within this system that can have significant effects. How many points to you give the player to start with, and how many do you give them per turn? If you top everyone off before a battle but make them regenerate slowly, you can create a similar system to MP or &lt;a href=&quot;abilities.resources.cd&quot;&gt;cooldown&lt;/a&gt; where players can use strong abilities early but have to wait a while before they can use them again. What is the maximum amount they can hold? A low maximum encourages players to use their points quickly to avoid wasting regeneration, while a high maximum may encourage hoarding and more conservative play. Maybe you don&#39;t want a maximum at all? Does everyone operate on the same rules, or does everyone have a different flow? I encourage you to play around with these parameters and see how they change the feel of the game.

Alternatively, you can make players work for their energy generation. Often, this is a very good way to encourage players to play the game the way you want them to. If you want battles to be fast-paced and reward offense, make regular attacks generate energy and players will be rewarded for playing that way. If you want a more cerebral experience, maybe defending or smart play, such as hitting weaknesses, will do it.

You can complicate this even further by adding multiple resource pools and making them interact! Maybe you have traditional MP, regenerating stamina, and manually generated energy points all at the same time. Maybe you can expend one pool to refresh another? It&#39;ll be complicated, but it can lead to great fun and tactical depth if you can pull it off.

Some games also make energy a group resource, rather than each character having their own separate pool. This can create more tactical depth, with certain characters who can act as &quot;batteries&quot; for the whole group, but asks a lot more of the player -- if they don&#39;t know what they&#39;re doing, they can incapacitate the whole group, not just a single character!

In sum: Renewable resources are best for games with a focus on intense individual fights. This system tends to be more intuitive for the player and easier for the designer to balance, so I recommend starting with it. It&#39;s very modular, and you can adjust a lot of the variables to create a different experience.

Some examples of games that use this system well (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/272/&quot; target=&quot;_blank&quot;&gt;Alter A.I.L.A. Genesis&lt;/a&gt;&lt;/i&gt;, which was a major inspiration for &lt;i&gt;Cartoon Battle&lt;/i&gt;; you will notice a lot of similarities. It&#39;s much more complicated, though, with a manual generation pool on top of renewable energy, and special equipment that can change the rules.&lt;/li&gt;
&lt;li&gt;&quot;Limit Break&quot; abilities, popularized by &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Final_Fantasy_VII&quot; target=&quot;_blank&quot;&gt;Final Fantasy VII&lt;/a&gt;&lt;/i&gt;, are an example of abilities tied to a manually-generated resource&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/4526/&quot; target=&quot;_blank&quot;&gt;Wine &amp; Roses&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Steven_Universe:_Attack_the_Light!&quot; target=&quot;_blank&quot;&gt;Steven Universe: Attack the Light&lt;/a&gt;&lt;/i&gt; is an example of a group resource for actions&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3937/&quot; target=&quot;_blank&quot;&gt;Obelisk: Devilkiller&lt;/a&gt;&lt;/i&gt; features both group and individual resources&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/7969/&quot; target=&quot;_blank&quot;&gt;Prayer of the Faithless&lt;/a&gt;&lt;/i&gt; is an interesting example of a game that uses this system and still manages to be resource management. The developer&#39;s blog posts are also very instructive in terms of game design.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;abilities.resources.cd&quot;&gt;Cooldown&lt;/h3&gt;
Cooldown is a feature that makes the player wait a certain number of turns before they can use a skill again. Cooldown may be tied to skill use itself, or more commonly, each individual skill has its own cooldown.

This is a much more literalized method of skill throttling: if you only want players to use a skill every X turns, you can just make it so, with no further balance testing needed. This has similar advantages to a renewable-resource system, in that it is intuitive for the player and easier to design. It provides similar tactical depth by forcing the player to think ahead so as not to box themselves into a corner.

This method may be combined with any of the others. In particular, it&#39;s a good way to mitigate the problems of a limited-resource system in a tactical setting, by preventing players from just using their strongest attacks constantly. You can include other twists too, like things that add or reduce cooldowns.

Personally, I do not like this system; I feel it is too literal and restrictive, and I feel obligated to use high-cooldown skills as often as possible. I prefer the flexibility of a renewable-resource system. However, this system is gaining popularity, and you and your players may feel differently!

In sum: Cooldown has many of the same advantages as a renewable-resource system, but it is simpler and more straightforward, with the pros and cons that implies. It is recommended for novice developers, as it is easy to implement and balance. It is highly compatible with other systems if you want to add more complexity.

This system is already implemented in the default system for enemies. To implement this for the player, you can add the same attribute to the &quot;Puppet&quot; class or to individual actions.

Some examples of games that use this system well (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://store.steampowered.com/app/706560/Jimmy_and_the_Pulsating_Mass/&quot; target=&quot;_blank&quot;&gt;Jimmy and the Pulsating Mass&lt;/a&gt;&lt;/i&gt; (warning: horror game) combines this with a limited-resource system&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3937/&quot; target=&quot;_blank&quot;&gt;Obelisk: Devilkiller&lt;/a&gt;&lt;/i&gt; combines this with a renewable-resource system&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;abilities.resources.recoil&quot;&gt;Recoil/Blowback&lt;/h3&gt;
Instead of tying skills to a specific resource, you can also limit them by having them affect &lt;i&gt;other&lt;/i&gt; resources, such as a character&#39;s health and stats. Maybe a reckless attack leaves a character injured, or using dark magic saps their strength. This can create a similar situation to limited-resource systems where the player can go into a fight guns blazing, but recoil is far more punishing of reckless behavior. Exhausting your resources in this system doesn&#39;t just lock off your abilities, it can make your characters completely helpless.

Done well, this system can create probably the most tactical and strategical depth of all these systems, forcing the player to make tradeoffs on multiple axes with every action. However, it is very difficult to implement and balance correctly. You have to keep track of not just one resource but several, and ones that interact with the rest of the battle system as well.

As always, you can merge this with other systems as well, possibly only implementing it for a few skills. I did this in &lt;i&gt;Cartoon Battle&lt;/i&gt;, where Mage&#39;s Sacrifice skill consumes HP, and Fighter&#39;s Bull Rush skill self-inflicts a negative effect.

In sum: This system can work with both tactical games and resource management games, but is very complicated. It will take the player some getting used to, and it will be even harder to design fairly. If you want to use this, try easing your way into it by merging it with other systems.

This is the most difficult system to implement: unless you want a consistent theme like all skills consuming HP, you&#39;ll have to incorporate unique behavior into every skill.

Some examples of games that use this system well (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pok%C3%A9mon_(video_game_series)&quot; target=&quot;_blank&quot;&gt;Pokemon&lt;/a&gt;&lt;/i&gt; has moves that inflict recoil damage, and most of the strongest attacks self-inflict debuffs to discourage continuous use&lt;/li&gt;
&lt;li&gt;Physical skills in the &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shin_Megami_Tensei&quot; target=&quot;_blank&quot;&gt;Shin Megami Tensei&lt;/a&gt;&lt;/i&gt; series consume HP rather than MP&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/7969/&quot; target=&quot;_blank&quot;&gt;Prayer of the Faithless&lt;/a&gt;&lt;/i&gt; combines this with a renewable resource system, as your stamina is also your defense&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Live_A_Live&quot; target=&quot;_blank&quot;&gt;Live-A-Live&lt;/a&gt;&lt;/i&gt; is a rare example of a version that uses no other skill limitations&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;abilities.elements&quot;&gt;Elemental Effects&lt;/h3&gt;
If you&#39;ve played any RPG, chances are you&#39;ve run into elemental type matchups. You get a bonus if you use fire magic on the ice monster and ice magic on the fire monster, that sort of thing. Sometimes you&#39;ll see different flavors, like crushing attacks being more effective against armored foes or a hunter character getting a bonus against certain types of monsters. This is a nice way to diversify your player&#39;s options, instead of just giving them one skill that does more damage in all situations.

There&#39;s a reason I didn&#39;t include this in &lt;i&gt;Cartoon Battle&lt;/i&gt;, though: I personally don&#39;t feel like it adds very much. In most RPGs, there is no difference in each elemental spell other than the element, so whether you&#39;re attacking with Fireball or Ice Bolt creates no change in tactics; you&#39;re still just using &quot;the attack that does more damage&quot;. If you plan to use elemental effects, I encourage you to add more personality to each one. Maybe fire spells are the only ones that can hit multiple targets at once? Maybe lightning spells are stronger, but cost more? Alternatively, you can go in the reverse direction, and give elements to personalities. If you restrict certain elements to specific characters, you can use elemental affinities to create tactical depth. Say the healer is the only character who can use the element a certain enemy is weak to? That&#39;s going to force you to make tactical trade-offs, and fight differently than you would otherwise.

And this is more a writing tip than a game design one, but I encourage you to break out of the standard mold of the Classical elements or the fire/ice/lightning trifecta. These are &lt;i&gt;elements&lt;/i&gt;; fundamental components of your world and everything in it. They should inform the story and atmosphere of your game. &lt;i&gt;Why&lt;/i&gt; is everything made of fire, water, wind, and earth? What does that &lt;i&gt;mean?&lt;/i&gt; Are your different elemental forms for monsters functionally identical except for the different hat? Why on Earth are you doing that when you could be making enemies that are actually meaningfully diverse and tell the player something interesting about your setting?

If you&#39;re making something a core gameplay feature, it should tie into your story too. I purposefully encourage this with the vagueness of the default &quot;elements&quot; in the engine -- it&#39;s easy to map the colors onto the standard fire/ice/lightning/dark/holy set, but as I say in the Artist&#39;s attack descriptions, you can interpret them many different ways. Mabel isn&#39;t weak to Blue because she&#39;s bad with cold; she&#39;s weak to Blue because she&#39;s bad at dealing with heavy and negative emotions, which is what I choose to interpret Blue as representing. Think hard about what elements you choose to use in your game and how you can use them to inform the story and characters, not just add depth to the gameplay.
&lt;ul&gt;
&lt;li&gt;In &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3554/&quot; target=&quot;_blank&quot;&gt;Star-Stealing Prince&lt;/a&gt;&lt;/i&gt;, every character uses a different element. Each character has a distinct role, so enemies&#39; weaknesses change the overall group synergy by encouraging different characters towards offense.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3937/&quot; target=&quot;_blank&quot;&gt;Obelisk: Devilkiller&lt;/a&gt;&lt;/i&gt; may be an example of going too far: it&#39;s widely criticized for the major power gap between Solar and Lunar attacks, making Solar-resistant enemies take far longer to beat for no real purpose.&lt;/li&gt;
&lt;li&gt;The &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shin_Megami_Tensei&quot; target=&quot;_blank&quot;&gt;Shin Megami Tensei&lt;/a&gt;&lt;/i&gt; series strongly rewards correct elemental matchups with its mechanics, and encourages a diverse loadout due to limited skill slots and enemies with diverse resistances, including to physical attacks.&lt;/li&gt;
&lt;li&gt;Though it&#39;s not notable from a gameplay perspective, &lt;i&gt;OFF&lt;/i&gt; features some truly bizarre element choices: Smoke, meat, metal, and plastic. This supports the game&#39;s overall surrealist atmosphere and the strangeness of its world.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;abilities.heal&quot;&gt;Healing&lt;/h3&gt;
So far we&#39;ve mainly talked about offensive abilities, but what about healing? If you&#39;ve played RPGs, you&#39;re probably familiar with certain characters having this role; the cleric in &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt;, the white mage in &lt;i&gt;Final Fantasy&lt;/i&gt;, and so on.

You may be surprised to learn this is actually a controversial topic in the indie designer scene! There&#39;s a school of thought positing that healing skills rob the game of tactical depth, because they prevent actions from having permanent consequences. If the player can just keep healing indefinitely until they win, this encourages players to fall into a rut of &quot;turtling&quot;, or playing very defensively and only chipping away at enemies. This can make battles very boring. On the flipside, there exists a tipping point where players will no longer be able to outheal an enemy&#39;s attacks, but it may not be clear to the player where this is, causing them to circle a drain of spending all their time healing and never having the breathing room to attack.

However, giving the player a chance to bounce back from their mistakes may be a good thing. If you give players a lot of HP but no healing, they may be doomed by early mistakes but not realize it until the end of the battle; they must manage their resources carefully every step of the way. It can be asking a lot of your players to make them think that far ahead!

A middle ground exists with revival skills. If there is no possibility of in-battle revival, players can recover from some of their mistakes but not all: if they mess up too badly and let characters get KO&#39;d, they&#39;re punished with an inability to reverse it. If you still find that too punishing, revival skills themselves are separate balance. Do you want HP hitting 0 to be a meaningfully distinct scenario from HP hitting 1? If so, you probably shouldn&#39;t let revival skills recover as much as healing skills. If it&#39;s possible to revive a character to full health every turn, then death hath lost its sting, no? You may as well let normal healing skills revive people -- and that is, itself, a valid option used by some RPGs.

It must also be said: there is some visceral satisfaction in seeing a strong attack bring your party to its knees, even if intellectually you know you can reverse it on the next turn. Your game will lack this if the enemies are just chipping away at you at the same rate you&#39;re chipping away at them. An enemy ripping off 20% of your HP in a single attack can be even more significant than ripping off 80% if you can&#39;t get it back, but our gut reaction is still that it&#39;s less impressive.

Healing skills are a tricky balance to get right. Experiment with it, and see what other games have done. It&#39;s probably a better idea to tie healing to limited resources to avoid an endless turtling scenario, but it can work with renewable resources as well.

These games may be worth consideration (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3937/&quot; target=&quot;_blank&quot;&gt;Obelisk: Devilkiller&lt;/a&gt;&lt;/i&gt; combines healing with long cooldowns with the end result of slowing the pace of damage, but not actually reversing it&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://store.steampowered.com/app/706560/Jimmy_and_the_Pulsating_Mass/&quot; target=&quot;_blank&quot;&gt;Jimmy and the Pulsating Mass&lt;/a&gt;&lt;/i&gt; makes all healing skills proportional to max HP, so they are just as effective throughout the game&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5751/&quot; target=&quot;_blank&quot;&gt;Soul Sunder&lt;/a&gt;&lt;/i&gt; limits healing to items&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/3135/&quot; target=&quot;_blank&quot;&gt;Edifice&lt;/a&gt;&lt;/i&gt; takes no healing to an extreme: there is no healing &lt;i&gt;outside&lt;/i&gt; of battle, either&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;items&quot;&gt;Item Design&lt;/h2&gt;
Most RPGs feature items the player can accumulate over the course of the game. They often expand the player&#39;s options in some way by giving them additional resources.

Items can usually be classed into two categories: &lt;b&gt;Consumable&lt;/b&gt; items are one-use items that produce immediate effects and disappear after use. Health potions and spell scrolls fall into this category. &lt;b&gt;Equipment&lt;/b&gt; can be worn by characters to improve, or at least change, their capabilities. A steel sword, leather armor, and a ring of +2 Strength are all examples of this category.

&lt;h3 id=&quot;items.consumable&quot;&gt;Consumables&lt;/h3&gt;
Consumable items can be thought of as a form of &lt;a class=&quot;noExternal&quot; href=&quot;#abilities.mana&quot;&gt;limited-resource abilities&lt;/a&gt;, and similar design principles apply. The main distinction is that their effects are (usually) independent of the characters&#39; stats, so everyone can use items equally well and there are no soft limits on how many you can store at once. (But not always! Some systems allow different characters to carry more items, or increase the amount of items you can hold over the course of the game. It&#39;s also possible for items to mimic abilities complete with drawing on the relevant stats, or using their own stat entirely. &lt;i&gt;Cartoon Battle&lt;/i&gt; does the latter.)

The important considerations here are how powerful you allow items to be (more powerful than regular abilities? Less?), how many you give the player (can everything be bought, or do you only get a fixed amount for the whole game and that&#39;s it?), and how many the player can store at once (can you only hold a certain number of different items? Can they stack?). If the player can go into battle with 99 full-heal potions in their back pocket, there&#39;s basically no way they can really lose. Some people enjoy the puzzle of managing limited inventory space, but some people find it a frustrating waste of time. And if items have uniquely powerful effects, that will skew gameplay in favor of item use; while if items are inferior to standard abilities, they may become irrelevant.

A major problem that tends to crop up with consumable items is &lt;b&gt;hoarding&lt;/b&gt;. Even if you do run into a situation where you could really use that full-heal elixir, &lt;i&gt;what if I need it later?&lt;/i&gt; Cue walking into the final boss fight with 99 elixirs and turning it into a cakewalk. You should try to this problem. There are a number of ways you can do so, but probably the easiest way is to set low caps for items. &lt;i&gt;Final Fantasy&lt;/i&gt; and most RPG Maker systems let you store a dizzying 99 of each item, which is probably more than you can ever use. If you cap it at a much lower number, that will teach the player that they are supposed to be burning through their inventory space to make room for new items instead of hoarding.

A low item cap also helps with game balance, as it restricts the number of states a player can enter battles with. A player who enters a battle with 99 healing potions is going to have a much easier time than one who enters with 10 or none at all; it&#39;s really hard to balance that to give a challenging but surmountable experience to every player. A lower item cap means a smaller range of preparedness you need to account for. By default, the stock cap in Another RPG Engine is a relatively low &lt;b&gt;9&lt;/b&gt;, but you can change it by editing the {{{ITEM_MAX}}} variable. You can even make stock caps unique for every item, such as allowing fewer copies of higher-level items compared to lower ones; some entries in the &lt;i&gt;Shin Megami Tensei&lt;/i&gt; series do this.

It also helps to clearly communicate item scarcity to the player. A lot of items are hoarded because the player doesn&#39;t know when they&#39;ll get another one, if at all. Something like a rarity marker on items can help the player make more informed decisions. Or, even more directly, just pull back the curtain and show them the locations and drop rates of items in the world. (See the Bestiary in [[Additional Features]] for one way to implement this feature.)

You can also just eschew items entirely, of course, if you&#39;d rather keep things simple.

For more on this topic, see the video &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=HT-Z03YVBPI&amp;list=PL8K0_g1wdQepKF0a8eh_4dhhivcSrSKyO&amp;index=19&quot; target=&quot;_blank&quot;&gt;How Can I Stop Item Hoarding in Games?&lt;/a&gt;&quot; by Design Doc.

These games may be worth consideration (external links):
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://site.scfworks.com/?page_id=8&quot; target=&quot;_blank&quot;&gt;Last Scenario&lt;/a&gt;&lt;/i&gt; has its attack items correspond to spells, but you often get high-level attack items long before you get the corresponding spell, making them function as previews of later abilities. The intense difficulty of the boss fights also requires you to use all your resources to the fullest, including items.&lt;/li&gt;
&lt;li&gt;In &lt;i&gt;&lt;a href=&quot;https://store.steampowered.com/app/706560/Jimmy_and_the_Pulsating_Mass/&quot; target=&quot;_blank&quot;&gt;Jimmy and the Pulsating Mass&lt;/a&gt;&lt;/i&gt;, consumable items are almost never found outside of shops, and you can only carry 9 at a time. This means you will never take them for granted; they are a purposeful investment, and you cannot trivialize battles by stocking up on dozens of everything.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/5751/&quot; target=&quot;_blank&quot;&gt;Soul Sunder&lt;/a&gt;&lt;/i&gt; and its spiritual successor &lt;i&gt;&lt;a href=&quot;https://rpgmaker.net/games/7969/&quot; target=&quot;_blank&quot;&gt;Prayer of the Faithless&lt;/a&gt;&lt;/i&gt; have largely item-based battle systems&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;items.equipment&quot;&gt;Equipment&lt;/h3&gt;
Equipment is a common feature in RPGs. Over the course of the game you obtain different weapons, armor, and other trinkets that improve your stats or confer other advantages. This adds tactical depth to the gameplay, as it provides a resource you can use to modify your characters, thus creating different set-ups for battle.

The most common way this manifests in RPGs is that equipment just provides better bonuses as the game goes on; your starting sword gives +1 Attack, the sword in the next town gives +3 Attack, the sword after that gives +5, etc. This creates a sort of secondary progression method alongside experience levels (discussed in [[Additional Features]]). Even if you have good base stats from leveling up, you will fall behind unless you update your equipment too.

I would generally recommend avoiding this model. I find it redundant with normal level up mechanics, and it provides no tactical depth: if every next item is objectively better than the last, you never have reason to do anything differently. You&#39;ll just add another thing you&#39;ll have to balance for, for no real benefit.

A better method is to think of equipment as providing &lt;i&gt;qualitative&lt;/i&gt; changes rather than quantitative ones. Maybe a weapon inflicts a status effect, or deals extra damage to a specific type of creature. Maybe a piece of armor makes you take more physical damage, but grants you immunity to status effects. Maybe an accessory changes a healing spell into a destructive one, allowing your healer to play a different role. Ideally, the equipment you have at the start of the game should still be viable at the end, or at least most of the way through. This encourages the player to make evaluations and trade-offs over the course of the game instead of finding the one equipment loadout that&#39;s best in all situations. You can still have a &quot;progression&quot; of better equipment, generally by combining multiple effects, but the progression will be less uniform and absolute.

This is also not in any way a required feature for an RPG; don&#39;t feel bad if you don&#39;t want to use it.

&lt;h2 id=&quot;effects&quot;&gt;Status Effects&lt;/h2&gt;
Status effects are things that modify the normal flow of battle. They may change stats, lock off certain abilities, or incapacitate characters entirely. They can affect the whole field, too, not just individuals! This is a great, and often crucial, way to add tactical depth to an RPG. Without status effects, turn-based RPGs are just damage-race number games, which is really boring! Status effects allow you to make strategical trade-offs and throw a wrench into established strategies, forcing the player to adapt and improvise. However, status effects are also one of the things players most often complain about. Careful planning and balance testing is necessary here.

For further reading, see the video &lt;a href=&quot;https://www.youtube.com/watch?v=ThDVGP4UB30&amp;list=PL8K0_g1wdQepKF0a8eh_4dhhivcSrSKyO&amp;index=18&quot; target=&quot;_blank&quot;&gt;What&#39;s the Point of Status Effects?&lt;/a&gt; by Design Doc.

&lt;h3 id=&quot;effects.control&quot;&gt;Hold Effects&lt;/h3&gt;
Hold effects restrict what characters can do in battle. The one you&#39;re probably most familiar with is the &quot;Silence&quot; effect, which restricts the use of magic in several of the most popular jRPG franchises. The excellent indie horror RPG &lt;i&gt;Soul Sunder&lt;/i&gt; takes a more visceral approach, with &quot;arm injuries&quot; locking physical techniques and &quot;head injuries&quot; locking magic. I would also classify effects that prevent you from acting at all under this label.

Hold effects are usually binary in their application -- you&#39;re either affected or you&#39;re not. This makes them very easy to design and implement.

However, balance is, as always, a concern. The power of these effects will depend a lot on the rest of the battle system. Is magic really crucial? Then locking that is going to incapacitate the player pretty badly. Can magic only be used by one character? Then Silence won&#39;t even matter to anyone but them! And magic&#39;s not the only thing you can lock -- you can disable items or even regular attacks.

This also interacts interestingly with status cures. If Silence locks spells, you can&#39;t use your status cure on yourself to fix it! This tends to lead to Silence cure items having higher value than others -- but you can always turn it around with an item-sealing Embargo effect that can only be cured by magic! Some designers, often indie ones who are likely just as sick of this as their players, will go easy on you and let status cure spells remain usable under skill locks. In &lt;i&gt;Cartoon Battle&lt;/i&gt;, I took this route with Fighter&#39;s self-curing Meditate ability and Witch&#39;s Cleanse, but not with Mage&#39;s Restoration spell.

If you don&#39;t make cures easy, though, you have to be careful with how often you throw these out, especially total paralysis effects. If an enemy is paralyzing the whole party with every attack, the player can feel frustrated and powerless, forced to waste time watching their characters slowly die with nothing they can do about it. And if you include a paralysis effect that doesn&#39;t wear off naturally, that&#39;s effectively an instant kill attack. If only certain characters can cure it and they get hit, they&#39;re disabled for the rest of the fight. (If you played &lt;i&gt;Cartoon Battle&lt;/i&gt;, you probably experienced this in the Bill Cipher fight, where petrification could only be cured by limited items if it struck your healers, Witch and Mage.) Maybe you want to be that hardcore, but if you don&#39;t, maybe pull it back a little.

One good way to keep hold effects manageable is to provide characters with a protection effect when they wear off, preventing them from being &quot;stunlocked&quot; continuously. I used this with &lt;i&gt;Cartoon Battle&lt;/i&gt;&#39;s &quot;Alert&quot; status, which is automatically applied after a stun and prevents future applications of &quot;Stunned&quot; until it wears off. I took this idea from &lt;i&gt;Jimmy and the Pulsating Mass&lt;/i&gt;, which additionally makes the &quot;Alert&quot; status last longer after every stun, further discouraging its overuse.

&lt;h3 id=&quot;effects.loss&quot;&gt;Loss-of-control / Uncontrollable Effects&lt;/h3&gt;
Loss-of-control effects are similar to hold effects, but different in their execution. They remove a player character from your control, and force them to act under an AI routine instead. Examples you may be familiar with are the &quot;Berserk&quot; and &quot;Confusion&quot; effects common to many RPGs.

While these effects don&#39;t prevent a character from acting &lt;i&gt;entirely&lt;/i&gt;, they can still severely limit their abilities. Usually, these effects restrict a character to using only their basic attack ability, and you have no say in who they target, preventing you from effectively coordinating attacks. These effects may also compel the character to attack their &lt;i&gt;allies&lt;/i&gt;, which is even worse than just preventing them from acting at all!

The default engine has support for these effects, but only in their most basic form: The affected character only uses their basic attack, and selects their target completely randomly. It is possible to generate a more sophisticated AI that can choose from multiple abilities -- for instance, maybe the character always chooses their strongest attacking ability with no regard for the cost, quickly exhausting their resources? But if you need to make unique logic for every character, that&#39;s going to be a lot of work. You can also implement more complex targeting logic, like the standard targeting logic for enemies.

Some games have these effects convey a tradeoff, providing additional advantages in exchange for the loss of control. For instance, the &quot;Berserk&quot; status provides an offense boost in some games. (In others, it doesn&#39;t -- it&#39;s just loss of control.) They also have interesting interactions with damage reflection, counters, and other features that require careful and judicious targeting. Under normal circumstances you may not find damage reflection too concerning, since you can just stop attacking if you get too hurt... but if the enemy inflicts a berserk effect, your characters will keep attacking with no regard for their own safety! These effects also have interesting combinations with other effects, such as debuffing a character&#39;s Attack before berserking them, or &lt;i&gt;buffing&lt;/i&gt; their Attack before turning them on their allies. Get creative.

It should be noted that these &lt;i&gt;are&lt;/i&gt; effectively hold effects, and the same cautionary notes apply. Don&#39;t use them too much, or players will feel powerless and frustrated.

&lt;h3 id=&quot;effects.statmod&quot;&gt;Stat Modification Effects&lt;/h3&gt;
Stat mods are effects that temporarily modify your stats. They can often function as a &quot;soft&quot; version of hold effects: it may not prevent you from using magic outright, but if your magic stat has been crippled to the point that you&#39;ll only do middling damage... maybe best to wait. They can also incapacitate character archetypes that rely heavily on certain stats: the tank, for instance, might not be up for provoking attacks if their defenses have suddenly been stripped.

These effects are simple in theory, but they can really throw a wrench into players&#39; strategies and shake up complacent tacticians.

But... this is going to be a numerical effect, so fine-tuning is crucial. Just how much are the stats changed by? Do you want it to be possible to drain a character all the way to 0 in a stat? Into the negatives?

The answer is first going to depend on what the stats actually &lt;i&gt;do&lt;/i&gt;. How does a stat correlate to its effect? Will you only need small changes to see significant results, or big ones? If stats are relatively small and even single-digit changes can be significant, stat mods can get pretty overpowered if you&#39;re not careful.

Once you know what range of stat changes you want to be working with, there are a few ways you can get there. Most RPGs take a simple approach: effects always change stats by the same proportion, say 50%. This is easy to test because it means the effect always behaves the same no matter who uses or receives it.

However, complications still arise from this method. Recall from our discussion of &lt;a class=&quot;noExternal&quot; href=&quot;#dmgform.defenses&quot;&gt;subtractive vs. divisive damage formulas&lt;/a&gt; that stat changes can have wildly different effects depending on how they&#39;re applied. In a divisive defense system, fixed-proportion changes will work great throughout the whole game: the stat&#39;s effectiveness will always be reflected by the same amount. However, in a subtractive defense system, it&#39;s &lt;i&gt;absolute&lt;/i&gt; changes that matter. If your characters&#39; stats are increasing over the course of the game, the same proportional changes will lead to greater absolute differences. You can balance it well for the beginning of the game, but it&#39;ll behave totally differently by the end! Changing the effect to an absolute modification can be a viable solution, depending on how the rest of the system works.

If you want to make things more complicated, you can actually make stat mods function like an attack, with variable effects depending on the user and target. &lt;i&gt;Cartoon Battle&lt;/i&gt; does this: stat mods use the same basic formula as regular attacks, but with the base and damping constants halved. This is very tricky to balance! Even if you can balance it correctly in a resting state, results can be volatile if the governing stats change. In the current version of &lt;i&gt;Cartoon Battle&lt;/i&gt;, even a low-power Curse can totally cripple an opponent if their Special has been reduced. So maybe don&#39;t use this method for your first rodeo. Done well, however, it can create a cool shadow-battle mechanic where effect specialists can chip away at each others&#39; stats just as fighters chip away at their HP.

The holy grail of this method is probably to make effect damage use the exact same formula as damage. &lt;i&gt;Bonfire&lt;/i&gt; manages to do this, thanks to its heavy stat damper that both reduces the effect of large stat changes and prevents a buffed character&#39;s effects from getting too powerful.

&lt;h3 id=&quot;effects.dot&quot;&gt;Damage Over Time&lt;/h3&gt;
Damage-over-time effects inflict damage at certain intervals, typically the start or end of a character&#39;s turn. This is one of the simplest effects conceptually, but one of the most complex to actually design.

The first question you want to ask is: how much damage? There are a lot of methods you can use, discussed in [[the code section|Documentation (Advanced)]].

Most RPGs use &lt;b&gt;proportional&lt;/b&gt; damage, meaning that the effect inflicts a portion of max HP (usually 1/8th). This kind of damage affects everyone equally: everyone will go down in the same number of turns, no matter how much HP they have. This levels the playing field between tough and fragile characters, because you can&#39;t mitigate damage-over-time with more HP like you can with regular attacks. This may be a problem if you want a game with a heavy tanking and defensive focus where that distinction is supposed to matter; or you could purposefully use it as a special case to turn those rules on their heads.

Other games, including &lt;i&gt;Cartoon Battle&lt;/i&gt;, calculate damage-over-time like a regular attack, allowing it to be mitigated by higher HP and defenses. You can make this calculation similar to normal damage, thus making damage-over-time as dangerous as a regular attack, or you could shrink it, making damage-over-time less significant. This may seem redundant with a regular attack that just does more damage, but you could use it as a purposeful tradeoff: it will inflict more damage overall, but you have to wait while the enemy continues to attack, and it could be cut off early if the target has a curing ability. You can also make it draw from a different stat, creating a mage/fighter distinction where certain characters are better at dealing damage through different methods.

The second question is: how long does it last? If it only lasts a set number of turns before expiring, then it is effectively just a delayed attack. If it never wears off, its total damage becomes indefinite, potentially making it much more dangerous. The latter implies a heavily status-based battle system, where status cures need to be thrown around a lot.

This all interacts with &lt;a class=&quot;noExternal&quot; href=&quot;#heal&quot;&gt;healing&lt;/a&gt;, too. You&#39;ll need to do a lot of mathematical planning and balance testing to make sure you don&#39;t make damage-over-time effects overpowering or insignificant.

&lt;h3 id=&quot;effects.death&quot;&gt;Instant Death Effects&lt;/h3&gt;
Don&#39;t use these unless you really know what you&#39;re doing. Please. I&#39;m begging you. The entire point of RPGs is that different characters are good at different things. If everyone gets killed equally well, defense-focused characters get the shaft. These totally wreck the game&#39;s balance unless you design the whole system around them.

And oh lordy, do not even get me started on &lt;i&gt;random chance&lt;/i&gt; instant death effects. Are you trying to make a slot machine? No? Then please don&#39;t. Please.

&lt;h3 id=&quot;effects.protect&quot;&gt;Effect Protection&lt;/h3&gt;
Status effects can be big gamechangers, to the point that they may be hard to balance if they&#39;re applied every time they&#39;re used. You could balance this by tweaking their effectiveness or the battle system around them, but there&#39;s often not a lot of middle ground between &quot;harmless&quot; and &quot;overwhelming&quot;.

This is why you see a lot of RPGs make attacks apply effects only some of the time, putting it down to random chance. I, personally, hate this. A little random variance in damage or targeting is fine, but when something as important as a status effect is left up to random chance, the battle can go completely differently just based on a coin flip, through no fault of the player. There is something to be said for this method: a totally deterministic game is solvable, and therefore loses the fun if a player figures it out too easily. Randomness keeps a game fresh by forcing the player to roll with the punches and adapt on the fly.

But let&#39;s say you don&#39;t want that. You can also throttle status effect application through factors under the player&#39;s control, such as protective equipment or &quot;safeguarding&quot; effects like &lt;i&gt;Cartoon Battle&lt;/i&gt;&#39;s &quot;Chi Shield&quot;. I recommend making these all-or-nothing, even if you incorporate randomness in normal effect application: a resource expenditure like equipment or a spell is so major that it&#39;s rather unfair if it has a chance of failure.

But then, what if you want some middle ground between complete immunity and complete vulnerablility to a status effect? Most RPGs handle this by making status effect resistance a kind of &quot;dodge&quot; stat, where e.g. a 50% resistance will let you avoid the effect 50% of the time.

I designed a deterministic form of this method in &lt;i&gt;Cartoon Battle&lt;/i&gt;. The premise is to flatten random resistance chances into a deterministic pattern. For example: if you resist a status effect 50% of the time, then, on average, you should suffer the status effect on every other application. You can mimic this deterministically by giving characters a statistic (let&#39;s call it &quot;tolerance&quot;) that acts sort of like &quot;hit points&quot; for the effect application: every time an effect would be applied, it&#39;s reduced, and when it runs out the effect sticks.

As an example, if we were to give a character a tolerance of 1 against the &quot;Curse&quot; effect, then if Mage targeted them with Curse, the target would not suffer the effect but their tolerance would be reduced by 1. The next time Mage used Curse, it would stick, as the target&#39;s tolerance is now at 0. When the Curse effect wears off, the enemy&#39;s tolerance is renewed at 1 again.

The end result of this is that they will &lt;i&gt;always&lt;/i&gt; block the effect the first time it&#39;s used, but they will &lt;i&gt;always&lt;/i&gt; take the effect if it&#39;s used a second time. The cycle then repeats. This has the same result as a 50% random resistance on average, but is fully deterministic. A tolerance value of 2 would correspond to a 67% resistance, a tolerance value of 3 would correspond to a 75% resistance, and so on.

I believe this has an advantage in that the player can see a consistent result to their actions. Attempting to apply a status effect to an enemy with random resistance can feel tedious and demoralizing, as there&#39;s no telling when or if you&#39;ll succeed. This &quot;tolerance&quot; system guarantees a result to a player after a given amount of investment.

There are also additional wrinkles you can add to this system. Perhaps some tolerances do &lt;i&gt;not&lt;/i&gt; reset once a status effect gets through, but they have a greater starting value? Or perhaps the reverse, a tolerance that only comes into play after the effect has been applied once? You could create an additional &quot;shadow economy&quot; of attacks that destroy or shore up tolerances without applying effects themselves.

&lt;h3 id=&quot;effects.player&quot;&gt;Can players use them?&lt;/h3&gt;
It&#39;s something of a debate whether or not to let players use status effects on enemies. Early RPGs typically didn&#39;t allow this at all, and even when they did it was usually a poorly-balanced afterthought.

However, there is good reason for this. All the difficult balance tweaking I mentioned in the earlier parts? If you want to give status effects to players, you have to do that a second time for everything, often running into brand-new problems because enemies usually behave differently than player characters. Enemies typically don&#39;t have healing skills, for instance. A proportional damage-over-time effect that&#39;s only chipping away at a player who can easily heal it back becomes devastating against an enemy that can&#39;t heal. If you apply proportional damage, you can just sit back and win any fight in a few turns. And what about control effects? Enemies typically have fewer abilities and more rigid behaviors; even a partial control effect like a skill lock could effectively be incapacitating. To say nothing of outright stun effects: if you just keep using that, you can win without letting the enemy get a single turn!

I advise giving status effects to your players because it opens up a huge avenue of new tactical options when done well. However, if you don&#39;t want to go through the work of balancing it, it&#39;s fine to keep things simple and just let the player focus on normal skills.

In &lt;i&gt;Cartoon Battle&lt;/i&gt;, I gave players access to most status effects, but not all. Barring the &quot;Winded&quot; status was obvious, because enemies don&#39;t use the energy system in the first place. However, I also barred &quot;Dizzy&quot;, the skill lock effect, due to the problem mentioned above. How would I even implement that? How would I determine which skills would be affected? How would I lock them off -- would I need to make two behavior sets for every enemy depending on if they were dizzy? That sounded like way more work than it was worth, so I just decided not to bother with it.

Striking this balance is a lot easier if you use a system where players and enemies are all on equal footing, such as in &lt;i&gt;Pokemon&lt;/i&gt;. If not, the same effect can have different results when applied to players versus enemies, and some effects might just not be feasible. Do try not to fall into the trap of giving players status effects but making everything they might feasibly be useful against immune to them, though -- that&#39;s just pointless.

&lt;h3 id=&quot;effects.extra&quot;&gt;Noteworthy Examples&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&quot;Monster collecting games&quot;, of which &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pok%C3%A9mon_(video_game_series)&quot; target=&quot;_blank&quot;&gt;Pokemon&lt;/a&gt;&lt;/i&gt; is the most famous, often keep status effects relevant by making everyone operate under the same rules.&lt;/li&gt;
&lt;li&gt;Status effects are often vital to strategy in the &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shin_Megami_Tensei&quot; target=&quot;_blank&quot;&gt;Shin Megami Tensei&lt;/a&gt;&lt;/i&gt; series.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://store.steampowered.com/app/706560/Jimmy_and_the_Pulsating_Mass/&quot; target=&quot;_blank&quot;&gt;Jimmy and the Pulsating Mass&lt;/a&gt;&lt;/i&gt; streamlines the experience by only giving players access to a few status effects, mainly damage-over-time and a one-turn stun effect. No enemies are immune, even bosses. It is also only possible to protect against a few &quot;basic&quot; status effects; though this may seem unfair, it means no status effect can be totally debilitating, and forces players to actually figure out how to survive status effects instead of just ignoring them.&lt;/li&gt;
&lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://site.scfworks.com/?page_id=8&quot; target=&quot;_blank&quot;&gt;Last Scenario&lt;/a&gt;&lt;/i&gt; lets enemies use status effects against you relentlessly, but doesn&#39;t give you access to any. Much of the game&#39;s strategy involves figuring out how to block and mitigate status effects; until the endgame, your options are limited, so you must pick and choose which ones you can ignore and which ones you will have to endure.&lt;/li&gt;
&lt;li&gt;The &lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Monster_Hunter&quot; target=&quot;_blank&quot;&gt;Monster Hunter&lt;/a&gt;&lt;/i&gt; series features a similar system to my tolerance mechanic, where attacking bosses with status effects will drain a resistance meter until they are finally applied. I actually wasn&#39;t aware of this at all when I designed my system, but it&#39;s good to know there&#39;s another example out there!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;targeting&quot;&gt;Targeting and AI&lt;/h2&gt;
I hate random targeting systems in RPGs. Hate hate hate. RPGs often balance more powerful or useful characters by giving them poor defense, but if you have no way to meaningfully protect them, that just makes the battle a complete crapshoot. If enemies all gang up on your tough fighter, you&#39;ll be fine; if they all gang up on your healer every turn, you&#39;re screwed. It&#39;s the absolute worst system possible: You &lt;i&gt;know&lt;/i&gt; the problem and the optimal outcome, but you&#39;re powerless to influence it. That&#39;s not fair and it&#39;s not fun.

...But you have to admit, making sophisticated AI is hard -- and a completely deterministic enemy becomes a solved game. A common compromise is to make targeting random by default, but give the player means to nudge the dice or influence who can and can&#39;t be attacked. In &lt;i&gt;Cartoon Battle&lt;/i&gt;, I provided this through the Protector, Sneak, and Martyr abilities. It&#39;s possible for enemies to gang up on your squishy Mage if you&#39;re unlucky, but you can completely eliminate that possibility if you protect them -- at the cost, of course, of sacrificing Fighter&#39;s own turn. There&#39;s still uncertainty and risk, but it&#39;s a risk you can weigh and calculate. Other games use different methods, such as aggro systems that allow you to influence the enemy&#39;s behavior through other factors.

&lt;h3 id=&quot;targeting.smart&quot;&gt;Smart Targeting&lt;/h3&gt;
The standard targeting system in the default engine is just random selection, nothing much interesting there. But I also added additional code for &quot;smarter&quot; targeting behavior. These procedures came logically from me imagining how I or another human player would think when selecting a target, and emulating that as best I could.

In the default engine, there is an effect, &quot;Off-Balance&quot;, that makes the character more vulnerable to direct damage, but only lasts for one turn. Obviously, an attacker would want to prioritize anyone with this status (unless, of course, they were using a non-damaging move). Similarly, there is an effect, &quot;Knocked Down&quot;, that sharply reduces a character&#39;s Defense stat -- also an obvious priority target. I included handlers for these effects that made the enemies prioritize them -- either to the exclusion of all else (on &quot;hard&quot; difficulty) or just having a higher chance to select them (on &quot;medium&quot; difficulty).

There is also, in the default engine, an additional wrinkle with debuff abilities: They are influenced by the target&#39;s Special stat, and so will be more effective if the target has reduced Special due to a debuff. So in the case that the enemy was using a debuff ability, I added another handler that made them prioritize such targets.

That&#39;s all the smart targeting I included in the default engine, but you could go a lot further. As a player, you probably like to focus your fire on the target with the lowest health or defense to take them out quickly; maybe enemies should do the same? You probably also recognize that certain types of enemies, like healers or mages, are more dangerous and should be taken out first; maybe enemies should be more inclined to target certain characters based on their class or other attributes. Think about your thought process when you select a target, and how you might translate that into programming logic.

This makes the enemies harder, but in a way it also makes the battles fairer. These outcomes are much worse for the player; but if we left it entirely up to random chance, players would have wildly different experiences depending on if the random selector chose a more vulnerable character or not. By making the enemies always prioritize vulnerable targets, players can&#39;t just rely on good luck to get them through the battle; they must actually pay attention to their defenses and protect characters appropriately.

&lt;h3 id=&quot;targeting.aggro&quot;&gt;Aggro Systems&lt;/h3&gt;
The basic idea behind aggro systems is a logical one. If you think about how a player prioritizes targets, they make their decisions based on what abilities the enemies use, right? Obviously you&#39;ll want to defeat a healer before anything else, and then probably you&#39;d want to go after a dangerous mage before a tough but less remarkable fighter. Aggro systems emulate this behavior by giving every action a statistic that draws enemy attention. The exact mechanics vary: Usually, doing more damage draws more attention, but healing and support abilities can also be made to draw aggro. The key advantage of such a system is that, by quantifying levels of enemy attention, you can give &quot;tank&quot; characters a lot more to do, such as &quot;Taunt&quot; abilities that draw additional aggro towards them, or an inverse ability that removes aggro from themselves or others.

The aggro system in the default engine is based on the one used in &lt;i&gt;Flawed Crystals&lt;/i&gt;, a game made by A Friendly Irin in this engine, which was in turn based on the system used by the &lt;i&gt;Dragon Age&lt;/i&gt; series of video games. You can read about how the system works in &lt;i&gt;Dragon Age&lt;/i&gt; &lt;a href=&quot;https://dragonage.fandom.com/wiki/Threat&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.

You should notice that this system makes some key assumptions and tradeoffs that influence what the resultant gameplay will look like. The key means of drawing threat is through direct damage, which will draw enemy attention towards offensive characters and away from support characters. Moreover, threat gain is based not on total but &lt;i&gt;proportional&lt;/i&gt; damage; this means that weak enemies who can be dispatched in a few hits will be more influenced by direct attacks, while strong enemies with lots of HP will be less easily moved. However, the corollary to this is that enemies with low dependence on direct attacks will be more strongly influenced by abilities that generate flat threat increments, such as the &quot;Taunt&quot; skill in &lt;i&gt;Dragon Age&lt;/i&gt;.

You may note that one major departure from &lt;i&gt;Dragon Age&lt;/i&gt; is that this system is actually less deterministic. In &lt;i&gt;Dragon Age&lt;/i&gt;, enemies will &lt;i&gt;always&lt;/i&gt; target the character closest to them who has the highest threat value. In our system, having the highest threat gives you a greater chance of being targeted, but it is not a guarantee. This is an important consideration in aggro systems: how strongly do you want it to control enemy behavior? Too much and it may, again, lead to a solved game where the player can easily direct everyone&#39;s attention to the tank, who shrugs off every blow while the mages lay waste to your foes with impunity. You would have to carefully tweak the tank&#39;s stats such that they cannot survive a constant onslaught and must occasionally pass the buck to someone else, and perhaps give enemies area-of-effect attacks that the tank cannot protect everyone from.

Another interesting feature of this system is that enemies do not coordinate. Threat is not universal; every enemy has their own unique set of threat values towards each character. An enemy will not bat an eye at a character annihilating their neighbor, so long as they aren&#39;t hit too. It&#39;s a lot simpler to consider every enemy in isolation like this, but that&#39;s not terribly realistic, is it? If an enemy starts wailing on a vulnerable character, you&#39;d focus your fire to take them out quickly. It&#39;s worth considering how you might change the existing code to accomplish this, and why. (A common method is to tie aggro to the player characters, rather than every enemy having their own unique hitlist, and using this value to influence all enemies simultaneously.) This can make enemies a lot more dangerous, but their behavior will feel more like fighting against a human player.

Finally, note a contradiction in this system: I said that a human player would prioritize targeting enemies with support skills, but under this system, enemies do not register support characters at all! This can easily lead to very unbalanced gameplay where the healers can stay back and just keep healing the tanks continuously, who will continue drawing aggro and leave the healers untouched. The easy solution to this is to make support skills draw aggro too, but too much and you may end up tipping in the other direction, with supporters getting too quickly swarmed to use their abilities effectively. You can also generate an unstable feedback loop where a healer in danger needs to heal themselves, which in turn draws more aggro and gets them attacked more...

As with all things in design, this is a balancing act. How realistic do you want the enemies&#39; behavior to be? How much do you want to force the player to outwit them and balance their actions? What behaviors do you want to incentivize or disincentivize? These are complicated questions, and the difficulty in answering them may explain why so many designers choose to make the AI more random and just give enemies more power to make up the difference.</tw-passagedata><tw-passagedata pid="183" name="Documentation (Basic)" tags="text info" position="350,2350" size="100,100">Use the table of contents to navigate. You can come back to the top at any time by pressing the &quot;home&quot; key on your keyboard.

This introduction will teach you how to add content to the default engine settings. For advanced documentation and advice on customization, see [[Documentation (Advanced)]]. This documentation will assume you are familiar with SugarCube basics; see &lt;a href=&quot;https://www.motoslave.net/sugarcube/2/docs/&quot; target=&quot;_blank&quot;&gt;the SugarCube documentation&lt;/a&gt; for reference.

&lt;h1&gt;Table of Contents&lt;/h1&gt;
&gt;&lt;a href=&quot;#databases&quot;&gt;Objects, Classes, and Databases&lt;/a&gt;
&gt;&lt;a href=&quot;#data.puppets&quot;&gt;Creating Puppets&lt;/a&gt;
&gt;&lt;a href=&quot;#data.actions&quot;&gt;Creating Actions&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actions.targeting&quot;&gt;Targeting Logic&lt;/a&gt;
&gt;&lt;a href=&quot;#data.effects&quot;&gt;Creating Effects&lt;/a&gt;
&gt;&lt;a href=&quot;#data.items&quot;&gt;Creating Items&lt;/a&gt;
&gt;&lt;a href=&quot;#data.enemies&quot;&gt;Creating Enemies&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#enemyactions&quot;&gt;Enemy Actions&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#enemyactions.finn&quot;&gt;Simple Example: Finn&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#enemyactions.bubblegum&quot;&gt;Advanced Example: Princess Bubblegum&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#enemyactions.bonnibel&quot;&gt;Complex Example: Bonnibel&lt;/a&gt;
&gt;&lt;a href=&quot;#encounters&quot;&gt;Creating Encounters&lt;/a&gt;
&gt;&lt;a href=&quot;#customization&quot;&gt;Customization&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#custom.init&quot;&gt;Initial Variables&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#custom.passages&quot;&gt;Customizing Passages&lt;/a&gt;

&lt;h2 id=&quot;databases&quot;&gt;Objects, Classes, and Databases&lt;/h2&gt;
RPGs tend to involve a lot of &lt;i&gt;stuff&lt;/i&gt;. Heroes, stats, items, equipment, spells, enemies... It can get dizzying quite quickly. Fortunately, the engine is set up to make creating these objects easy.

An &lt;i&gt;object&lt;/i&gt;, in programming, is a general term for a data structure that contains other data structures within it. Objects are very useful for keeping track of variables that have a lot of associated data. As an example, say you are the manager of a company and want to maintain a digital list of employees. You might want to keep track of various attributes like the name, age, and income of every employee. It would be tedious and confusing to have to keep track of each of these variables if they were not connected in any way. You&#39;d have to give them names like {{{John_age}}}, {{{Jane_name}}}, {{{Jane_income}}}, and {{{John_name}}}, all floating around in a huge unconnected mess.

With objects, you could simply collect all these variables under one person, using the curly brace &lt;code&gt;{}&lt;/code&gt; operators:
{{{
var John = {
  firstName: &quot;John&quot;,
  lastName: &quot;Smith&quot;,
  age: 18,
  income: 27
}
}}}
From then on, every time you want to access one of John&#39;s sub-variables, you can simply place a dot ({{{.}}}) symbol after the &quot;John&quot; object to call them. {{{John.firstName}}} will return &quot;John&quot;, {{{John.age}}} will return &quot;18&quot;, and so on. These sub-variables are called &lt;b&gt;properties&lt;/b&gt; or &lt;b&gt;attributes&lt;/b&gt;, and can, themselves, contain objects (or even functions). You can call up attributes of attributes the same way, with another dot operator, as many times as you need. For instance, if we split John&#39;s {{{income}}} attribute into two properties, {{{hourly}}} and {{{yearly}}}, we could write {{{John.income.hourly}}} to get his hourly wage.

Objects are helpful, but for something as complicated as a game, we need to go one step further, and turn them into &lt;b&gt;classes&lt;/b&gt;. Classes can be thought of as a template or assembly line to produce many copies the same object. Classes of objects all share the same structure, construction method, and functions. This is very useful in RPGs, where we may want to classify our data into broad groups -- say, characters, actions, and items -- that each have unique data but should each behave similarly. For instance, all characters in an RPG should have attributes like HP and Attack. By defining a class, we can create a general template for an object that will always be constructed through the &lt;b&gt;constructor&lt;/b&gt; method defined within it.

To create an object via a class template, you use a different syntax than defining regular objects. You use the keyword {{{new}}} paired with the class name, like so:
{{{
var John = new Employee(&quot;John Smith&quot;);
}}}
You will always need to pair a class instantiation with a function call {{{()}}}; this calls the constructor function used to create the object. You can pass arguments to the constructor like any other function to modify the instance being created; for instance, in this code, the constructor might be able to use the argument &quot;John Smith&quot; to assign the {{{Employee}}}&#39;s {{{firstName}}} and {{{lastName}}} attributes.

(For more information, see w3school&#39;s tutorials on &lt;a href=&quot;https://www.w3schools.com/js/js_objects.asp&quot; target=&quot;_blank&quot;&gt;objects&lt;/a&gt; and &lt;a href=&quot;https://www.w3schools.com/Js/js_classes.asp&quot; target=&quot;_blank&quot;&gt;classes&lt;/a&gt;.)

The details of how our classes are defined are explained in [[Documentation (Advanced)]], but to get started, all you need to do is provide data for your objects. This is handled through &lt;b&gt;database&lt;/b&gt; passages, found in the &quot;custom&quot; subfolder of the &quot;javascript&quot; folder.

Each database is handled similarly. We create a database object as the attribute of the {{{setup}}} variable, which is a special variable used by SugarCube. (Assigning databases to {{{setup}}} is important for reasons &lt;a href=&quot;https://www.motoslave.net/sugarcube/2/docs/#guide-state-sessions-and-saving-refreshing-and-restarting&quot; target=&quot;_blank&quot;&gt;explained in the SugarCube documentation&lt;/a&gt;.) Each property of this database object corresponds to a single object we want to define, and contains data that will be read to create an instance of the object when the game is up and running. Once you have a fully-defined database entry, you need only pass the entry&#39;s name as the argument to the object constructor, and you&#39;ll create a live instance of that object.

&lt;h2 id=&quot;data.puppets&quot;&gt;Creating Puppets&lt;/h2&gt;
The class for playable characters is called &quot;Puppet&quot;, as a carry-over joke from &lt;i&gt;Cartoon Battle&lt;/i&gt;. As such, the database object is called {{{puppetData}}}.

Puppet data entries look like this:
{{{
&quot;Fighter&quot;: {
	&quot;gender&quot;: &#39;N&#39;,
	&quot;hp&quot;: 1000,
	&quot;stats&quot;: {
		&quot;Attack&quot;	: 30,
		&quot;Defense&quot;	: 50,
		&quot;Special&quot;	: 10
	},
	&quot;actions&quot;: [
		&quot;Firefly&quot;,
		&quot;Sword&quot;,
		&quot;Punch&quot;,
		&quot;Hammer&quot;,
		&quot;Bull Rush&quot;,
		&quot;Assault&quot;,
		&quot;Meditate&quot;,
		&quot;Berserker&quot;,
		&quot;Defender&quot;,
		&quot;Protector&quot;,
		&quot;Martyr&quot;
	],
	&quot;defaultAction&quot;: &quot;Sword&quot;,
	&quot;crisis&quot;: &quot;Perfect Defense&quot;,
	&quot;specialInit&quot;: function (actor) {
		actor.firefly = true;
	}
}
}}}
This isn&#39;t what a live {{{Puppet}}} object looks like, but it contains all the data the {{{Puppet}}} constructor needs to create one.
* {{{gender}}} determines what pronouns the system will use to refer to the character. You can spell out &quot;male&quot;, &quot;female&quot;, or &quot;neutral&quot;, or use the one-letter shorthand. If undefined, pronouns will default to &quot;it/its&quot;.
* {{{fullname}}} is a string; this is the name that will be displayed in the actor box. Defaults to the character&#39;s regular name.
* {{{hp}}} determines the character&#39;s starting number of hit points. This determines how much damage they can take before they are defeated.
* {{{stats}}} is, itself, an object. You can define any stats you want here, but the defaults are {{{Attack}}}, {{{Defense}}}, and {{{Special}}}. The character will be created with stats equal to the numbers assigned here.
* {{{actions}}} is an array listing the actions this character can take in battle. You only need to provide the names of each action here; see &lt;a class=&quot;noExternal&quot; href=&quot;#data.actions&quot;&gt;Creating Actions&lt;/a&gt; for details on action construction.
* {{{equipSlots}}} is an object; the keys are the names of equipment slots, and the value is the number of subslots. Defaults to the object specified in {{{DEFAULT_EQUIP_SLOTS}}}.
* {{{defaultAction}}} determines what action will be used when the player uses the {{{[Q]}}} shortcut in battle.
* {{{crisis}}} determines the character&#39;s Crisis ability. Like with regular actions, only the name is required. An array can be used here to give a character multiple Crises. If undefined, the character simply won&#39;t have a Crisis ability.
* {{{tolerances}}} is an object that sets the character&#39;s ailment tolerances. The character must be hit with the ailment a number of times equal to 1 plus the tolerance before it will apply. A value of -1 conveys total immunity to the ailment.
* {{{elements}}} is an object that sets the character&#39;s elemental affinities. Note that these are multipliers, not percentile values; e.g. a value of 2 will make the character take double damage, and a value of -1 will heal the character for whatever damage the attack would have normally done. The property names must match elements defined in {{{ELEMENT_LIST}}}.
* {{{respawn}}} is an integer; after the character is defeated, they will be revived after this many turns. If unset, the character will never respawn automatically.
** {{{respawnHP}}} is a number between 0 and 1; the character will regain this proportion of their max HP when respawning.
** {{{respawnMessage}}} is the message that will be displayed when the character respawns.
* {{{retaliations}}} is an integer; sets how many times the character can counterattack on their turn. Note that you will also need to assign a {{{counter}}} property for it to trigger.
* {{{deathMessage}}} is a string; printed when the character is defeated (HP reaches 0). Defaults to &quot;{{{&lt;character name&gt; is defeated!}}}&quot;.
* {{{immortal}}} is a Boolean; if {{{true}}}, the character will not be defeated if their HP reaches 0. (Make sure their encounter has a custom resolution handler!)
* {{{large}}} is a Boolean; if {{{true}}}, the character&#39;s actor box will span the full width of the screen.
* {{{maskhp}}} is a Boolean; if {{{true}}}, the character&#39;s HP bar and HP total will not be displayed in their actor box.
* {{{loadBearing}}} is a Boolean; if {{{true}}}, the battle will end when this character is defeated, regardless of the status of their teammates.
* {{{specialInit}}} is a function that is run at the end of the {{{Puppet}}} constructor. This is a catchall that allows you to tweak any other variables you want that aren&#39;t specified by the regular attributes. (Due to a coding quirk, the object under construction needs to pass itself as an argument to this function, so assign your code to {{{actor}}} rather than {{{this}}}.) In addition to custom variables, it supports the assignment of the following properties:
** {{{showMaxHP}}} is a Boolean; if {{{true}}}, the character&#39;s max HP will be displayed alongside their current HP in their actor box.
** {{{caps}}} is a Boolean; if {{{true}}}, the character&#39;s name will be capitalized in their actor box.
** {{{firefly}}} is a Boolean; if {{{true}}}, the character will have a higher chance of being targeted by enemies.
** {{{wallflower}}} is a Boolean; if {{{true}}}, the character will have a lower chance of being targeted by enemies.

&lt;h2 id=&quot;data.actions&quot;&gt;Creating Actions&lt;/h2&gt;
Actions determine what things your characters can do in battle -- attacking, casting spells, etc. The database object for actions is called {{{actionData}}}, and its entries look like this:
{{{
&quot;Sword&quot;: {
	&quot;cost&quot;: 2,
	&quot;weight&quot;: 1,
	&quot;basic&quot;: true,
	&quot;info&quot;: function (action) {return `Attack with a weight of ${action.weight}.`},
	&quot;desc&quot;: `Ah, the sword: favored weapon of heroes everywhere. In reality they&#39;re pretty impractical and hard to use, but they just look so cool!`,
	&quot;useText&quot;: null,
	&quot;actText&quot;: function () {
		return `$subject.name swings their sword with perfect form.`;
	},
	&quot;act&quot;: justdmg
}
}}}
This isn&#39;t what a live {{{Action}}} object looks like, but it contains all the data the {{{Action}}} constructor needs to create one. There are additional attributes not shown in this entry that are detailed below:
* {{{useText}}} is displayed in bold before the action&#39;s description in the action phase. Set this to {{{null}}} to omit that section entirely. By default, this text is {{{&lt;user&gt;.name uses &quot;&lt;action&gt;.name&quot;.}}}, quotes included.
* {{{actText}}} is a prose description of the action. It is entirely optional, and only for flavor. (Note that if you want to use variables such as the user&#39;s name in this description, you will need to make it a function that returns a string; if you write it as a raw string, the variable you need won&#39;t exist when the {{{Action}}} object is created!)
* {{{act}}} is the code for what the action actually does in a gameplay sense. It is recommended to make this function return a string of SugarCube code containing your real code, as it is much easier to print text to the screen with SugarCube, and many gameplay functions are contained in SugarCube widgets. Alternatively, there are a number of generic action functions you can assign here. (See the file {{{2_action-functions.js}}} for details.)
* {{{preview}}} is a function that provides a projection of the action&#39;s effects in the confirm phase. If left undefined, a default preview will be generated for damage (if the action has a {{{weight}}}) and effect application (if the action has {{{effects}}}). You can also assign a string value to customize this default preview further:
** &quot;multihit&quot; will read the action&#39;s {{{hits}}} to accurately display damage calculation.
** &quot;spread&quot; can be used for multi-hit attacks with random targets; since the target is unknown, damage calculation will not be done.
** &quot;splash&quot; will calculate splash damage in addition to the initial hit.
** Area effect names (&quot;row&quot;, &quot;column&quot;, &quot;+&quot;, and &quot;all&quot;) will calculate damage for every enemy in their area of effect.
** &quot;removeEffect&quot; will calculate whether the effects in {{{effects}}} will be removed from the target.
** &quot;cleanse&quot; is used to calculate the special functionality of the &quot;Cleanse&quot;, &quot;Neutralize&quot;, and &quot;Restoration&quot; actions.
** {{{null}}} (the value, not the word &quot;null&quot;) will cause no preview to display.
* {{{info}}} provides information about the action&#39;s gameplay function to the player, and is displayed in the action&#39;s help description. (Note that if you want to reference data values of the action, you will need to make this a function, as shown in the example entry.)
* {{{desc}}} is flavor text describing the action, and is displayed below {{{info}}} in the action&#39;s help description. Optional.
* {{{phase}}} is a string; forwards the player to the matching battle phase passage when the action is selected. Must match a passage name EXACTLY. Defaults to &quot;targeting phase&quot;.
* {{{target}}} is a string; can take a value of &quot;enemy&quot;, &quot;ally&quot;, or &quot;all&quot;. Determines which party or parties can be targeted by the action. Defaults to &quot;enemy&quot;.
* {{{cost}}} is a nonnegative integer; determines how many EN points the action consumes when used.
* {{{hpcost}}} is a nonnegative integer; determines how many hit points the action consumes when used. Defaults to 0.
* {{{weight}}} is a number; multiplied by the user&#39;s {{{Attack}}} stat when determining the damage of an attack. (See the damage formula for a deeper explanation.)
* {{{base}}} is a positive integer; a flat value added to the action&#39;s damage output. (See the damage formula for a deeper explanation.)
* {{{hits}}} is a positive integer; determines the number of attacks launched if this is a multi-hit action.
* {{{effweight}}} is a number; determines the strength of any status effects applied by the action.
* {{{dur}}} is an integer; determines the duration of any status effects applied by the action.
* {{{effects}}} is a string or array; lists the effects this action applies or removes. (You can also plug this in manually in the {{{applyEffect}}} function.)
* {{{toleranceDamage}}} is a positive integer; determines how many tolerance points the action consumes if it applies an effect. Defaults to 1.
* {{{accuracy}}} is a nonnegative integer; equal to the percentile value of the action&#39;s chance to hit. Set to {{{true}}} to make the action always hit. Defaults to {{{true}}}.
* {{{critRate}}} is a nonnegative integer; equal to the percentile value of the action&#39;s chance of landing a critical hit. Defaults to 0.
* {{{critMultiplier}}} is a nonnegative number; damage is multipled by this value if the attack lands a critical hit. Defaults to 1.5.
* {{{element}}} is a string; determines the action&#39;s elemental property. Must match one of the elements defined in {{{ELEMENT_LIST}}}. Optional.
* {{{useSpecial}}} is a number between 0 and 1; determines proportion of base damage dependent on Special. Defaults to 0.
* {{{uses}}} is a nonnegative integer; determines how many times an action can be used before its uses must be refilled. If not defined, this attribute will not be set. Optional.
* {{{cooldown}}} is a nonnegative integer; determines how many turns must elapse after use before the action can be used again. If not defined, this attribute will not be set. Optional.
** {{{enemyCD}}} is a nonnegative integer; determines the cooldown of this action when used by an enemy. Defaults to {{{cooldown}}}. Optional.
** {{{nameCD}}} is a string; determines the key in the enemy&#39;s {{{cd}}} Map the cooldown will reference when set. Defaults to the action&#39;s name. Optional.
* {{{warmup}}} is a nonnegative integer; determines how many turns must elapse from the start of a battle before the action can be used. Requires a defined {{{cooldown}}} attribute. If not defined, this attribute will not be set. Optional.
* {{{area}}} is a string; denotes the type of area-of-effect this action has, if any. If not defined, the action will be assumed to be single-target. Optional.
* {{{formula}}} is a function; if defined, it will be used in place of the regular formula when calculating attack damage.
* {{{basic}}} is a Boolean; if {{{true}}}, the action can be used when the character is under a skill lock effect.
* {{{pierce}}} is a Boolean; if {{{true}}}, the attack ignores the target&#39;s {{{Defense}}} stat when calculating damage.
* {{{instant}}} is a Boolean; if {{{true}}}, the action will not end the user&#39;s turn.
* {{{counter}}} is a Boolean; if {{{true}}}, the action is considered a counterattack action.
* {{{noself}}} is a Boolean; if {{{true}}}, the user cannot target themselves with this action.
* {{{oncePerTurn}}} is a Boolean; if {{{true}}}, the action can only be used once per turn, even if it is instant.
* {{{noShock}}} is a Boolean; if {{{true}}}, the action will not cure effects that can be cured through direct damage.
* {{{silent}}} is a Boolean; if {{{true}}}, action code will execute without any display in the action phase.
* {{{truce}}} is a Boolean; if {{{true}}}, it won&#39;t violate the enemy&#39;s surrender. By default, this is {{{true}}} for {{{silent}}} actions, and {{{false}}} otherwise.
* {{{invisible}}} is a Boolean; if {{{true}}}, the action will not be displayed by the standard action listing. By default this is {{{true}}} for {{{passive}}} abilities when in-battle, and {{{false}}} otherwise.
* {{{noDefault}}} is a Boolean; if {{{true}}}, the action cannot be set as a character&#39;s default action. By default, this is {{{false}}} if the action inflicts damage, and {{{true}}} otherwise.
* {{{nosave}}} is a Boolean; if {{{true}}}, the action will not be saved as the character&#39;s last action after use.
* {{{saveMod}}} is a string; the user&#39;s last action will be set to the action named with {{{saveMod}}}. Defaults to the action itself.
* {{{crisis}}} is a Boolean; if {{{true}}}, the action is a Crisis action and can only be used by fully consuming the user&#39;s Crisis points.
* {{{ranged}}} is a Boolean; if {{{true}}}, the action will ignore range limitations on the battle grid (see [[Additional Features]]).
* {{{setupAction}}} is a string; if populated, a delayed action of the same name will be stored in the user&#39;s {{{delayedAction}}} property.
** {{{setupDelay}}} is an integer; specifies the number of turns that must elapse before the delayed action specified by {{{setupAction}}} will occur. Defaults to 1.
** {{{delayPersist}}} is a Boolean; if {{{true}}}, the delayed action will occur even if the user would otherwise be incapable of using an action (dead, stunned, etc). This must be set &lt;b&gt;on the action that will be performed&lt;/b&gt;, not the setup action.
** {{{delayHold}}} is a Boolean; if {{{true}}}, the user will be unable to act while charging their delayed action. This must be set &lt;b&gt;on the action that will be performed&lt;/b&gt;, not the setup action.
** {{{delayMessage}}} is a function; returns a string to be displayed at the top of rounds while an action is charging. Set to {{{null}}} to display no message. This must be set &lt;b&gt;on the action that will be performed&lt;/b&gt;, not the setup action.
* {{{canTargetDead}}} is a Boolean; if {{{true}}}, the action can target dead characters. (By default, dead characters cannot be targeted.)

&lt;h3 id=&quot;actions.targeting&quot;&gt;Targeting Logic&lt;/h3&gt;
There are also parameters we can add to actions that will influence the logic used to select a target when the action is used by a computer-controlled character, such as an enemy. This is handled by two properties: {{{targetMethod}}} and {{{targetMod}}}. With {{{targetMethod}}}, you can define your own targeting function to completely customize your targeting logic. It must return the object you want to be the target of the action. If this property is unset, the action will use the default logic in {{{Hitlist.targetEnemy}}}. (See the {{{targeting.js}}} file for details.)

However, you may think the default target method is fine, but want to make a few relevant tweaks; for instance, a piercing attack should prefer high-Defense characters, while a non-piercing attack should do the reverse. For that, you can use {{{targetMod}}}. This is an array of strings that will alter the default targeting logic in specific ways without you needing to define a custom method.
* {{{&quot;ignore untargetable&quot;}}} and {{{&quot;ignore martyr&quot;}}}: Ignores the relevant effects when determining valid targets.
* {{{&quot;random&quot;}}}: Produces a totally random result (but does not ignore untargetables or martyrs unless specified).
* {{{&quot;smart&quot;}}}: The action will always use smart targeting, regardless of the user&#39;s {{{mercy}}} stat.
* {{{&quot;dispel&quot;}}}: The action will run the {{{dispelFactors}}} method, preferentially targeting characters with buffs.
** {{{&quot;exclusive dispel&quot;}}}: The action will &lt;i&gt;only&lt;/i&gt; target characters with buffs.
* {{{&quot;exclusive&quot;}}}: The action will ignore characters who are not preferred by the following mods. (These mods can also be used without the &quot;exclusive&quot; tag.)
** {{{&quot;most &lt;Stat&gt;&quot;}}} or {{{&quot;least &lt;Stat&gt;&quot;}}}: Preferentially targets characters with the highest or lowest specified stat. HP can also be used, but targeting will be adjusted based on current HP, not maximum HP.
** {{{&quot;most damage&quot;}}}: Preferentially targets the character who inflicted the most damage last round.
** {{{&quot;no effect&quot;}}}: Preferentially targets characters who do not already have the effects applied by this action (as specified in the {{{effects}}} property).
* {{{&quot;ignore downed&quot;}}}: Will &lt;i&gt;not&lt;/i&gt; preferentially target characters with the &quot;Off-Balance&quot; or &quot;Knocked Down&quot; effects.
* {{{&quot;ignore damaging&quot;}}}: Will &lt;i&gt;not&lt;/i&gt; preferentially target the character who inflicted the most damage last round.
* {{{&quot;ignore vulnerable&quot;}}}: Will &lt;i&gt;not&lt;/i&gt; preferentially target characters with debuffed Defense or characters with low HP.
* {{{&quot;pierce&quot;}}}: Preferentially targets the character with the highest Defense.
* {{{&quot;ruthless&quot;}}}: Preferentially target characters based on the inverse proportion of their current HP to their maximum HP, multiplied by an additional weight specified by {{{setup.RUTHLESS_FACTOR}}} (default 3).
* {{{&quot;effect&quot;}}}: Preferentially targets characters with debuffed Special, but ignores characters with a blocking effect.

There are also some effects exclusive to ally-targeting abilities:
* {{{&quot;pragmatic&quot;}}}: Ignores characters whose HP is lower than the proportion specified by {{{setup.PRAGMATIC_CUTOFF}}}.
* {{{&quot;ailments&quot;}}}: Prefers characters with ailments, with additional weighting based on the effects&#39; {{{threat}}} value.

Several of these mods are added by default based on the action&#39;s properties. For example, actions with {{{pierce}}} will add the &quot;pierce&quot; mod, and actions with defined {{{effects}}} will add the &quot;effect&quot; mod.

&lt;h2 id=&quot;data.effects&quot;&gt;Creating Effects&lt;/h2&gt;
Status effects change characters in some way. They can be beneficial, like boosting one or more stats, or detrimental, like preventing the character from using certain actions. (For more information, see [[Design]].) The database object for effects is called {{{effectData}}}, and its entries look like this:
{{{
&quot;ATK Boost&quot;: {
  &quot;buff&quot;: true,
  &quot;stackable&quot;: true,
  &quot;statmod&quot;: true,
  &quot;onApply&quot;: function (puppet) {
    this.id = puppet.stats[&quot;Attack&quot;].addMod(&quot;ATK Boost&quot;,this.power);
  },
  &quot;onRemove&quot;: function (puppet) {
    puppet.stats[&quot;Attack&quot;].removeMod(&quot;ATK Boost&quot;,this.id);
  },
  &quot;info&quot;: function (effect) {
    return `Attack boosted by ${this.power}.`;
  },
  &quot;addText&quot;: function (target) {
    return `${target} is surging with strength!`;
  },
  &quot;removeText&quot;: setup.effectFunctions.remBuff
}
}}}
This isn&#39;t what a live {{{Effect}}} object looks like, but it contains all the data the {{{Effect}}} constructor needs to create one. There are additional attributes not shown in this entry that are detailed below:
* {{{onApply}}} is a function run when the effect is applied. It takes the target character as an argument. As an example, this function may involve changing a stat or applying a special flag.
* {{{onRemove}}} is a function run when the effect is removed from a character. It takes the target character as an argument. This function usually reverses the effects of {{{onApply}}}, but may include additional code.
* {{{info}}} is a description of the effect, printed in the status pane. If you want this description to reference attributes of the effect, you will need to make this a function.
* {{{addText}}} and {{{removeText}}} are text messages displayed when the effect is added or removed, respectively. It takes the host character&#39;s name as an argument.
** There are default text formats defined in {{{setup.effectFunctions}}}, above the database.
* {{{shock}}} is an integer between 1 and 100; corresponds to the percent chance of direct damage removing the effect. Optional.
* {{{topDec}}} is a Boolean; if {{{true}}}, the effect will decay at the start of the round. By default, effects decay at the end of the round.
* {{{sticky}}} is a Boolean; if {{{true}}}, the effect cannot be removed through normal means.
* {{{ULTIMATESTICKY}}} is a Boolean; if {{{true}}}, the effect cannot be removed through &lt;i&gt;any&lt;/i&gt; means except ending the battle.
* {{{unblockable}}} is a Boolean; if {{{true}}}, the effect cannot be blocked by protective effects such as Stasis.
* {{{synonym}}} is a string; if set, tolerance calculations will use the tolerance value specified by this string instead of the effect&#39;s own name. Note that this must match a valid tolerance name EXACTLY.
* {{{persistAfterBattle}}} and {{{persistAfterDeath}}} are Booleans; if {{{true}}}, the effect will persist past their respective events. By default, effects are always removed after battle and on character defeat.
* {{{buff}}} is a Boolean; if {{{true}}}, the effect is considered positive. Relevant to some actions and system messages.
* {{{stackable}}} is a Boolean; if {{{true}}}, multiple instances of the same effect can exist on the same character.
* {{{exclusive}}} is a Boolean; no two {{{Effect}}}s with {{{exclusive}}} set to {{{true}}} can exist at the same time on the same character.
* {{{unique}}} is a Boolean; no two {{{Effect}}}s with {{{unique}}} set to {{{true}}} can exist at the same time in the same party.
* {{{statmod}}} is a Boolean; if {{{true}}}, the effect modifies a character&#39;s stats. Relevant for some effect calculations.
* {{{untargetable}}} is a Boolean; if {{{true}}}, the effect prevents a character from being directly targeted by attacks. This property will hold as long as a character has any effects with this property.
* {{{uncontrollable}}} is a Boolean; if {{{true}}}, the effect is considered a loss-of-control effect. Characters will be uncontrollable as long as they have any effects with this property.
* {{{threat}}} is a number; determines how highly a logic function will value this effect for the purposes of dispels, cures, etc. This value will be automatically incremented based on the effect&#39;s current duration minus 1. (In the case of effects with indefinite durations, this value will instead be multiplied by the value specified in {{{INDEFINITE_EFFECT_MULTIPLIER}}}.)
* {{{skillLock}}} is a Boolean; if {{{true}}}, the effect prevents the victim from using non-basic actions.
* {{{hold}}} is a Boolean; if {{{true}}}, the effect is considered a hold action that restricts the victim from moving. As long as a character has any hold effects, they cannot act.
** {{{holdAction}}} is a function for hold effects; it returns the dummy action that will be displayed if an enemy is held by the effect. This is usually just text, but may include other functionality.
** {{{priority}}} is an integer; determines the order in which enemies must resolve hold effects. Lower numbers are resolved first.
* {{{dot}}} is a Boolean; it is short for &quot;damage over time&quot;. If {{{true}}}, the effect is a damage-over-time effect.
** {{{dmgtype}}} is a function; determines how the damage-over-time is calculated. Several pre-written functions are specified in {{{setup.effectFunctions}}}.
** {{{msg}}} is the message displayed when the damage-over-time triggers.
** {{{weight}}} determines the strength of the damage-over-time. For most effects, this is calculated as part of the action that applies the effect, but some damage-over-time effects use a fixed weight.
* {{{shield}}} is a Boolean; if {{{true}}}, this is a &quot;shielding&quot; effect and will block attacks.
** {{{uses}}} is a nonnegative integer; sets the number of hits a shielding effect can block.
** {{{onHit}}} is a function run when the shield is hit. This may just be a message, or it can include other functionality.

&lt;h2 id=&quot;data.items&quot;&gt;Creating Items&lt;/h2&gt;
Items are objects that characters can obtain during gameplay. They may be consumed on use for a one-time benefit, such as a healing potion, or they may be equipment that grants some bonus when equipped. The database object for items is called {{{itemData}}}, and its entries look like this:
{{{
&quot;Apple of Life&quot;: {
  &quot;usable&quot;: [&quot;inmenu&quot;],
  &quot;onUse&quot;: function (puppet) {
    puppet.maxhp += 100;
    inv().decItem(this.name);
    return;
  },
  &quot;info&quot;: &quot;Permanently increases max HP by 100.&quot;,
  &quot;desc&quot;: `The apple Adam and Eve didn&#39;t eat. It&#39;s lost much of its power, this far from the Garden, but it&#39;ll still make a puppet a little more vivacious than usual.`
}
}}}
This isn&#39;t what a live {{{Item}}} object looks like, but it contains all the data the {{{Item}}} constructor needs to create one. There are additional attributes not shown in this entry that are detailed below:
* {{{info}}} and {{{desc}}} function exactly like they do in &lt;a class=&quot;noExternal&quot; href=&quot;#data.actions&quot;&gt;Actions&lt;/a&gt;.
* {{{stackSize}}} is an integer; determines the max number of copies of this item that can exist in an inventory. Defaults to the value of {{{ITEM_MAX}}} in {{{setup}}}.
* {{{usable}}} is an array that can have up to two elements: &quot;inmenu&quot; and &quot;inbattle&quot;. This determines if the item can be used in the party menu, in battle, or both (if both strings are included in the array). Optional.
** {{{onUse}}} is a function that determines what happens when the item is used in the party menu.
** {{{action}}} is a string; name of the action the item will generate if used in-battle. This defaults to the item&#39;s name.
** {{{instantUse}}} is a Boolean; if {{{true}}}, the item&#39;s {{{onUse}}} will execute as soon as it is selected, rather than requiring a target first. (This is useful for e.g. items that affect the whole party or which take the player to another passage for more detailed interaction.)
* {{{value}}} is an integer; determines the units of currency the item can be bought and sold for at shops.
* {{{fakeName}}} is a string; alternate name that will be displayed until the item is used or equipped. Optional.

Equippable items have several additional properties. An example entry looks like this:
{{{
&quot;Symbol of Destruction&quot;: {
	&quot;equippable&quot;: {slot: &quot;Weapon&quot;, tags: [&quot;symbol&quot;], restrictedTo: []},
	&quot;onEquip&quot;: function (puppet) {
		puppet.stats[&quot;Attack&quot;].addMod(&quot;Symbol of Destruction&quot;,5,true);
	},
	&quot;onRemove&quot;: function (puppet) {
		puppet.stats[&quot;Attack&quot;].removeMod(&quot;Symbol of Destruction&quot;);
	},
	&quot;desc&quot;: &quot;A weapon.&quot;,
	&quot;info&quot;: &quot;ATK +5&quot;
}
}}}
* {{{equippable}}} is an object with three sub-properties. Its existence is checked to determine if an item can be equipped.
** {{{slot}}} is a string; states what slot the item will be equipped to. Must match a character equipment slot.
** {{{restrictedTo}}} is an array; contains the names of characters who can equip the item. Make the array empty for no restrictions.
** {{{tags}}} is an array; stores any additional metadata, such as e.g. equipment restrictions by character class. Optional.
* {{{onEquip}}} and {{{onRemove}}} are functions determining the behavior of the item when it is equipped and removed, respectively.
* {{{sticky}}} is a Boolean; if {{{true}}}, the item is considered cursed and can only be removed through a decurse station.

Note that items are stored in an {{{Inventory}}} object, the code for which can be found in {{{class-item.js}}}. Use the {{{addItem}}} and {{{removeItem}}} functions when adding or removing items to an inventory.

&lt;h2 id=&quot;data.enemies&quot;&gt;Creating Enemies&lt;/h2&gt;
Enemies are the opponents your player will face off against in battles. They are similar to {{{Puppet}}} objects in most respects, but contain several key differences. The database object for enemies is called {{{enemyData}}}, and its entries look like this:
{{{
&quot;Dipper&quot;: {
  &quot;bestiaryNo&quot;: 0,
  &quot;alts&quot;: [&quot;Big Dipper&quot;],
  &quot;gender&quot;: &#39;M&#39;,
  &quot;hp&quot;: 1000,
  &quot;stats&quot;: {
    &quot;Attack&quot;	: 25,
    &quot;Defense&quot;	: 30,
    &quot;Special&quot;	: 35
  },
  &quot;elements&quot;: {
    &quot;black&quot;	: 0.8,
    &quot;white&quot;	: 1.2,
    &quot;blue&quot;	: 0,
    &quot;yellow&quot;: -0.1
  },
  &quot;cooldown&quot;: {
    &quot;Dispel Magick&quot;: 0
  },
  &quot;actions&quot;: function () {
    while (V().action === null) {
      (...)
    } // end loop
		return;
	}
}
}}}
This isn&#39;t what a live {{{Enemy}}} object looks like, but it contains all the data the {{{Enemy}}} constructor needs to create one. Most attributes common to {{{Puppet}}} entries work the same here, but additional attributes are detailed below:
* {{{cooldown}}} is an object that determines the cooldown for the enemy&#39;s actions. You can have multiple property names for different actions.
* {{{noAttacks}}} is a nonnegative integer that determines how many actions the enemy can take per round. By default, this is 1.
* {{{priority}}} is a number that determines the order in which enemies will act during the enemy turn. By default, this is equal to their index in the enemy party array. Lower numbers act first.
* {{{mercy}}} is a number; determines the chance of an enemy skipping smart targeting. (See [[Documentation (Advanced)]] for details on targeting logic.)
* {{{surrender}}} is a function; run when an enemy is spared (if the option is available).
* {{{surrenderFail}}} is a function; run when the player violates an enemy&#39;s surrender by using a damaging action.
* {{{xp}}} and {{{gp}}} are the number of experience points and currency points, respectively, the enemy awards on defeat. Must be integers. Defaults to 0 in both cases.
* {{{itemDrops}}} is an object. Property names must correspond to items, and values must be integers between 1 and 100. Values are the percentile chance of the respective item dropping upon the enemy&#39;s defeat.
* {{{uncounted}}} is a Boolean; if {{{true}}}, this character does not need to be defeated to win the battle.
* {{{boss}}} is a Boolean; denotes that this is a boss enemy. Bosses are treated differently by some system code. (Must be assigned through {{{specialInit}}}.)
* {{{specialdeath}}} is a string; the player will be forwarded to this passage when the enemy is defeated. (Must be assigned through {{{specialInit}}}.)
* {{{bestiaryNo}}} is an integer that determines the order in which the enemy appears in the bestiary, if there is one.
** {{{alts}}} is an array of strings listing any alternate forms to display in the bestiary entry. Optional.
** {{{desc}}} is a description to be displayed in the enemy&#39;s bestiary entry.

&lt;h3 id=&quot;enemyactions&quot;&gt;Enemy Actions&lt;/h3&gt;
The most complicated attribute for enemies is {{{actions}}}. Unlike player characters, enemies don&#39;t have any human mind to pick their actions for them, so it&#39;s not enough to just list what actions they can use. We have to provide a logic for how and when they should act as well.

Here is an example of the beginning of one enemy&#39;s logic function:
{{{
&quot;actions&quot;: function () {
	while (V().action === null){
		var act = random(1,100);

	if (act &lt;= 20){
		V().action = new Action(&quot;Cuteness Poisoning&quot;);
	}
}}}
Let&#39;s break this down.
{{{
while (V().action === null)
}}}
We generally want to wrap this whole function in this {{{while}}} loop. There will be some random variance and conditionals when choosing an action for an enemy, so an action may not always be chosen on the first pass. This loop can only be exited if an action is chosen, which ensures that an action &lt;i&gt;will&lt;/i&gt; be chosen for the enemy. (If not, all sorts of bugs could occur when the engine tries to read a {{{null}}} action.) &lt;b&gt;However, be wary of infinite loops.&lt;/b&gt; Make sure it is always possible for this function to pick some action under any circumstance, even if it&#39;s only a dummy action. Otherwise, the program will be stuck running this loop forever, which will prevent the program from continuing and crash the user&#39;s browser.
{{{
if (act &lt;= 20)
}}}
When an enemy has multiple actions, they&#39;re chosen through an if-else tree. The program will test each conditional in order to find what action to select. Typically, there is an element of randomness to this, as enemies could become solved games if they always behaved exactly the same way.

(I align these conditionals with the same indentation as the {{{while}}} loop. Formatting standards typically suggest indenting everything within a loop, but I find it easier to keep them at this level due to the amount of data inside them. You can format them either way.)
{{{
if (this.CDcheck(&quot;Glitter Bomb&quot;) &amp;&amp; act &lt;= 60 &amp;&amp; act &gt; 40)
}}}
It is possible to use further conditionals to implement more complex behavior and disqualify a selected action based on other factors, such as this example from Mabel&#39;s Glitter Bomb ability. If Glitter Bomb hasn&#39;t finished its cooldown (which we can find with {{{CDcheck()}}}, a function common to all {{{Enemy}}} objects), it can&#39;t be selected, even if it otherwise falls into the correct {{{act}}} threshold. Thanks to the {{{while (V().action === null)}}}, a new action will be chosen afterwards.
{{{
puppets().forEach(function(puppet){
  count += puppet.effects.length;
});

  var t = 20 + (count-2)*20;

if (this.CDcheck(&quot;Wild Magic&quot;) &amp;&amp; count &gt;= 2 &amp;&amp; act &lt;= t)
}}}
We can also run additional code in the action selector itself to get additional variables and dynamic reactions to the player&#39;s state. In this example, from Bill Cipher, we count the number of effects present on all puppets, then plug that into a function: {{{20 + (count-2)*20}}}. In addition to &quot;Wild Magic&quot; needing to pass the cooldown check, {{{act}}} must also be less than this variable for it to work. This makes selecting Wild Magic 20% more likely for every effect present on the player&#39;s party.

To learn more about the targeting logic and customizations you can make, see the relevant section in [[Documentation (Advanced)]].

After this, we can define the statistics of the action, either manually or through a call to the actions database. In the default examples, action values are all set manually within these conditionals. I like this method because it allows me to see both the action statistics and the logic used to trigger them at the same time, which is helpful for balance tweaking. In &lt;i&gt;Cartoon Battle&lt;/i&gt; every enemy was a set piece with unique abilities, but if you want to create an RPG with enemies who share general actions, you may want to define them separately in the database.

These are the basic components of enemy behavior. The default engine includes the behavior of every first-tier enemy in &lt;i&gt;Cartoon Battle&lt;/i&gt; for you to examine to get a sense of how it works in practice. If you&#39;d like additional examples, the fan wiki for &lt;i&gt;Final Fantasy&lt;/i&gt;, a popular RPG franchise, &lt;a href=&quot;https://finalfantasy.fandom.com/wiki/Final_Fantasy_VII_enemies&quot; target=&quot;_blank&quot;&gt;lists the AI code for every enemy in &lt;i&gt;Final Fantasy VII&lt;/i&gt;&lt;/a&gt;, which may be instructive, especially for how to write simpler enemies.

For now, let&#39;s go over Finn and Princess Bubblegum as simple and complicated examples, respectively.

&lt;h4 id=&quot;enemyactions.finn&quot;&gt;Simple Example: Finn&lt;/h4&gt;
{{{
this.actions = function () {
	while (V().action === null){
		var act = random(1,2);

	if (act == 1) {
		V().action = new Action(&quot;Sword&quot;);
		V().action.actText = &quot;Finn swings his sword wildly!&quot;;
		V().action.useText = null;
	} else if (act == 2) {
		V().action = new Action(&quot;Assault&quot;);
		V().action.actText = &quot;Finn charges in recklessly!&quot;;
		V().action.useText = null;
    V().action.act = applyEffect(&quot;Off-Balance&quot;,{self: true, dmg: true});
	}

	} /* end loop */
	return;
}
}}}
Finn shows us the basics of how enemy actions are structured. We set the variable {{{act}}} based on some logic -- here, randomly -- and then create an {{{if}}} tree keyed to it, with actions in each branch.

Finn has only two actions: a regular attack, and a reckless charge. We determine which one to use based on a random coin flip; then the {{{$action}}} variable is set through a call to the {{{Action}}} constructor; then we set the attributes of the action. In this case, we don&#39;t need to do much to define the actions, as they are intentionally exact copies of extant actions: Fighter&#39;s Sword and Assault skills. We only need to alter the flavor text (and the applied effect, for Assault). If you plan to have multiple enemies use the same actions, it may be a good idea to define them in the action database so you don&#39;t have to set as many attributes here.

You can see here that Finn has very simple behavior: half the time he will use a regular attack, and half the time he will use a stronger attack that leaves him open. This behavior is totally random; he won&#39;t avoid using the charge attack if he&#39;s low on health or afflicted with a Defense debuff, as the player might in his position. This is a lot easier to code, but it also aligns well with how I wanted Finn to behave. In &lt;i&gt;Adventure Time&lt;/i&gt;, Finn is a reckless and foolhardy character, so this behavior is fitting for his personality.

&lt;h4 id=&quot;enemyactions.bubblegum&quot;&gt;Advanced Example: Princess Bubblegum&lt;/h4&gt;
{{{
&quot;cooldown&quot;: {
  &quot;mass buff&quot;: 0,
  &quot;Chi Shield&quot;: 0
},
&quot;actions&quot;: function () {
	while (V().action === null){
		var act = random(1,100);

	if (this.cd.get(&quot;mass buff&quot;) &lt; 0) {
		act = random(1,3)
		switch (act) {
			case 1:
				V().action = new Action(&quot;Call to Arms&quot;);
				break;
			case 2:
				V().action = new Action(&quot;Walled City&quot;);
				break;
			case 3:
				V().action = new Action(&quot;Age of Enlightenment&quot;);
				break;
		}
		this.cd.set(&quot;mass buff&quot;,2);
	}
	else if (this.ready) {
		act = random(1,2)
		if (act == 1) {
			V().action = new ItemAction(&quot;Grenade&quot;);
			V().action.weight = 1;
			V().action.useText = null;
			V().action.actText = `Princess Bubblegum throws what appears to be a giant peppermint, but as soon as it hits the ground it explodes with the force of a grenade, spreading hard candy shrapnel everywhere.`;
		}
		else if (act == 2) {
			V().action = new Action();
			V().action.effweight = 0.8;
			V().action.dur = 4;
			V().action.useText = null;
			V().action.actText = `Princess Bubblegum douses $target.name in a stinging, sticky syrup. They cough and stagger as their skin breaks out in welts.`;
			V().action.act = justeffect(&#39;t&#39;,&quot;Poisoned&quot;);
		}
		this.ready = false;
	}
	else if (act &lt;= 50) {
		var hitlist = [];
		if (!V().enemies[0].dead &amp;&amp; !V().enemies[0].stasis){
			hitlist.push(V().enemies[0]);
		} else if (!V().enemies[2].dead &amp;&amp; !V().enemies[2].stasis){
			hitlist.push(V().enemies[2]);
		}
		if (hitlist.length &gt; 0) {
			var t = random(0,hitlist.length-1);
			target() = hitlist[t];
			act = random(1,3)
			switch (act) {
				case 1:
					V().action = new Action(&quot;Adrenaline&quot;);
					V().action.dur = 2;
					V().action.effweight = 0.4;
					V().act = justeffect(&#39;t&#39;,&quot;ATK Boost&quot;);
					break;
				case 2:
					V().action = new Action(&quot;Stoneskin&quot;);
					V().action.dur = 2;
					V().action.effweight = 0.4;
					V().act = justeffect(&#39;t&#39;,&quot;DEF Boost&quot;);
					break;
				case 3:
					V().action = new Action(&quot;Nootropic&quot;);
					V().action.dur = 2;
					V().action.effweight = 0.4;
					V().act = justeffect(&#39;t&#39;,&quot;SPC Boost&quot;);
					break;
			}
		}
	}
	else if (this.cd.get(&quot;Chi Shield&quot;) &lt; 0 &amp;&amp; act &lt;= 75 &amp;&amp; act &gt; 50) {
		V().action = new Action();
		V().action.dur = 2;
		V().action.useText = null;
		V().action.actText = function () {
			var str;
			if (target() == subject()){
				str = &quot;becomes&quot;;
			} else {
				str = &quot;$target.name is&quot;;
			}
			return `$subject.name presses a button, the air around ${str} surrounded by a force field.`
		}
		V().act = justeffect(&#39;t&#39;,&quot;Chi Shield&quot;);
		this.cd.set(&quot;Chi Shield&quot;,1);
	}
	else {
		V().action = new Action();
		V().action.useText = null;
		V().action.actText = `Princess Bubblegum pulls something out of her pack.`;
		V().act = `Something has changed...`;
		this.ready = true;
	}

	} /* end loop */
	return;
}
}}}
In contrast to Finn, Princess Bubblegum has a highly intelligent and pragmatic personality, so to be true to her character I wanted to give her more sophisticated behavior.

To begin with, you&#39;ll notice she has additional attributes above {{{actions}}}. Just like the player&#39;s abilities, we need some way to balance enemy abilities. Some abilities are very powerful, and would make the game way too hard if enemies could use them all the time! You could implement an energy system like the player characters use, but I found that too difficult. I used a simpler system: when the enemy uses a powerful attack, their &quot;cooldown&quot; variable for that attack is increased. Cooldown is reduced by 1 at the start of every turn, so enemies must wait that many turns before using a special attack again.

Cooldown is set with the {{{cooldown}}} property of an enemy entry, and you can evaluate if an action is usable with the function {{{CDcheck(&lt;cooldown key&gt;)}}}, which is common to all {{{Enemy}}} objects.
{{{
if (this.CDcheck(&quot;mass buff&quot;)) {
	act = random(1,3)
	switch (act) {
		case 1:
			V().action = new Action(&quot;Call to Arms&quot;);
			break;
		case 2:
			V().action = new Action(&quot;Walled City&quot;);
			break;
		case 3:
			V().action = new Action(&quot;Age of Enlightenment&quot;);
			break;
	}
	this.cd.set(&quot;mass buff&quot;,3);
}
}}}
We can use {{{if}}} statements to make these variables influence Bubblegum&#39;s behavior. If her &quot;mass buff&quot; cooldown passes the check, she can choose this action; otherwise, she will skip it. This is the first branch of the if tree, so it gets the highest priority: she will &lt;i&gt;always&lt;/i&gt; choose this action if the conditional is fulfilled.

Because there are three possible buffs for her to choose from, we have to add additional logic to select the specific action. We could make complicated logic here, such as prioritizing Defense if the party is injured or Special if she&#39;s already readied a bomb, but for simplicity&#39;s sake I just made the choice completely random. Bubblegum gets an even chance of selecting any buff ability, 1/3rd each.

(Like with Finn, since these are actions shared by puppets and therefore already defined in the database, we just need a single constructor call. We don&#39;t even need to modify the flavor text, since these skills don&#39;t have any to begin with.)

At the very end, we set the &quot;mass buff&quot; cooldown to 3, which is the duration of the buffs. The game could get pretty unfair if she could stack mass buffs, so we want to make sure she can only have one buff active at a time.
{{{
else if (this.ready) {
	act = random(1,2)
	if (act == 1) {
		V().action = new ItemAction(&quot;Grenade&quot;);
		V().action.weight = 1;
		V().action.useText = null;
		V().action.actText = `Princess Bubblegum throws what appears to be a giant peppermint, but as soon as it hits the ground it explodes with the force of a grenade, spreading hard candy shrapnel everywhere.`;
	}
	else if (act == 2) {
		V().action = new Action();
		V().action.effweight = 0.8;
		V().action.dur = 4;
		V().action.useText = null;
		V().action.actText = `Princess Bubblegum douses $target.name in a stinging, sticky syrup. They cough and stagger as their skin breaks out in welts.`;
		V().action.act = justeffect(&#39;t&#39;,&quot;Poisoned&quot;);
	}
	this.ready = false;
}
}}}
The very next branch checks against Bubblegum&#39;s {{{ready}}} attribute. If it&#39;s true, she&#39;s going to throw a bomb. Since this is the branch immediately after the last one, it takes priority over all other actions: she &lt;i&gt;will always&lt;/i&gt; throw a bomb if she&#39;s ready and can&#39;t use a mass buff.

Once again, there are multiple specific actions she can take here, so we do another randomized roll. Half the time she will use a grenade, and half the time she will use a poisoning attack.
{{{
V().action = new ItemAction(&quot;Grenade&quot;);
V().action.weight = 1;
}}}
Notice that we call a pre-defined action here, but we proceed to specify a {{{weight}}} value anyway. In this case, I decided that the normal Grenade weight would be too unfair for this battle, so I lowered it to 1. Anything you specify here will overwrite anything that was defined by the constructor.
{{{
else if (act &lt;= 50) {
	var hitlist = [];
	if (!V().enemies[0].dead &amp;&amp; !V().enemies[0].stasis){
		hitlist.push(V().enemies[0]);
	} else if (!V().enemies[2].dead &amp;&amp; !V().enemies[2].stasis){
		hitlist.push(V().enemies[2]);
	}
	if (hitlist.length &gt; 0) {
		var t = random(0,hitlist.length-1);
		target() = hitlist[t];
		act = random(1,3)
		switch (act) {
			case 1:
				V().action = new Action(&quot;Adrenaline&quot;);
				V().action.dur = 2;
				V().action.effweight = 0.4;
				V().act = justeffect(&#39;t&#39;,&quot;ATK Boost&quot;);
				break;
			case 2:
				V().action = new Action(&quot;Stoneskin&quot;);
				V().action.dur = 2;
				V().action.effweight = 0.4;
				V().act = justeffect(&#39;t&#39;,&quot;DEF Boost&quot;);
				break;
			case 3:
				V().action = new Action(&quot;Nootropic&quot;);
				V().action.dur = 2;
				V().action.effweight = 0.4;
				V().act = justeffect(&#39;t&#39;,&quot;SPC Boost&quot;);
				break;
		}
	}
}
}}}
In the next branch we finally get into one of her &quot;normal&quot; actions: giving a buff drug to one of her allies.
{{{
if (act &lt;= 50)
}}}
We see that the conditional uses the {{{act}}} variable. Because {{{act}}} was set to a random value between 1 and 100, this action will be selected half the time.
{{{
var hitlist = [];
if (!V().enemies[0].dead &amp;&amp; !V().enemies[0].stasis){
	hitlist.push(V().enemies[0]);
} else if (!V().enemies[2].dead &amp;&amp; !V().enemies[2].stasis){
	hitlist.push(V().enemies[2]);
}
if (hitlist.length &gt; 0) {
	var t = random(0,hitlist.length-1);
	target() = hitlist[t];
}}}
We then proceed to implement some unique targeting logic, though it&#39;s similar to the logic discussed previously. Bubblegum will exclude herself as a viable target, and only choose between her allies (at index 0 and index 2). She won&#39;t target them if they&#39;re already defeated, of course, and since this is a buff, she won&#39;t target them if they&#39;re in Stasis either. The action definition is inside the final {{{if}}}, so this action will only be chosen if a viable target was found.
{{{
act = random(1,3)
switch (act) {
	case 1:
		V().action = new ItemAction(&quot;Adrenaline&quot;);
		V().action.dur = 2;
		V().action.effweight = 0.4;
		V().act = justeffect(&#39;t&#39;,&quot;ATK Boost&quot;);
		break;
	(etc.)
}}}
As with the mass buffs, Bubblegum has three to choose from, and once again the choice is made with a simple random roll. And as with the grenade, though the action mimics a database action, I have chosen to overwrite its values for game balance purposes.
{{{
else if (this.CDcheck(&quot;Chi Shield&quot;) &amp;&amp; act &lt;= 75 &amp;&amp; act &gt; 50) {
	if (target() !== null){
		V().action = new Action();
		V().action.dur = 2;
		V().action.useText = null;
		V().action.actText = function () {
			var str;
			if (target() == subject()){
				str = &quot;her becomes&quot;;
			} else {
				str = &quot;$target.name is&quot;;
			}
			return `$subject.name presses a button, the air around ${str} surrounded by a force field.`
		}
		V().act = justeffect(&#39;t&#39;,&quot;Chi Shield&quot;);
		this.cd.set(&quot;Chi Shield&quot;,2);
	}
}
}}}
Bubblegum&#39;s next action is another buff, this time providing Chi Shield.
{{{
if (this.cd.get(&quot;Chi Shield&quot;) &lt; 0 &amp;&amp; act &lt;= 75 &amp;&amp; act &gt; 50)
}}}
This is another action with a cooldown, so we must check against it in the conditional. However, it must also pass an {{{act}}} range. Even with no cooldowns active, this action will only be selected when {{{act}}} is between 51 and 75, or 25% of the time.

The action is otherwise quite straightforward. We create a blank action, define its attributes, and set the cooldown when we&#39;re done.
{{{
else {
	V().action = new Action();
	V().action.useText = null;
	V().action.actText = `Princess Bubblegum pulls something out of her pack.`;
	V().act = `Something has changed...`;
	this.ready = true;
}
}}}
Bubblegum&#39;s final action is covered under a default {{{else}}} clause, so it will always trigger if no other condition is met. Effectively, this means it will trigger at {{{act}}} values 76-100, or 25% of the time. This action just sets {{{ready}}} to true, enabling Bubblegum to throw a bomb on the next turn.

Princess Bubblegum is my favorite character from &lt;i&gt;Adventure Time&lt;/i&gt;, so I played favorites: I made her the focus of the battle and gave her two separate behaviors depending on what stage the battle was in. This has only described her normal behavior, but you can look up the &quot;PB alone&quot; case in {{{changeInto}}} to see how her behavior changes when the player defeats her cohorts.

&lt;h4 id=&quot;enemyactions.bonnibel&quot;&gt;Complex Example: Bonnibel&lt;/h4&gt;
Princess Bubblegum reappears in the final battle of &lt;i&gt;Cartoon Battle&lt;/i&gt;, but this time in her season 7 incarnation, where she has been stripped of her crown and forced to rely only on her own wits for survival. Not content to simply reuse her behavior from the first fight, I designed the most complex AI in the game for her, making her a &quot;mirror&quot; to the player&#39;s own Rogue.
{{{
&quot;specialInit&quot;: function(actor) {
  actor._idname = &quot;PB Champ&quot;;
  actor.name = &quot;Bonnibel&quot;;
  actor.ready = true;
  actor.inventory = new Map([
      [&quot;Bottled Chi&quot;,3],
      [&quot;Adrenaline&quot;,3],
      [&quot;Stoneskin&quot;,3],
      [&quot;Nootropic&quot;,3],
      [&quot;Powdered Glass&quot;,2],
      [&quot;Grenade&quot;,2],
      [&quot;Calamity Bomb&quot;,2],
      [&quot;Gas Bomb&quot;,1],
      [&quot;Flamethrower&quot;,1],
      [&quot;Chaff Grenade&quot;,1],
      [&quot;Panacea&quot;,3]
    ]);
  actor.attackItemLogic = function () {
  	while (V().action === null) { // hasItem check should prevent infinite loop but BE CAREFUL
  		var act = random(1,100);
  		var noPowderedGlass = false;
  		var noCalamityBomb = false;
  		var count = 0;

  		if (act &lt;= 40) { // use single-target item
  			console.log(&quot;Bonnibel single-target attack item branch&quot;);
  			chiCheck([&quot;alert&quot;,&quot;dead&quot;]);
  			console.log(&quot;Chi check performed, count = &quot;+count);
  			if (count == V().puppets.length) {
  				noPowderedGlass = true; // if all puppets are alert or dead, there are no viable targets for Powdered Glass
  			}
  			chiCheck([&quot;dead&quot;]);
  			if (count == V().puppets.length) {
  				noCalamityBomb = true; // if all puppets are protected or dead, there are no viable targets for Calamity Bomb
  			}
  			if (noPowderedGlass &amp;&amp; noCalamityBomb) {
  				act = 2;
  			} else if (noPowderedGlass) {
  				act = random(2,3);
  			} else if (noCalamityBomb) {
  				act = random(1,2);
  			} else {
  				act = random(1,3);
  			}
  			if (this.inventory.get(&quot;Powdered Glass&quot;) &gt; 0 &amp;&amp; act == 1) {
  				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot;&gt;&gt;&#39;);
  				if (!target().alert &amp;&amp; !target().chi &amp;&amp; !target().stasis) {
  					V().action = new ItemAction(&quot;Powdered Glass&quot;);
  					action().actText = `Bonnibel pours what appears to be bright pink sugar onto her palm. She blows it into ${target().name}&#39;s face, and they recoil and claw at their face as if they were shards of glass.`;
  				}
  			}
  			else if (this.inventory.get(&quot;Grenade&quot;) &gt; 0 &amp;&amp; act == 2) {
  				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot;&gt;&gt;&#39;);
  				V().action = new ItemAction(&quot;Grenade&quot;);
  				action().act = splashDamage(&#39;p&#39;);
  			}
  			else if (this.inventory.get(&quot;Calamity Bomb&quot;) &gt; 0 &amp;&amp; act == 3) {
  				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot; &quot;debuff&quot;&gt;&gt;&#39;);
  				V().action = new ItemAction(&quot;Calamity Bomb&quot;);
  			}
  		}
  		else { // use multi-target item
  			act = random(1,3);
  			if (this.inventory.get(&quot;Gas Bomb&quot;) &gt; 0 &amp;&amp; act == 1) {
  				V().action = new ItemAction(&quot;Gas Bomb&quot;);
  				V().action.act = massAttack(&#39;p&#39;,&quot;Poisoned&quot;,V().action.dur);
  			}
  			else if (this.inventory.get(&quot;Flamethrower&quot;) &gt; 0 &amp;&amp; act == 2) {
  				V().action = new ItemAction(&quot;Flamethrower&quot;);
  				action().actText = `Bonnibel assembles a flamethrower from components on her tool belt, and douses your puppets in flame.`;
  				V().action.act = massAttack(&#39;p&#39;,&quot;Burning&quot;,V().action.dur);
  			}
  			else if (this.inventory.get(&quot;Chaff Grenade&quot;) &gt; 0 &amp;&amp; act == 3) {
  				V().action = new ItemAction(&quot;Chaff Grenade&quot;);
  				V().action.weight = 1;
  				V().action.dur = 3;
  				V().action.actText = `Bonnibel lobs a grenade at you -- but to your surprise, when it explodes it leaves a massive cloud of shiny metal flakes. It just looks like silly confetti to you, but your puppets stutter and freeze up trying to see through all the flashing lights!`;
  				V().action.act = massAttack(&#39;p&#39;,&quot;Dizzy&quot;);
  			}
  		}
  	}
  }
},
&quot;actions&quot;: function () {
	while (V().action === null){
		var act = random(1,100);
		console.log(&quot;Bonnibel act = &quot;+act);
		var hasItem;
		var stasisCount = 0;
		var deadCount = 0;
		enemies().forEach(function(enemy) {
			if (enemy.stasis) {stasisCount++;}
			if (enemy.dead) {deadCount++;}
		});

	/*
	Rogue. Can use items freely, but has limited stock. Has 1 of each attack item + chaff grenade, puts rest of her points into drugs and Bottled Chi.

	if SPC buffed, 75% chance to use attack item
	normal:
	50%: support
	-first, check if anyone has &gt;= 2 buffs and &lt;= 1 ailment. If yes, they are added to a hitlist. If hitlist contains viable targets, 50% chance to use Stasis (target selection totally random). Otherwise...
	-target is random, but (1-hp/maxhp) chance to reroll if they are below half health (don&#39;t waste items on doomed people)
	-25%: bottled chi
	-50%: buff drug for focus stat (Gumball gets 25% for all)
	-12.5%: buff drug for other stat
	20%: attack item
	20%: off-balance one
	10%/default: gun or reload
	*/

	this.inventory.forEach(function(stock,item) {
		switch (item) {
			case &quot;Powdered Glass&quot;:
			case &quot;Grenade&quot;:
			case &quot;Calamity Bomb&quot;:
			case &quot;Flamethrower&quot;:
			case &quot;Gas Bomb&quot;:
			case &quot;Chaff Grenade&quot;:
				if (stock &gt; 0) {
					hasItem = true;
					break;
				}
		}
	});

	if (this.get($SpecialStat) &gt; this.getBase($SpecialStat) &amp;&amp; act &lt;= 85 &amp;&amp; hasItem === true) {
		this.attackItemLogic();
		this.inventory.inc(action().name,-1);
		return;
	}

		act = random(1,100);
		console.log(&quot;Special attack item check failed, new act = &quot;+act);

	if (stasisCount &lt; (V().enemies.length - deadCount) &amp;&amp; act &lt;= 50) {
		if (this.CDcheck(&quot;stasis&quot;)) {
			var buffCount;
			var ailmentCount;
			var hitlist = [];
			enemies().forEach(function(enemy) {
				buffCount = 0;
				ailmentCount = 0;
				if (!enemy.stasis &amp;&amp; !enemy.stunned){
					enemy.effects.forEach(function(effect) {
						if (effect.buff) {buffCount++;}
						if (!effect.buff) {ailmentCount++;}
					});
					if (buffCount &gt;= 2 &amp;&amp; ailmentCount &lt;= 1) {
						hitlist.push(enemy);
					}
				}
			});
			if (hitlist.length &gt; 0) {
				act = random(0,hitlist.length-1);
				V().target = hitlist[act];
				V().action = new Action(&quot;Thaumastasis&quot;);
				action().actText = `Bonnibel pulls a strange device out of her pocket, and points it at ${target().name}. There is an indescribable noise, and then the flow of magic around ${target().name} has frozen like amber.`;
				this.cd.set(&quot;stasis&quot;,5);
				return;
			}
		}
		hasItem = false;
		this.inventory.forEach(function(stock,item) {
			switch (item) {
				case &quot;Bottled Chi&quot;:
				case &quot;Adrenaline&quot;:
				case &quot;Stoneskin&quot;:
				case &quot;Nootropic&quot;:
					if (stock &gt; 0) {
						hasItem = true;
						break;
					}
			}
		});
		if (hasItem) {
			var keepGoing = true;
			var chance;
			while (keepGoing) {
				$.wiki(&#39;&lt;&lt;allytarget &quot;buff&quot;&gt;&gt;&#39;);
				if (deadCount == 3) { // There is no point in rerolling if the user is the only viable target
					keepGoing = false;
				}
				else if (target().name != &quot;Bonnibel&quot; &amp;&amp; target().hp &lt; (target().maxhp / 2)){ // Don&#39;t waste items on people who are about to die (but Bonnibel is a little selfish and excludes herself from this check)
					chance = random(1,100);
					if (chance &lt; ((target().hp / target().maxhp) * 100)) {
						keepGoing = false;
					}
				}
				else {
					keepGoing = false;
				}
			}
			while (V().action === null) { // The hasItem check SHOULD prevent an infinite loop from occurring here, but be careful
				act = random(1,8);
				if (act &lt;= 2 &amp;&amp; this.inventory.get(&quot;Bottled Chi&quot;) &gt; 0) {
					V().action = new ItemAction(&quot;Bottled Chi&quot;);
				}
				else if (target().name == &quot;Gumball&quot;) {
					act = random(1,3);
					switch (act) {
						case 1:
							if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0) {V().action = new ItemAction(&quot;Adrenaline&quot;)};
							break;
						case 2:
							if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0) {V().action = new ItemAction(&quot;Stoneskin&quot;)};
							break;
						case 3:
							if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0) {V().action = new ItemAction(&quot;Nootropic&quot;)};
							break;
					}
				}
				else {
					switch (target().name) {
						case &quot;Bonnibel&quot;:
							if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
								V().action = new ItemAction(&quot;Nootropic&quot;);
							}
							else if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act == 7) {
								V().action = new ItemAction(&quot;Stoneskin&quot;);
							}
							else if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act == 8) {
								V().action = new ItemAction(&quot;Adrenaline&quot;);
							}
							break;
						case &quot;Dipper&quot;:
							if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
								V().action = new ItemAction(&quot;Adrenaline&quot;);
							}
							else if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act == 7) {
								V().action = new ItemAction(&quot;Stoneskin&quot;);
							}
							else if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act == 8) {
								V().action = new ItemAction(&quot;Nootropic&quot;);
							}
							if (V().B.dipper_drug_event != &quot;done&quot; &amp;&amp; V().action !== null) {V().B.dipper_drug_event = &quot;active&quot;;}
							break;
						case &quot;Stevonnie&quot;:
							if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
								V().action = new ItemAction(&quot;Stoneskin&quot;);
							}
							else if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act == 7) {
								V().action = new ItemAction(&quot;Nootropic&quot;);
							}
							else if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act == 8) {
								V().action = new ItemAction(&quot;Adrenaline&quot;);
							}
							break;
					}
				}
			}
			this.inventory.inc(action().name,-1);
		}
	}
	else if (act &lt;= 80 &amp;&amp; act &gt; 50) {
		this.attackItemLogic();
		this.inventory.inc(action().name,-1);
	}
	else if (deadCount &lt; 3 &amp;&amp; act &lt;= 90 &amp;&amp; act &gt; 80) { // no point in using this if she is only one left
		$.wiki(&#39;&lt;&lt;randomTarget &quot;ignore downed&quot;&gt;&gt;&#39;);
		V().action = new Action(&quot;sonar&quot;);
		action().useText = null;
		action().actText = `Bonnibel pulls out a strange device and points it at ${target().name}. You hear a strange, high-pitched noise just on the edge of your hearing. It&#39;s easy enough for you to ignore, but ${target().name} can&#39;t seem to stand it -- they twitch and spasm, jerking backward and swaying.`;
		action().act = justeffect(&#39;t&#39;,&quot;Off-Balance&quot;,1);
	}
	else {
		if (this.ready){
			$.wiki(&#39;&lt;&lt;randomTarget &quot;pierce&quot;&gt;&gt;&#39;);
			V().action = new Action(&quot;shotgun&quot;);
			action().weight = 1;
			action().pierce = true;
			action().useText = null;
			action().actText = `Bonnibel blasts ${target().name} with her shotgun.`;
			action().act = justdmg;
			this.ready = false;
		}
		else {
			V().action = new Action(&quot;load&quot;);
			action().useText = null;
			action().actText = `Bonnibel loads a cartridge into her shotgun.`;
			action().act = null;
			this.ready = true;
		}
	}

	} /* end loop */
	return;
}
}}}
That&#39;s a lot, yeah? Let&#39;s break it down.
{{{
actor.inventory = new Map([
		[&quot;Bottled Chi&quot;,3],
		[&quot;Adrenaline&quot;,3],
		[&quot;Stoneskin&quot;,3],
		[&quot;Nootropic&quot;,3],
		[&quot;Powdered Glass&quot;,2],
		[&quot;Grenade&quot;,2],
		[&quot;Calamity Bomb&quot;,2],
		[&quot;Gas Bomb&quot;,1],
		[&quot;Flamethrower&quot;,1],
		[&quot;Chaff Grenade&quot;,1],
		[&quot;Panacea&quot;,3]
	]);
}}}
To begin with, I gave her an actual inventory with limited item stocks, just like the player&#39;s. I avoided doing this for Bubblegum&#39;s first fight, instead giving her an infinite stock of items but requiring her to spend two turns to use them, because I feared it would be too complicated. However, I realized that if I wanted to truly mirror the player&#39;s own abilities (as is the intended theme of the final fight), I&#39;d have to do it this way. It actually wasn&#39;t as difficult to implement as I feared; but we will get into that shortly.

We will revist {{{attackItemLogic}}} later. Let&#39;s look at the main {{{actions}}} function first.
{{{
var hasItem;
var stasisCount = 0;
var deadCount = 0;
enemies().forEach(function(enemy) {
	if (enemy.stasis) {stasisCount++;}
	if (enemy.dead) {deadCount++;}
});
}}}
The first thing you should notice is that we define additional variables here, not just the normal {{{act}}} randomizer. Because Bonnibel has a limited inventory stock, we need a variable that tells us whether or not she has the item she plans to use; and because she uses buff abilities, she needs to know if her allies have Stasis or are defeated -- if everyone is, there&#39;s no point in even considering using a buff.
{{{
this.inventory.forEach(function(stock,item) {
	switch (item) {
		case &quot;Powdered Glass&quot;:
		case &quot;Grenade&quot;:
		case &quot;Calamity Bomb&quot;:
		case &quot;Flamethrower&quot;:
		case &quot;Gas Bomb&quot;:
		case &quot;Chaff Grenade&quot;:
			if (stock &gt; 0) {
				hasItem = true;
				break;
			}
	}
});

if (this.get($SpecialStat) &gt; this.getBase($SpecialStat) &amp;&amp; act &lt;= 85 &amp;&amp; hasItem === true) {
	this.attackItemLogic();
	this.inventory.inc(action().name,-1);
	return;
}
}}}
Then we get into the actual action selection logic. However, our first check is a special circumstance that occurs outside the normal action tree.

Bonnibel&#39;s attack items are extremely valuable, so it makes sense that she should favor their use when she can get the most out of them; which is to say, when her Special stat is boosted. We can model this by giving her a higher chance of using an attack item than she would normally when {{{this.get($SpecialStat) &gt; this.getBase($SpecialStat)}}}. However, this is hard to model within the same tree as other actions without interfering with the probabilities of those other actions. For instance, let&#39;s say a character takes one action at {{{act}}} values 0-30 and another at {{{act}}} values 31-50. Under a special circumstance, you want the character to take the first action 50% of the time instead. You could model this by telling them to perform the action {{{if (act &lt;= 30 || (circumstance === true &amp;&amp; act &lt;= 50)}}}... but if you do not change the {{{act}}} range for the second action as well, now the character will &lt;i&gt;never&lt;/i&gt; take that action if {{{circumstance}}} is {{{true}}}! All possible values for {{{act}}} that could trigger it will now trigger the first action instead, and so the second action will be ignored. In some cases, this may be what you want; but for most cases, it is easier to segregate these special actions away from the main {{{if}}} tree.

Additionally, because Bonnibel has a limited inventory, we need to check if she has any items that match with this action at all; otherwise, running through this logic will be at best a waste of time, and at worst a glitch that will allow her to keep using items after she&#39;s exhausted them. We check this with a simple {{{forEach}}} loop run over her {{{inventory}}} attribute; if any of her attack items have a {{{stock}}} value greater than 0, she can use an attack item, and so we set {{{hasItem}}} to {{{true}}}.

We&#39;ve outsourced the actual details of this action to {{{attackItemLogic}}}, because the exact same logic will be used later in the tree. We will discuss it then.
{{{
act = random(1,100);
}}}
Finally, to avoid the crowding-out problem I just discussed, we have to reroll the {{{act}}} variable before entering the main tree; otherwise, no actions with {{{act}}} thresholds less than 85 would be possible!
{{{
if (stasisCount &lt; (V().enemies.length - deadCount) &amp;&amp; act &lt;= 50)
}}}
We then enter Bonnibel&#39;s main action tree. Because I wanted Bonnibel to be more support-oriented, her support moves come first, and have a high probability of being used. However, because they&#39;re all buffs, it&#39;s worth checking if this branch is worth attempting at all. Remember, Stasis prevents the application of new effects, good or bad, so if every surviving character is in Stasis, buffs are useless. That&#39;s what we check with {{{stasisCount &lt; (V().enemies.length - deadCount)}}}, using the variables we initialized at the beginning of the loop: this branch will only activate if the number of enemy characters with Stasis is less than the number of enemy characters remaining; i.e., if there are any viable targets for Bonnibel&#39;s buffs.

This branch actually has two sub-branches. Bonnibel can use one of her buff items, or she can use Witch&#39;s &quot;Thaumastasis&quot; ability to give someone Stasis. The latter is simpler, so that comes first:
{{{
if (this.CDcheck(&quot;stasis&quot;)) {
	var buffCount;
	var ailmentCount;
	var hitlist = [];
	enemies().forEach(function(enemy) {
		buffCount = 0;
		ailmentCount = 0;
		if (!enemy.stasis &amp;&amp; !enemy.stunned){
			enemy.effects.forEach(function(effect) {
				if (effect.buff) {buffCount++;}
				if (!effect.buff) {ailmentCount++;}
			});
			if (buffCount &gt;= 2 &amp;&amp; ailmentCount &lt;= 1) {
				hitlist.push(enemy);
			}
		}
	});
	if (hitlist.length &gt; 0) {
		act = random(0,hitlist.length-1);
		V().target = hitlist[act];
		V().action = new Action(&quot;Thaumastasis&quot;);
		action().actText = `Bonnibel pulls a strange device out of her pocket, and points it at ${target().name}. There is an indescribable noise, and then the flow of magic around ${target().name} has frozen like amber.`;
		this.cd.set(&quot;stasis&quot;,5);
		return;
	}
}
}}}
Stasis is a risky buff to use, because it has potentially severe downsides: it prevents you from adding any other buffs for a long time, and any ailments the character has will be extended for the duration. For that reason, Bonnibel shouldn&#39;t just use it on anyone: we want her to check to make sure their number of buffs and ailments are within acceptable parameters. We can do this by running a {{{forEach}}} loop over the enemy party and tracking each character&#39;s number of buffs and ailments with {{{buffCount}}} and {{{ailmentCount}}}, respectively. If and only if the character has 2 or more buffs &lt;i&gt;and&lt;/i&gt; 1 or fewer ailments, they become a viable target for Stasis and we add them to {{{hitlist}}}. (The character is not considered at all if they are Stunned, because that&#39;s too debilitating of an ailment to lock in Stasis no matter what.)

The likelihood of these things aligning is so rare that I did not include any other checks against Thaumastasis, such as an {{{act}}} randomizer -- if Bonnibel can use it, she will always use it.

If Bonnibel does not use Thaumastasis, she will move on to using one of her buff items.
{{{
hasItem = false;
this.inventory.forEach(function(stock,item) {
	switch (item) {
		case &quot;Bottled Chi&quot;:
		case &quot;Adrenaline&quot;:
		case &quot;Stoneskin&quot;:
		case &quot;Nootropic&quot;:
			if (stock &gt; 0) {
				hasItem = true;
				break;
			}
	}
});
}}}
First, as with the attack items, we have to check to make sure she has any items to use in the first place. Since it&#39;s possible {{{hasItem}}} was flipped to {{{true}}} when checking for attack items, we have to reset it to {{{false}}} to avoid a false positive here. Otherwise, the check works exactly the same, with buff item names in place of attack item names.

Then things get complicated.
{{{
if (hasItem) {
	var keepGoing = true;
	var chance;
	while (keepGoing) {
		$.wiki(&#39;&lt;&lt;allytarget &quot;buff&quot;&gt;&gt;&#39;);
		if (deadCount == 3) { // There is no point in rerolling if the user is the only viable target
			keepGoing = false;
		}
		else if (target().name != &quot;Bonnibel&quot; &amp;&amp; target().hp &lt; (target().maxhp / 2)){ // Don&#39;t waste items on people who are about to die (but Bonnibel is a little selfish and excludes herself from this check)
			chance = random(1,100);
			if (chance &lt; ((target().hp / target().maxhp) * 100)) {
				keepGoing = false;
			}
		}
		else {
			keepGoing = false;
		}
	}
}}}
Before anything else, Bonnibel has to pick a target. We already have a widget for this scenario, {{{&lt;&lt;allytarget&gt;&gt;}}}... but Bonnibel&#39;s targeting is a little more complicated. Because her items are limited in stock, she shouldn&#39;t throw them around willy-nilly: if someone looks likely to die before they can use the buff, she&#39;s not going to waste it on them. Cold, but efficient! The way I modeled this logic is thus: select a target as normal with {{{&lt;&lt;allytarget&gt;&gt;}}}, and then check if that target is below half HP. If they are, roll a random percentile value, and if it&#39;s greater than the percentage of HP they have remaining, roll for a new target. This effectively means that characters have a chance of being selected equal to the proportion of HP they have remaining; someone with 40% HP left still has a decent chance of getting a buff, but someone at 10% HP is almost certainly going to get passed over. This is accomplished through a {{{while}}} loop tied to the aptly-named Boolean {{{keepGoing}}}; Bonnibel will keep selecting new targets until we set {{{keepGoing}}} to {{{false}}}, which occurs if she is the only viable target, if the target is above half health, or the target is below half health but passes its luck test.
{{{
while (V().action === null) { // The hasItem check SHOULD prevent an infinite loop from occurring here, but be careful
	act = random(1,8);
	if (act &lt;= 2 &amp;&amp; this.inventory.get(&quot;Bottled Chi&quot;) &gt; 0) {
		V().action = new ItemAction(&quot;Bottled Chi&quot;);
	}
	else if (target().name == &quot;Gumball&quot;) {
		act = random(1,3);
		switch (act) {
			case 1:
				if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0) {V().action = new ItemAction(&quot;Adrenaline&quot;)};
				break;
			case 2:
				if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0) {V().action = new ItemAction(&quot;Stoneskin&quot;)};
				break;
			case 3:
				if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0) {V().action = new ItemAction(&quot;Nootropic&quot;)};
				break;
		}
	}
	else {
		switch (target().name) {
			case &quot;Bonnibel&quot;:
				if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
					V().action = new ItemAction(&quot;Nootropic&quot;);
				}
				else if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act == 7) {
					V().action = new ItemAction(&quot;Stoneskin&quot;);
				}
				else if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act == 8) {
					V().action = new ItemAction(&quot;Adrenaline&quot;);
				}
				break;
			case &quot;Dipper&quot;:
				if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
					V().action = new ItemAction(&quot;Adrenaline&quot;);
				}
				else if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act == 7) {
					V().action = new ItemAction(&quot;Stoneskin&quot;);
				}
				else if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act == 8) {
					V().action = new ItemAction(&quot;Nootropic&quot;);
				}
				if (V().B.dipper_drug_event != &quot;done&quot; &amp;&amp; V().action !== null) {V().B.dipper_drug_event = &quot;active&quot;;}
				break;
			case &quot;Stevonnie&quot;:
				if (this.inventory.get(&quot;Stoneskin&quot;) &gt; 0 &amp;&amp; act &lt;= 6 &amp;&amp; act &gt; 2) {
					V().action = new ItemAction(&quot;Stoneskin&quot;);
				}
				else if (this.inventory.get(&quot;Nootropic&quot;) &gt; 0 &amp;&amp; act == 7) {
					V().action = new ItemAction(&quot;Nootropic&quot;);
				}
				else if (this.inventory.get(&quot;Adrenaline&quot;) &gt; 0 &amp;&amp; act == 8) {
					V().action = new ItemAction(&quot;Adrenaline&quot;);
				}
				break;
		}
	}
}
}}}
Then it&#39;s time to pick which item Bonnibel uses. This is accomplished through a minature version of the greater action loop: Bonnibel will keep looping until she&#39;s selected an action. Note that this is why I was careful to exclude this branch entirely if she had no items to choose from; because this loop requires her to pick an item, if I didn&#39;t make that check, this could result in an infinite loop! We check to make sure she hasn&#39;t exhausted her stock with {{{this.inventory.get(&lt;item name&gt;) &gt; 0}}} before each selection.

Bonnibel has four items to pick from: Bottled Chi, Adrenaline, Stoneskin, and Nootropics. However, I added a twist to make her seem a little more tactical: she&#39;ll play to characters&#39; existing strengths. She has a higher chance to use Nootropics on herself, the item-user; a higher chance to use Adrenaline on Dipper, the damager; and a higher chance to use Stoneskin on Stevonnie, the tank. (Gumball, the jack-of-all-trades, has an even chance of getting any item.) Because of the fixed options here, I rolled the {{{act}}} randomizer from 1 to 8 instead of the normal percentile value. Bottled Chi gets a 1/4 chance, the &quot;strong&quot; buff a 1/2 chance, and the &quot;weak&quot; buffs get 1/8 each.

(As you can see in the inventory definition, I planned to give her status cure items as well. However, I decided designing logic for that was too much work and gave a general status cure ability to Dipper instead.)
{{{
this.inventory.inc(action().name,-1);
}}}
After the loop (meaning that an item was successfully selected), we decrement that item in the inventory so it&#39;s actually used up.
{{{
else if (act &lt;= 80 &amp;&amp; act &gt; 50) {
	this.attackItemLogic();
	this.inventory.inc(action().name,-1);
}
}}}
Next is the normal branch for using an attack item. Normally, Bonnibel has only a 30% chance of using one, as opposed to an 85% chance when her Special stat is boosted. Because the same action occurs in two different places, I outsourced its logic to a function.
{{{
this.attackItemLogic = function () {
	while (V().action === null) { // hasItem check should prevent infinite loop but BE CAREFUL
		var act = random(1,100);
		var noPowderedGlass = false;
		var noCalamityBomb = false;
		var count = 0;

		if (act &lt;= 40) { // use single-target item
			console.log(&quot;Bonnibel single-target attack item branch&quot;);
			chiCheck([&quot;alert&quot;,&quot;dead&quot;]);
			console.log(&quot;Chi check performed, count = &quot;+count);
			if (count == V().puppets.length) {
				noPowderedGlass = true; // if all puppets are alert or dead, there are no viable targets for Powdered Glass
			}
			chiCheck([&quot;dead&quot;]);
			if (count == V().puppets.length) {
				noCalamityBomb = true; // if all puppets are protected or dead, there are no viable targets for Calamity Bomb
			}
			if (noPowderedGlass &amp;&amp; noCalamityBomb) {
				act = 2;
			} else if (noPowderedGlass) {
				act = random(2,3);
			} else if (noCalamityBomb) {
				act = random(1,2);
			} else {
				act = random(1,3);
			}
			if (this.inventory.get(&quot;Powdered Glass&quot;) &gt; 0 &amp;&amp; act == 1) {
				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot;&gt;&gt;&#39;);
				if (!target().alert &amp;&amp; !target().chi &amp;&amp; !target().stasis) {
					V().action = new ItemAction(&quot;Powdered Glass&quot;);
					action().actText = `Bonnibel pours what appears to be bright pink sugar onto her palm. She blows it into ${target().name}&#39;s face, and they recoil and claw at their face as if they were shards of glass.`;
				}
			}
			else if (this.inventory.get(&quot;Grenade&quot;) &gt; 0 &amp;&amp; act == 2) {
				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot;&gt;&gt;&#39;);
				V().action = new ItemAction(&quot;Grenade&quot;);
				action().act = splashDamage(&#39;p&#39;);
			}
			else if (this.inventory.get(&quot;Calamity Bomb&quot;) &gt; 0 &amp;&amp; act == 3) {
				$.wiki(&#39;&lt;&lt;randomTarget &quot;smart&quot; &quot;debuff&quot;&gt;&gt;&#39;);
				V().action = new ItemAction(&quot;Calamity Bomb&quot;);
			}
		}
		else { // use multi-target item
			act = random(1,3);
			if (this.inventory.get(&quot;Gas Bomb&quot;) &gt; 0 &amp;&amp; act == 1) {
				V().action = new ItemAction(&quot;Gas Bomb&quot;);
				V().action.act = massAttack(&#39;p&#39;,&quot;Poisoned&quot;,V().action.dur);
			}
			else if (this.inventory.get(&quot;Flamethrower&quot;) &gt; 0 &amp;&amp; act == 2) {
				V().action = new ItemAction(&quot;Flamethrower&quot;);
				action().actText = `Bonnibel assembles a flamethrower from components on her tool belt, and douses your puppets in flame.`;
				V().action.act = massAttack(&#39;p&#39;,&quot;Burning&quot;,V().action.dur);
			}
			else if (this.inventory.get(&quot;Chaff Grenade&quot;) &gt; 0 &amp;&amp; act == 3) {
				V().action = new ItemAction(&quot;Chaff Grenade&quot;);
				V().action.weight = 1;
				V().action.dur = 3;
				V().action.actText = `Bonnibel lobs a grenade at you -- but to your surprise, when it explodes it leaves a massive cloud of shiny metal flakes. It just looks like silly confetti to you, but your puppets stutter and freeze up trying to see through all the flashing lights!`;
				V().action.act = massAttack(&#39;p&#39;,&quot;Dizzy&quot;);
			}
		}
	}
}
}}}
This logic is similar to the support item logic. It&#39;s segregated into single-target items (Powdered Glass, Calamity Bombs, and Grenades) and items that don&#39;t require a target (Gas Bombs, Flamethrowers, and Chaff Grenades). There&#39;s some additional checks for Powdered Glass and Calamity Bombs using the {{{chiCheck}}} function; if all possible targets are Alert, there&#39;s no point in even considering the former, and likewise, there&#39;s no point in considering the latter if all possible targets have Chi Shield or Stasis. If either of those cases turn out to be true, they&#39;re removed as a possibility for selection.

Bonnibel&#39;s other abilities are normal and should be straightforward to follow.

Your takeaway from this example should be that &lt;b&gt;supportive AI is hard!&lt;/b&gt; Just dealing damage is simple, but knowing when and how to strategically apply a buff is quite complicated -- even something as simple as personalizing buffs to certain characters required a huge {{{switch}}} statement. It&#39;s worthwhile to step back and analyze your own decisions when playing RPGs -- what goes through your mind when you decide who to pick for a buff or heal? What variables influce your decision? Can you think of how to translate your reasoning into code? It can be quite hard to account for every possibility!

These examples should hopefully show you how to implement enemy behavior yourself. AI design is unfortunately not my forte, so many of these examples are relatively simplistic. If you ask around RPG design communities, they may be able to help you with more complex designs.

&lt;h2 id=&quot;encounters&quot;&gt;Creating Encounters&lt;/h2&gt;
Once you&#39;ve created your enemies, you still have to bundle them into an &lt;i&gt;encounter&lt;/i&gt;. An encounter is a specific battle containing a party of enemies. Each one may correspond to, for example, a particular room of a dungeon, or to one of several possible random encounters.

Encounters are defined in the {{{database-encounters.tw}}} file in the {{{passages-custom}}} folder. In this file, you&#39;ll see a widget called {{{&lt;&lt;callEncounter&gt;&gt;}}} that contains a {{{&lt;&lt;switch&gt;&gt;}}} statement keyed to the variable {{{$scenario}}}. Create a case statement for your scenario id and define your {{{$enemies}}} party variable within it. You can also add other variables, such as making the encounter an ambush or defining an aesthetic style. (Any string you assign to the {{{$B.style}}} property will be added to the passage body as a class for the duration of the battle.)

There is another widget defined here, {{{&lt;&lt;populateEnemies&gt;&gt;}}}, to make your work a little easier. Instead of having to write {{{new Enemy}}} for every single enemy, just pass their names to {{{&lt;&lt;populateEnemies&gt;&gt;}}} and it&#39;ll automate that for you. Note that you will have to wrap the argument in backticks {{{`}}} for it to be read correctly.

To start an encounter in-game, you can set the {{{$scenario}}} manually and make a direct link to the &quot;Preparation&quot; passage, or you can use the {{{&lt;&lt;fight&gt;&gt;}}} widget.
{{{
&lt;&lt;widget &quot;fight&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0&gt;&gt;
	&lt;&lt;if typeof($args[1]) == &quot;string&quot;&gt;&gt;
		&lt;&lt;set _text = $args[1]&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _text = &quot;BATTLE&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;center&gt;&lt;&lt;button _text &quot;Preparation&quot;&gt;&gt;&lt;&lt;set $scenario = $args[0]&gt;&gt;&lt;&lt;/button&gt;&gt;&lt;/center&gt;
&lt;&lt;else&gt;&gt;
	&lt;b&gt;ERROR in fight: no arguments&lt;/b&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget provides a quick and standardized format for battle links. Pass the name of the encounter you want to call as the first argument, and custom text for the battle button as the second. By default, the button text will default to &quot;BATTLE&quot;. The widget will create a centered button that forwards the player to the battle, all with just one widget call.

&lt;h2 id=&quot;customization&quot;&gt;Customization&lt;/h2&gt;
Another RPG Engine is designed to be modular and to allow the user to customize features to suit their needs. This is handled through the passages stored in the {{{passages-custom}}} folder, which are slotted into core passages when needed.

&lt;h3 id=&quot;custom.init&quot;&gt;Initial Variables&lt;/h3&gt;
&lt;code&gt;StoryInit&lt;/code&gt; is a special passage that is run when the game starts. It is used to define many variables that determine several aspects of the engine, such as the color of health bars, the constants used in damage formulas, and the elements used for magic spells. These variables are set to certain defaults, but you can overwrite them with new specifications by editing {{{user storyinit.tw}}}.

Most variables are explained in the comments of the &lt;code&gt;StoryInit&lt;/code&gt; file, but this section will go into detail on some of the more complex ones:
* {{{formula}}} determines the default damage formula used for attacks. A few options are provided by default. See [[Design]] for more information.
* {{{statInfo}}} provides a tooltip description of every stat when the player hovers over its name in the party menu. This is helpful for communicating to your player what each stat does, especially if you use particularly complex or esoteric stats.
** {{{statInfo}}} is also considered a database of every stat used in the game, so make sure it matches the stats you define for characters.
* {{{hiddenStats}}} is an array of stat names that will be hidden in places where stats are normally displayed, such as the party menu.
* {{{ELEMENT_LIST}}} is an array of names corresponding to all the elemental properties that will be used in your game.
** {{{elementMessages}}} is an object containing messages that will be added to damage reports to show that an attack has hit an elemental weakness or resistance.
* {{{MENU_OPTIONS}}} is an array of strings corresponding to what options the player can select in the party menu. For the options available in the default engine, see the &quot;party menu&quot; twee files. Additional options you will have to create yourself.
* {{{STATUS_SCREENS}}} is an object of arrays of strings corresponding to what options the player can select in status panes. There are separate lists for the status menu, the in-battle status pane, and the bestiary. Additional options you will have to create yourself.
* {{{DEFAULT_EQUIP_SLOTS}}} is an object that will be read to generate default equipment slots if no {{{equipSlots}}} object is provided in the character database entry. Keys correspond to equipment slots, values correspond to the number of subslots.
* {{{THREAT_TARGETING}}} and {{{BATTLE_GRID}}} are Booleans that allow you to activate alternate gameplay styles. See [[Documentation (Advanced)]] for details on threat targeting and [[Additional Features]] for details on the battle grid.
* The various animation variables determine the length of the battle popup animations, in milliseconds.

This is also where you should define the player&#39;s starting party with the {{{$puppets}}} variable, and their starting inventory with the {{{$inventory}}} variable.

&lt;h3 id=&quot;custom.passages&quot;&gt;Customizing Passages&lt;/h3&gt;
The passages in {{{passages-custom}}} are slotted into certain core passages through the {{{&lt;&lt;include&gt;&gt;}}} macro. By modifying these custom passages, you can customize various features without needing to alter the core passages.
* {{{battle display mods actorlist}}} lets you conditionally add classes to the enemy or puppet displays in the battle layout, such as reversing the display order for certain encounters.
* {{{battle interruptions}}} will appear during the action phase, after the action&#39;s {{{useText}}} but before its {{{actText}}}. You can make them appear conditionally based on encounter scenario or other variables. The interruptions for the Steven Universe encounter are provided as an example.
* {{{custom battle preparation}}} is run at the end of the setup code before every battle. By default, it only adds the {{{&lt;&lt;restock&gt;&gt;}}} widget, which refreshes any items used during the battle.
* {{{custom end of action effects}}} is run on every action, after followup attacks and potential surrender failure. Use it for any special action adjustments you want to make. By default, this only includes the EN refund for the &quot;Focus&quot; ability.
* {{{custom end of battle}}} is run at the end of the {{{&lt;&lt;endofbattle&gt;&gt;}}} widget. By default, it only adds the {{{&lt;&lt;restock&gt;&gt;}}} widget, which refreshes any items used during the battle.
* {{{custom newturn}}} is run at the end of the {{{&lt;&lt;newTurn&gt;&gt;}}} widget. By default, it regenerates puppet EN.
* {{{damagecalc custom factors}}} is run at the end of {{{&lt;&lt;damageCalc&gt;&gt;}}}, the widget that runs damage calculation. Use it for any miscellaneous modifiers you want to apply to damage, such as the multipliers from Fighter&#39;s &quot;Defender&quot; and &quot;Berserker&quot; effects.
* The various {{{formula}}} passages let you customize the formulas for various calculations, such as accuracy, critical rate, and damage.
* {{{loss of control effects}}} handles the logic for loss-of-control effects, and is run at the start of every player turn. The default passage includes logic for the &quot;Hatred&quot;, &quot;Confusion&quot;, and &quot;Charmed&quot; effects, but you can add additional branches for your own effects.
* {{{special battle lines}}} is displayed in-between the enemy and player parties in the battle screen. This is useful for displaying relevant in-battle messages, such as the progress for Mage&#39;s sunrise spell in the Marceline battle.
* {{{special checks}}} is run at the start of the player turn, and is used to forward the player to special scenes, such as Dipper and Mabel&#39;s transformations, or to make other adjustments. By default, it includes the handler for loss-of-control effects.
* {{{user storyinit}}} is appended to {{{StoryInit}}}, as previously discussed.

Additionally, if you create a passage file with the same name as an existing passage, it will be overwritten when your game is compiled. This allows you to overwrite the default widgets and passages completely with your own versions if you need to radically change things -- but make sure you know what you&#39;re doing!</tw-passagedata><tw-passagedata pid="184" name="Documentation (Advanced)" tags="text info" position="475,2350" size="100,100">Use the table of contents to navigate. You can come back to the top at any time by pressing the &quot;home&quot; key on your keyboard.

This documentation will assume you are familiar with the explanations detailed in [[Documentation (Basic)]]. This advanced documentation will go into detail on the code of every passage.

In addition to the code in the engine itself, the engine uses &lt;a href=&quot;https://twinelab.net/custom-macros-for-sugarcube-2/&quot; target=&quot;_blank&quot;&gt;Chapel&#39;s custom macros&lt;/a&gt;. Click the link to learn more.

The opening sections will be quite technical, and deal with external script. If you&#39;d like to skip to how the Twine passages operate, you can head to &lt;a class=&quot;noExternal&quot; href=&quot;#setup&quot;&gt;Setting up the battle&lt;/a&gt;.

&lt;h1&gt;Table of Contents&lt;/h1&gt;
&gt;&lt;a href=&quot;#JS&quot;&gt;JavaScript vs. Twine&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.config&quot;&gt;Config&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.databases&quot;&gt;Objects, Classes, and Databases&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.actor&quot;&gt;Actor Class&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.constructor&quot;&gt;Constructor&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.getters&quot;&gt;Getters and Setters&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.effectFunctions&quot;&gt;Effect Functions&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.equipFunctions&quot;&gt;Equipment Functions&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.toleranceFunctions&quot;&gt;Tolerance Functions&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.actor.misc&quot;&gt;Miscellaneous Functions&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.stats&quot;&gt;Stat Class&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.stats.fill&quot;&gt;The FillStat Class&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#JS.tolerances&quot;&gt;Tolerance Class&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.puppets&quot;&gt;Puppet Class&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.enemies&quot;&gt;Enemy Class&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.actions&quot;&gt;Action Class&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.items&quot;&gt;Inventory and Items&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.support&quot;&gt;Support Functions&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.serial&quot;&gt;Serialization and Save Files&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#JS.updates&quot;&gt;What if we want to update something in a new version?&lt;/a&gt;
&gt;&lt;a href=&quot;#display&quot;&gt;Display and aesthetics&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#statusdisplay&quot;&gt;Displaying the status pane&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#nobr&quot;&gt;The nobr tag&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#pronouns&quot;&gt;Personalized text&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#healthbars&quot;&gt;Health Bar Formatting&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#battlestyle&quot;&gt;Special Aesthetics for Battles&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#savesmodifier&quot;&gt;Modifying the Save Display&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#animationsDoc&quot;&gt;Animations&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#animations.design&quot;&gt;Designing the Animations&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#animations.setup&quot;&gt;Setup&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#animations.execution&quot;&gt;Execution&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#animations.disabling&quot;&gt;Disabling the Continue Button&lt;/a&gt;
&gt;&lt;a href=&quot;#setup&quot;&gt;Setting up the battle&lt;/a&gt;
&gt;&lt;a href=&quot;#skeleton&quot;&gt;How the battle passages work&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#auto-end&quot;&gt;Auto-endturn&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actorlistDoc&quot;&gt;Actor List&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#actorBoxDoc&quot;&gt;Actor Box&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#commands&quot;&gt;Commands&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targetingphase&quot;&gt;Targeting Phase&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#confirmphase&quot;&gt;Confirm Phase&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#spellphase&quot;&gt;Spell Phase&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actionphase&quot;&gt;Action Phase&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actionqueue&quot;&gt;The Action Queue&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#endOfRound&quot;&gt;End of Round&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#enemyphase&quot;&gt;Enemy Phase&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#enemyphase.multiActions&quot;&gt;Enemies with Multiple Actions&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#advanceturn&quot;&gt;Advancing Turns&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#victorydefeat&quot;&gt;Victory and Defeat&lt;/a&gt;
&gt;&lt;a href=&quot;#actions&quot;&gt;Action Mechanics&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actions1&quot;&gt;Special Cases&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actions2&quot;&gt;The Functional Link&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#actions3&quot;&gt;Info Display&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#crossbow&quot;&gt;How does Rogue&#39;s crossbow work?&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#items&quot;&gt;Items&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#delayed&quot;&gt;Delayed Attacks&lt;/a&gt;
&gt;&lt;a href=&quot;#damage&quot;&gt;Calculating and applying damage&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#damage.1&quot;&gt;Calculating damage&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#damage.2&quot;&gt;Applying damage&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmgreflection&quot;&gt;Damage Reflection&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmg.onhit&quot;&gt;onHit&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmg.shock&quot;&gt;Shock cures&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#dmg.counters&quot;&gt;Setting up counterattacks&lt;/a&gt;
&gt;&lt;a href=&quot;#effects&quot;&gt;Status Effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects1&quot;&gt;Applying effects&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#effects1.1&quot;&gt;Accounting for protective effects&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#effects1.2&quot;&gt;Numerical components&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#effects1.3&quot;&gt;Exclusivity&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.calc.dot&quot;&gt;Damage-over-time effects&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#effects.loss&quot;&gt;Loss-of-control Effects&lt;/a&gt;
&gt;&lt;a href=&quot;#targeting&quot;&gt;Targeting and Enemy AI&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#hitlist-class&quot;&gt;Making a Hitlist&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targeting.basic&quot;&gt;Standard Targeting&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#targeting.basic.1&quot;&gt;Martyr check&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#targeting.basic.3&quot;&gt;Mercy&lt;/a&gt;
&gt;&gt;&gt;&lt;a href=&quot;#targeting.basic.4&quot;&gt;Smart targeting&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targeting.threat&quot;&gt;Threat-based/Aggro Targeting&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#dispel&quot;&gt;Dispel Targeting&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#targeting.ally&quot;&gt;Ally Targeting&lt;/a&gt;
&gt;&lt;a href=&quot;#menus&quot;&gt;Menu Functionality&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#menus.status&quot;&gt;Status&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#menus.inventory&quot;&gt;Inventory&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#partypicker&quot;&gt;Party Picker&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#equipmanager&quot;&gt;Equipment Manager&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#itemshop&quot;&gt;Item Shop&lt;/a&gt;
&gt;&lt;a href=&quot;#hotkeys&quot;&gt;Hotkeys&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#hotkeys.summary&quot;&gt;Summary&lt;/a&gt;
&gt;&lt;a href=&quot;#widgets&quot;&gt;Other Widgets&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#chain&quot;&gt;The {{{&lt;&lt;chain&gt;&gt;}}} widget&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#refreshPuppets&quot;&gt;{{{&lt;&lt;refreshPuppets&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#deathcheck&quot;&gt;{{{&lt;&lt;deathcheck&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#statusDoc&quot;&gt;{{{&lt;&lt;status&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#endofbattle&quot;&gt;{{{&lt;&lt;endofbattle&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#backbtn&quot;&gt;{{{&lt;&lt;backbtn&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#victorycheck&quot;&gt;{{{&lt;&lt;victorycheck&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#stat&quot;&gt;{{{&lt;&lt;stat&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#itemdrop&quot;&gt;{{{&lt;&lt;itemDrop&gt;&gt;}}}&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#musicwidgets&quot;&gt;Music widgets&lt;/a&gt;
&gt;&gt;&lt;a href=&quot;#find&quot;&gt;{{{&lt;&lt;find&gt;&gt;}}}&lt;/a&gt;

&lt;h2 id=&quot;JS&quot;&gt;JavaScript vs. Twine&lt;/h2&gt;
To begin, it&#39;s important you understand how to operate JavaScript in Twine.

The code you see in Twine passages, such as {{{&lt;&lt;if condition&gt;&gt;&lt;&lt;set $variable to value&gt;&gt;}}}, is a modified form of JavaScript designed to be easier to use with stories. However, it has some limitations. For a project as complex as an RPG engine, I chose to include pure JavaScript as well.

Fortunately, Twine is compatible with external JavaScript files. Normally, this is accessed through a special passage that can be accessed by clicking the story&#39;s title at the bottom of the screen; however, because Twine only allows one JavaScript passage, for ease of use, I separated it into multiple independent JavaScript files which can be found in {{{src/javascript}}}. For this engine, the JavaScript is mostly used for storing information for data structures used in the game, such as characters, items, and actions. You can edit these files by opening them in a text editor such as Notepad++, and add them to the story by compiling them with Tweego. (Editing through Twine is unfortunately difficult, due to a lack of a search feature.)

JavaScript is very similar to SugarCube Twine code, but has a separate store of variables from the ones defined in Twine. To access a story variable in JavaScript, you must put {{{variables().}}} in place of where you would put the {{{$}}} symbol in Twine. To access a temporary variable, you must put {{{temporary().}}} in place of the {{{_}}} symbol.

&lt;h3 id=&quot;JS.config&quot;&gt;Config&lt;/h3&gt;
The first JavaScript file is &quot;0_config&quot;. The 0 is added to ensure it comes first in the directory, as files are compiled in alphabetical order.

This file stores configuration settings for Twine, such as how saves are formatted and what path to use for media files. Additionally, the {{{variables()}}} function used to access story variables is assigned to the shorter name {{{V()}}}, for convenience. Note that this is case sensitive.

You can add additional configuration settings as needed for your story. See the SugarCube documentation for details.

&lt;h3 id=&quot;JS.databases&quot;&gt;Classes and Databases, advanced&lt;/h3&gt;
In [[Documentation (Basic)]], you learned how to create your own entries for the engine&#39;s databases. Here, you will learn how those entries are read and constructed into live objects.

You also learned that objects are collections of sub-variables called &lt;b&gt;properties&lt;/b&gt; that you can access with the dot operator. Typically, there are variables stored inside each property; however, that is not strictly necessary.

RPGs use a lot of terms and structures that have associated data, such as characters, abilities, and items. In many cases, the data associated with these structures doesn&#39;t change. For instance, Fighter&#39;s &quot;Sword&quot; ability always has a cost of 2, a weight of 1, always does damage for its action, and always has the same info and description data. None of that will change over the course of the game.

We therefore don&#39;t need to encode all of that data into a &quot;Sword&quot; object. In fact, it would be very good if we didn&#39;t have to, because Twine has to copy every single object and variable every time it makes a passage transition! With lots of bulky objects, that can really slow down performance. Instead, since the data doesn&#39;t change, we can define it in a separate database object, and look it up through functions tied to object classes.

Here is an example from the &lt;code&gt;Action&lt;/code&gt; class:
{{{
get actionData () {
	return (setup.actionData[this.name] || setup.actionData[this.displayname] || {});
}
}}}
This is known as a &lt;b&gt;getter function&lt;/b&gt;. When you define a function through the keyword &lt;code&gt;get&lt;/code&gt;, that function can be called just like an attribute of the object -- no function call required! This means it can&#39;t take any arguments, but that&#39;s okay. We only need simple functions for this.

With this function, if we define an object in &lt;code&gt;setup.actionData&lt;/code&gt; with the action&#39;s name as a property, this will return whatever data is associated with that action. (Note the parentheses and &lt;code&gt;||&lt;/code&gt; operator; if you are not familiar with how that feature works, read about it &lt;a href=&quot;https://stackoverflow.com/questions/2802055/what-does-the-construct-x-x-y-mean&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;. tl;dr If the result of the code is falsy, it will skip it and attempt to return the next entry. This is useful for defining default values in the case that something is undefined.)

We can then define a getter for every property we need by extracting it from &lt;code&gt;actionData&lt;/code&gt;:
{{{
get cost () {
	var val = this._cost;
	if (val === undefined) {
		val = this.actionData.cost;
	}
	if (val === undefined) {
		val = 0;
	}
	return (val instanceof Function) ? val(this) : val;
}

(etc.)
}}}
Note the way this is constructed. There may be times where we &lt;i&gt;do&lt;/i&gt; want to modify a particular Action instance with a unique property that&#39;s different from its property in the database, such as with the variable effects of Mage&#39;s spells. For this, we use a special property with the same name, but prepended with an underscore &lt;code&gt;_&lt;/code&gt; to denote it as an override property. We may also want to calculate the property through another function rather than hold it as a single value, so we have to include a check to call the function if there is one.

(Why does this look so much more complicated than the one-line return statement in the last getter? Because variable return works on logical operation, which means it skips an entry if it evaluates to &lt;code&gt;false&lt;/code&gt; -- &lt;i&gt;not just&lt;/i&gt; if it&#39;s &lt;code&gt;undefined&lt;/code&gt;! &lt;code&gt;cost&lt;/code&gt; can be 0, which is a falsy value. Because of this, we have to write out a full &lt;code&gt;if&lt;/code&gt; tree that explicitly only excludes &lt;code&gt;undefined&lt;/code&gt; values. You&#39;ll want to do this for any property that could have a falsy evaluation, which are listed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;. It&#39;s a pain, but doing it here will save you more trouble in the long run!)

This method of offloading constant data to a database and accessing it through lookup is known as &lt;b&gt;Flyweight&lt;/b&gt;. It is very useful for streamlining our data: Now, our objects only have to store a &lt;code&gt;name&lt;/code&gt; property and any dynamic properties that might change over the course of the game. As an added bonus, this makes updating the game between versions easier as well: The &lt;code&gt;setup&lt;/code&gt; variable exists independent of save states, so any changes made to the database will automatically be reflected in existing saves.

Now that you know the general principles, let&#39;s get into the individual classes.

&lt;h3 id=&quot;JS.actor&quot;&gt;Actor Class&lt;/h3&gt;
The &lt;b&gt;Actor&lt;/b&gt; class defines a character who, as the name implies, acts in battle. This means it should define all the attributes we want battling characters to have.

&lt;h4 id=&quot;JS.actor.constructor&quot;&gt;Constructor&lt;/h4&gt;
All classes require a &lt;b&gt;constructor&lt;/b&gt; function that standardizes how they are initialized. It takes arguments just like any other function that are used in the construction of the object. Since we use a database structure, for {{{Actors}}}, we only need the name.
{{{
if (this instanceof Puppet) {
	this.id = &quot;p&quot;;
} else if (this instanceof Enemy) {
	this.id = &quot;e&quot;;
} else {
	this.id = &quot;_&quot;;
}
this.id += (new Date().getTime() + Math.random() * 0x10000000000).toString(16);
}}}
The first thing we do in the constructor is create a unique ID value for the Actor. This is necessary for a few other features that need to be able to identify a specific Actor out of an array. It&#39;s also necessary for the ID to distinguish between Puppets (player characters) and Enemies, so we use an if tree to append a unique symbol to the start of the ID depending on which one this object is. (Puppet and Enemy are also object classes; they will be explained later.)
{{{
this.name = name;
}}}
We then start assigning values to the object&#39;s attributes, starting by assigning the &lt;code&gt;name&lt;/code&gt; argument to a &lt;code&gt;name&lt;/code&gt; property.
{{{
if (this.data)
}}}
Then we perform this check before proceeding. We will learn how this works when we examine Actor&#39;s functions. For now, just remember this.
{{{
this._HPregen = {
	&quot;flat&quot;: new Stat(0),
	&quot;percent&quot;: new Stat(0)
}
this.elements = new Map();
if (setup.ELEMENT_LIST !== undefined){
	setup.ELEMENT_LIST.forEach(function(x) {
		this.elements.set(x,{&quot;percent&quot;: new Stat(1), &quot;flat&quot;: new Stat(0)});
	}, this);
}
this.tolerances = new Map();
if (setup.effectData !== undefined){
	Object.keys(setup.effectData).forEach(function(x) {
		this.tolerances.set(x,new Tolerance(0));
	}, this);
}
}}}
Then three properties are initialized to default valies: HP regeneration (which contains both flat and percentage rates), elemental affinities, and ailment tolerances. {{{ELEMENT_LIST}}} is a story variable you can define in StoryInit to list all the elements you want in your game. This code checks to make sure it exists, and if it does, runs across it to create elemental affinity values for each. (By default, they are all neutral: 1 for the proportional multiplier and 0 for flat reduction.) This will prevent the game from throwing an error when a character is attacked with an elemental ability; if the game tries to read a value and there&#39;s nothing there, it may create problems. Similarly, {{{tolerances}}} generates ailment resistances by running over {{{effectData}}}, the database of all status effects in your game (see &lt;a class=&quot;noExternal&quot; href=&quot;#effects&quot;&gt;Status Effects&lt;/a&gt;), and creating resistances based on the name values it extracts.

The {{{elements}}} and {{{tolerances}}} attributes are defined as a Map object rather than an array. Maps are very similar to arrays, but their index values can be anything, not just numbers. To extract a value from a Map, you use {{{&lt;var&gt;.get(&lt;key&gt;)}}}, similarly to how you use {{{&lt;var&gt;[index]}}} to extract values from arrays. This makes it much easier to call an affinity in response to an elemental attack, as you can just input the name and the program will pull up the corresponding value, instead of having to remember the order of the array.
{{{
this._maxhp = new Stat(this.data.hp);
this._hp = this.data.hp;
this.stats = {};
for (let [pn,v] of Object.entries(this.data.stats)) {
	this.stats[pn] = new Stat(v);
}
if (this.data.elements) { this.setElements(Object.entries(this.data.elements),&quot;percent&quot;); }
if (this.data.tolerances) { this.setTol(Object.entries(this.data.tolerances)); }
if (this.data.retaliations) { this._retaliations = new FillStat(this.data.retaliations); } else { this._retaliations = new FillStat(0); }
}}}
Next we start actually extracting data from the database. Main stats such as Attack and Defense are stored in the &lt;code&gt;stats&lt;/code&gt; attribute, which is populated by looping over the entries provided by the &lt;code&gt;stats&lt;/code&gt; property in the character&#39;s database entry. (This means that the initialization will work for any number of stats; you don&#39;t need to change the code here if you want to add or remove stats.) If the character has defined &lt;code&gt;elements&lt;/code&gt;, &lt;code&gt;tolerances&lt;/code&gt;, or &lt;code&gt;retaliations&lt;/code&gt; in their database entry, those are extracted; otherwise, they remain at their default values. (Currently, only percent-based elemental affinities are initialized here. You&#39;ll have to implement your own code for flat rates.)
{{{
this.isDone = false;
this.dead = false;
this.effects = [];
this._deathMessage = `${this.name} is defeated!`;
}}}
Next we initialize some important flags. &lt;code&gt;isDone&lt;/code&gt; will be used to determine if a character has finished their turn, and &lt;code&gt;effects&lt;/code&gt; holds status effects. After this, we set a bunch of flags that mark if a character has a certain status effect (see &lt;a class=&quot;noExternal&quot; href=&quot;#effects&quot;&gt;Status Effects&lt;/a&gt;).
{{{
this.equipment = new Map([
	[&quot;Weapon&quot;,null],
	[&quot;Armor&quot;,null],
	[&quot;Accessory&quot;,[null,null] ]
]);
}}}
Finally, we define equipment slots. Thesse are discussed more in &lt;a class=&quot;noExternal&quot; href=&quot;#JS.items&quot;&gt;the Item Database&lt;/a&gt;.
{{{
else {
	console.log(&quot;ERROR: Actor &quot;+name+&quot; is not in database&quot;);
	this.name = &quot;INVALID ACTOR&quot;;
	this._hp = 1;
	this._maxhp = new Stat(1);
}
}}}
We finish with a default error handler in the case that our earlier &lt;code&gt;if (this.data)&lt;/code&gt; check failed. This will at least fill the important fields so we don&#39;t have a completely undefined object breaking things, and log an error to the database that tells us what happened.

&lt;h4 id=&quot;JS.actor.getters&quot;&gt;Getters and Setters&lt;/h4&gt;
We are then finished with the constructor, but we can continue to add other functions. These functions, called &lt;b&gt;object methods&lt;/b&gt;, can be used by any instance of the Actor class.
{{{
get data () {
	var id = (this.idname || this.name);
	if (this instanceof Puppet) {
		return (setup.puppetData[id] || false);
	}
	else if (this instanceof Enemy) {
		return (setup.enemyData[id] || false);
	}
	else {
		return undefined;
	}
}
}}}
Like all database-associated objects, we need to start with a function that accesses the database. This one is a little more complicated than others, because we don&#39;t intend to use pure Actor objects in our game; every Actor is going to be one of two subclasses, Puppets or Enemies. The data for these classes are defined in separate databases, so we need to check the type of our object to determine which database to access. We also need to return &lt;code&gt;false&lt;/code&gt; for our default value instead of an empty object so that our &lt;code&gt;if (this.data)&lt;/code&gt; check will fail in the event there&#39;s no matching database entry.

(We also use a multiple-choice assignment to pick from two possible identifiers, for &lt;a class=&quot;noExternal&quot; href=&quot;#JS.enemies&quot;&gt;reasons&lt;/a&gt;.)

We next define getters and setters for several properties. Accessing Map values is a little unwieldy, especially when those values are themselves objects, so we define functions with shorter names that do the same thing. We have functions here for getting and setting all modifiable stats, and obtaining equipment and circumstance bonuses.

Note the &lt;code&gt;hp&lt;/code&gt; setter:
{{{
set hp (amt) {
	this._hp = Math.clamp(amt,0,this.maxhp);
}
}}}
This prevents a character&#39;s HP from going below 0 or above their maximum HP.
{{{
get (key) {
	// calculates effective stats
	if (this.stats[key]) {
		let v = this.stats[key];
		let n = v.current;
		if (n &lt; setup.MIN_STAT &amp;&amp; !(key == &quot;Defense&quot; &amp;&amp; this.forsaken)){
			n = setup.MIN_STAT; // 0 in subtractive, 1 otherwise
		}
		return Math.round(n);
	} else {
		console.log(&quot;ERROR in stat getter, target does not have requested stat&quot;);
		return 0;
	}
}
}}}
Similarly, this function (just called &lt;code&gt;get&lt;/code&gt;) not only returns a stat, but ensures it stays within acceptable bounds. In a divisive defense system, letting a defense stat hit 0 can result in a division by zero error, so this is very important! (This isn&#39;t an issue in the default subtractive system, so I included a little handler here that lets Defense go negative if the character has the Forsaken status. This is how Forsaken is uniquely able to reduce Defense below 0.)
{{{
getElement (needle,type) {
	if (type === undefined) {
		return this.elements.get(needle);
	} else {
		return this.elements.get(needle)[type].current
	}
}

setElements (array,type) {
	// Easy way to set base elemental affinities. Takes an array of arrays that each contain two elements, the name of the effect and the base value. Pass the second argument to denote if you are setting flat or percent rates.
	if (type === undefined || typeof(type) !== &#39;string&#39;) {
		console.log(&quot;ERROR in setElements: no type defined&quot;);
	} else {
		array.forEach(function(data) {
			if (this.elements.has(data[0])) {
				this.elements.get(data[0])[type].base = data[1];
			}
		}, this);
	}
}

(...)

getTol (key) {
	// This is for evaluating tolerance in-battle, and therefore only returns the current value. DON&#39;T use it to access the whole tolerance object, because that&#39;s not what it returns.
	if (!this.tolerances.has(key)){
		return undefined;
	} else {
		return this.tolerances.get(key).currentVal;
	}
}

setTol (array) {
	// Easy way to set base tolerances. Takes an array of arrays that each contain two elements, the name of the effect and the base value.
	array.forEach(function(data) {
		if (this.tolerances.has(data[0])) {
			this.tolerances.get(data[0]).base = data[1];
		}
	}, this);
}
}}}
We also have some special getters and setters for handling elemental affinities and ailment tolerances. Because these are complicated structures stored in large maps, it&#39;s difficult to access and modify them directly. {{{getElement}}} lets you specify if you want the flat soak or the proportional resistance associated with that element and returns the {{{current}}} value (see &lt;a class=&quot;noExternal&quot; href=&quot;#JS.stats&gt;the Stat class&lt;/a&gt;) of the associated property, making it very easy to plug it into in-game calculations; {{{getTol}}} does the same for tolerances, but is less complicated since tolerances don&#39;t have sub-properties for flat and proportional. (Note that these are not normal &quot;getter&quot; functions, as they do not actually access the maps&#39; raw values. You will need to use {{{.get(key)}}} for that.) {{{setElements}}} lets you quickly set base values for elemental affinities, and {{{setTol}}} does the same for tolerances.

&lt;h4 id=&quot;JS.actor.effectFunctions&quot;&gt;Effect Functions&lt;/h4&gt;
{{{
addEffect (effect,time,power) {
	if (typeof(effect) == &#39;string&#39;){
		effect = new Effect(effect,time,power);
	}
	this.effects.push(effect);
	effect.onApply(this);
	return effect.addText(this.name);
}

removeEffect (effect,mods) {
	mods = (mods || {});
	if (!this.stasis || mods.pierce === true){
		var E;
		if (typeof(effect) == &#39;string&#39;) {
			E = this.effects.find(function(e) { return e &amp;&amp; e.name === effect; });
		}
		else {
			E = effect;
		}
		if (!V().inbattle || ((!E.ULTIMATESTICKY || mods.unsticky == &quot;ultimate&quot;) &amp;&amp; (!E.sticky || mods.unsticky))) {
			E.onRemove(this);
			this.effects.delete(E);
			return E.removeText(this.name);
		}
		else {
			return `${E.name} status can&#39;t be removed!&lt;br/&gt;`;
		}
	} else {
		return `${this.name}&#39;s Stasis held the effect in place!&lt;br/&gt;`;
	}
}
}}}
The next set of functions governs how status effects interact with the character. They effectively bundle three functionalities together for us: adding or removing the Effect object in the character&#39;s {{{effects}}} array, applying the effect&#39;s actual functionality, and sending a message to the player.

Note that these functions have branching functionality depending on the arguments they receive:
{{{
if (typeof(effect) == &#39;string&#39;){
	effect = new Effect(effect,time,power);
}
}}}
{{{addEffect}}} is designed to take a single argument -- an Effect object -- by default. This is because it has to call {{{onApply}}} and {{{addText}}}, which are functions of Effect objects. The standard structure of effect management is set up to be compatible with format. However, what if you want to make a new effect and add it at the same time? This sometimes happens in special circumstances, such as Darwin&#39;s power up scene in &lt;i&gt;Cartoon Battle&lt;/i&gt;. You could say {{{addEffect(new Effect(name,time,power))}}}, but this is a little awkward to write. It&#39;s easier if we&#39;re just able to pass the raw variables directly, as we would when constructing a new Effect. That&#39;s what this {{{if}}} statement does: If the first argument is a string, the function assumes the user is trying to construct a new Effect object, and does so before proceeding.
{{{
if (typeof(effect) == &#39;string&#39;) {
	E = this.effects.find(function(e) { return e &amp;&amp; e.name === effect; });
}
else {
	E = effect;
}
}}}
We see something similar in {{{removeEffect}}}. By default, it is designed to take a single object -- an Effect object present in the Actor&#39;s list of {{{effects}}} -- so it can remove it through the {{{delete}}} function. This assumption is valid for the default engine structure, where effect removal actions iterate over the {{{effects}}} array and remove elements non-specifically. But what if we &lt;i&gt;do&lt;/i&gt; want that specificity? What if we only want to remove a specific effect? We could iterate over the {{{effects}}} array and check against the name of the effect we want to remove every time, but that&#39;s tedious. Instead, we can just pass a string, and the work of searching is offloaded to this function. (Note, however, that due to the way {{{find}}} works, this will only remove the &lt;b&gt;first&lt;/b&gt; effect it finds, and leave the others alone. If you want to remove all instances of a stackable effect, you will indeed need to loop through the whole array to collect them.)

If you call these functions with a {{{&lt;&lt;print&gt;&gt;}}} statement, the {{{return}}} statement will be printed to the screen. You don&#39;t need to call it again; the code of a function is executed regardless of the context in which it is called, so it&#39;ll still run in addition to printing the text. If you want to discard the output, all you need to do is call the function with a {{{&lt;&lt;run&gt;&gt;}}} statement instead; it will still perform its functionality, but you won&#39;t print the {{{return}}} statement.
{{{
if (!V().inbattle || ((!E.ULTIMATESTICKY || mods.unsticky == &quot;ultimate&quot;) &amp;&amp; (!E.sticky || mods.unsticky)))
}}}
Additionally, &lt;code&gt;removeEffect&lt;/code&gt; has this clause before it removes an effect. &quot;Sticky&quot; effects aren&#39;t supposed to be removable by normal means. We could manually implement this functionality into every cure or dispel ability, but that&#39;s tedious. Since this is universal behavior, we&#39;ll implement it here. If you want a special ability to be able to remove sticky effects, such as Witch&#39;s &quot;Renewal&quot; ability, you can pass an {{{unsticky}}} flag here.

Certain effects have an &quot;ULTIMATESTICKY&quot; property as well that prevents them from being removed even by normal unsticky abilities. You can still remove these, but you will need to assign the string &quot;ultimate&quot; to the {{{unsticky}}} variable.

(We also have to be careful -- we still want to be able to remove sticky effects through system cleanup, such as end-of-battle processing! I account for this by implementing a bypass if the game isn&#39;t currently in a battle, but if you want sticky effects to persist after battle you will have to do something different.)

&lt;h4 id=&quot;JS.actor.equipFunctions&quot;&gt;Equipment Functions&lt;/h4&gt;
{{{
unequip (slot,index,mods) {
	mods = (mods || {});
	if (this.equipment.has(slot)) {
		var item = null;
		if (this.equipment.get(slot) instanceof Array) {
			if (typeof(index) == &#39;number&#39;) {
				item = this.equipment.get(slot)[index];
			} else { console.log(&quot;ERROR in unequip: Invalid item index.&quot;); return; }
		} else {
			item = this.equipment.get(slot);
		}
		if (item !== null){
			if (item.default === undefined &amp;&amp; mods.destroy !== true) {
				inv().addItem(item.name);
			}
			if (item.onRemove !== undefined) {
				item.onRemove(this);
			}
			(this.equipment.get(slot) instanceof Array) ? this.equipment.get(slot)[index] = null : this.equipment.set(slot,null);
			//this.equipment.set(slot,new Item(&quot;Default &quot;+slot));
		}
	}
	else { console.log(&quot;Attempted to unequip nonexistent slot.&quot;); return; }
}
}}}
There are similar functions for handling equipment, though in this case we define the removal function first. {{{unequip}}} is straightforward in most cases: it is passed the slot to unequip, and the item in that slot is removed. We require a common-sense check to ensure the given slot exists and isn&#39;t already empty. We also want to store the unequipped item and place it back in the player&#39;s inventory, as the {{{set}}} function will simply overwrite what was originally in the slot. (If we &lt;i&gt;do&lt;/i&gt; want the player to permanently lose the item, we can set the {{{destroy}}} flag to {{{true}}}.)

Things become slightly more complex if we are looking at an equipment slot with multiple subslots, such as &quot;Accessory&quot; in the default engine. If we&#39;re unequipping from such a slot, the function must be passed an {{{index}}} value so it knows which subslot to unequip. It will then check at the beginning if the slot is an array; if it is, it will assign the item at the index value to {{{item}}}, instead of the slot itself. The function checks once more at the end so that it can correctly target the slot to set to {{{null}}}.

There is an optional statement here for systems that cannot function with a {{{null}}} equipment slot; for instance, most versions of &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; must read the statistics of the equipped weapon for attacks. In this case, instead of setting the slot to {{{null}}}, you would want to replace it with another object. These default objects can be defined in the item database like any other.

There is also an {{{unequipAll}}} function, which simply runs through the Actor&#39;s {{{equipment}}} and calls this on each item.
{{{
equip (item) {
	if (this.equipment.has(item.equippable.slot)) {
		var slot = this.equipment.get(item.equippable.slot);
		var existing = null;
		var subslot = undefined;
		if (slot instanceof Array) {
			for (let i = 0; i &lt; slot.length; i++) {
				if (slot[i] === null) {
					subslot = i;
					break;
				}
			}
			if (subslot === undefined) {
				subslot = slot.length-1;
				existing = slot[subslot];
			}
		}
		else {
			existing = slot;
		}
		if (existing !== null){
			this.unequip(item.equippable.slot,subslot);
		}
		(slot instanceof Array) ? slot[subslot] = item : this.equipment.set(item.equippable.slot,item);
		if (item.onEquip !== undefined){
			item.onEquip(this);
		}
		if (inv() !== undefined &amp;&amp; inv().has(item.name)){
			inv().decItem(item.name);
		}
	} else { console.log(&quot;ERROR: Equipment type not recognized&quot;); return; }
}
}}}
The {{{equip}}} function is similar; however, to equip something we have to unequip what was already there! Fortunately, we&#39;ve defined {{{unequip}}} already, so we can simply call it (after making common-sense checks that the slot exists and isn&#39;t empty). Then we assign the item to the slot and run any {{{onEquip}}} functionality, if it exists. We will also want to remove the item from the player&#39;s inventory; the {{{set}}} statement creates a new copy, so if we didn&#39;t remove the original we&#39;d be duplicating the item!

Subslot compatibility is more complicated for this function. If the slot is an array, we need to search through it with a {{{for}}} loop to find the first available subslot (the first slot with contents {{{null}}}). As soon as it finds an empty slot, we {{{break}}} out of the loop to save processing power. This ensures that equipping additional items to this slot will fill the subslots in ascending order.

What if there are no empty subslots? In this case, {{{subslot}}} remains {{{undefined}}} and the {{{if}}} statement triggers, targeting the last subslot to swap with the new item.

&lt;h4 id=&quot;JS.actor.toleranceFunctions&quot;&gt;Tolerance Functions&lt;/h4&gt;
{{{
decTol (k) {
	this.tolerances.get(k).currentVal--;
}

resetTol (key) {
	this.tolerances.get(key).refill();
}
}}}
We also have functions that simply shorten common tasks for handling tolerances. {{{decTol}}} decrements the current tolerance value (normally a mouthful to access, as you can see here), and {{{resetTol}}} resets the current tolerance value to its maximum.

(See &lt;a class=&quot;noExternal&quot; href=&quot;#effects1&quot;&gt;Applying Effects&lt;/a&gt; for more explanation on tolerances.)

&lt;h4 id=&quot;JS.actor.misc&quot;&gt;Miscellaneous Functions&lt;/h4&gt;
{{{
regenHP () {
	this.setHP(this.maxhp * this.HPregenPercent);
	this.setHP(this.HPregenFlat);
}
}}}
{{{regenHP}}} shortens two lines of code into one. Because HP regeneration can have both flat and propotional attributes, we have to apply both when running HP regeneration.
{{{
get row () {
	if (setup.BATTLE_GRID === true) {
		var party;
		if (this instanceof Enemy) {
			party = V().enemies;
		} else if (this instanceof Puppet) {
			party = V().puppets;
		}
		for (var i = 1; i &lt;	setup.COLUMN_SIZE; i++) {
			if (party.indexOf(this) &lt; i * setup.ROW_SIZE) {
				return i;
			}
		}
		console.log(&quot;ERROR in row getter: could not find row&quot;);
		return 0;
	} else {
		return;
	}
}

get col () {
	if (setup.BATTLE_GRID === true) {
		var party;
		if (this instanceof Enemy) {
			party = V().enemies;
		} else if (this instanceof Puppet) {
			party = V().puppets;
		}
		for (var i = 1; i &lt;	setup.ROW_SIZE; i++) {
			if (party.indexOf(this) % setup.COLUMN_SIZE == (i-1)) {
				return i;
			}
		}
		console.log(&quot;ERROR in column getter: could not find column&quot;);
		return 0;
	} else {
		return;
	}
}
}}}
These getters tell us the row and column addresses of a character if they are in a battle grid. See [[the Battle Grid|Additional Features]] for more information.

&lt;h3 id=&quot;JS.stats&quot;&gt;Stat Class&lt;/h3&gt;
Stats also require their own class. If you intend for your stats to be totally static and never undergo temporary changes, defining them as a simple variable is fine; but what if you want to give players a ring that provides +1 Strength they can put on or take off at will, or a &quot;weaken&quot; status effect that decreases Strength for a given duration?

That is the main function of this class, defined in {{{stat class.js}}}.
{{{
constructor (base) {
    this._base = base;
    this._mods = {};
    this._current = undefined;
}
}}}
The constructor isn&#39;t too special; we just initialize some properties.
{{{
addMod (id, mod, equipment) {
	id = String(id);
	var mods = this._mods[id] = this._mods[id] || [];
	if(Number.isFinite(mod)) {
		mod = { add: mod };
		if (equipment === true) {
			mod.equipment = true;
		}
	}
	if(typeof mod === &quot;object&quot;) {
		var idx = 0;
		mods.forEach(function(mod) { idx = Math.max(idx, mod.idx); });
		mod.idx = (++ idx);
		mods.push(mod);
		this.clearCache();
		return mod.idx;
	}
}
}}}
The {{{addMod}}} function is the main purpose of this class. The way it works is this: Every {{{Stat}}} has a {{{_mods}}} property that initializes as an empty object, &lt;code&gt;{}&lt;/code&gt;. This empty object acts as a container for every modifier that acts on the stat. Every time you want to add something that modifies the stat, such as a piece of equipment, you pass a name ({{{id}}}), and {{{_mods}}} will gain a property with that name that contains the modifier data.

However, there&#39;s an additional wrinkle: What if you want multiple mods of the same type to stack, such as applying multiple copies of the same status effect, or wearing two Rings of +1 Strength at the same time? And object can&#39;t have multiple properties with the same name; attempting the second assignment will simply overwrite the existing property. To account for this, each mod&#39;s name points to an &lt;i&gt;array&lt;/i&gt; of modifier objects, rather than just one modifier object. We initialize this through the following statement:
{{{
var mods = this._mods[id] = this._mods[id] || [];
}}}
In English, this says, &quot;If {{{this._mods}}} already contains a property with the given {{{id}}}, copy it; if it does not, create a property with the given {{{id}}} and make it an empty array. Then, define a new variable {{{mods}}} and assign it to {{{this._mods}}}.&quot; Essentially, this statement is evaluated from right to left instead of left to right.

We then check if the passed {{{mod}}} is a finite number. If it is, we convert it into object form, attaching the passed value to an {{{add}}} attribute. We also check if the {{{equipment}}} argument has a value of {{{true}}}; if so, we mark the mod as an equipment-based modifier by adding an {{{equipment}}} attribute.

(We can bypass this code if we pass an object to the {{{mod}}} argument; this is useful if you want to create other, special properties for your mod. However, this functionality works for most purposes.)

After this processing, the finalized mod is added to the {{{mods}}} array. For accurate recall, every mod in the array needs a unique identifier, which we add through the {{{idx}}} variable and the following function:
{{{
mods.forEach(function(mod) { idx = Math.max(idx, mod.idx); });
mod.idx = (++ idx);
}}}
In English, this says: &quot;For every mod in the mods array, compare the existing {{{idx}}} value to the mod&#39;s {{{idx}}} value, and set {{{idx}}} to whichever value is higher. Then, increment {{{idx}}} by 1 and assign it to the mod object we want to add to {{{mods}}}.&quot; This allows us to ensure that every mod has a unique {{{idx}}} value, and that they increment in logical order.

Because adding a mod obviously causes a change in the stat&#39;s modifiers, we next run {{{clearCache()}}}, which recalculates the stat&#39;s current value.

We end by returning the value of {{{idx}}}. This is useful for storing the specific mod&#39;s index to another variable so we can recall it for accurate removal later.

As an example of how this is used, here is the data for a status effect that does exactly what it sounds like, ATK Boost:
{{{
&#39;ATK Boost&#39;: {
	&quot;buff&quot;: true,
	&quot;stackable&quot;: true,
	&quot;statmod&quot;: true,
	&quot;onApply&quot;: function (puppet) {
		this.id = puppet.stats.addMod(&quot;Attack&quot;,&quot;ATK Boost&quot;,this.power);
	},
	&quot;onRemove&quot;: function (puppet) {
		puppet.stats.removeMod(&quot;Attack&quot;,&quot;ATK Boost&quot;,this.id);
	},
	&quot;info&quot;: function (effect) {
		return `Attack boosted by ${this.power}.`;
	},
	&quot;addText&quot;: function (target) {
		return `${target} is surging with strength!`;
	},
	&quot;removeText&quot;: setup.effectFunctions.remBuff
}
}}}
When an ATK Boost is applied to a character, they gain a mod with the name &quot;ATK Boost&quot; that points to the array {{{[ {add: &lt;power&gt;, idx: 1} ]}}}, and the ATK Boost object gets the ID of the mod, {{{1}}}, assigned to its {{{id}}} property. This is a stackable effect, so if the character got a second ATK Boost, it would be added to the &quot;ATK Boost&quot; array, which would now look like this: {{{[ {add: &lt;power&gt;, idx: 1}, {add: &lt;power&gt;, idx: 2} ]}}}
{{{
removeMod (id, index) {
	id = String(id);
	if (Number.isFinite(index)) {
		this._mods[id].deleteWith(function(mod) { return (mod.idx === index); })
	} else {
		delete this._mods[id];
	}
	this.clearCache();
}
}}}
To remove a mod, we need only the mod&#39;s ID and, optionally, its index within the ID. If no index is passed, this function simply deletes all mods under the given ID, which is fine for non-stackable effects. If an index is passed, we instead delete only the mod with that index value, using SugarCube&#39;s {{{deleteWith}}} function.
{{{
get current () {
	if (this._current === undefined) {
		/* gather multipliers */
		var mult = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return Number.isFinite(m.mult) ? m.mult : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		/* gather sums */
		var add = Object.values(this._mods)
			.reduce(function(bigSum, entry) { return bigSum + entry
				.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
				.reduce(function(sum, add) { return sum + add; }, 0);
			}, 0);
		this._current = this.base * (mult + 1) + add;
	}
		return this._current;
}
}}}
Here is where it all comes together. When you call for a stat&#39;s {{{current}}} property, you don&#39;t get {{{_current}}}; the stat is calculated based on the base value and all modifiers.

This definition has functionality for both multiplier and incrementor modifiers, and has a sub-section for each. They&#39;re both fundamentally similar, however.

Note that the following happens all at once. Don&#39;t let the line breaks fool you; if there&#39;s no semicolon, the code doesn&#39;t stop.
{{{
Object.values(this._mods)
}}}
{{{Object.values()}}} extracts the values of an object&#39;s properties and converts them into an array. This is useful because arrays have additional functions that make finding and extracting data easier. We use this to get a list of all the mods in {{{_mods}}} in array form, then:
{{{
.reduce(function(bigSum, entry) { return bigSum + entry
}}}
The {{{Array.reduce}}} function defines an accumulator value, and then uses it in a function it applies to every element in the array. This is most commonly used for quickly summing all the values in an array of numbers, and that&#39;s exactly what we want to do here, after a fashion. However, remember that every mod in {{{_mods}}} is an array of objects, not values, so we need to go deeper. We need to perform another function on each {{{entry}}}:
{{{
.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
}}}
The {{{Array.map}}} function returns an array that is the result of performing a function on every element in the array. In this case, we use it to extract a specific property from our modifier objects: if the objects have a finite {{{add}}} value (or {{{mult}}} value, if we&#39;re tracking multipliers), it&#39;s returned and placed into a new array.

So we now have an array of the numeric data of our modifiers. We can compress that into a single value with another...
{{{
.reduce(function(sum, add) { return sum + add; }, 0);
}}}
This one is very straightforward: we simply run through every value in the array and add them together.

Going back to our initial {{{reduce}}}, this sum is the value that will finally be returned after all the processing we&#39;ve done on {{{entry}}}. It&#39;s then added to {{{bigSum}}}, and the process starts again for the next type of modifier. Once this is done, we&#39;ll have all our modifiers compiled into one final value.
{{{
this._current = this.base * (mult + 1) + add;
}}}
Then, at last, we can calculate what the current stat value should be. It&#39;s this value that&#39;s returned.

Notice this {{{if}}} statement at the start:
{{{
if (this._current === undefined)
}}}
All of this calculation only occurs if {{{_current}}} is {{{undefined}}}. This is very efficient, because it means the stat is only calculated when it needs to be. We only have to set {{{_current}}} to {{{undefined}}} when it needs to be recalculated, and can otherwise continue using the same value.
{{{
Map.prototype.addMod = function (key, id, mod, equipment, type) {
	if (type !== undefined &amp;&amp; typeof(type) == &#39;string&#39;) {
		return this.get(key)[type].addMod(id,mod,equipment);
	} else {
		return this.get(key).addMod(id,mod,equipment);
	}
}

Map.prototype.removeMod = function (key, id, index, type) {
	if (type !== undefined &amp;&amp; typeof(type) == &#39;string&#39;) {
		this.get(key)[type].removeMod(id, index);
	} else {
		this.get(key).removeMod(id, index);
	}
}
}}}
Finally, I created these two functions to make some things a little easier. Many {{{Stat}}}s, such as elemental affinities and tolerances, are stored in {{{Map}}} objects, and would therefore necessitate a lengthy {{{get}}} call to access for mod addition or removal. With these, you only have to pass the name of the entry you want to target, and the function will find it for you. (A wrinkle exists for stats with multiple properties, such as elemental affinities having both soak and resistance, so you can also pass the {{{type}}} you want to target, if necessary.)
{{{
setup.statInfo = {
	&quot;Attack&quot;: &quot;Increases damage of regular attacks.&quot;,
	&quot;Defense&quot;: &quot;Reduces damage taken.&quot;,
	&quot;Special&quot;: &quot;Improves effectiveness of status effects, mitigates received status ailments, and increases damage of item attacks.&quot;
}
}}}
Information on what each stat does is also defined in this file. This information is called as a tooltip in &lt;a class=&quot;noExternal&quot; href=&quot;#menus.status&quot;&gt;the party menu&lt;/a&gt;. I recommend defining these for any stats whose purpose is not immediately obvious, since the player needs to understand their basic toolset.

&lt;h4 id=&quot;JS.stats.fill&quot;&gt;The FillStat Class&lt;/h4&gt;
Some stats can be &quot;filled&quot; and &quot;depleted&quot;, with both a current and maximum value. This functionality is handled by the FillStat class, which is a subclass of the Stat class.
{{{
constructor (base) {
	super(base);
	this.currentVal = base;
}
}}}
The constructor is much the same, but it adds a new property, {{{currentVal}}}. Don&#39;t confuse this with the {{{current}}} value! Due to inheritance, we have to keep the name of the calculated stat value {{{current}}}, but this refers to the &lt;i&gt;maximum&lt;/i&gt; stat value, not the current &quot;points&quot; in the pool.
{{{
clearCache () {
	this._current = undefined;
	this.refill();
}

refill () {
	this.currentVal = this.current;
}
}}}
The mechanics of {{{currentVal}}} necessitate a slight change to the way {{{_current}}} is updated. When {{{_current}}} (the maximum stat value) is changed, we need to update {{{currentVal}}} to match it. This is accomplished through the {{{refill}}} function, and by running it in {{{clearCache}}}. &lt;b&gt;Note that this assumes you will not be modifying max values in the middle of battle, or that if you are, you want them to be refreshed alongside the change. If you want something different, you&#39;ll need to code different functionality.&lt;/b&gt;

&lt;h4 id=&quot;JS.tolerances&quot;&gt;Tolerance Class&lt;/h4&gt;
Tolerances (status ailment resistances) have additional properties that necessitate their own specialized form of {{{FillStat}}}.
{{{
get current () {
	if (this._current === undefined) {
		// check for immunity
		let immunity = false;
		if (this.base &gt;= 0) {
			Object.values(this._mods)	// returns array of arrays
				.forEach(function(modArray) {
					modArray.forEach(function(mod) { if (mod.immune === true) {immunity = true;} });
				});
		} else {
			immunity = true;
		}
		if (immunity === true) {
			this._current = -1;
		} else {
			// gather tolerance
			var tol = Object.values(this._mods)
				.reduce(function(bigSum, entry) { return bigSum + entry
					.map(function(m) { return Number.isFinite(m.add) ? m.add : 0; })
					.reduce(function(sum, add) { return sum + add; }, 0);
				}, 0);
			this._current = this.base + tol;
		}
	}
		return this._current;
}
}}}
The only change comes in the getter for {{{current}}}. In addition to partial resistance, it is possible for a tolerance to grant complete immunity to an ailment, and this has to be handled differently than in the normal {{{current}}} calculation.
{{{
if (this.base &gt;= 0)
}}}
Obviously, if mods provide an immunity, calculating the resistance value is moot. This means we should check for immunity first. Immunity is conveyed through a negative tolerance value, so we can check if the base tolerance already provides it with this {{{if}}} statement. If the {{{base}}} is less than 0, we know the character is already immune, so we can skip the rest of this function; but if it&#39;s not, we need to check for immunity from mods.
{{{
Object.values(this._mods)
	.forEach(function(modArray) {
		modArray.forEach(function(mod) { if (mod.immune === true) {immunity = true;} });
	});
}}}
The immunity check works differently from the other calculations. Instead of a total value, we only care about a binary state: is there an immunity or not? We therefore only need a regular {{{forEach}}} function to run through and test all the mods. If we find a mod with an {{{immune}}} property of {{{true}}}, we set the previously-defined {{{immunity}}} variable to {{{true}}} to record that we found an immunity.

If we found an immunity, we can set {{{_current}}} to -1 (a negative value, so it will be read as an immunity) and end the calculation. If we didn&#39;t, we gather tolerance values using the normal {{{Stat}}} code.

&lt;h3 id=&quot;JS.puppets&quot;&gt;Puppet Class&lt;/h3&gt;
This file defines the statistics of the player characters. They&#39;re called &quot;puppets&quot; as a holdover from &lt;i&gt;Cartoon Battle&lt;/i&gt;, but you can change the name if you like.
{{{
class Puppet extends Actor
}}}
To begin with, we say that the {{{Puppet}}} class &lt;i&gt;extends&lt;/i&gt; {{{Actor}}}. This makes {{{Puppet}}} a &lt;i&gt;subclass&lt;/i&gt; of the {{{Actor}}} class. It will inherit all of {{{Actor}}}&#39;s object methods, and will count as an instance of {{{Actor}}} for data check purposes. We can still use {{{.get}}} with it, for instance. This is handy because it allows us to define unique attributes of puppets we don&#39;t want for enemies, while still maintaining access to all the useful attributes and methods defined in {{{Actor}}}.

Subclasses are constructed a little differently: they still have a {{{constructor}}} function, but it must use the parent class&#39;s constructor before it can make its own unique modifications. This is done through the keyword {{{super}}}. This can be thought of as us constructing an instance of the parent class and then modifying it with unique subclass features.
{{{
this.lastAction = null;
this.maxen = 10;
this.en = 5;
this.inspired = false;
this.defeats = 0;
this.kills = 0;
}}}
By default, that&#39;s these features: Energy values, the &lt;code&gt;inspired&lt;/code&gt; flag, &lt;code&gt;kills&lt;/code&gt; and &lt;code&gt;defeats&lt;/code&gt; counters, and the &lt;code&gt;lastAction&lt;/code&gt; property, which is initialized to a blank &lt;code&gt;null&lt;/code&gt;. You can change this section if, for instance, you want unique Energy stats for every character.
{{{
for (let n of this.data.actions) {
	this.actions.push(new Action(n));
}
this.defaultAction = new Action(this.data.defaultAction);
if (this.data.specialInit) { this.data.specialInit(this); }
}}}
For specific data unique to the character, we make calls to the database. Recall that most statistics, such as HP and core stats, are already handled by the &lt;code&gt;Actor&lt;/code&gt; constructor. By defult, the subclass&#39; constructor adds the character&#39;s actions and default action, with any miscellaneous modifications run through the &lt;code&gt;specialInit&lt;/code&gt; function (assuming it exists).

You can also define unique method functions here if you need them. By default, there&#39;s a getter and setter for the {{{en}}} property that, like the HP setter, is designed to keep it within bounds, and some functions for calculating XP requirements.

&lt;h3 id=&quot;JS.enemies&quot;&gt;Enemy Class&lt;/h3&gt;
Enemies are constructed similarly to puppets, with of course the major change that their {{{actions}}} property functions completely differently, as explained in [[Documentation (Basic)]]. However, their constructor has a few unique statements:
{{{
if (this.data.cooldown) { this.cd = new Map(Object.entries(this.data.cooldown)); }
}}}
You may recall that some enemies had a {{{cooldown}}} attribute in their entry. This statement extracts those values and assigns them to a Map, just as with elements and tolerances. This {{{cd}}} Map (short for &quot;cooldown&quot;) can then be checked with the {{{CDcheck}}} function.
{{{
this._noAttacks = Number.isInteger(this.data.noAttacks) &amp;&amp; this.data.noAttacks &gt; 0
	? new FillStat(this.data.noAttacks)
	: new FillStat(1);
}}}
Enemies also have a special handler for their {{{noAttacks}}} attribute. If the {{{noAttacks}}} property of their database entry is a positive integer, the constructor creates a {{{FillStat}}} equal to that number; otherwise, their {{{noAttacks}}} defaults to 1.
{{{
get noAttacks () {
	return this._noAttacks.currentVal;
}

set noAttacks (amt) {
	this._noAttacks.currentVal = amt;
}
}}}
This property assignment requires an underscore because the getters and setters for the enemy&#39;s {{{noAttacks}}} property point to the {{{FillStat}}}&#39;s {{{currentVal}}} property, rather than the {{{FillStat}}} itself.
{{{
if (setup.THREAT_TARGETING === true) {
	this.threat = new Map();
	puppets().forEach(function(puppet) {
		this.threat.set(puppet.name,puppet.initialThreat());
	}, this);
}
}}}
If your game uses threat targeting, enemies also generate a threat table with a value keyed to every puppet.
{{{
changeInto (name) {
	if (setup.enemyData[name].hp) {
		this.setMaxHP(setup.enemyData[name].hp);
	}
	if (setup.enemyData[name].stats) {
		for (let [pn,v] of Object.entries(setup.enemyData[name].stats)) {
			this.setBase(pn,v);
		}
	}
	if (setup.enemyData[name].actions) {
		this._actions = setup.enemyData[name].actions;
	}

	if (setup.enemyData[name].special) {
		setup.enemyData[name].special(this);
	}
}
}}}
Finally, there is the {{{changeInto}}} function. This is a quick way of modifying enemies, such as if they transform into another form with different stats or actions. You could define these alternate forms as entirely separate enemies and generate the new form with a constructor call, but that would overwrite all the enemy&#39;s current attributes, such as their active effects. {{{changeInto}}} allows the enemy to retain all attributes you do not change. The entries specified by the {{{name}}} argument are also entries in the database, as you can see in the entry for Big Dipper:
{{{
&quot;Big Dipper&quot;: {
	&quot;special&quot;: function (actor) {
		actor.idname = &quot;Dipper&quot;;
		actor.name = &quot;Big Dipper&quot;;
	},
	&quot;actions&quot;: function () {
	(...)
	}
}
}}}
Note the {{{idname}}} property here. You may recall from &lt;a class=&quot;noExternal&quot; href=&quot;#JS.actor&quot;&gt;the Actor class&lt;/a&gt; that this is used when fetching data from the database. The issue here is that but Big Dipper isn&#39;t a complete entry, as it&#39;s only intended to modify the base Dipper and I otherwise want to keep using the data from that entry -- but I do want the new name &quot;Big Dipper&quot; to display in battle, even though that will make the object point to this entry in the database. The solution is to make a new variable whose &lt;i&gt;only&lt;/i&gt; function is to serve as a pointer for the database entry. Now, the enemy the player sees can have the official name of &quot;Big Dipper&quot;, while still pointing to &quot;Dipper&quot; if it needs something that&#39;s not listed in &quot;Big Dipper&quot;.

We also define several other method functions for enemies.
* {{{decCD}}} is a quick way of decrementing cooldowns at the start of every turn.
* {{{CDcheck}}} is a quick way of determining if a cooldown action is available. It returns {{{true}}} if the cooldown is less than 0 and {{{false}}} otherwise.
* {{{surrenderCheck}}} checks if an action violates an enemy&#39;s surrender by checking against the action&#39;s {{{truce}}} property. Note that, by default, this includes actions that don&#39;t affect the enemy at all; they are smart enough to understand that the only reason you&#39;d be casting a buff is if you plan to attack them. You can change this logic if you want.
{{{
get priority () {
	if (this._priority === undefined) {
		return V().enemies.indexOf(this);
	} else {
		return this._priority;
	}
}
}}}
As a final note, here is the getter for the {{{priority}}} attribute. This determines what order enemies act in during the enemy turn. To set a unique priority value, you will need to assign a value to {{{_priority}}}; otherwise, the enemies default to acting in index order.

&lt;h3 id=&quot;JS.actions&quot;&gt;Action Class&lt;/h3&gt;
This class defines actions that characters use in battle. It should be quite straightforward, as unlike battling characters, action properties are almost always invariant and require little processing in the constructor or object itself. For more on how action properties are used, see &lt;a class=&quot;noExternal&quot; href=&quot;#actionphase&quot;&gt;the Action Phase&lt;/a&gt;.

There is also a subclass, {{{ItemAction}}}, that is used for consumable items. It functions in much the same way, but has a few different default values.

You may also want to look at the file {{{2_action functions.js}}}. This file contains several functions used to define common action code, such as adding an effect or dealing damage. This makes it easier to define actions. You can see it used in this example in the &quot;act&quot; property of the &quot;Sword&quot; entry: it was assigned the {{{justdmg}}} function, which, as the name implies, just does damage and nothing else. Corresponding preview code is stored under the {{{Prev}}} object as well. These are designed to be modular, and can be passed an {{{extension}}} argument to add additional functionality.

&lt;h3 id=&quot;JS.items&quot;&gt;Inventory and Items&lt;/h3&gt;
{{{
window.inv = function inv () {return V().inv;}
}}}
When working with items, the very first thing we want to do is define our inventory. We need an inventory to put items in, right? A lot of code references the inventory, so we need a standardized way to refer to it. That&#39;s this: the {{{inv()}}} function returns whatever your actual inventory variable is. By default, it&#39;s a story variable, but you could rename it or tie it to specific characters.
{{{
class Inventory extends Map {
	constructor(ItemArray){
		var m = [];
		ItemArray.forEach(function(item){
			m.push([item.name,item]);
		});
		super(m);
	}

	addItem (name,amt) {
		if (amt === undefined){
			amt = 1;
		}
		if (this.has(name)){
			if (this.get(name).stock + amt &gt; setup.ITEM_MAX) {
				let s = 1;
				while (((this.get(name).stock + 1) &lt; setup.ITEM_MAX) &amp;&amp; s &lt; amt) {
					this.get(name).stock += 1;
					s++;
				}
				return false;
			} else {
				this.get(name).stock += amt;
				return true;
			}
		} else {
			this.set(name,new Item(name,amt));
			return true;
		}
	}

	decItem (name,amt) {
		if (this.has(name)){
			if (amt === undefined){
				amt = 1;
			}
			var v = this.get(name);
			v.stock -= amt;
			if (v.stock &lt;= 0){
				this.delete(name);
			}
			return;
		} else {
			return &quot;ERROR in decItem: item name not found in inventory\n&quot;;
		}
	}
}
}}}
Then, we should probably define what functionality we want our &quot;inventory&quot; to have. The {{{Inventory}}} class extends the {{{Map}}} object, meaning it functions the same way: if you need to reference an item, you can just call up its name. However, we&#39;ve also added some method functions, and modified the constructor.
{{{
constructor(ItemArray){
	var m = [];
	ItemArray.forEach(function(item){
		m.push([item.name,item]);
	});
	super(m);
}
}}}
Instead of how you would normally construct a {{{Map}}} (an array of key/value pairs), you can construct an {{{Inventory}}} with just an array of items. The constructor will automatically extract the {{{name}}} attribute from the item and turn it into the key for that entry.
{{{
addItem (name,amt) {
	if (amt === undefined){
		amt = 1;
	}
	if (this.has(name)){
		if (this.get(name).stock + amt &gt; setup.ITEM_MAX) {
			let s = 1;
			while (((this.get(name).stock + 1) &lt; setup.ITEM_MAX) &amp;&amp; s &lt; amt) {
				this.get(name).stock += 1;
				s++;
			}
			return false;
		} else {
			this.get(name).stock += amt;
			return true;
		}
	} else {
		this.set(name,new Item(name,amt));
		return true;
	}
}
}}}
We also require special functionality for adding an item to the inventory. We run into the issue that if an item already exists in the {{{Inventory}}}, we only want to add to its {{{stock}}} value rather than creating a whole separate key. That&#39;s what this function checks for: if the {{{Inventory}}} already has the given item, it just increases the {{{stock}}} of that item, and if it doesn&#39;t, it makes a new entry with a {{{set}}} command.

We also include a check against {{{ITEM_MAX}}}. If adding the item to the inventory would exceed the item cap, we&#39;ll run a loop up to the value of {{{amt}}} and increment the item&#39;s stock by 1 each time until we reach the cap. This will allow the player to take as much as they can carry if they get a huge windfall of items, instead of getting nothing. The function will also return {{{false}}}, allowing your code to know that the player couldn&#39;t store all of the treasure. &lt;b&gt;Note that there&#39;s no corresponding code to automatically decrement the &quot;stock&quot; of a partially obtained treasure. For now, you will have to keep track of that manually.&lt;/b&gt;

(This assumes you want your inventory to function in this way, with items being &quot;stackable&quot;. Some games don&#39;t allow this, and make every item appear as its own instance in the inventory. If you want this kind of behavior, you could base {{{Inventory}}} on an {{{Array}}} instead, but be warned that it will be very hard to refer to an item after it&#39;s been added.)

There is a corresponding function, {{{decItem}}}, that operates similarly: it decreases {{{stock}}}, and deletes the item from the {{{Inventory}}} if there&#39;s none left. You can change this if you do want items to still appear even at 0 stock.

(If you ever want to completely clear an item, you can use {{{Map}}}&#39;s {{{.delete}}} function directly.)

Items themselves are constructed exactly like &lt;a class=&quot;noExternal&quot; href=&quot;#JS.actions&gt;actions&lt;/a&gt;: the class definition itself only defines getter functions to fetch data from a database, and the actual details of the items are defined in the {{{itemData}}} object.

&lt;h3 id=&quot;JS.support&quot;&gt;Support Functions&lt;/h3&gt;
There are several other useful functions storied in {{{1_support-functions.js}}} designed to make some common tasks easier.
{{{
window.target = function target () {return State.variables.B === undefined ? null : State.variables.B.target;};
window.subject = function subject () {return State.variables.B === undefined ? null : State.variables.B.subject;};
window.action = function action () {return State.variables.action;};
}}}
A big draw are these functions, which allow us to more conveniently access the active target, subject, and action in battle. You&#39;ll be seeing these a lot. (However, be aware that &lt;b&gt;you cannot use a function to call a variable for assignment.&lt;/b&gt; For example, you cannot say {{{target() = Object}}}. You must say {{{V().target = Object}}}.)
{{{
Map.prototype.inc = function (key,amt) {
	this.set(key,this.get(key)+amt);
	return;
}
}}}
This is a simple function added to the {{{Map}}} prototype, which means that all {{{Map}}}s we use will have access to it. This is a relative setter that &lt;i&gt;adds&lt;/i&gt; the passed value to to the value in the {{{Map}}}, as opposed to an absolute setter like the default {{{Map.set}}} function.
{{{
window.deadCount = function deadCount () {
	let count = 0;
	puppets().forEach(function(puppet) {
		if (puppet.dead) {
			count++;
		}
	});
	return count;
}
}}}
We have a function for quickly representing the number of defeated characters. This is useful when calculating &lt;a class=&quot;noExternal&quot; href=&quot;#victorycheck&quot;&gt;victory and defeat conditions&lt;/a&gt;.
{{{
window.puppets = function puppets () {
	return V().puppets.filter(function(p) { return p !== null });
}

window.enemies = function enemies () {
	return V().enemies.filter(function(p) { return p !== null });
}
}}}
These functions return party arrays with all {{{null}}} entries removed. This is helpful if you want to use the battle grid.
{{{
setup.textWidth = function(text, bold, size) {
    /* create the &lt;span&gt; to measure the text width */
	if (bold === undefined) {
		bold = &quot;normal&quot;;
	}
	else if (bold === true) {
		bold = &quot;bold&quot;;
	}
	if (size === undefined || typeof(size) != &#39;number&#39;) {
		size = &quot;12pt&quot;;
	} else {
		size = Number.toString(size) + &quot;px&quot;;
	}
    var tElement = jQuery(`&lt;span style=&quot;font-weight: ${bold}&quot;&gt;` + String(text) + &quot;&lt;/span&gt;&quot;);
    /* add it (hidden) to the end of the document&#39;s body so that
       the browser updates its width and we can save it */
    tElement.hide().appendTo(document.body);
    var width = tElement.width();
    /* clean up */
    tElement.remove();
    return width;
};

setup.scaledTextDiv = function(text, width, bold, size, print) {
    var tWidth = setup.textWidth(text, bold, size);
	if (print !== undefined) {
		text = print;
	}
    if (temporary().enemy !== undefined &amp;&amp; temporary().enemy.large) {
		return `&lt;div&gt;${text}&lt;/div&gt;`;
	} else if(tWidth &lt; width) {
        return `&lt;div style=&quot;width: ${width}px; overflow: hidden;&quot;&gt;&lt;span style=&quot;display: inline-block; white-space: nowrap;&quot;&gt;${text}&lt;/span&gt;&lt;/div&gt;`;
    } else {
        return `&lt;div style=&quot;width: ${width}px; overflow: hidden;&quot;&gt;&lt;span style=&quot;display: inline-block; white-space: nowrap; transform: translate(-50%, 0) scaleX(${width / tWidth}) translate(50%, 0);&quot;&gt;${text}&lt;/span&gt;&lt;/div&gt;`;
    }
};
}}}
These functions allow you to scale text to fit it within a certain width; the text will be compressed instead of overflowing or breaking its container. This is useful if you have variable elements displaying inside a container that must have a fixed width, such as the actor boxes. Though the code here is complicated, the function is simple to use: Simply pass the text you want to scale, the maximum width you wish to allow, whether or not the text is bold, its font size (in pt), and what you want the text to finally display if that&#39;s different than the original. (This is useful for, say, making links or other macros containing text we want scaled -- you can pass the text as the {{{text}}} argument and the macro as the {{{print}}} argument, and it will work.)
{{{
(function(window){
  // A full compatability script from MDN:
  var supportPageOffset = window.pageXOffset !== undefined;
  var isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;);

  // Set up some variables
  var statusbar;
  var noHorizontal;
  var noVertical;
  // Add an event to the window.onscroll event
  window.addEventListener(&quot;scroll&quot;, function(e) {

	statusbar = document.getElementById(&quot;status&quot;);
	noHorizontal = document.getElementById(&quot;noHorizontal&quot;);
	noVertical = document.getElementById(&quot;noVertical&quot;);

	// A full compatability script from MDN for gathering the x and y values of scroll:
	var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
	var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

	if (noHorizontal) {
		noHorizontal.style.left = -x + 1250 + &quot;px&quot;;
	}
	if (statusbar) {
		statusbar.style.left = -x + 1020 + &quot;px&quot;;
	}
	if (noVertical) {
		noVertical.style.top = -y + 50 + &quot;px&quot;;
	}
  });
})(window);
}}}
This function is designed to allow the status pane to scroll with the user&#39;s viewport. Currently, the offset numbers used in this function do not automatically scale to the width of the status or battle panes, and must be tweaked manually. Don&#39;t change them or the attributes of the {{{#status}}} element unless you know what you&#39;re doing.

{{{getActor}}} is discussed with &lt;a class=&quot;noExternal&quot; href=&quot;#chain&quot;&gt;the {{{&lt;&lt;chain&gt;&gt;}}} widget&lt;/a&gt;.

{{{reverseChildren}}} and {{{guardCheck}}} are discussed with [[the Battle Grid|Additional Features]].

&lt;h3 id=&quot;JS.serial&quot;&gt;Serialization and Save Files&lt;/h3&gt;
If you look at the end JS files, you may notice that every class has a variation on these two functions at the end:
{{{
&lt;Object&gt;.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new &lt;Object&gt;(this);
};

&lt;Object&gt;.prototype.toJSON = function () {
	// Return a code string that will create a new instance
	// containing our current data.
	const data = {};
    Object.keys(this).forEach(pn =&gt; data[pn] = clone(this[pn]));
    return JSON.reviveWrapper(&#39;new &lt;Object&gt;($ReviveData$)&#39;, data);
};
}}}
You may also notice that several classes have an odd addition to their constructors:
{{{
if (typeof(&lt;1st argument&gt;) == &#39;object&#39;){
	Object.keys(&lt;1st argument&gt;).forEach(prop =&gt; this[prop] = clone(&lt;1st argument&gt;[prop]));
}
}}}
These features are necessary to make custom classes work with Twine&#39;s save/load feature. Essentially, every time a save is loaded, the game must generate a completely new instance of every object via its constructor. The {{{toJSON()}}} function, which in turn depends on the {{{clone()}}} function, tells the program how to do this.

It would be a huge hassle to need to pass every single one of an object&#39;s properties to its constructor, so we can simplify things by instead passing it an object and assigning its properties to the new object. If this passed object is a clone of the old one, the new object will be reconstructed perfectly. However, we still want a &quot;normal&quot; constructor for constructing completely new objects. To accomplish both functionalities, we add {{{if (typeof(&lt;1st argument&gt;) == &#39;object&#39;)}}} to the start of the constructor, to branch its functionality. This tells the program that if we pass an object to the constructor instead of a normal variable, it should copy over that object&#39;s properties instead of going through the normal construction.

This is accomplished through {{{Object.keys(&lt;1st argument&gt;).forEach(prop =&gt; this[prop] = clone(&lt;1st argument&gt;[prop]))}}}. In English, this says, &quot;Assemble a list of every property name in the object passed as the 1st argument; then, for every one of those properties, clone the property in the passed argument and assign it to a property of the same name in this new object we&#39;re creating.&quot; Or, alternatively, &quot;Make this object a clone of the 1st argument.&quot; The only trick is that we need to do the exact same thing in the {{{toJSON()}}} function to create an object to pass to the revival method, because just passing the existing object ({{{this}}}) to {{{reviveWrapper()}}} will create an error.

(If our custom object doesn&#39;t reference any custom objects itself, we can use the shorter {{{Object.assign(this,&lt;1st argument&gt;)}}}. However, this method ensures all properties are cloned correctly too, so it is best to use it just to be safe.)

&lt;b&gt;Warning:&lt;/b&gt; Arrays return &#39;object&#39; when passed to {{{typeof()}}}. If you want your normal constructor to read an array, you will need to use {{{instanceof Array}}} instead.

&lt;h3 id=&quot;JS.updates&quot;&gt;What if we want to update something in a new version?&lt;/h3&gt;
Let&#39;s say one of your beta testers discovers an action or item is incredibly gamebreaking. Not a problem, you say, you&#39;ll just tweak some values in the database and all new games will use those values instead. But wait! People who are already playing the game and have the old version saved will still have the old values! How can you ensure they get updated too?

The structure of the database actually means this won&#39;t be a problem. We tie action, effect, and item data to the {{{setup}}} variable, which exists independently of save game states. It is specifically designed for exactly this scenario -- any changes to {{{setup}}} will be reflected in existing saves, no additional modification necessary. You should use {{{setup}}} for any variables you intend to remain constant throughout a playthrough.

But what if you need to change something that isn&#39;t part of {{{setup}}}? Let&#39;s say you realize you made a typo in a variable adjustment when writing the consequences for a certain choice the player can make during the course of the game. Well, don&#39;t worry, you can fix that too.
{{{
Config.saves.onLoad = function (save) {
	switch (save.version){
			// You would make a case for older version numbers, and adjust variables as necessary. If you&#39;ve made variable changes since that would cause conflicts with the save, you can update them here.
		case 0:
			/*
			save.version++;
			save.state.history.forEach(function (moment) {
				//Access story variables through moment.variables
			});
			*/
		default:
			// all is (hopefully) well, do nothing
	}
};
}}}
In the {{{0_config.js}}} file, you will see this. {{{onLoad}}} is a function built into SugarCube that is called before loading any save, and is particularly useful for updating saves to current versions. The save game version (which you can set with {{{Config.saves.version}}}) is placed into a {{{switch}}} statement here, allowing you to run unique code depending on the version. You&#39;ll want to increment the save version in each case so you don&#39;t keep running the same code every time you load a save in your current version. (Note that this is distinct from the official version number you would display in the game itself; you only need to update the save version when you need to make another case for {{{onLoad}}}.)

There is one trick involved here. See, you can&#39;t access the variables in a save through the normal {{{variables()}}} and {{{temporary()}}} functions, because those only refer to the &lt;i&gt;existing&lt;/i&gt; story state. To modify a save, you have to call the variables in each {{{moment}}} of its {{{history}}} attribute. This code has already written out how to do that for you: Run a {{{forEach}}} loop over the save&#39;s {{{history}}}, and then modify the {{{variables}}} of each {{{moment}}} in the {{{history}}}. It may sound complicated, but other than that wrapper, you can access and modify variables the same way you would otherwise.

I recommend copying this code to a new case every time you make an update function so you don&#39;t forget it.

&lt;h2 id=&quot;display&quot;&gt;Display and aesthetics&lt;/h2&gt;
[img[setup.ImagePath + &quot;documentation/002.PNG&quot;]]

Visual display -- the color and placement of the text, the borders around blocks, and the positioning of elements -- is determined by the &lt;b&gt;story stylesheet&lt;/b&gt;, which can be accessed by clicking on the story title in the editor. This stylesheet uses a different coding language than Twine&#39;s script: CSS, or &lt;b&gt;Cascading Style Sheets&lt;/b&gt;.

By default, the content width is optimized for three-character parties, so you may want to extend it if you are looking for larger party sizes. With more advanced CSS elements, such as a grid, you could even incorporate features like a battle map where characters can move in two-dimensional space.

If you didn&#39;t understand any of that, don&#39;t worry! You don&#39;t need to know CSS to use the engine, just if you want to make it look different.

&lt;h3 id=&quot;statusdisplay&quot;&gt;Displaying the status pane&lt;/h3&gt;
{{{
&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;span id=&quot;actorlist&quot;&gt;
&lt;&lt;include &quot;actorlist&quot;&gt;&gt;
&lt;/span&gt;
&lt;div id=&quot;phase&quot;&gt;

&lt;/div&gt;
&lt;/span&gt;
}}}
This is the body code for the &quot;Battle!&quot; passage. We&#39;ll get more into the rest later, but for now, just notice that the status pane is in a separate {{{&lt;span&gt;}}} from everything else. This is necessary to get it to display in its proper spot, directly to the right of the battle content. The stylesheet code responsible for the correct display can be seen here:
{{{
.passage.battle {
  width: 1030px;
}

#content {
	float: left;
	width: 640px;
	border: dotted 1px;
	padding: 1em;
}

#status {
	float: right;
	width: 300px;
	min-height: 300px;
	padding: 1em;
	border-left: 1px solid;
	font-weight: bold;
}
}}}
The key component here is that &lt;b&gt;the passage itself&lt;/b&gt; is set to be wider than the {{{#content}}} and {{{#status}}} widths together. If you don&#39;t do this, the two sections will crash into each other and display on separate lines, like so:

[img[setup.ImagePath + &quot;documentation/003.PNG&quot;]]

Note, however, that this width is only fixed in passages tagged &quot;battle&quot;. In all other passages, the passage width will scale to fit the resolution of the screen. This makes things easier for smaller monitors, but you&#39;ll need to make sure to tag any passage where you want to the status pane to display.

You can tweak the widths in the stylesheet depending on your preferences.

&lt;h3 id=&quot;nobr&quot;&gt;The nobr tag&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/004.PNG&quot;]]

You may notice a gray {{{nobr}}} tag at the top of several passages. &lt;b&gt;These are really important for preventing unwanted whitespace.&lt;/b&gt; Twine parses all line breaks by default, even when you only use them to organize code. To make your code readable without creating tons of empty lines in the process, you&#39;ll need to use {{{nobr}}}. The downside to this is that when you &lt;i&gt;do&lt;/i&gt; want a line break, you will need to add it manually with the {{{&lt;br/&gt;}}} tag.

&lt;h3 id=&quot;pronouns&quot;&gt;Personalized text&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/005.PNG&quot;]]

So English has these annoying things called &quot;gendered pronouns&quot;. As you can see in the above example from an earlier version of the engine, they make natural-sounding system text a little tricky.

I tried to sidestep this issue by avoiding pronouns entirely in system messages, but eventually gave up and defaulted to the gender-neutral &quot;they&quot;. This is great for &lt;i&gt;Cartoon Battle&lt;/i&gt;&#39;s genderless puppets, but sounds awkward when applied to other characters; not to mention you may want to have characters go up against animals or monsters, for whom &quot;it&quot; pronouns may be more appropriate.
{{{
getPronouns (type) {
	if (typeof(type) == &#39;string&#39;) {
		var pr;
		switch(this.gender.toLowerCase()) {
			case &#39;f&#39;:
			case &#39;female&#39;:
				pr = {obj: &quot;her&quot;, subj: &quot;she&quot;, pos: &quot;her&quot;};
				break;
			case &#39;m&#39;:
			case &#39;male&#39;:
				pr = {obj: &quot;him&quot;, subj: &quot;he&quot;, pos: &quot;his&quot;};
				break;
			case &#39;n&#39;:
			case &#39;neuter&#39;:
			case &#39;neutral&#39;:
			case &#39;agender&#39;:
				pr = {obj: &quot;them&quot;, subj: &quot;they&quot;, pos: &quot;their&quot;};
				break;
			default:
				pr = {obj: &quot;it&quot;, subj: &quot;it&quot;, pos: &quot;its&quot;};
		}
		var result = pr[type];
		if (result === undefined) { console.log(&quot;ERROR in getPronouns: invalid pronoun type&quot;); }
		return result;
	}
	else {
		console.log(&quot;ERROR in getPronouns: no pronoun type passed&quot;);
		return undefined;
	}
}

get them () {
	return this.getPronouns(&quot;obj&quot;);
}

get they () {
	return this.getPronouns(&quot;subj&quot;);
}

get their () {
	return this.getPronouns(&quot;pos&quot;);
}

get theyare () {
	switch (this.they) {
		case &quot;they&quot;:
			return &quot;they are&quot;;
		default:
			return (this.they + &quot; is&quot;);
	}
}
}}}
To solve this, I made gender an accessible attribute of characters, and getter functions for determining each type of pronoun.

Twine will automatically print naked variables, so to use them you can just place them in text like this: {{{_subject.name swings _subject.their sword!}}} That will evaluate to &quot;Ros swings their sword!&quot; if {{{_subject}}}&#39;s pronouns are set to neutral, or &quot;Monster swings its sword!&quot; if {{{_subject}}}&#39;s pronouns are default, and so on.

&lt;h3 id=&quot;healthbars&quot;&gt;Health Bar Formatting&lt;/h3&gt;
Battling characters have health bars, provided by &lt;a href=&quot;https://twinelab.net/custom-macros-for-sugarcube-2/#/meter-macros&quot; target=&quot;_blank&quot;&gt;Chapel&#39;s meter macro set.&lt;/a&gt; You can define the color of the enemy and player bars in StoryInit; by default, they are set to red and green, respectively. If you want to edit the meter&#39;s appearance further, you can find the macro in {{{bundle.js}}}, the source code for all of Chapel&#39;s custom macros. Find this section:
{{{
var $wrapper = $(document.createElement(&#39;div&#39;))
    .addClass(&#39;chapel-meter&#39;)
    .attr({
        &#39;data-val&#39; : value,
        &#39;data-label&#39; : this.settings.label
    })
    .css({
        &#39;position&#39; : &#39;relative&#39;,
        &#39;background-color&#39; : this.settings.back,
        &#39;height&#39; : this.settings.height,
        &#39;width&#39; : this.settings.width,
        &#39;overflow&#39; : &#39;hidden&#39;,
		&#39;border-radius&#39; : &#39;3px&#39;
    });
}}}
You can edit the {{{.css}}} attribute here to add any CSS formatting you wish to the meter. Just understand that the attribute names and values must both be strings (so, in quotes). Here, you can see that I have added a {{{border-radius}}} attribute to the default formatting, which is what gives the meters their rounded look. If you prefer them more angular, you can remove that attribute.

&lt;h3 id=&quot;battlestyle&quot;&gt;Special Aesthetics for Battles&lt;/h3&gt;
There may be instances where you want certain battles to look different. Maybe the player is fighting a scary enemy in a dark room, and you find that the engine&#39;s default bright white background undercuts the atmosphere.

There is functionality for this in the &quot;Preparation&quot; passage, called before all battles:
{{{
&lt;&lt;callEncounter $scenario&gt;&gt;
&lt;&lt;if typeof($B.style) == &#39;string&#39;&gt;&gt;
	&lt;&lt;addclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
If you set the {{{style}}} property in the encounter call or anywhere else, the code will add that class to the story document. You can add whatever formatting you want to this class or others in the stylesheet files. In the default engine, the &quot;dark&quot; class has the following format:
{{{
html.dark body
{
  background-color:#111;
  color:#fff;
}
}}}
This is the default SugarCube style: white text on a dark gray background.

&lt;b&gt;NOTE:&lt;/b&gt; Modifying the document in this way affects the entire story, not just the current passage. This is &lt;b&gt;good&lt;/b&gt; for our purposes, because the battle engine actually consists of multiple passages. This way, we don&#39;t need to worry about the custom formatting disappearing on passage jumps. &lt;b&gt;However,&lt;/b&gt; you will need to undo this change if you don&#39;t want the story to keep looking like the custom format for the rest of the game. This is handled through the {{{&lt;&lt;endofbattle&gt;&gt;}}} widget:
{{{
&lt;&lt;if $B.style&gt;&gt;
	&lt;&lt;addclass &quot;body&quot; $B.style&gt;&gt;
	&lt;&lt;removeclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
(Why add the class to the {{{body}}} element first? Because otherwise, there will be a &quot;flicker&quot; of default formatting in the victory passage before the player is forwarded to the next passage. Unlike {{{html}}}, the {{{body}}} element is refreshed between passages, so this still removes the styling while ensuring a smoother transition.)

&lt;h3 id=&quot;savesmodifier&quot;&gt;Modifying the Save Display&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/default_save.PNG&quot;]]
By default, SugarCube uses a passage excerpt to describe a save in the save menu. This is useful for most text adventure games, where there is little else to worry about other than the player&#39;s position in the story.
&lt;&lt;nobr&gt;&gt;
&lt;center&gt;
&lt;figure&gt;
	&lt;img @src=&quot;setup.ImagePath+&#39;documentation/sojourner_save.PNG&#39;&quot; /&gt;
	&lt;figcaption&gt;
	&lt;span style=&quot;font-size:10pt&quot;&gt;(Screenshot from &lt;i&gt;Sojourner&lt;/i&gt;, taken by myself)&lt;/span&gt;
	&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/center&gt;&lt;&lt;/nobr&gt;&gt;In an RPG, there are potentially many more variables that are relevant to the player, beyond just the current location or chapter in the story. This screenshot (from an RPG Maker VX Ace game) is an extreme example, with a very large save screen that contains a lot of information. Some of this information you may consider extraneous, but the party level, composition, and finances are likely relevant when remembering which save to choose.
[img[setup.ImagePath + &quot;documentation/custom_save.PNG&quot;]]
I think you will agree that this save file is a lot more informative than the default, even if it isn&#39;t as huge as RPG Maker&#39;s! By default, Another RPG Engine&#39;s custom save display shows the major area (set through the {{{currentArea}}} story variable), the party&#39;s GP, and the current party composition and the levels of each.

How is this constructed, and what must you do if you wish to add, subtract, or modify information for your own game? Well, it turns out that&#39;s a bit tricky. The description of a save file object can&#39;t be modified through SugarCube directly. We have to devise a workaround using JavaScript.
{{{
(function() {
	// Add metadata to saves.
	Save.onSave.add(function (save) {
		var active = save.state.history[save.state.index];
		save.metadata = {
			area	: active.variables.currentArea,
			party	: active.variables.puppets.filter(function (p) { return p !== null; }),
			money	: active.variables.currency
		};
	});

	// Create save description from metadata.
	function createSaveDescription(metadata) {
		var desc = `&lt;div class=&quot;save-desc monospace&quot;&gt;&lt;div class=&quot;save-left&quot;&gt;`;

		if (metadata.area !== undefined) { desc += `&lt;span class=&quot;save-area&quot;&gt;${metadata.area}&lt;/span&gt;`; }
		if (metadata.money !== undefined) { desc += `&lt;span class=&quot;save-money&quot;&gt;${setup.CURRENCY_NAME}: ${metadata.money}&lt;/span&gt;`; }
		desc += `&lt;/div&gt;`;
		if (metadata.party !== undefined) {
			desc += `&lt;span class=&quot;save-party&quot; style=&quot;min-width:${setup.PORTRAIT_SIZE*setup.PARTY_SIZE}px;&quot;&gt;`;
			metadata.party.forEach(function(puppet) {
				desc += `&lt;div style=&quot;display:inline-flex; flex-direction:column;&quot;&gt;&lt;span class=&quot;save-puppet&quot; style=&quot;width:${setup.PORTRAIT_SIZE}px; height:${setup.PORTRAIT_SIZE}px;&quot;&gt;`;
				if (setup.SHOW_PORTRAITS === true &amp;&amp; puppet.portrait !== undefined) {
					desc += `&lt;img src=&quot;${puppet.portrait}&quot; /&gt;`;
				} else {
					desc += `${puppet.portrait}`;
				}
				desc += `&lt;/span&gt;LV ${puppet.level}&lt;/div&gt;`;
			});
			desc += &#39;&lt;/span&gt;&#39;;
		}

		return desc+`&lt;/div&gt;`;
	}

	// Modify native Save dialog descriptions upon opening the dialog.
	if (true) {
		$(document).on(&#39;:dialogopening&#39;, function () {
			if ($(&#39;#ui-dialog-body&#39;).hasClass(&#39;saves&#39;)) {
				$(&#39;#ui-dialog-body.saves tr&#39;).each(function (_, el) {
					var $tr = $(el);
					var $load = $tr.find(&#39;button.load:not([disabled])&#39;);

					if ($load.length === 0) {
						return;
					}

					var slot = $load.attr(&#39;id&#39;).split(&#39;-&#39;)[2];
					var save = slot === &#39;auto&#39;
						? Save.autosave.get()
						: Save.slots.get(Number(slot));

					if (save !== null &amp;&amp; typeof(save.metadata) == &#39;object&#39;) {
						$tr.find(&#39;td&gt;div:first-child&#39;)
							.empty()
							.append(createSaveDescription(save.metadata));
					}
				});
				// Refresh the custom display when deleting saves
				$(&#39;#ui-dialog-body.saves button.delete&#39;).on(&#39;click&#39;, function () {
					$(document).trigger(&#39;:dialogopening&#39;);
				});
			}
		});
	}
})();
}}}
That is the purpose of this function, found in {{{saves-modifier.js}}} and authored by TheMadExile. There are three components here, but we will only cover the first two. (The third function, in a nutshell, alters the content of the HTML element holding the save description when the save menu is opened. You shouldn&#39;t need to touch it unless you really know what you&#39;re doing.)
{{{
	Save.onSave.add(function (save) {
		var active = save.state.history[save.state.index];
		save.metadata = {
			area	: active.variables.currentArea,
			party	: active.variables.puppets.filter(function (p) { return p !== null; }),
			money	: active.variables.currency,
		};
	});
}}}
The first thing we need to do is record the data we want to use in our display. Fortunately, SugarCube saves have a property just for this kind of thing, called {{{metadata}}}. This function extracts the variables from the currently active moment of the story (so, the most current passage) and allows us to store them however we wish as properties of {{{metadata}}} when a save is made. By default, we store information for the area, the active party, and the player&#39;s money.
{{{
function createSaveDescription(metadata) {
	var desc = `&lt;div class=&quot;save-desc monospace&quot;&gt;&lt;div class=&quot;save-left&quot;&gt;`;

	if (metadata.area !== undefined) { desc += `&lt;span class=&quot;save-area&quot;&gt;${metadata.area}&lt;/span&gt;`; }
	if (metadata.money !== undefined) { desc += `&lt;span class=&quot;save-money&quot;&gt;${setup.CURRENCY_NAME}: ${metadata.money}&lt;/span&gt;`; }
	desc += `&lt;/div&gt;`;
	if (metadata.party !== undefined) {
		desc += `&lt;span class=&quot;save-party&quot; style=&quot;min-width:${setup.PORTRAIT_SIZE*setup.PARTY_SIZE}px;&quot;&gt;`;
		metadata.party.forEach(function(puppet) {
			desc += `&lt;div style=&quot;display:inline-flex; flex-direction:column;&quot;&gt;&lt;span class=&quot;save-puppet&quot; style=&quot;width:${setup.PORTRAIT_SIZE}px; height:${setup.PORTRAIT_SIZE}px;&quot;&gt;`;
			if (setup.SHOW_PORTRAITS === true &amp;&amp; puppet.portrait !== undefined) {
				desc += `&lt;img src=&quot;${puppet.portrait}&quot; /&gt;`;
			} else {
				desc += `${puppet.portrait}`;
			}
			desc += `&lt;/span&gt;LV ${puppet.level}&lt;/div&gt;`;
		});
		desc += &#39;&lt;/span&gt;&#39;;
	}

	return desc+`&lt;/div&gt;`;
}
}}}
{{{createSaveDescription}}} is where we construct the custom description itself, based on the metadata from the save. You &lt;i&gt;could&lt;/i&gt; just plunk all the data in raw, but that wouldn&#39;t look very nice. We use HTML elements to construct the description piece by piece, and then return the full HTML code when we&#39;re done.

You can see the CSS used to make the save display presentable in {{{saves desc.css}}}. Some of it&#39;s pretty complicated, so don&#39;t mess with it unless you know what you&#39;re doing! In particular, the default party display looks ugly because the default characters don&#39;t have portraits or other associated art &lt;del&gt;because I can&#39;t draw&lt;/del&gt;. You should probably use portraits or other representative images for your party members; this is better than using their names, because with images, you can ensure a consistent size that won&#39;t break the display. (By default, the space provided for each character is 50 pixels square; you can change this through the {{{PORTRAIT_SIZE}}} variable in StoryInit.) You may also want to set the caps on currency and level with care, as there is currently no handler for overflow if the numbers get too large and exceed their expected dimensions.

&lt;h3 id=&quot;animationsDoc&quot;&gt;Animations&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/AnimExample.gif&quot;]]
Animations give a sense of life to the otherwise still world of a text-based video game. They&#39;re a great way to make your game more exciting and engaging. In this section, you&#39;ll learn how they&#39;re implemented in this engine, and how you can customize your own animations.

&lt;h4 id=&quot;animations.design&quot;&gt;Designing the Animations&lt;/h4&gt;
The animations are coded through CSS. In addition to letting you customize the properties of HTML elements, CSS can also change properties dynamically with animations. The animations used in the default engine are modified from animations provided by &lt;a href=&quot;https://animate.style/&quot; target=&quot;_blank&quot;&gt;animate.css&lt;/a&gt;, a free set of excellent CSS animations. The complete set of animations is included in the {{{stylesheets}}} folder, with the modified animations in {{{custom animations.css}}}. (Redefining the same animation name with different properties will overwrite it, provided the version you want in the final product comes last in compilation order.) In particular, I used modified forms of the &quot;headShake&quot;, &quot;slideOutUp&quot;, and &quot;slideOutDown&quot; animations.

For more information on how to design your own animations, see &lt;a href=&quot;https://www.w3schools.com/css/css3_animations.asp&quot; target=&quot;_blank&quot;&gt;this guide by w3schools&lt;/a&gt;.

&lt;h4 id=&quot;animations.setup&quot;&gt;Setup&lt;/h4&gt;
To begin with, you&#39;re going to need to see how the animations are set up. This is done in the {{{action effects}}} passage.
{{{
&lt;&lt;set _queue = new Set()&gt;&gt;
}}}
To begin with, we define this variable before we run any action code. It is a temporary variable, so we don&#39;t have to worry about it accidentally bleeding information over to the next passage. We define it as a {{{Set}}} object; this is an iterable container object like an array, but with the distinction that &lt;b&gt;all its elements must be unique&lt;/b&gt; -- it cannot contain duplicates. If you try to add a duplicate element, nothing will happen. This is exactly what we want for the {{{_queue}}} object, because we will be using it to store every character we want to animate. A {{{Set}}} allows us to run general code for adding a character to the {{{_queue}}} for everything that would trigger an animation, without duplicating them if e.g. they were hit multiple times by the same attack.
{{{
&lt;&lt;if $ANIMATIONS === true &amp;&amp; _queue.size &gt; 0&gt;&gt;
&lt;div class=&quot;actors animationContainer&quot;&gt;
&lt;&lt;set _animationActive = true&gt;&gt;

&lt;&lt;for _i, _p range _queue&gt;&gt;
  &lt;div style=&quot;position:relative&quot;&gt;
    &lt;div @id=&quot;&#39;box&#39;+_i&quot; style=&quot;display:inline-block&quot;&gt;
		&lt;&lt;capture _p&gt;&gt;
		&lt;&lt;liveblock&gt;&gt;
    	&lt;&lt;actorBox _p &quot;&quot; &quot;simplified&quot;&gt;&gt;
		&lt;&lt;/liveblock&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
    &lt;/div&gt;
		&lt;&lt;for _x, _m range _p.battleMsg&gt;&gt;
	    &lt;div @id=&quot;&#39;dmg&#39;+_i+&#39;-&#39;+_x&quot; class=&quot;dmgPopup&quot;&gt;
				&lt;&lt;print _m.content&gt;&gt;
	    &lt;/div&gt;
		&lt;&lt;/for&gt;&gt;
  &lt;/div&gt;
&lt;&lt;/for&gt;&gt;

&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then comes the animation block. Note that this code is run &lt;i&gt;after&lt;/i&gt; the action code is run, even though in the final passage it&#39;s displayed first; this is due to the {{{order}}} property, which allows flexbox elements to be displayed in a different order than in the code. In this case, we need to run the action code first to collect data that we need for the animations.
{{{
&lt;&lt;if $ANIMATIONS === true &amp;&amp; _queue.size &gt; 0&gt;&gt;
}}}
First, we only run this if the user has allowed it through the {{{ANIMATIONS}}} variable (defined in {{{StoryInit}}}), and if there are characters in the {{{_queue}}}. Some actions don&#39;t target anyone, in which case there&#39;s no need for an animation.
{{{
&lt;div class=&quot;actors animationContainer&quot;&gt;
&lt;&lt;set _animationActive = true&gt;&gt;
}}}
We want the animation lineup to look similar to the character lineup in the normal battle display, so we use the same container class, but with an additional {{{animationContainer}}} class that will allow us to specify custom details in the stylesheet. We also set an {{{_animationActive}}} flag, which we will use later.
{{{
&lt;&lt;for _i, _p range _queue&gt;&gt;
  &lt;div style=&quot;position:relative&quot;&gt;
    &lt;div @id=&quot;&#39;box&#39;+_i&quot; style=&quot;display:inline-block&quot;&gt;
		&lt;&lt;capture _p&gt;&gt;
		&lt;&lt;liveblock&gt;&gt;
    	&lt;&lt;actorBox _p &quot;&quot; &quot;simplified&quot;&gt;&gt;
		&lt;&lt;/liveblock&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
    &lt;/div&gt;
		&lt;&lt;for _x, _m range _p.battleMsg&gt;&gt;
	    &lt;div @id=&quot;&#39;dmg&#39;+_i+&#39;-&#39;+_x&quot; class=&quot;dmgPopup&quot;&gt;
				&lt;&lt;print _m.content&gt;&gt;
	    &lt;/div&gt;
		&lt;&lt;/for&gt;&gt;
  &lt;/div&gt;
&lt;&lt;/for&gt;&gt;
}}}
The contents are generated similarly to &lt;a class=&quot;noExternal&quot; href=&quot;#actorlistDoc&quot;&gt;the actor list&lt;/a&gt;, generating an {{{&lt;&lt;actorBox&gt;&gt;}}} for every character in the {{{_queue}}}. We also run a second loop over the character&#39;s {{{battleMsg}}} attribute, which is an array containing information for every message we want to pop up during the animation, and generate another element for each message. (These elements are invisible by default, as a property of the {{{dmgPopup}}} class. We will make them visible only when the animation begins.) Note that we need to tag each one of these elements with a unique ID, as we will need to be able to reference them later to trigger the animation.
{{{
&lt;&lt;liveblock&gt;&gt;
	&lt;&lt;actorBox _p &quot;&quot; &quot;simplified&quot;&gt;&gt;
&lt;&lt;/liveblock&gt;&gt;
}}}
We also wrap each {{{&lt;&lt;actorBox&gt;&gt;}}} in a {{{&lt;&lt;liveblock&gt;&gt;}}} macro so it can be updated dynamically during the animation.
{{{
&lt;&lt;set target().battleMsg.push({shake: true, type: &quot;damage&quot;, content:$dmg})&gt;&gt;
}}}
Messages themselves are set up when the action executes; for example, here is a line of code from the {{{&lt;&lt;echoDamage&gt;&gt;}}} widget. (This is why we need the action code to execute first.) Each message contains three important attributes that determine how it will appear: the type (damage, healing, effect, etc.), the content (the text that will display in the popup), and whether or not it makes the actor box shake. By default, negative effects (taking damage, gaining ailments, losing buffs) all make the box shake, to simulate being hit by an attack. Positive effects (healing, gaining buffs, losing ailments) just display the popup with no shake.

&lt;h4 id=&quot;animations.execution&quot;&gt;Execution&lt;/h4&gt;
The control code for animations is called in a special passage, {{{PassageDone}}}. {{{PassageDone}}} executes only after the passage has finished rendering, which is important for ensuring there are no glitches in animation delays due to passage load times. The animation controller itself is stored in the file &quot;battle animations&quot;.
{{{
&lt;&lt;set _animationsToComplete = 0&gt;&gt;
&lt;&lt;set _animationsComplete = 0&gt;&gt;
}}}
The first thing we do is define the {{{_animationsToComplete}}} and {{{_animationsComplete}}} variables. This allows us to track when all animations are complete, which we will need to know later.
{{{
&lt;&lt;timed setup.ANIM_WINDUP+&quot;ms&quot;&gt;&gt;
}}}
The main animation code is wrapped in this {{{&lt;&lt;timed&gt;&gt;}}} block. This gives the player a moment to absorb the information of the new action before the animation begins, and also to offset the time taken to load the passage. {{{ANIM_WINDUP}}} is set to 750 milliseconds by default, but you can change it in {{{StoryInit}}}.
{{{
&lt;&lt;for _i, _p range _queue&gt;&gt;
	&lt;&lt;set _idA = &quot;#box&quot;+_i&gt;&gt;
	&lt;&lt;capture _idA, _p&gt;&gt;
    &lt;&lt;for _x, _m range _p.battleMsg&gt;&gt;
			&lt;&lt;set _idB = &quot;#dmg&quot;+_i+&#39;-&#39;+_x&gt;&gt;
			&lt;&lt;capture _x, _idB, _m&gt;&gt;
			&lt;&lt;if _m.shake&gt;&gt; /* if true, box shakes */
				&lt;&lt;set _time = (_x*(setup.ANIM_DURATION+400))+&quot;ms&quot;&gt;&gt;
				&lt;&lt;timed _time&gt;&gt;
					&lt;&lt;run animateCSS(_idA,&quot;headShake&quot;,setup.ANIM_DURATION+&quot;ms&quot;)&gt;&gt;
					&lt;&lt;include &quot;popup animation&quot;&gt;&gt;
				&lt;&lt;/timed&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set _time = (_x*500)+&quot;ms&quot;&gt;&gt;
				&lt;&lt;timed _time&gt;&gt;
					&lt;&lt;include &quot;popup animation&quot;&gt;&gt;
				&lt;&lt;/timed&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
    &lt;&lt;/for&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;&lt;set _animationsToComplete += _p.battleMsg.length&gt;&gt;
	&lt;&lt;set _p.battleMsg = []&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
The animations are activated through two nested loops: Once over every character in the {{{_queue}}} variable, and then over every message in those characters&#39; {{{battleMsg}}} attributes. At the end of every loop, we add the number of messages the character carried to a running total in {{{_animationsToComplete}}}, and reset the {{{battleMsg}}} attribute to an empty array so no messages are erroneously carried over into the next turn.

Now, to get the timing right on the animations, we have to think carefully. This entire block of code, like everything else, will be executed as soon as the passage loads at the speed of the computer&#39;s processor (very fast). If we simply trigger the animation within each loop, they will all execute at once, making all the messages overlap each other in a sloppy mess.
{{{
&lt;&lt;set _time = (_x*500)+&quot;ms&quot;&gt;&gt;
&lt;&lt;timed _time&gt;&gt;
}}}
To stagger the messages, we need to use {{{&lt;&lt;timed&gt;&gt;}}} macros, but here is the key: the code for the &lt;i&gt;creation&lt;/i&gt; of the {{{&lt;&lt;timed&gt;&gt;}}} macros executes at the same time as everything else; that is, near-instantaneously. If we use the same delay for every {{{&lt;&lt;timed&gt;&gt;}}} macro, they&#39;ll all go off at the same time, defeating the purpose of staggering them. To space them out properly, we need to increment the delay with every loop by multiplying the index variable (the current iteration number) by some constant. This will near-simultaneously create a {{{&lt;&lt;timed&gt;&gt;}}} macro with a delay of 500ms, then another of 1000ms, and so on, creating {{{&lt;&lt;timed&gt;&gt;}}} macros that trigger 500ms apart.

Note that for messages that make the actor shake, we use a longer delay time. This is because we have to make sure the shake animation completes before we trigger it again. If an animation is reactivated before it completes, it may behave strangely or simply not trigger again.
{{{
&lt;&lt;set _animation = &quot;slideOutUp&quot;&gt;&gt;
&lt;&lt;switch _m.type&gt;&gt;
	&lt;&lt;case &quot;damage&quot;&gt;&gt;
		&lt;&lt;set _p.hp -= _m.content&gt;&gt;
	&lt;&lt;case &quot;healing&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;green&quot;)&gt;&gt;
		&lt;&lt;set _p.hp += _m.content&gt;&gt;
	&lt;&lt;case &quot;block&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
	&lt;&lt;case &quot;addEffect&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;stat-raised&quot;)&gt;&gt;
	&lt;&lt;case &quot;removeEffect&quot;&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;small&quot;)&gt;&gt;
		&lt;&lt;run $(_idB).addClass(&quot;maroon&quot;)&gt;&gt;
		&lt;&lt;set _animation = &quot;slideOutDown&quot;&gt;&gt;
&lt;&lt;/switch&gt;&gt;
&lt;&lt;update&gt;&gt;
&lt;&lt;if typeof(_m.mod) == &quot;string&quot;&gt;&gt;
	&lt;&lt;run $(_idB).addClass(_m.mod)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _animationsComplete++&gt;&gt;
&lt;&lt;run animateCSS(_idB,_animation,setup.DMG_DURATION+&quot;ms&quot;)&gt;&gt;
}}}
Here is the code for the popup animation specifically. The code reads the {{{type}}} attribute of the message to determine its behavior, adds any classes specified in the message&#39;s {{{mod}}} attribute (if it has one), and increments {{{_animationsComplete}}}. By default, healing numbers are colored green, added effects are colored blue, and removed effects are colored maroon. (Elemental weaknesses and resistances are also marked with special colors, which you can see in {{{&lt;&lt;echoDamage&gt;&gt;}}}.)

&lt;b&gt;Note that HP adjustments for damage and healing are only done here and not in the action code itself.&lt;/b&gt; This is to create the appearance of the actor box dynamically updating to reflect the results of each hit. However, because this code takes place inside a {{{&lt;&lt;timed&gt;&gt;}}} block, &lt;b&gt;it will not execute if the player leaves the passage before the animation triggers&lt;/b&gt;.

&lt;h4 id=&quot;animations.disabling&quot;&gt;Disabling the Continue Button&lt;/h4&gt;
To ensure the above glitch doesn&#39;t happen, we need to prevent the player from moving to the next passage until all the animations complete.
{{{
&lt;&lt;if $(&quot;#continue&quot;) !== undefined&gt;&gt;
	&lt;&lt;script&gt;&gt;
	$(&quot;#continue .macro-button&quot;).each((index, element) =&gt; {
			element.disabled = true;
		});
	&lt;&lt;/script&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
That&#39;s done through this code, run at the start of the animation activator. This script uses jQuery to select the continue button (which we have tagged with the {{{#continue}}} ID) and disables it, preventing it from being clicked by the player.

However, we can&#39;t just end it there; otherwise, the player will never be able to click the continue button, and they&#39;ll be stuck!
{{{
function handleAnimationEnd() {
	node.classList.remove(`${prefix}animated`, animationName);
	if ($(&#39;#continue&#39;) !== undefined &amp;&amp; temporary().animationsComplete &gt;= temporary().animationsToComplete) {
			$(&quot;#continue .macro-button&quot;).each((index, element) =&gt; {
				element.disabled = false;
			});
	}
	resolve(&#39;Animation ended&#39;);
}
}}}
We re-activate the continue button with this function, defined within the {{{animateCSS}}} function and called at the end of every animation. If {{{_animationsComplete}}} matches the number of {{{_animationsToComplete}}}, we run the same code in reverse, re-enabling the continue button.

For actions that don&#39;t generate any animations, the animation activator won&#39;t be called, so the continue button won&#39;t be disabled in the first place.

&lt;h2 id=&quot;setup&quot;&gt;Setting up the battle&lt;/h2&gt;
{{{
&lt;&lt;set $B = {target: null, subject: null, actor: null, turn: &quot;player&quot;, turnCounter: 0, enemyTurns: 0, phase: &quot;command&quot;, embargo: 0, event: false, surrender: false, kills: [], specialdeath: [], XPreward: 0, moneyReward: 0, destination: previous()}&gt;&gt;
&lt;&lt;callEncounter $scenario&gt;&gt;
&lt;&lt;refreshPuppets&gt;&gt;
&lt;&lt;if typeof($B.style) == &#39;string&#39;&gt;&gt;
	&lt;&lt;addclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set $B.playerBars = []&gt;&gt;
&lt;&lt;for _i, _p range $puppets&gt;&gt;
	&lt;&lt;set _id = &#39;p&#39;+_i&gt;&gt;
	&lt;&lt;run $B.playerBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;set $B.enemyBars = []&gt;&gt;
&lt;&lt;for _i, _e range $enemies&gt;&gt;
	&lt;&lt;set _id = &#39;e&#39;+_i&gt;&gt;
	&lt;&lt;run $B.enemyBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.ENEMY_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;include &quot;custom battle preparation&quot;&gt;&gt;
&lt;&lt;set $inbattle to true&gt;&gt;
&lt;&lt;set $stScreen = 1&gt;&gt;
&lt;&lt;if $B.ambush&gt;&gt;
	&lt;&lt;set $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The &quot;Preparation&quot; passage, shown here, is responsible for cleaning up variables and getting everything ready for the battle. You will want to have something like this to make sure every battle starts the way you want it to, without any loose flags or variables messing things up. The most important thing here is the initialization of the {{{$B}}} variable, which stands for &quot;battle controller&quot;. {{{$B}}} will be used to handle every flag and variable we need to keep track of during battle. Tying these variables to a single object makes keeping track of them easy -- if we want to clear and reset our variables (such as when starting a new battle), we can just create a brand new {{{$B}}}, instead of having to keep track of whether or not we&#39;ve reset every single variable that can come up during battle.

You should pay attention to the {{{&lt;&lt;callEncounter&gt;&gt;}}} line, immediately after the initialization of {{{$B}}}. This references a widget defined in the &quot;Database: Encounters&quot; passage.
{{{
&lt;&lt;widget &quot;callEncounter&quot;&gt;&gt;

&lt;&lt;switch $args[0]&gt;&gt;

&lt;&lt;case &quot;tutorial&quot;&gt;&gt;
/* Dummy enemies for the tutorial. */
&lt;&lt;set $enemies to [new Enemy(), new Enemy(), new Enemy()]&gt;&gt;
&lt;&lt;run $enemies[0].effects.push(new Effect(&quot;Stunned&quot;,1,0))&gt;&gt;
&lt;&lt;run $enemies[1].effects.push(new Effect(&quot;Pain&quot;,3,10))&gt;&gt;
&lt;&lt;run $enemies[2].effects.push(new Effect(&quot;SPC Boost&quot;,3,10))&gt;&gt;
}}}
In &quot;Database: Encounters&quot; we can see how the {{{&lt;&lt;callEncounter&gt;&gt;}}} widget is used to create the enemy parties. They are created as arrays of either &quot;Puppet&quot; or &quot;Enemy&quot; objects, which is useful because it will allow us to easily iterate over them later. I recommend creating your own &quot;Database: Encounters&quot; passage as a separate twee file and using it to overwrite the default passage.

&lt;b&gt;NOTE: Though you may be tempted, DO NOT use the {{{fill()}}} function to fill enemy arrays.&lt;/b&gt; {{{fill()}}} fills an array with exact copies of fill element, which means all the enemies will have the same ID. This makes it impossible to accurately recall the target and subject; see &lt;a class=&quot;noExternal&quot; href=&quot;#chain&quot;&gt;the {{{&lt;&lt;chain&gt;&gt;}}} widget&lt;/a&gt; for details.
{{{
&lt;&lt;refreshPuppets&gt;&gt;
}}}
Next, we reset puppets to their resting states with {{{&lt;&lt;refreshPuppets&gt;&gt;}}}. For more details, go &lt;a class=&quot;noExternal&quot; href=&quot;#refreshPuppets&quot;&gt;here&lt;/a&gt;.
{{{
&lt;&lt;set $B.playerBars = []&gt;&gt;
&lt;&lt;for _i, _p range $puppets&gt;&gt;
	&lt;&lt;set _id = &#39;p&#39;+_i&gt;&gt;
	&lt;&lt;run $B.playerBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;set $B.enemyBars = []&gt;&gt;
&lt;&lt;for _i, _e range $enemies&gt;&gt;
	&lt;&lt;set _id = &#39;e&#39;+_i&gt;&gt;
	&lt;&lt;run $B.enemyBars.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.ENEMY_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
Next, we define the characters&#39; health bars. Due to the unusual ways meters function and are stored in the game data, these have to be made on battle initialization, as each one requires a unique name. Because parties can be any size, we can&#39;t know how many meters to create in advance. Instead, we have to key them to the number of players and enemies in the current battle.

By default, I&#39;ve set the health bars to have no color transition, no animation, and to span the full width of their container. You can edit any of these features if you like. The color variables are set in StoryInit, though this also allows for you to give characters unique colors; just define a {{{color}}} attribute or some such and pass it to the {{{&lt;&lt;colors&gt;&gt;}}} macro.

&lt;b&gt;Note that meters are not stateful.&lt;/b&gt; This means that they do not persist across save game loads or browser refreshes. You may have noticed that if you refresh the page during the battle, the display will become a mess of error messages telling you the health meters don&#39;t exist; this is why. Unless you plan to remake the meters at the start of every passage, you should not allow saving during battles.

After this, custom preparation code is called. In the default engine, this is just the {{{&lt;&lt;restock&gt;&gt;}}} widget, which replenishes items.

&lt;h2 id=&quot;skeleton&quot;&gt;How the battle passages work&lt;/h2&gt;
The battle screen that the player sees isn&#39;t just a single passage. It&#39;s many smaller passages (including the &quot;Preparation&quot; passage you just read about) all linked together and called at various points. You can see all of them in the &quot;Battle Phases&quot; file in the &quot;passages&quot; folder. You can open that file to follow along.

The file begins by defining a lot of the widgets used in battle. We&#39;ll return to these; you can skip over them for now.

The &quot;Battle!&quot; passage is the passage that ties everything together, but it doesn&#39;t contain much code, other than {{{&lt;&lt;include&gt;&gt;}}}ing the relevant passages in the right spots. Note how it is structured, however:
{{{
&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;
&lt;span id=&quot;actorlist&quot;&gt;
&lt;&lt;include &quot;actorlist&quot;&gt;&gt;
&lt;/span&gt;
&lt;div id=&quot;phase&quot;&gt;

&lt;/div&gt;
&lt;/span&gt;
}}}
The two major components of the battle display, the character display and the phase of battle, are wrapped in HTML elements that give them unique IDs. This is necessary if we want to change them using macros.

&lt;h3 id=&quot;auto-end&quot;&gt;Auto-endturn&lt;/h3&gt;
{{{
&lt;&lt;set _doneCount = 0&gt;&gt;
&lt;&lt;for _puppet range puppets()&gt;&gt;
	&lt;&lt;if (_puppet.isDone || _puppet.dead || _puppet.noact)&gt;&gt;
		&lt;&lt;set _doneCount++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if !($B.victory || $B.defeat || _specialmsg)&gt;&gt;
	&lt;&lt;if $AUTO_ENDTURN === true &amp;&amp; _doneCount == puppets().length&gt;&gt;
		&lt;&lt;endturn&gt;&gt;
	&lt;&lt;elseif setup.TURN_EXCHANGE === true &amp;&amp; $B.enemyTurns &gt; 0&gt;&gt;
		&lt;&lt;set $B.phase = null&gt;&gt;
		&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
In addition to the main content, there is also this handler for the automatic turn ending feature, which can be enabled in the Settings menu. If it&#39;s enabled, we automatically end the player&#39;s turn after all characters have acted. To accomplish this, we intialize a {{{_doneCount}}} variable to 0, then run a loop over {{{$puppets}}}, incrementing {{{_doneCount}}} whenever we find a puppet who has acted or cannot act (due to being defeated or under a hold effect). If {{{_doneCount}}} then equals the length of {{{$puppets}}}, all characters have acted and we end the turn.
{{{
&lt;&lt;if $AUTO_ENDTURN === true &amp;&amp; _doneCount == puppets().length&gt;&gt;
}}}
The feature is controlled by this conditional. {{{$AUTO_ENDTURN}}} is controlled by the Settings menu.
{{{
&lt;&lt;if !($B.victory || $B.defeat || _specialmsg)&gt;&gt;
}}}
Note that we also perform this check before we consider the auto-forwarder at all. Why? Well, Twine has a strange quirk: If it is forced to execute multiple {{{&lt;&lt;goto&gt;&gt;}}} operations on the same page, they will all execute simultaneously, ending with the player being forwarded to the last passage specified by a {{{&lt;&lt;goto&gt;&gt;}}}. Since the victory and defeat handlers also forward the player to another passage (see &lt;a class=&quot;noExternal&quot; href=&quot;#victorycheck&quot;&gt;{{{&lt;&lt;victorycheck&gt;&gt;}}}&lt;/a&gt;), we need to prevent that from happening. Otherwise, players will be forwarded to the victory passage and then immediately back to the battle screen, causing all sorts of problems! You can also set a {{{_specialmsg}}} flag in case you need to use any other passage forwarding, such as to a special scene using {{{&lt;&lt;specialcheck&gt;&gt;}}}.
{{{
&lt;&lt;elseif setup.TURN_EXCHANGE === true &amp;&amp; $B.enemyTurns &gt; 0&gt;&gt;
	&lt;&lt;set $B.phase = null&gt;&gt;
	&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
A related feature is &quot;turn exchange&quot;, which is set in {{{StoryInit}}}. This will force a shift to the enemy phase if there are any {{{enemyTurns}}} stored -- in practice, after every player action.

&lt;h3 id=&quot;actorlistDoc&quot;&gt;Actor List&lt;/h3&gt;
{{{
&lt;&lt;set _enemiesClass = &quot;actors enemies&quot;&gt;&gt;
&lt;&lt;set _puppetsClass = &quot;actors&quot;&gt;&gt;
&lt;&lt;include &quot;battle display mods actorlist&quot;&gt;&gt;

&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;set _enemiesClass += &quot; grid&quot;; _puppetsClass += &quot; grid&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $B.reverse_display&gt;&gt;
&lt;&lt;set _enemiesClass += &quot; reverse&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;div @class=&quot;_enemiesClass&quot; id=&quot;enemies&quot;&gt;
&lt;&lt;include &quot;actorlist enemies&quot;&gt;&gt;
&lt;/div&gt;

&lt;div id=&quot;battlelines&quot;&gt;
&lt;&lt;include &quot;special battle lines&quot;&gt;&gt;
&lt;/div&gt;

&lt;div id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;
&lt;/div&gt;
}}}
The &lt;b&gt;actorlist&lt;/b&gt; passage displays the battling characters.

In the default formatting, each of the character &quot;blocks&quot; you see in-game are held in a CSS structure called a &quot;flexbox&quot;. This is a useful structure for placing elements in 1-dimensional space, as it gives us a lot of control over where its elements are placed and how they&#39;re formatted. To do this, there has to be a &lt;i&gt;container&lt;/i&gt; element that controls the flexbox formatting, and &lt;i&gt;item&lt;/i&gt; elements that go inside the container.

The way this works in the default stylesheet is that the &lt;i&gt;actors&lt;/i&gt; class is the container, and the &lt;i&gt;actor&lt;/i&gt; class represents items. So before we do anything we need to make a {{{&lt;div&gt;}}} element with the class &quot;actors&quot; to create the container, and then we can add elements classed &quot;actor&quot; inside.
{{{
&lt;div @class=&quot;_enemiesClass&quot; id=&quot;enemies&quot;&gt;
}}}
You can situationally modify the formatting of the flexbox using Twine&#39;s {{{@}}} operator. When placed before an HTML attribute, it will cause the attribute data to be read as TwineScript, allowing you to pass Twine variables as attributes. Here, we use it to input the class of the container element. If you want a certain battle scenario to display the characters in reverse order (such as in the Crystal Gems encounter in &lt;i&gt;Cartoon Battle&lt;/i&gt;), you can define {{{_enemiesClass}}} as &quot;actors reverse&quot; to add the additional &quot;reverse&quot; class to the container. In all other cases, {{{_enemiesClass}}} is just defined as &quot;actors&quot;, and the default formatting is used. &lt;i&gt;Note that you &lt;b&gt;must&lt;/b&gt; always define something in {{{_enemiesClass}}} if you use this method, as there is no way to evaluate the attribute as partially literal and partially TwineScript.&lt;/i&gt;

&lt;h4 id=&quot;actorBoxDoc&quot;&gt;Actor Box&lt;/h4&gt;
Once the container is established, we can start adding items. This is done through a standardized widget, {{{&lt;&lt;actorBox&gt;&gt;}}}.
{{{
&lt;&lt;widget &quot;actorBox&quot;&gt;&gt;
&lt;&lt;set _actor = $args[0]&gt;&gt;

&lt;&lt;if _actor instanceof Puppet&gt;&gt;
  &lt;&lt;set _idx = $puppets.findIndex(function (a) { return _actor.id == a.id; })&gt;&gt;
  &lt;&lt;set _nameID = &quot;pname&quot;+_idx&gt;&gt;
  &lt;&lt;set _boxID = &quot;p&quot;+_idx&gt;&gt;
  &lt;&lt;set _healthBar = $B.playerBars[_idx]&gt;&gt;
&lt;&lt;elseif _actor instanceof Enemy&gt;&gt;
  &lt;&lt;set _idx = $enemies.findIndex(function (a) { return _actor.id == a.id })&gt;&gt;
  &lt;&lt;set _nameID = &quot;ename&quot;+_idx&gt;&gt;
  &lt;&lt;set _boxID = &quot;e&quot;+_idx&gt;&gt;
  &lt;&lt;set _healthBar = $B.enemyBars[_idx]&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _class = &quot;actor &quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 1 &amp;&amp; typeof($args[1]) == &quot;string&quot;&gt;&gt;
  &lt;&lt;set _class += $args[1]&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The widget starts by declaring some variables: the actor itself (passed as the 0th argument to the widget), additional classes to be added to the box (the 1st argument to the widget, optional), and the actor&#39;s index in its party array, which is used to create unique anchors for hotkeys and to identify the correct health bar.
{{{
&lt;&lt;if _actor.caps&gt;&gt;
  &lt;&lt;set _nameStyle = &quot;text-transform:uppercase&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
  &lt;&lt;set _nameStyle = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We also define this style code if the actor&#39;s &quot;caps&quot; property is true, which will make their name display as uppercase. Otherwise, {{{_nameStyle}}} is blank. You can add other name modifiers here if you wish.

Then we can begin constructing the box itself. We want each block to contain the character&#39;s name, HP, HP meter, and status button. In the puppet blocks, we also want to print EN after HP. Let&#39;s go over how to do these things.

The first element we want to display is the name. This is also the most complicated element, because it also functions as a link that can perform multiple functions depending on the context of the battle.
{{{
/* Element 1: name */
&lt;span class=&quot;actorname&quot; @id=_nameID @style=_nameStyle&gt;
&lt;&lt;if _actor.dead&gt;&gt;
	/* Dead characters display their name and the † (dagger) symbol in place of the status button */
	&lt;&lt;set _class = &quot;statusbutton&quot;&gt;&gt;
	&lt;&lt;if _actor.large&gt;&gt;
		&lt;&lt;set _class += &quot; absolute&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;span class=&quot;dead&quot;&gt;
		_actor.fullname
		&lt;span @class=_class&gt;&amp;dagger;&lt;/span&gt;
	&lt;/span&gt;
}}}
The simplest special case is if the actor is dead. In this case, all we want is for the actor&#39;s name to be grayed out and for a &amp;dagger; (dagger) symbol to be displayed in the corner of their box. (If you can&#39;t see the symbol, your Unicode support is out of date; try updating your browser.) We want the dagger symbol to replace the status button (discussed later), so we will use the same positioning class to display it. We will also wrap the name in a &quot;dead&quot; class, which we can use to provide the gray color.
{{{
&lt;&lt;elseif _actor instanceof Puppet &amp;&amp; $B.phase == &quot;selection&quot; &amp;&amp; ndef _s &amp;&amp; (!_actor.noact || _actor.down) &amp;&amp; !_actor.isDone&gt;&gt;
  /* For Puppets in the selection phase, their name becomes a link that sets them as the subject and allows the player to select their commands. */
  &lt;&lt;capture _idx, _actor&gt;&gt;
  &lt;&lt;link &quot;_actor.name&quot;&gt;&gt;
    &lt;&lt;set $subject = _actor&gt;&gt;
    &lt;&lt;set _s = _idx&gt;&gt;
    &lt;&lt;set $B.phase = &quot;command&quot;&gt;&gt;
    &lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
      &lt;&lt;removeclass &quot;#puppets&quot; &quot;grid&quot;&gt;&gt;
    &lt;&lt;/if&gt;&gt;
    &lt;&lt;addclass &quot;#enemies&quot; &quot;invisible&quot;&gt;&gt;
    &lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;actorlist puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
    &lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;commands&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
  &lt;&lt;/link&gt;&gt;
  &lt;&lt;/capture&gt;&gt;
}}}
The next case concerns how the name should appear during the selection phase (when the player is selecting which puppet to act). What this says in English is, &quot;If this actor is a Puppet, and the player&#39;s turn is in the selection phase, and a character has not already been selected ({{{_s}}} stands for &quot;selection&quot;), and this character is not under a hold effect, and this character has not already acted, turn this character&#39;s name into a link that sets this character as the subject, assign their index in the {{{$puppets}}} array to the {{{_s}}} variable, refresh the puppet actor list, and make commands appear in the {{{#phase}}} area.&quot;

To see what will happen when this link is clicked, we must take a quick trip to the &quot;actorlist puppets&quot; passage:
{{{
&lt;div @class=&quot;_puppetsClass&quot;&gt;
(...)
&lt;&lt;if def _s&gt;&gt;
	&lt;div style=&quot;position:absolute; top:0; right:0&quot;&gt;&lt;&lt;backbtn&gt;&gt;&lt;/div&gt;
	&lt;&lt;actorBox $subject&gt;&gt;
}}}
That&#39;s it! The puppet container will refresh to display only the character the player has just selected, allowing them to focus on them while they consider what commands to pick. Despite the complex setup code, the result is simple.

The next case determines how characters can be selected during the &lt;a class=&quot;noExternal&quot; href=&quot;#targetingphase&quot;&gt;Targeting Phase&lt;/a&gt;, and is discussed in that section.
{{{
&lt;&lt;else&gt;&gt;
  /* In all other phases, just display the name as normal. */
  _actor.fullname
&lt;&lt;/if&gt;&gt;
}}}
Otherwise, the actor&#39;s name is displayed as plain text, no fluff.
{{{
/* Element 2: status button */
&lt;&lt;if !_actor.dead&gt;&gt;
  /* only display status button if character is not dead */
  &lt;&lt;set _class = &quot;statusbutton&quot;&gt;&gt;
  &lt;&lt;if _actor.large&gt;&gt;
    &lt;&lt;set _class += &quot; absolute&quot;&gt;&gt;
  &lt;&lt;/if&gt;&gt;
  &lt;&lt;capture _actor&gt;&gt;&lt;span @class=_class&gt;&lt;&lt;status _actor&gt;&gt;&lt;/span&gt;&lt;&lt;/capture&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then we display the status button, which is much simpler, as the code for the button itself is offloaded to the {{{&lt;&lt;status&gt;&gt;}}} widget. All this code has to do is make sure the button appears correctly; by default, only if the character is not dead. (We also have to add the additional &quot;absolute&quot; class if the actor box is large, as the large box requires the status button be positioned differently.)
{{{
/* Element 3: HP */
&lt;&lt;if !_actor.dead&gt;&gt;
  &lt;&lt;capture _healthBar&gt;&gt;
  &lt;div&gt;
  HP: &lt;&lt;if _actor.maskhp&gt;&gt;???
  &lt;&lt;else&gt;&gt;&lt;&lt;print _actor.hp&gt;&gt;&lt;&lt;if _actor.showMaxHP&gt;&gt; / _actor.maxhp&lt;&lt;/if&gt;&gt;
  &lt;&lt;/if&gt;&gt;
  &lt;/div&gt;
	(...)
  &lt;&lt;/capture&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Next, we display HP (but only if the character isn&#39;t dead). There are several modifiers to this display you can set as properties of the actor object. By default, only the current HP is shown, but you can also display the maximum HP by setting the {{{showMaxHP}}} attribute. The {{{maskhp}}} attribute will instead forego this whole process and just display the HP as &quot;???&quot;, for when you don&#39;t want the player to know the character&#39;s HP.
{{{
&lt;&lt;if (!_actor.maskhp &amp;&amp; setup.SHOW_HEALTHBARS)&gt;&gt;
  &lt;&lt;if setup.BATTLE_GRID === true &amp;&amp; _actor.large&gt;&gt;
    &lt;div class=&quot;largehealth&quot;&gt;
      &lt;&lt;showmeter _healthBar `_actor.hp / _actor.maxhp`&gt;&gt;
    &lt;/div&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;showmeter _healthBar `_actor.hp / _actor.maxhp`&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Next, we display the health bars, provided {{{setup.SHOW_HEALTHBARS}}} is set to true. The bar will stretch the entire length of the character block. For boss characters, whose block extends across the entire screen, this makes the bar very long!
{{{
/* Element 4: EN (Puppets only) */
&lt;&lt;if !_actor.dead &amp;&amp; _actor instanceof Puppet &amp;&amp; !$args.includes(&quot;simplified&quot;)&gt;&gt;
  &lt;div&gt;
  EN: _actor.en / _actor.maxen
  &lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
On the next line, EN is displayed, but only for Puppets, and only if they&#39;re not dead. (This section is also omitted in &quot;simplified&quot; form, such as in damage animations.) By default, this display is very simple, but you can modify it as you need.
{{{
/* Element 5: Crisis points */
&lt;&lt;if !_actor.dead &amp;&amp; def _s &amp;&amp; _actor.crisis instanceof Array &amp;&amp; _actor.crisis.length &gt; 0 &amp;&amp; !$args.includes(&quot;simplified&quot;)&gt;&gt;
  /* Only display this if the character isn&#39;t currently selected (and if they have a valid Crisis in the first place) */
  &lt;&lt;set _style = &quot;font-size: 10pt; &quot;&gt;&gt;
  &lt;&lt;if _actor.crisisPoints &gt;= 100&gt;&gt;
    &lt;&lt;set _style += &quot;color:red&quot;&gt;&gt;
  &lt;&lt;else&gt;&gt;
    &lt;&lt;set _style += &quot;font-weight:normal&quot;&gt;&gt;
  &lt;&lt;/if&gt;&gt;
  &lt;div @style=_style&gt;
    Crisis: &lt;&lt;print _actor.crisisPoints&gt;&gt;%
  &lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
Crisis points are displayed next, but only if the character has a valid {{{crisis}}} attribute (and isn&#39;t dead). If you don&#39;t want to use Crises in your game, just don&#39;t give the characters any, and this whole section will be ignored.

By default, Crisis points are displayed in at a smaller size than normal (because the actor box is getting pretty big by this point), and is highlighted an eye-catching red if it&#39;s at maximum.
{{{
/* Element 6: Status messages */
&lt;&lt;if !_actor.dead&gt;&gt;
  &lt;div class=&quot;noact&quot;&gt;
  &lt;&lt;if $args.includes(&quot;simplified&quot;)&gt;&gt;
    &lt;br/&gt;
  &lt;&lt;elseif _actor.isDone&gt;&gt;
    Done!
  &lt;&lt;elseif _actor.stunned&gt;&gt;
    Stunned!
  &lt;&lt;elseif _actor.down&gt;&gt;
    Prone!
  &lt;&lt;else&gt;&gt;
    &lt;br/&gt;
  &lt;&lt;/if&gt;&gt;
  &lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
The final element is a little notifier for when the character&#39;s turn is done, or if they&#39;re under a hold effect. In the simplified display, these messages are ignored and replaced with an empty line. Including an extra line break in the default case is not strictly necessary, but it keeps the character box dimensions consistent; if you don&#39;t include it, the box will become taller or shorter depending on if a message is displayed or not.

&lt;h3 id=&quot;commands&quot;&gt;Commands&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/012.PNG&quot;]]
[img[setup.ImagePath + &quot;documentation/012a.PNG&quot;]]

We need the player to be able to select actions and give commands to their characters to play the game. But by default, we see no commands, just the character boxes. When a character is selected, all the other characters disappear, and a command pane appears below their character box.

To show how this is done, we have to move up a step, and look at {{{actorlist puppets}}}, the container for &lt;i&gt;all&lt;/i&gt; the actor boxes for the player characters.
{{{
&lt;div @class=&quot;_puppetsClass&quot;&gt;
(...)
&lt;&lt;if def _s&gt;&gt;
	&lt;div style=&quot;position:absolute; top:0; right:0&quot;&gt;&lt;&lt;backbtn&gt;&gt;&lt;/div&gt;
	&lt;&lt;actorBox $subject&gt;&gt;
&lt;&lt;else&gt;&gt;
	(...)
	&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
		&lt;&lt;set _puppetClass = &quot;&quot;&gt;&gt;
		(...)
		&lt;&lt;if _puppet === null&gt;&gt;
			(...)
		&lt;&lt;else&gt;&gt;
			&lt;&lt;actorBox _puppet _puppetClass&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;for&gt;&gt;
}}}
Recall from &lt;a class=&quot;noExternal&quot; href=&quot;#actorBoxDoc&quot;&gt;the Actor Box&lt;/a&gt; that when a Puppet&#39;s name is clicked in the selection phase, the {{{_s}}} variable is set and the puppet container is refreshed. That triggers the first {{{if}}} clause here, and displays &lt;i&gt;only&lt;/i&gt; the box for the active subject (the puppet selected). (Because it is still within the flexbox container, the character box is automatically centered on the screen, which is handy.) Otherwise, we iterate over the {{{$puppets}}} array and make an {{{actorBox}}} for everyone.
{{{
&lt;div style=&quot;position:absolute; top:0; right:0&quot;&gt;&lt;&lt;backbtn&gt;&gt;&lt;/div&gt;
}}}
Note that this code in the selection branch is an important addition. We need to give the player the ability to go back in case they decide they want a different character to act. The {{{div}}} here is just to make sure it is placed in an aesthetically pleasing position; we can&#39;t place it inside the normal element flow, since it will go inside the flexbox and interfere with the placement of the character box. {{{position:absolute}}} allows us to control where it appears without affecting any other elements; in this case, we place it in the upper-right corner of the flexbox container. This displays it prominently near the character box, which is a good location.

However, this still doesn&#39;t show us how we get the commands to display. To answer that, recall this element from the master &quot;Battle!&quot; passage:
{{{
&lt;div id=&quot;phase&quot;&gt;

&lt;/div&gt;
}}}
You may recall that clicking the selection link replaced this element with a passage called &quot;commands&quot;, so let&#39;s look there:
{{{
&lt;div class=&quot;commandcontainer&quot;&gt;
&lt;div class=&quot;commands&quot;&gt;
	&lt;span id=&quot;actbtn&quot;&gt;&lt;&lt;act $puppets[_s]&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;span id=&quot;restbtn&quot;&gt;&lt;&lt;rest $puppets[_s]&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;span id=&quot;itembtn&quot;&gt;&lt;&lt;items $puppets[_s]&gt;&gt;&lt;/span&gt;&lt;br /&gt;
	&lt;&lt;if $B.surrender is true&gt;&gt;
		&lt;&lt;spare $puppets[_s]&gt;&gt;&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;/div&gt;
}}}
Here, finally, are our commands. They display only if this passage has been slotted into the {{{#phase}}} element through the selection link, and they appear in a flexbox of identical dimensions that ensures they will display just under the character box. This is how we are able to display the commands only when a character has been selected.

As for the commands themselves, the mechanics required for these are a bit more complicated than a normal Twine link, so they refer to custom widgets found at the top of the &quot;Battle Phases&quot; file:
{{{
&lt;&lt;widget &quot;act&quot;&gt;&gt;
&lt;&lt;if _puppet.down is true&gt;&gt;
	&lt;&lt;if $args[0].en &gt;= setup.struggleCost&gt;&gt;
		&lt;&lt;link &quot;Struggle&quot;&gt;&gt;
			&lt;&lt;set $subject = $args[0]; $action = new Action(&quot;struggle&quot;); $target = null&gt;&gt;
			&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;confirm phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;b&gt;Exhausted!&lt;/b&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Act&quot;&gt;&gt;
		&lt;&lt;set $subject = $args[0]&gt;&gt;
		&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;actions&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;span class=&quot;hotkey monospace right&quot;&gt;[Q]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;
}}}
The first branch of the if clause here may look complicated, but it&#39;s only for a special case that turns the &quot;Act&quot; button into a selection for a single action. The part that the player will see for most of the battle is the default {{{&lt;&lt;else&gt;&gt;}}} case, which links to the &quot;actions&quot; passage while assigning the current character to the {{{$subject}}} variable.
{{{
&lt;&lt;set $B.phase = &quot;actions&quot;&gt;&gt;
&lt;span class=&quot;hotkey monospace&quot;&gt;[Q] = basic action | [W] = last action&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;

&lt;&lt;actionList $subject&gt;&gt;
}}}
Instead of making a separate passage for every character (which would quickly get cumbersome), everything is outsourced to another widget in order to reduce clutter. This can be found the widgets section of the &quot;Battle Phases&quot; file, and is discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#actions&quot;&gt;Action Mechanics&lt;/a&gt;.

The &quot;Item&quot; command works similarly.

Once you have selected an action, you are moved to the targeting phase to choose a target.

&lt;h3 id=&quot;targetingphase&quot;&gt;Targeting Phase&lt;/h3&gt;
{{{
&lt;&lt;set $B.phase = &quot;targeting&quot;&gt;&gt;
&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;include &quot;actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;if $B.targeting == &quot;enemy&quot;&gt;&gt;
	&lt;&lt;addclass &quot;#puppets&quot; &quot;invisible&quot;&gt;&gt;
&lt;&lt;elseif $B.targeting == &quot;ally&quot;&gt;&gt;
	&lt;&lt;addclass &quot;#enemies&quot; &quot;invisible&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;backbtn&gt;&gt;

Select a target. &lt;span class=&quot;hotkey monospace&quot;&gt;[hotkeys: 1-0] &lt;&lt;if $B.reverse_display&gt;&gt;[enemies are displayed in reverse order]&lt;&lt;/if&gt;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;if $B.targeting == &quot;all&quot;&gt;&gt;
&lt;&lt;set _targetingEnemy = true&gt;&gt;
&lt;span class=&quot;hotkey monospace&quot; id=&quot;target_help&quot;&gt;
[Hotkeys targeting &lt;&lt;if _targetingEnemy === true&gt;&gt;enemies&lt;&lt;else&gt;&gt;allies&lt;&lt;/if&gt;&gt;. Press Shift to switch targets.]
&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
}}}
The &lt;b&gt;targeting phase&lt;/b&gt; passage is not much to look at in and of itself. It is basically a filler passage that gives the player a stage to select their target. For clarity, the opposite party is made invisible if the action can only target one party or another.

However, to see how it behaves under normal circumstances, let us return to {{{&lt;&lt;actorBox&gt;&gt;}}}:
{{{
&lt;&lt;elseif $B.phase == &quot;targeting&quot;&gt;&gt;
	&lt;span class=&quot;targetnumber&quot;&gt;&lt;&lt;print _idx+1&gt;&gt;&lt;/span&gt;
	&lt;&lt;if ($B.targeting == &quot;all&quot; || (_actor instanceof Enemy &amp;&amp; $B.targeting == &quot;enemy&quot;) || (_actor instanceof Puppet &amp;&amp; $B.targeting == &quot;ally&quot;))&gt;&gt;
		&lt;&lt;if (_actor instanceof Puppet &amp;&amp; !($subject.name == _actor.name &amp;&amp; $B.noself === true)) ||
			(_actor instanceof Enemy &amp;&amp;
			((_actor.martyr || (!_martyr &amp;&amp; !_actor.untargetable)) &amp;&amp; ($action.ranged || guardCheck(_idx))))&gt;&gt;
			&lt;&lt;capture _actor&gt;&gt;
			&lt;&lt;link &quot;_actor.fullname&quot;&gt;&gt;
				&lt;&lt;set $target = _actor; $B.targeting = null&gt;&gt;
				&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;confirm phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
		&lt;&lt;else&gt;&gt;
			/* If invalid target, just display the name as normal. */
			_actor.fullname
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;else&gt;&gt;
		/* If not being targeted, just display the name as normal. */
		_actor.fullname
	&lt;&lt;/if&gt;&gt;
}}}
This is the name-display clause we skipped over previously. During the targeting phase, this clause turns the character&#39;s name into a link that, when clicked, directs the player to the confirm phase and sets the character as the target of the ability.

(There are also several riders for special circumstances: if an enemy is flagged untargetable they are, well, untargetable, and the same applies if they are protected by someone or their team has a martyr. On the player side, there is a rider that disables the user as a valid target if {{{$B.noself}}} is {{{true}}}. This will be explained in the action section.)

&lt;h3 id=&quot;confirmphase&quot;&gt;Confirm Phase&lt;/h3&gt;
{{{
&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;if $SHOW_CONFIRM&gt;&gt;
&lt;&lt;set $B.phase = &quot;confirm&quot;&gt;&gt;
&lt;&lt;backbtn&gt;&gt;

$subject.name will

&lt;&lt;if $action.name is &quot;rest&quot;&gt;&gt;
	&lt;b&gt;rest&lt;/b&gt; this turn.
&lt;&lt;elseif $action.name is &quot;struggle&quot;&gt;&gt;
	spend setup.struggleCost Energy to get back on &lt;&lt;print subject().their&gt;&gt; feet.
&lt;&lt;elseif $action.item is true&gt;&gt;
	use &lt;&lt;switch $action.name.first().toLowerCase()&gt;&gt;&lt;&lt;case &#39;a&#39; &#39;e&#39; &#39;i&#39; &#39;o&#39; &#39;u&#39;&gt;&gt;an&lt;&lt;default&gt;&gt;a&lt;&lt;/switch&gt;&gt; $action.name.
&lt;&lt;elseif $action.name is &quot;spare&quot;&gt;&gt;
	accept the enemy&#39;s surrender.
&lt;&lt;else&gt;&gt;
	use &lt;b&gt;$action.name&lt;/b&gt;&lt;&lt;if $target isnot null&gt;&gt; on &lt;b&gt;$target.name&lt;/b&gt;&lt;&lt;/if&gt;&gt;.
&lt;&lt;/if&gt;&gt;
 [[Confirm?|action phase]]&lt;br /&gt;
&lt;span class=&quot;preview&quot;&gt;
&lt;&lt;if $action.preview instanceof Function&gt;&gt;
	&lt;&lt;print $action.preview()&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.preview&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;
&lt;&lt;else&gt;&gt;
&lt;&lt;goto &quot;action phase&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The confirm phase is very simple. It is designed as a courtesy to players to prevent them from accidentally confirming the wrong action by misclicking, and to allow them to review how the action will play out. It can be turned off in the Settings menu if players don&#39;t want to make the extra click, however.

The complicated-looking if clause here is just fluff to provide different messages depending on the class of action chosen. The a/an rule in English presents an issue when describing the use of items starting with vowels. I whipped up a quick {{{&lt;&lt;switch&gt;&gt;}}} statement to address this directly, but you may be able to come up with something more robust. (Or you could just accept defeat and display it as &quot;a(n)&quot;. If you ever wondered why game developers do that, now you know!)

The {{{preview}}} attribute is another courtesy to the player. It describes the expected effect of the action, such as pre-calculating damage. It&#39;s unique for every action, and can be examined in the action database JavaScript.

&lt;h3 id=&quot;spellphase&quot;&gt;Spell Phase&lt;/h3&gt;
In the default engine, Mage can expend additional energy points to make their spells stronger. This functionality is handled in the &lt;b&gt;spell phase&lt;/b&gt; and &lt;b&gt;spell check&lt;/b&gt; passages.
{{{
&lt;&lt;backbtn&gt;&gt;

&lt;&lt;if isNaN($action.cost)&gt;&gt;
You need to input a number.&lt;br/&gt;
&lt;&lt;elseif $action.cost &lt; $B.mincost&gt;&gt;
Spell requires at least $B.mincost Energy.&lt;br/&gt;
&lt;&lt;elseif $subject.en &lt; $action.cost&gt;&gt;
Not enough Energy!&lt;br/&gt;
&lt;&lt;/if&gt;&gt;

How much Energy do you want to put into $action.name? (Minimum $B.mincost)&lt;br /&gt;
&lt;&lt;numberboxplus &quot;$action.cost&quot; $B.mincost autofocus&gt;&gt;
&lt;&lt;include &quot;spell check&quot;&gt;&gt;
&lt;&lt;/numberboxplus&gt;&gt;&lt;br/&gt;
(Press Enter to confirm.)&lt;br/&gt;
}}}
The &lt;b&gt;spell phase&lt;/b&gt; passage is shown above. A {{{&lt;&lt;numberboxplus&gt;&gt;}}} macro is used to receive player input, because it allows the player to continue just by pressing the Enter key rather than having to fuss with another confirm link. The {{{&lt;&lt;numberboxplus&gt;&gt;}}} modifies the {{{$action.cost}}} variable, is initialized to a default value of {{{$B.mincost}}} (the minimum cost for the spell), calls the &quot;spell check&quot; passage when Enter is pressed, and autofocuses when the page is loaded.

(Thanks to SugarCube developer TheMadExile for providing the {{{&lt;&lt;numberboxplus&gt;&gt;}}} macro, which was necessary for preserving the engine&#39;s structure.)
{{{
&lt;&lt;run $action.cost *= 1&gt;&gt;
&lt;&lt;if ($action.cost &lt; $B.mincost) or ($subject.en &lt; $action.cost) or isNaN($action.cost)&gt;&gt;
&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;spell phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;run $action.spellMod()&gt;&gt;

&lt;&lt;if $action.phase != &quot;confirm phase&quot;&gt;&gt;
	&lt;&lt;set $B.targeting = $action.target&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include &quot;targeting phase&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include _action.phase&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;
}}}
The &lt;b&gt;spell check&lt;/b&gt; passage, shown above, is not something the player should ever see. It is only for running calculations and directing the player to the correct passage.
{{{
&lt;&lt;run $action.cost *= 1&gt;&gt;
}}}
This initial {{{&lt;&lt;run&gt;&gt;}}} macro is needed to convert the {{{$action.cost}}} variable to a number, as it is passed as a string (text) when obtained through a text field.

From there, the if clause checks if the {{{$action.cost}}} value is within acceptable bounds. If the player inputted less energy than the minimum, more energy than Mage currently possesses, or something that wasn&#39;t a number, the player is pushed back to the spell phase and prompted to try again.

If the input was correct, the spell&#39;s {{{spellMod()}}} function is called to calculate adjustments for supercharging the spell. Each spell has a unique {{{spellMod()}}} that is defined in the action database. Once this is done, the player is directed to the next phase, and the action proceeds as normal.

&lt;h3 id=&quot;actionphase&quot;&gt;Action Phase&lt;/h3&gt;
This is where actions take place. The &quot;action phase&quot; passage itself only executes standard behavior, such as variable cleanup. This will be discussed later. The details of specific actions take place in the &quot;action effects&quot; passage, which is {{{&lt;&lt;include&gt;&gt;}}}d in &quot;action phase&quot;.

The actorlist passage is not included here, simply because it is difficult to update stats in real time.

Let&#39;s look at &quot;action effects&quot;:
{{{
&lt;&lt;if $action.silent === true&gt;&gt;
	&lt;&lt;if $action.act instanceof Function&gt;&gt;
		&lt;&lt;print $action.act()&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;print $action.act&gt;&gt;
	&lt;&lt;/if&gt;&gt;
		&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
}}}
The first section handles actions that don&#39;t do anything significant enough to require a message. {{{silent}}} actions immediately forward the player back to the main battle screen after performing their function.

The &quot;else&quot; case here handles everything else -- that is to say, actions that &lt;i&gt;do&lt;/i&gt; display a message and create text during the action phase.

How you code this section will depend on exactly how you want your actions to look. By default, this passage neatly partitions the display into use text, flavor text, and the mechanical effect of the action. Every section is given a unique ID that can be modified in the story stylesheet.
{{{
&lt;div id=&quot;actFlavor&quot;&gt;

&lt;&lt;if !($action.useText === null || ($action.useText instanceof Function &amp;&amp; $action.useText() === null))&gt;&gt;
&lt;div id=&quot;useText&quot;&gt;
&lt;&lt;if $action.useText instanceof Function&gt;&gt;
	&lt;&lt;print $action.useText()&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.useText&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;battle interruptions&quot;&gt;&gt;

&lt;&lt;if $action.actText !== null&gt;&gt;
&lt;div id=&quot;actText&quot;&gt;
&lt;&lt;if $action.actText instanceof Function&gt;&gt;
	&lt;&lt;print $action.actText()&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;print $action.actText&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

&lt;/div&gt;
}}}
First, we&#39;re going to open the &quot;#actFlavor&quot; {{{div}}}. This is the black-bordered text box that contains the descriptive text of the action. There are two portions to this {{{div}}}, the use text and the action text, and both get their own {{{div}}}s that you can format independently. The contents are defined as attributes of the action, and can be either normal strings, or functions (if, for instance, you want text to vary depending on certain variables). If you wish to bypass either element, you can set the corresponding attribute to {{{null}}} and the {{{div}}} will not generate.

There is also a call to {{{&lt;&lt;include&gt;&gt;}}} the &quot;battle interruptions&quot; passage, which can add special circumstances and additional scenes, such as one enemy protecting another from your attack.
{{{
&lt;&lt;if $action.act !== null&gt;&gt;
&lt;div id=&quot;actEffect&quot;&gt;

&lt;&lt;if def _targetingMsg&gt;&gt;
&lt;&lt;print _targetingMsg&gt;&gt;
&lt;&lt;unset _targetingMsg&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $action.act instanceof Function&gt;&gt;
&lt;&lt;print $action.act()&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;&lt;print $action.act&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then, there is a similar section for mechanical effects. Like use and act text, this is defined as an attribute of the action, usually a string of SugarCube code (which will execute as normal when {{{&lt;&lt;print&gt;&gt;}}}ed), and the element will not appear at all if the attribute is set to {{{null}}}. There is also a handler for the {{{_targetingMsg}}} variable, which handles a complicated problem discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#targeting.basic&quot;&gt;Standard Targeting&lt;/a&gt;.
{{{
&lt;&lt;if def _OG&gt;&gt;
	&lt;&lt;set $subject = _OG.subject; $target = _OG.target; $action = _OG.action&gt;&gt;
	&lt;&lt;unset _OG&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We also have to run this code at the very end. For special actions like counterattacks, we may want to temporarily change the subjet, target, and action, but we need to put them back afterwards so any further actions don&#39;t use the wrong variables.

This format creates a very nice, standardized, and customizable appearance for actions, but it does require actions to adhere to its rigid structure. All non-invisible actions &lt;i&gt;must&lt;/i&gt; have a {{{useText}}}, {{{actText}}}, and {{{act}}} attribute, even if it&#39;s only {{{null}}}. Otherwise, you&#39;re going to be drowning in error messages when this passage displays.

We then bring this all together in the action phase:
{{{
&lt;&lt;set $B.phase = null&gt;&gt;
&lt;span id=&quot;content&quot;&gt;

/* Some abilities (such as AoE attacks) don&#39;t always end with the same target as the one they started with. This saves the initial target if you want to use it for something, e.g. a reaction scene. */
&lt;&lt;set _initialTarget = $target&gt;&gt;

/* Saves the number of kills from before the action. By comparing this to the kills array afterwards, you can identify whether or not a kill happened during the action. */
&lt;&lt;set _initialKills = $B.kills.length&gt;&gt;

/* Tracks characters who have counterattacked this action. Required to enable counters. */
&lt;&lt;set _counters = []&gt;&gt;

&lt;&lt;if $action.name == &quot;spare&quot;&gt;&gt;
	&lt;&lt;run $enemy_to_spare.surrender()&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Add any bonus threat from the action. */
&lt;&lt;if setup.THREAT_TARGETING === true &amp;&amp; target() instanceof Enemy &amp;&amp; subject() instanceof Puppet&gt;&gt;
	&lt;&lt;run target().threat.inc(subject().name,$action.threat)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;include &quot;action effects&quot;&gt;&gt;

/* Variable cleanup. Due to the way goto works, this will work even for invisible actions. */

/* Remember this action for the last action shortcut: */
&lt;&lt;if !$action.nosave &amp;&amp; !($action.name == &quot;struggle&quot; || $action.name == &quot;spare&quot;)&gt;&gt;
	&lt;&lt;include &quot;lastaction mods&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* If action has limited uses, decrement that */
&lt;&lt;if def $action.uses&gt;&gt;
	&lt;&lt;run subject().actions.find(function(a) { return a &amp;&amp; a.name == $action.name }).uses -= 1&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* If action has a cooldown, reset it */
&lt;&lt;if def $action.cd&gt;&gt;
	&lt;&lt;run subject().actions.find(function(a) { return a &amp;&amp; a.name == $action.name }).resetCD()&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* If target was an enemy (i.e. an attacking skill was used), subject is marked as attacker. (This is for enemies that target the last puppet to attack them.) */
&lt;&lt;if $target instanceof Enemy&gt;&gt;
	&lt;&lt;set $B.attacker = $puppets.indexOf($subject)&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* isDone logic; checks for confounding factors */
&lt;&lt;if $action.instant&gt;&gt;
	/* do nothing */
&lt;&lt;elseif $subject.inspired&gt;&gt;
	&lt;&lt;set $subject.inspired = false&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $subject.isDone = true&gt;&gt;
	&lt;&lt;set $B.enemyTurns++&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $action.oncePerTurn&gt;&gt;
	&lt;&lt;set $action.used = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Subtract action cost */
&lt;&lt;if $action instanceof ItemAction&gt;&gt;
	&lt;&lt;set $B.item_used = true&gt;&gt;
	&lt;&lt;if $subject.crafty&gt;&gt;
		&lt;&lt;set $action._cost = Math.round(setup.ITEM_COST/2)&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $action._cost = setup.ITEM_COST&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set $subject.en -= $action.cost&gt;&gt;

&lt;&lt;if $B.surrender &amp;&amp; def $action.name&gt;&gt;
	&lt;&lt;print $enemy_to_spare.surrenderCheck()&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;br/&gt;
&lt;center&gt;&lt;&lt;button &quot;Continue...&quot; &quot;Battle!&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;&lt;/center&gt;

&lt;/span&gt;
}}}
Now you can see how it all comes together in the action phase. The bits of code at the end are for tidying up. The action is saved to {{{lastAction}}}, the subject is flagged as done for the turn, and various other necessary flags are set. This code is simple in its basic structure, but a few special cases require some {{{&lt;&lt;if&gt;&gt;}}} statements, such as instant skills or the additional turn from Mage&#39;s &quot;Inspiration&quot; ability.
{{{
&lt;&lt;if $B.surrender &amp;&amp; def $action.name&gt;&gt;
	&lt;&lt;run $enemy_to_spare.surrenderCheck()&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
There is also functionality here for calling the {{{surrenderCheck}}} function, described in the &lt;a class=&quot;noExternal&quot; href=&quot;#JS.enemies&quot;&gt;Enemy Database&lt;/a&gt;. If the player uses an action that doesn&#39;t pass the check, the surrendering enemy will be aggro&#39;d and cease their surrender.

&lt;h3 id=&quot;actionqueue&quot;&gt;Action Queue&lt;/h3&gt;
There is additional functionality for handling special actions, such as counterattacks and Archer&#39;s Mark attacks. It is included in the {{{Widgets (Special Attacks).tw}}} file, which also handles the logic for triggering these special actions.
{{{
&lt;center id=&quot;continue&quot;&gt;
(...)
	&lt;&lt;button &quot;Continue...&quot;&gt;&gt;
		&lt;&lt;if $B.actionQueue.length &gt; 0&gt;&gt;
			&lt;&lt;replace &quot;#content&quot; &quot;t8n&quot;&gt;&gt;
				&lt;&lt;include &quot;Action Queue&quot;&gt;&gt;
				&lt;&lt;timed 0s&gt;&gt;&lt;&lt;include &quot;animation activator&quot;&gt;&gt;&lt;&lt;/timed&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		(...)
&lt;/center&gt;
}}}
If you look at the &quot;Battle Continue Button&quot; passage, you will see this handler within the button code. This says that if the {{{actionQueue}}}, and array property of the battle controller defined at the start of the battle, has a {{{length}}} greater than 0 (i.e. it has entries), we run this code instead of forwarding the player to the next passage as normal. We {{{&lt;&lt;replace&gt;&gt;}}} the existing passage instead of moving to a new one to preserve the identity of the current passage, as the passage name is used when determining the player&#39;s next destination when the queue is finished.

The &quot;Action Queue&quot; passage itself looks like this:
{{{
&lt;&lt;if $B.actionQueue.length &gt; 0&gt;&gt;
	&lt;&lt;set _data = $B.actionQueue.shift()&gt;&gt;
	&lt;&lt;set _OG = {target: $target, subject: $subject, action: $action}&gt;&gt;
	&lt;&lt;set $subject = getActorById(_data[0]); $action = _data[1]&gt;&gt;
	&lt;&lt;if !(subject().dead || subject().noact)&gt;&gt;
		&lt;&lt;if $action.counter&gt;&gt;
			&lt;&lt;set $target = _OG.subject&gt;&gt;
			&lt;&lt;set _counterActive = true&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;
		&lt;&lt;set _counterActive = false&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;timed 0s&gt;&gt;&lt;&lt;trigger &#39;click&#39; &quot;#continue button&quot;&gt;&gt;&lt;&lt;/timed&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;include &quot;Battle Continue Button&quot;&gt;&gt;
}}}
We start by {{{shift}}}ing the first entry out of the {{{actionQueue}}} and storing it in {{{_data}}}. ({{{shift}}} is an array function that extracts the first entry from an array; this both removes it from the original array, and allows us to store the entry in another variable. Because this shortens the array, we will eventually empty the {{{actionQueue}}} this way.) Then, we need to store the original target, subject, and action in a holder variable, so that we can put them back when we&#39;re done.
{{{
&lt;&lt;set $subject = getActorById(_data[0]); $action = _data[1]&gt;&gt;
}}}
We then need to set the new subject and action. We do this by reading the entry we got from the {{{actionQueue}}}. Entries added to the {{{actionQueue}}} are assumed to be, themselves, arrays consisting of two elements: the ID of the character to perform the action, and then the action itself.

The target is determined by the action itself. For counterattacks, there is standard code that sets the target to the original subject.
{{{
&lt;&lt;include &quot;action effects&quot;&gt;&gt;
}}}
Note that we need to include &quot;action effects&quot; to run the action -- but that passage, itself, populates the {{{actionQueue}}}! If two characters with counterattacks started attacking each other, they&#39;d keep attacking in an endless loop. To prevent that, we set the {{{_counterActive}}} flag, which prevents further counterattacks from triggering. This prevents characters from countering counters and creating an endless loop. (We need to set similar flags for every class of special action to prevent similar loops.)
{{{
&lt;&lt;if !(subject().dead || subject().noact)&gt;&gt;
	(...)
&lt;&lt;else&gt;&gt;
	&lt;&lt;timed 0s&gt;&gt;&lt;&lt;trigger &#39;click&#39; &quot;#continue button&quot;&gt;&gt;&lt;&lt;/timed&gt;&gt;
}}}
Finally, we have an escape handler. If for some reason the character died or was stunned in-between triggering their counter and now, we skip straight to the next passage by simulating a click on the continue button. (Note that we have to wrap this code in a {{{&lt;&lt;timed&gt;&gt;}}} block because it references an element on the page, which won&#39;t exist until the whole page has finished rendering.)

&lt;h3 id=&quot;endOfRound&quot;&gt;End of Round&lt;/h3&gt;
{{{
&lt;span id=&quot;status&quot;&gt;
&lt;&lt;include status&gt;&gt;
&lt;/span&gt;

&lt;span id=&quot;content&quot;&gt;

&lt;&lt;if $B.turn eq &quot;player&quot;&gt;&gt;
/* If the turn reads &quot;player&quot;, it&#39;s because the enemy round just finished. Run end of turn for enemies. */
	/* If it&#39;s a new player turn, it&#39;s a &quot;true&quot; new round, so need to update and reset controller variables. */
	&lt;&lt;set $B.turnCounter++; $B.embargo--; $B.enemyTurns = 0; $B.actions_this_turn = {}&gt;&gt;
	&lt;&lt;endOfRound $enemies&gt;&gt;
	&lt;&lt;newTurn $puppets&gt;&gt;
	&lt;&lt;if _message&gt;&gt;
		&lt;&lt;button &quot;Continue...&quot; &quot;Battle!&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;elseif $B.turn eq &quot;enemy&quot;&gt;&gt;
/* If the turn reads &quot;enemy&quot;, the player turn just finished. Run end of turn for player. */
	&lt;&lt;endOfRound $puppets&gt;&gt;
	&lt;&lt;if _message&gt;&gt;
		&lt;br/&gt;&lt;&lt;button &quot;Continue...&quot; &quot;enemy phase&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;
}}}
As you can see, the functionality of the &lt;b&gt;end of round&lt;/b&gt; passage is mostly outsourced to a widget, which can be found at the top of the &quot;Battle Phases&quot; file.
{{{
&lt;&lt;widget &quot;endOfRound&quot;&gt;&gt;
&lt;&lt;for _actor range $args[0].filter(function (a) { return a !== null; })&gt;&gt;
	&lt;&lt;set _actor.isDone = false&gt;&gt;
	&lt;&lt;if _actor instanceof Enemy &amp;&amp; def _actor._respawn &amp;&amp; _actor.dead&gt;&gt;
		&lt;&lt;set _actor.respawn--&gt;&gt;
		&lt;&lt;if _actor.respawn &lt;= 0&gt;&gt;
			&lt;&lt;set _actor.dead = false; _actor.hp = _actor.maxhp; _actor.resetRespawn()&gt;&gt;
			&lt;&lt;set _message = true&gt;&gt;
				&lt;div id=&quot;actFlavor&quot;&gt;
					&lt;&lt;print _actor.respawnMessage&gt;&gt;
				&lt;/div&gt;
				&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _effect range _actor.effects&gt;&gt;
		/* DoT check */
		&lt;&lt;if _effect.dot is true&gt;&gt;
				&lt;&lt;set _message to true&gt;&gt;
				&lt;&lt;set $dmg = _effect.damage(_actor)&gt;&gt;
				&lt;div id=&quot;actFlavor&quot;&gt;
					&lt;&lt;print _effect.msg(_actor)&gt;&gt;
				&lt;/div&gt;
				&lt;div id=&quot;actEffect&quot;&gt;
					&lt;&lt;echoDamage _actor &quot;indirect&quot; &quot;nocalc&quot;&gt;&gt;
				&lt;/div&gt;
				&lt;br/&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;

	/* decrementor */
	&lt;&lt;decayMessage _actor.effects false&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
The main purpose of the end-of-round widget is to handle status effects. Status effect durations are decremented and damage-over-time effects inflict their damage. This is accomplished through two for loops: one across the party (which party is specified in the argument given to the widget), and one across the effects of the current character. If a damage-over-time effect is found, its damage is calculated its damage message is printed.

For effect decrement, we use another widget, {{{&lt;&lt;decayMessage&gt;&gt;}}}. (This code is compartmentalized because it is reused in the top-of-round code; see {{{newTurn}}}, below.)
{{{
&lt;&lt;widget &quot;decayMessage&quot;&gt;&gt;

&lt;&lt;set _topDec = Boolean($args[1])&gt;&gt;
&lt;&lt;set _decayMsg = &quot;&quot;&gt;&gt;
&lt;&lt;for _effect range $args[0].filter(function (eff) { return eff.topDec == temporary().topDec })&gt;&gt;
  &lt;&lt;set _m = _effect.decay(_actor)&gt;&gt;
  &lt;&lt;if _m.length &gt; 1&gt;&gt;
    &lt;&lt;set _decayMsg += _m&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _decayMsg.length &gt; 0&gt;&gt;
  &lt;div id=&quot;actEffect&quot;&gt;
    &lt;&lt;print _decayMsg&gt;&gt;
  &lt;/div&gt;
  &lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
We call the {{{decay}}} method function on each of the character&#39;s effects, which decrements the effect&#39;s duration by 1 and removes it if it hits 0. If the effect is removed, {{{decay}}} will return the removal message, which we will store in temporary variable {{{_m}}} and add to an aggregate text string, {{{_decayMsg}}}. When all effects are finished, we print the aggregate {{{_decayMsg}}}, providing it contains anything.
{{{
&lt;&lt;if _m.length &gt; 1&gt;&gt;
  &lt;&lt;set _decayMsg += _m&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Note this check here. Some effects produce an empty decay message, which is not meant to be displayed to the player. We don&#39;t want to add these strings to {{{_decayMsg}}}, so we need to check that {{{_m}}} is longer than 1 character. The reason the check is &lt;i&gt;strictly greater than&lt;/i&gt; 1 as opposed to &lt;i&gt;greater than or equal to&lt;/i&gt; 1 is because the {{{decay}}} function automatically adds a newline character, {{{\n}}}, to any decay message it receives, even if it&#39;s empty.
{{{
&lt;&lt;if _message&gt;&gt;
	&lt;&lt;button &quot;Continue...&quot; &quot;Battle!&quot;&gt;&gt;&lt;&lt;/button&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Finally, we use the {{{_message}}} flag is used to ensure the player only lingers on the &quot;end of round&quot; passage if necessary. If no messages were generated, {{{_message}}} will remain false, and the player will be pushed to the next passage automatically. This is done to create a smoother player experience. (The {{{decay}}} function will automatically flip {{{_message}}} to {{{true}}} if it receives a non-empty decay message.)

There is a corresponding widget called at the top of a round: {{{&lt;&lt;newTurn&gt;&gt;}}}.
{{{
&lt;&lt;widget &quot;newTurn&quot;&gt;&gt;
&lt;&lt;for _actor range $args[0].filter(function (a) { return a !== null; })&gt;&gt;
	&lt;&lt;set _actor.isDone to false&gt;&gt;
	&lt;&lt;if !_actor.dead&gt;&gt;
		&lt;&lt;run _actor.regenHP()&gt;&gt;
		&lt;&lt;run _actor._retaliations.refill()&gt;&gt;
  &lt;&lt;/if&gt;&gt;
	&lt;&lt;if _actor instanceof Puppet&gt;&gt;
    /* Puppet-exclusive tasks:
			decrement respawn (enemy respawn only decremented at end of round)
			refresh used actions */
    &lt;&lt;if _actor.dead &amp;&amp; def _actor._respawn&gt;&gt;
  		&lt;&lt;set _actor.respawn--&gt;&gt;
  		&lt;&lt;if _actor.respawn &lt;= 0&gt;&gt;
  			&lt;&lt;set _actor.dead = false; _actor.hp = Math.round(_actor.maxhp * setup.RESPAWN_HP); _actor.resetRespawn()&gt;&gt;
  			&lt;&lt;set _message to true&gt;&gt;
  			&lt;div id=&quot;actFlavor&quot;&gt;
  				&lt;&lt;print _actor.respawnMessage&gt;&gt;
  			&lt;/div&gt;
  			&lt;br/&gt;
  		&lt;&lt;/if&gt;&gt;
    &lt;&lt;/if&gt;&gt;
    &lt;&lt;for _action range _actor.actions.filter(function (act) { return act.used === true })&gt;&gt;
      &lt;&lt;run _action.used = false&gt;&gt;
    &lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
  &lt;&lt;decayMessage _actor.effects true&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;include &quot;custom newTurn&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This refreshes everyone&#39;s {{{isDone}}} flag, regenerates HP and retaliatiations, advances respawn counters, and decrements top-of-round status effects. Actions that can only be used once per turn, such as Mage&#39;s &quot;Sacrifice&quot; ability, are also reset so they can be used again. (In the default engine, EN regeneration is handled in &quot;custom newTurn&quot;, so you can easily remove it if you don&#39;t want to use EN.)

&lt;h3 id=&quot;enemyphase&quot;&gt;Enemy Phase&lt;/h3&gt;
The enemy turn. This passage is complicated, because it must essentially incorporate all the events of the previous passages at once.
{{{
&lt;&lt;if (deadCount() == puppets().length)&gt;&gt;
/* If all puppets are dead, it&#39;s game over -- no point in finishing this passage, just let victorycheck do its thing. */
}}}
The very first thing we have to do is actually to check if there&#39;s any point in running the enemy turn at all! It is possible for the enemies to defeat the player in the middle of their turn; it would be pointless for them to keep acting after that, as the player has already lost. In this case, we run no code in this passage, and just let the defeat handler resolve the battle.
{{{
&lt;&lt;if $B.ambush&gt;&gt;
	&lt;&lt;set $B.ambush = false; $B.turn = &quot;enemy&quot;&gt;&gt;
	&lt;center style=&quot;font-weight:bold&quot;&gt;AMBUSHED!&lt;/center&gt;&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
}}}
If we &lt;i&gt;are&lt;/i&gt; executing the enemy turn, first we have a handler for ambushes. Normally, battles start on the player&#39;s turn, but if the {{{ambush}}} property is flagged, the battle starts here. We display a message informing the player of this fact, and unset {{{ambush}}}.
{{{
&lt;&lt;set _enemy = enemies().sort(function(a,b) { return a.priority - b.priority; })
	.find(function (e) { return e &amp;&amp; !e.isDone &amp;&amp; !e.dead })&gt;&gt;
}}}
We then need to find the active enemy. We can&#39;t just iterate over the whole enemy party with a loop, because we don&#39;t want every enemy&#39;s turn to display at once. Instead, we have to pick a single enemy by searching the array. First, we sort the enemy party in ascending {{{priority}}} value; then, we run a {{{find}}} function searching for an enemy that is defined, not done, and not dead. Because {{{find}}} stops at the first element that satisfies its conditions, and because we have already sorted the array, this will ensure enemies act in the proper priority order.
{{{
&lt;&lt;if _enemy instanceof Enemy&gt;&gt;
(...)
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $B.turn = &quot;player&quot;&gt;&gt;
	&lt;&lt;goto &quot;end of round&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
However, we can only go ahead if that operation &lt;i&gt;did&lt;/i&gt; find a valid enemy! If all the enemies have acted, {{{find}}} will fail and return {{{undefined}}}. In this case, we should end the enemy turn and forward the player to the next round.
{{{
&lt;&lt;set $subject = _enemy&gt;&gt;
&lt;&lt;set $target = null&gt;&gt;
&lt;&lt;if _enemy.isFirstAction&gt;&gt;
	&lt;&lt;newTurn `[_enemy]`&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _enemy.isDone = true&gt;&gt;
}}}
But if all is well, we will run {{{&lt;&lt;newTurn&gt;&gt;}}} for the enemy, which provides the same functions as it did for the player characters. (Note that {{{&lt;&lt;newTurn&gt;&gt;}}} only works with arrays, so we need to place the enemy object within an array when passing it to the widget.) However, we need to manually set {{{isDone}}} to {{{true}}}, because if you recall, {{{&lt;&lt;newTurn&gt;&gt;}}} sets {{{isDone}}} to {{{false}}}. The enemy also becomes the active subject.
{{{
&lt;&lt;if !_enemy.fakedeath&gt;&gt;
(...)
&lt;&lt;else&gt;&gt;
	&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
}}}
Then we have to check this clause before proceeding. The {{{fakedeath}}} property essentially skips the enemy&#39;s turn as if they were dead, but still allows the above new-round effects to occur.
{{{
&lt;&lt;if _enemy.noact&gt;&gt;
	&lt;&lt;set _effect = _enemy.effects.sort(function(a,b) { return a.priority - b.priority; })
		.find(function (e) { return e &amp;&amp; e.holdAction instanceof Function })&gt;&gt;
	/* Sorts effects by priority and returns the first hold effect (one with a holdAction) */
	&lt;&lt;run console.assert(_effect !== undefined,`ERROR in enemy phase: ${_enemy.name} has noact but no hold effect`)&gt;&gt;
	&lt;&lt;set $action = _effect.holdAction()&gt;&gt;
	&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;
	&lt;&lt;include &quot;custom end of action effects&quot;&gt;&gt;
}}}
The enemy is then checked against hold effects. If they have one (or more), their effects are sorted by {{{priority}}}, then the first effect with a working {{{holdAction}}} property is found. {{{holdAction()}}} is then run, which fills {{{$action}}} with a &quot;dummy&quot; action that just contains {{{actText}}} informing the player that the enemy is under said effect. (The {{{priority}}} sort allows you to have a heirarchy of hold effects; for example, by default, enemies cannot right themselves from Knocked Down if they are also Stunned.)
{{{
&lt;&lt;else&gt;&gt;
	&lt;&lt;if _enemy.isFirstAction&gt;&gt;
		&lt;&lt;run _enemy.decCD()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _counters = []&gt;&gt;
	&lt;&lt;set $action = null&gt;&gt;
	&lt;&lt;run _enemy.actions()&gt;&gt;
	&lt;&lt;run $B.actionsThisTurn[_enemy.id].push($action.name)&gt;&gt;
	&lt;&lt;if !_targetfail&gt;&gt;
		&lt;&lt;include &quot;action effects&quot;&gt;&gt;&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
	(...)
		&lt;&lt;run $B.enemyTurns -= 1&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Only in the default {{{&lt;&lt;else&gt;&gt;}}} clause, if the enemy passes all these checks, does enemy action occur. The {{{actionsThisTurn}}} object can be used to track which actions the enemy has already used on their turn, if you want them to modify their behavior based on previous actions. (Note that we must populate it with the enemy&#39;s &lt;i&gt;ID&lt;/i&gt;, not the enemy&#39;s name, because while names can be duplicated, IDs are unique.)

The details of the {{{actions}}} function can be found in the {{{database-enemies}}} JavaScript file, which is discussed &lt;a class=&quot;noExternal&quot; href=&quot;#JS.enemies&quot;&gt;here&lt;/a&gt;. Setting {{{$action}}} to {{{null}}} is necessary to ensure the function works correctly; otherwise the enemy will think they&#39;ve already selected an action.
{{{
&lt;&lt;if !_targetfail&gt;&gt;
}}}
This check is necessary in case the enemy&#39;s attack fails to find a target. (See &lt;a class=&quot;noExternal&quot; href=&quot;#targeting.basic&quot;&gt;Targeting&lt;/a&gt;.) If this happens and the action is allowed to play out, glitches can occur.
{{{
&lt;center id=&quot;continue&quot;&gt;
&lt;&lt;button &quot;Continue...&quot;&gt;&gt;
	&lt;&lt;if $B.enemyTurns &gt; 0 || $B.turn == &quot;enemy&quot;&gt;&gt;
		&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/button&gt;&gt;
&lt;/center&gt;
}}}
Finally, at the very end of the passage, we generate a button to allow the player to continue. It has branching behavior depending on the {{{enemyTurns}}} counter: If there are enemy turns remaining (or if it&#39;s the enemy&#39;s turn, in which case they all act at once), we refresh this passage, which allows the next enemy to be selected and act. (Remember that if all the enemies have acted, we will forward the player to the end of round passage instead through an earlier handler.) Otherwise, the player is taken back to the main &quot;Battle!&quot; screen and returned to their turn.

&lt;h4 id=&quot;enemyphase.multiActions&quot;&gt;Enemies with Multiple Actions&lt;/h4&gt;
Some enemies can act multiple times per turn, as determined by their {{{noAttacks}}} (short for &quot;number of attacks&quot;) attribute. For this, we need some special handlers.
{{{
get isFirstAction () {
	return (V().B.actionsThisTurn[this.id] instanceof Array &amp;&amp; V().B.actionsThisTurn[this.id].length == 0);
}
}}}
You might recall seeing this property used in some of the previous checks. It returns {{{true}}} if the enemy&#39;s {{{noAttacks}}} is at maximum; that is, if they haven&#39;t taken any actions yet. This is useful, because we want to keep running the same action code for the enemy until they&#39;re out of actions, but there&#39;s some code, like {{{&lt;&lt;newTurn&gt;&gt;}}}, we only want to run once.
{{{
&lt;&lt;if $action.fullround === true&gt;&gt;
	&lt;&lt;run _enemy.noAttacks = 0&gt;&gt;
&lt;&lt;elseif !$action.instant&gt;&gt;
	&lt;&lt;run _enemy.noAttacks--&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _enemy.noAttacks &gt; 0&gt;&gt;
	&lt;&lt;set _enemy.isDone = false&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;run $B.enemyTurns -= 1&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
After the enemy&#39;s action is executed, we run some checks against their {{{noAttacks}}}. Firstly, if the action had the {{{fullround}}} attribute, it is considered to end the enemy&#39;s turn no matter how many actions they had remaining, so we set {{{noAttacks}}} to 0. Otherwise we&#39;ll reduce {{{noAttacks}}} by 1, unless the action was instant. Then, we&#39;ll only remove the enemy&#39;s turn from the {{{enemyTurns}}} pool &lt;i&gt;if they have no actions remaining&lt;/i&gt; -- if {{{noAttacks}}} is greater than 0, {{{isDone}}} is set to {{{false}}}, allowing the enemy to be selected again. In this way, we allow the enemy to keep acting until it&#39;s out of actions. ({{{noAttacks}}} is refreshed at the end of the round, starting the cycle anew.)

&lt;h3 id=&quot;advanceturn&quot;&gt;Advancing Turns&lt;/h3&gt;
There is a feature added in version 1.12 that modifies the behavior of the &quot;End Turn&quot; button.
{{{
&lt;&lt;set $subject.isDone = true&gt;&gt;
&lt;&lt;set $B.enemyTurns++&gt;&gt;
(...)
&lt;&lt;run _enemy.decCD(); $B.enemyTurns--&gt;&gt;
(...)
&lt;&lt;for _e, _enemy range $enemies.sort(function(a,b) { return a.priority - b.priority; })&gt;&gt;
	&lt;&lt;if !($B.enemyTurns &gt; 0 || $B.turn == &quot;enemy&quot;)&gt;&gt;
		&lt;&lt;break&gt;&gt;
}}}
Notice this {{{enemyTurns}}} variable. We skipped over it in prior discussions, but let&#39;s bring it all together now. You can see through this code (from the action and enemy phases) that {{{enemyTurns}}} is incremented when a player character finishes their turn, and decremented when an enemy performs their turn. If {{{enemyTurns}}} drops to 0 while the turn is still the player&#39;s, the {{{break}}} statement within {{{if !($B.enemyTurns &gt; 0 || $B.turn == &quot;enemy&quot;)}}} will be executed, and the enemy actions loop will stop prematurely.

This allows the player to space out the enemy turns, instead of having to take all of their attacks at once. This isn&#39;t too big of a deal in &lt;i&gt;Cartoon Battle&lt;/i&gt;, but players might appreciate it in a system where they have lower HP totals than the enemies and might get taken out if a single character is swarmed by all enemies.

However, we still need to account for the possibility that the enemy and player parties are unequal. If the enemy has 4 characters and you have only 3, what happens when you use all of your turns and have only given the enemy 3? This is the purpose the {{{if $B.turn == &quot;enemy&quot;}}} clause. If the player&#39;s turn has completely ended and the round has shifted to the enemies, they bypass the {{{enemyTurns}}} check and all remaining enemies can act freely.
{{{
&lt;&lt;if $B.enemyTurns == 0 || _doneCount == puppets().length&gt;&gt;
	&lt;&lt;button &quot;END TURN&quot;&gt;&gt;
		&lt;&lt;endturn&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;button &quot;ADVANCE TURN&quot;&gt;&gt;
		&lt;&lt;set $B.phase = null&gt;&gt;
		&lt;&lt;goto &quot;enemy phase&quot;&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;/if&gt;&gt;

(...)

&lt;&lt;widget &quot;endturn&quot;&gt;&gt;
&lt;&lt;set $B.turn = &quot;enemy&quot;; $B.phase = null&gt;&gt;
&lt;&lt;goto &quot;end of round&quot;&gt;&gt;
&lt;&lt;/widget&gt;&gt;

(...)

&lt;&lt;button &quot;Continue...&quot;&gt;&gt;
	&lt;&lt;if $B.turn == &quot;enemy&quot;&gt;&gt;
		&lt;&lt;set $B.turn = &quot;player&quot;&gt;&gt;
		&lt;&lt;goto &quot;end of round&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;goto &quot;Battle!&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/button&gt;&gt;
}}}
But that raises another question: How do we determine when the player&#39;s turn has &quot;ended&quot;? That&#39;s handled through the first block of code here, which generates the &quot;End Turn&quot; button for the player. If there are no enemy turns left or if all puppets have acted, the button says &quot;END TURN&quot;, sets the {{{turn}}} property to &quot;enemy&quot;, and forwards the player to the &quot;end of round&quot; passage. Otherwise, the button says &quot;ADVANCE TURN&quot;, and only forwards us to the enemy passage without modifying the {{{turn}}} property. From the previous code, you can see this means only a number of enemies equal to the {{{enemyTurns}}} variable will act. The enemy phase&#39;s &quot;Continue&quot; button has its own form of this: If the turn belongs to the enemy, we switch the {{{turn}}} property back around and go to &quot;end of round&quot; to finish the round; otherwise, we go back to the player&#39;s side of things.
{{{
&lt;&lt;if _start == $B.enemyTurns&gt;&gt;
	&lt;&lt;set $B.turn = &quot;player&quot;&gt;&gt;
	&lt;&lt;goto &quot;end of round&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
There&#39;s also this little check, which is just for convenience. If {{{enemyTurns}}} doesn&#39;t change -- so, no enemies act -- this passage will be blank except for the &quot;Continue&quot; button, which looks weird. There&#39;s no need for the player to linger on the passage in this case, so we just automatically forward them to the end of the round.

&lt;h3 id=&quot;victorydefeat&quot;&gt;Victory and Defeat&lt;/h3&gt;
So, what happens when the battle ends? There is a standard {{{Victory}}} passage that the player is forwarded to if they win (see &lt;a class=&quot;noExternal&quot; href=&quot;#victorycheck&quot;&gt;{{{&lt;&lt;victorycheck&gt;&gt;}}}&lt;/a&gt;). Let&#39;s look at it:
{{{
&lt;&lt;set _XPBars = []; _animationTime = &quot;1s&quot;&gt;&gt;
}}}
The first thing is to initialize the array of our experience bars and their animation time (defaulting to 1 second).
{{{
&lt;div class=&quot;actors&quot;&gt;
&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
	&lt;&lt;set _id = &#39;p&#39;+_i&gt;&gt;
	&lt;&lt;run _XPBars.push(_id)&gt;&gt;
	&lt;&lt;set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)&gt;&gt;
	&lt;&lt;newmeter _id _value&gt;&gt;
		&lt;&lt;colors cyan cyan black&gt;&gt;
		&lt;&lt;animation _animationTime linear&gt;&gt;
		&lt;&lt;sizing 100%&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
}}}
We iterate over our {{{$puppets}}} and generate XP bars similarly to how we generated health bars in &lt;a class=&quot;noExternal&quot; href=&quot;#actorlist&quot;&gt;actorlist&lt;/a&gt;. The starting value of the bars is a little complicated to calculate: We are looking not at the ratio of total XP to the XP of the next level (which both account for &lt;i&gt;all&lt;/i&gt; the XP a puppet has acquired since level 1), but how much &lt;i&gt;more&lt;/i&gt; XP the puppet has to get to reach the next level. To get that, we need to calibrate for the current level. To track the puppet&#39;s current progress, we subtract the puppet&#39;s current XP from the {{{XPtoNext}}} of the &lt;i&gt;previous&lt;/i&gt; level, and mark the &quot;goal&quot; as the {{{XPtoNext}}} of their current level minus their previous. We also have to clamp this ratio between 0 and 1 to prevent possible overflow.

That was probably confusing to follow, so here&#39;s a concrete example: Say the puppet has just reached level 3, and has 3000 XP in total. According to their {{{XPtoNext}}} function, they will reach level 4 when they have 5000 XP &lt;i&gt;in total&lt;/i&gt;. However, in relative terms, they only need 2000 more XP to reach the next level. If we just set the meter&#39;s progress to {{{XP / XPtoNext()}}}, that will give us {{{3000 / 5000}}}, starting the meter at 60% filled! But if we subtract the XP requirement for the previous level (3000) from both the current and target XP values, we get {{{0 / 2000}}} -- completely unfilled, as it should be when starting at the next level. If the puppet gains 1000 XP, the meter&#39;s progress will be {{{1000 / 2000}}} -- halfway filled.
{{{
&lt;&lt;animation _animationTime linear&gt;&gt;
}}}
Unlike the health bars, these meters &lt;i&gt;are&lt;/i&gt; animated, with a time set by {{{_animationTime}}}. You can change this if you like.
{{{
&lt;div class=&quot;actor victory&quot;&gt;
&lt;center style=&quot;text-transform:uppercase; font-weight:bold&quot;&gt;_puppet.name&lt;/center&gt;
LEVEL &lt;span @id=&quot;&#39;lv&#39;+_i&quot;&gt;_puppet.level&lt;/span&gt;
&lt;&lt;showmeter _XPBars[_i] _value&gt;&gt;
&lt;center @id=&quot;&#39;lvlupmsg&#39;+_i&quot;&gt;&amp;nbsp;&lt;/center&gt;
&lt;/div&gt;
}}}
With our calculations done, we can display the actual meter. The puppet is displayed in a standard {{{actor}}} box, with a few modifications from the {{{victory}}} class. (The most important one is a {{{margin-bottom: 1em}}} attribute, which spaces out the boxes more nicely if they run onto a second line.) The puppet&#39;s current level is displayed within a {{{&lt;span&gt;}}} marked with an {{{id}}} keyed to the puppet&#39;s index, then the XP bar, and then a placeholder for a level up message, again marked with an {{{id}}} keyed to the puppet&#39;s index so we can reference it later.
{{{
&lt;&lt;set _multiplier = 1&gt;&gt;
&lt;&lt;set _puppet.xp += Math.round($B.XPreward * _multiplier)&gt;&gt;
&lt;&lt;set _value = Math.clamp((_puppet.xp - _puppet.XPtoNext(_puppet.level - 1)) / (_puppet.XPtoNext() - _puppet.XPtoNext(_puppet.level - 1)),0,1)&gt;&gt;
&lt;&lt;updatemeter _XPBars[_i] _value&gt;&gt;
}}}
Having initialized the XP bar, now we can update it. Each puppet&#39;s XP is incremented by the {{{XPreward}}} accumulated throughout the battle (see &lt;a class=&quot;noExternal&quot; href=&quot;#deathcheck&quot;&gt;{{{&lt;&lt;deathcheck&gt;&gt;}}}&lt;/a&gt;), the new value of the meter is calculated the same way as before, and the meter is updated with the new value. (This will run the update animation. If you have no animation specified, the XP meters will immediately start at their updated values from the player&#39;s perspective. Note that there&#39;s no delay on this, so the meters will start filling immediately; if you want to space it out, you&#39;ll have to place this code in a separate {{{&lt;&lt;timed&gt;&gt;}}} block.)

We also include a variable, {{{_multipler}}}, that you can use to account for any special modifiers on XP. Perhaps you have a piece of equipment that lets you gain XP faster, or a status effect that renders you unable to gain XP.
{{{
&lt;&lt;set $currency += $B.moneyReward&gt;&gt;
&lt;center style=&quot;margin-top:1em;&quot;&gt;&lt;div style=&quot;display:inline-block; width:50%; font-size:20pt; text-align:left&quot;&gt;&lt;&lt;print setup.CURRENCY_NAME&gt;&gt; &lt;span style=&quot;float:right&quot;&gt;$B.moneyReward&lt;/span&gt;&lt;/div&gt;&lt;/center&gt;
}}}
After that&#39;s done for all puppets, we increment the player&#39;s currency variable by the battle&#39;s {{{moneyReward}}}, and display a message informing the player of this fact. (If you have more complicated rules for handling currency, such as every character having their own purse, you&#39;ll need to do something different.)
{{{
&lt;&lt;set _itemDrops = []&gt;&gt;
&lt;&lt;for _enemy range $B.kills&gt;&gt;
	&lt;&lt;for _item, _chance range _enemy.itemDrops&gt;&gt;
	/* Assumes itemDrops is an object with property names of items corresponding to a number between 1 and 100 equal to the % chance of the item being dropped. */
		&lt;&lt;if typeof(_item) == &#39;string&#39; &amp;&amp; typeof(_chance) == &#39;number&#39;&gt;&gt;
			&lt;&lt;set _r = random(1,100)&gt;&gt;
			&lt;&lt;if _r &lt;= _chance&gt;&gt;
				&lt;&lt;run inv().addItem(_item); _itemDrops.push(_item)&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _itemDrops.length &gt; 0&gt;&gt;
	&lt;center style=&quot;margin-top:1em;&quot;&gt;
	&lt;div style=&quot;font-size:20pt; font-weight:bold&quot;&gt;DROPS:&lt;/div&gt;
	&lt;span class=&quot;itembox&quot; style=&quot;width:30%&quot;&gt;
	&lt;&lt;for _item range _itemDrops&gt;&gt;
		&lt;b&gt;&lt;&lt;print _item&gt;&gt;&lt;/b&gt;&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/span&gt;
	&lt;/center&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then comes item drops. We&#39;ll loop over the {{{kills}}} array and extract the {{{itemDrops}}} table from each enemy. If the table has been constructed correctly (a list of item names as properties pointing to percentile values), we roll a d100 to see if the item was dropped by the enemy. If so, we add it to the player&#39;s inventory and to the {{{_itemDrops}}} array, which we iterate over next to display the information to the player.

Note that this code allows the same enemy to drop multiple items, as the loop over {{{itemDrops}}} is not stopped if a drop is found. You will need to change this code if you want different behavior.

Note also that this prints every item individually, even if they&#39;re duplicates. This could get cumbersome if you plan to have large party sizes and/or for enemies to drop many items, and it may be worthwhile to figure out a way to lump duplicate items together onto one line for this circumstance.
{{{
&lt;&lt;timed _animationTime&gt;&gt;
	&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
		&lt;&lt;if _puppet.xp &gt;= _puppet.XPtoNext()&gt;&gt;
			&lt;&lt;set _id = &quot;#lv&quot;+_i&gt;&gt;
			&lt;&lt;replace _id&gt;&gt;&lt;span style=&quot;font-weight:bold&quot;&gt;&lt;&lt;print (_puppet.level+1)&gt;&gt;&lt;/span&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;set _id = &quot;#lvlupmsg&quot;+_i&gt;&gt;
			&lt;&lt;replace _id&gt;&gt;&lt;span style=&quot;font-weight:bold; color:cyan&quot;&gt;LEVEL UP!&lt;/span&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;levelcheck&gt;&gt;
	&lt;&lt;timed 3s&gt;&gt;
		&lt;&lt;goto &quot;Level Check&quot;&gt;&gt;
	&lt;&lt;/timed&gt;&gt;
&lt;&lt;/timed&gt;&gt;
}}}
We then execute this {{{&lt;&lt;timed&gt;&gt;}}} block. It waits for the XP bars&#39; animations to finish, then if the puppet leveled up, it replaces the {{{&lt;span&gt;}}}s we marked earlier with a &quot;LEVEL UP!&quot; message and an update to reflect the puppet&#39;s new level.

After another {{{&lt;&lt;timed&gt;&gt;}}} block, to give the player a chance to read and process these messages, the player is forwarded to the &quot;Level Check&quot; passage:
{{{
&lt;&lt;if $LevelUps.length &gt; 0&gt;&gt;
	&lt;&lt;set _p = $LevelUps.shift()&gt;&gt;
	&lt;center&gt;&lt;&lt;LevelUp _p&gt;&gt;&lt;/center&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;endofbattle&gt;&gt;
	&lt;&lt;goto $B.destination&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
If any puppets were added to the {{{$LevelUps}}} queue, they&#39;re {{{shift}}}ed out of the list and leveled up. The &quot;Level Up&quot; passage will keep directing the player back here until all level ups are complete, at which point the battle will end and the player will be forwarded to the passage specified by {{{$B.destination}}}. (By default, this is the passage immediately before the battle started, but unique destinations can be specified in the encounter definitions.)

Note that all of this assumes you are using a standard RPG model with XP, levels, and currency rewards after every battle. If you aren&#39;t, you may need to change this passage.

&lt;h2 id=&quot;actions&quot;&gt;Action Mechanics&lt;/h2&gt;
{{{
&lt;&lt;widget &quot;actionList&quot;&gt;&gt;
/* Widget for display of player actions. */
/* Individual action widgets take cost, damage multiplier, and other relevant variables as arguments so they can be displayed in the description. Values are given in &quot;Database: Actions&quot;. */

&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; ($args[0] instanceof Puppet),&quot;ERROR in actionList: no Puppet&quot;)&gt;&gt;
&lt;&lt;set _char = $args[0]&gt;&gt;
(...)
&lt;&lt;set _actions = _char.actions&gt;&gt;
&lt;&lt;for _action range _actions&gt;&gt;
&lt;&lt;if $inbattle &amp;&amp; !_action.passive&gt;&gt;
	(...)
	&lt;div @class=&quot;_actionClass&quot;&gt;
	&lt;&lt;capture _action&gt;&gt;
	&lt;&lt;mouseover&gt;&gt;
	&lt;span class=&quot;actionName&quot;&gt;
	&lt;&lt;if actionStandardCheck(_action)&gt;&gt;
	_action.name&lt;&lt;if (def _action.cd &amp;&amp; _action.cd !== 0)&gt;&gt;&amp;nbsp;&lt;span class=&quot;cooldowndisplay&quot;&gt;[CD &lt;&lt;print _action.cd&gt;&gt;]&lt;/span&gt;&lt;&lt;/if&gt;&gt;
	&lt;&lt;elseif actionLockCheck(_action)&gt;&gt;
	&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;Dizzy!&lt;/span&gt;
	&lt;&lt;elseif actionHPCheck(_action)&gt;&gt;
	&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;Not enough HP!&lt;/span&gt;
	&lt;&lt;elseif actionElementCheck(_action)&gt;&gt;
	&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;No element.&lt;/span&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;link &quot;_action.name&quot;&gt;&gt;
			&lt;&lt;actionLink&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;/span&gt;
	&lt;&lt;onmouseover&gt;&gt;
		&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
				&lt;&lt;actionInfo _action _char &quot;full&quot;&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;onmouseout&gt;&gt;
		&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
				&lt;&lt;include &quot;action box default&quot;&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/mouseover&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;&lt;if $COMPRESSED_ACTIONS === true &amp;&amp; $inbattle&gt;&gt;
		&lt;&lt;actionInfo _action _char &quot;no name&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;actionInfo _action _char &quot;no name&quot; &quot;full&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;

&lt;&lt;elseif !$inbattle&gt;&gt;
	&lt;div class=&quot;actionDisplay uncompressed&quot;&gt;
		&lt;&lt;actionInfo _action _char &quot;full&quot;&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
The construction of actions is previously discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#JS.actions&quot;&gt;the action database&lt;/a&gt;. They are displayed in-game through this widget, found in the &quot;Battle Phases&quot; file. This widget iterates across the &quot;actions&quot; array of a character with a for loop to create the links you use to select actions in the game.
{{{
&lt;&lt;capture _action&gt;&gt;
}}}
Note that before we do anything, we need to {{{&lt;&lt;capture&gt;&gt;}}} the current {{{_action}}} for our code. Links are activated by the user after the page has already rendered, and thus after the loop is finished. If we don&#39;t capture our iterator variable, every link will behave based on the data from the last action found by the loop. {{{&lt;&lt;capture&gt;&gt;}}} holds variables within its bounds, so the variable can be used correctly by the link.

&lt;h3 id=&quot;actions1&quot;&gt;Special Cases&lt;/h3&gt;
The default {{{&lt;&lt;else&gt;&gt;}}} case, which determines how things normally look, is listed last, so special cases come first in the code.
{{{
&lt;&lt;if $inbattle &amp;&amp; !_action.passive&gt;&gt;
}}}
The first clause handles passive abilities. We don&#39;t want to display passive abilities in battle, so we will only run the code for the display if the action&#39;s {{{passive}}} property is not {{{true}}}.

We then run into this clause:
{{{
&lt;&lt;if actionStandardCheck(_action)&gt;&gt;
}}}
which refers to this function in {{{1_support_functions.js}}}:
{{{
window.actionStandardCheck = function actionStandardCheck (action) {
	return (temporary().char.en &lt; action.cost)
	|| (typeof(action.uses) == &quot;number&quot; &amp;&amp; action.uses &lt; 1)
	|| (typeof(action.cd) == &quot;number&quot; &amp;&amp; action.cd !== 0)
	|| (action.used === true)
	|| (action.crisis &amp;&amp; temporary().char.crisisPoints &lt; 100);
}
}}}
This is for checking the most obvious cases: When the character has insufficient energy, uses, or cooldown to perform an action, obviously the player shouldn&#39;t be able to choose the action. This will also disable &quot;once per turn&quot; actions such as Mage&#39;s &quot;Sacrifice&quot; if they have already been used. (Note that we have to check if the action has a defined {{{uses}}} property, because not all of them do, and unexpected behavior could occur if we try to use a comparison operator with an {{{undefined}}} value.)

If the character can&#39;t pay the cost, the action&#39;s name is displayed as plain text with no special properties. (If you want it to display some other way, you can add your own HTML and CSS to give it a different appearance.)
{{{
&lt;&lt;if (def _action.cd &amp;&amp; _action.cd !== 0)&gt;&gt;&amp;nbsp;&lt;span class=&quot;cooldowndisplay&quot;&gt;[CD &lt;&lt;print _action.cd&gt;&gt;]&lt;/span&gt;&lt;&lt;/if&gt;&gt;
}}}
We also display a cooldown message next to the action&#39;s name if it&#39;s on cooldown.
{{{
window.actionLockCheck = function actionLockCheck (action) {
	return (temporary().char.dizzy &amp;&amp; !action.basic);
}
}}}
The next clause handles the &quot;Dizzy&quot; effect. Most RPGs have a &quot;skill lock&quot; effect that prevents characters from using anything but basic attacks; the example you are probably most familiar with is the &quot;Silence&quot; effect from the &lt;i&gt;Final Fantasy&lt;/i&gt; series of games. Since &lt;i&gt;Cartoon Battle&lt;/i&gt; had a lot of physical skills, I chose to use the name &quot;Dizzy&quot; instead, implying that the characters could not perform complex actions while disoriented.
{{{
&lt;&lt;elseif actionLockCheck(_action)&gt;&gt;
&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;Dizzy!&lt;/span&gt;
}}}
What this clause says is that if the character&#39;s &quot;dizzy&quot; flag is marked true, the action name is crossed out next to a &quot;Dizzy!&quot; message, again with no clickable link -- unless the action is flagged &quot;basic&quot;, in which case the {{{!_action.basic}}} conditional will fail and this section will be bypassed.

Despite being functionally identical to the first clause, I chose to make this a separate clause to convey more information to the player. If the action looks the same regardless of whether the character is dizzy or out of energy, the player might be confused about why they&#39;re deactivated. Making a different display for each helps the player understand what&#39;s going on.
{{{
window.actionHPCheck = function actionHPCheck (action) {
	return (action.hpcost &amp;&amp; temporary().char.hp &lt;= action.hpcost);
}

(...)

&lt;&lt;elseif actionHPCheck(_action)&gt;&gt;
&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;Not enough HP!&lt;/span&gt;
}}}
The next case deactivates the link for HP-consuming skills if the character does not have the requisite HP, with a unique message again for clarity for the player. Some games will let characters kill themselves with HP-consuming skills, but I chose to be nice and prevent this possibility in &lt;i&gt;Cartoon Battle&lt;/i&gt;. (If the {{{hpcost}}} attribute is undefined this conditional will simply be skipped, so you don&#39;t have to worry about defining it for every action.)
{{{
window.actionElementCheck = function actionElementCheck (action) {
	return (action.needsPriorElement &amp;&amp; typeof(temporary().char.lastUsed) !== &quot;string&quot;);
}

(...)

&lt;&lt;elseif actionElementCheck(_action)&gt;&gt;
&lt;del&gt;_action.name&lt;/del&gt; &lt;span class=&quot;dizzy&quot;&gt;No element.&lt;/span&gt;
}}}
Lastly, there&#39;s this very specific check I had to make for Artist&#39;s abilities. If the action needs to read the user&#39;s last used element and no such property exists, the action needs to be disabled.

&lt;h3 id=&quot;actions2&quot;&gt;The Functional Link&lt;/h3&gt;
So what happens when everything&#39;s in order, and the player can select the action? That&#39;s handled by the final {{{else}}} clause:
{{{
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;_action.name&quot;&gt;&gt;
		&lt;&lt;actionLink&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The functionality here is offloaded to a widget:
{{{
&lt;&lt;widget &quot;actionLink&quot;&gt;&gt;
	&lt;&lt;if $args.length &gt; 0&gt;&gt;
		&lt;&lt;set _action = $args[0]&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;if !(actionStandardCheck(_action) || actionLockCheck(_action) || actionHPCheck(_action) || actionElementCheck(_action))&gt;&gt;

	&lt;&lt;unset _s&gt;&gt;
	&lt;&lt;if _action.passagejump&gt;&gt;
		&lt;&lt;goto _action.phase&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $action = clone(_action)&gt;&gt;
		&lt;&lt;if !$action.nosave&gt;&gt;
			&lt;&lt;set $subject.lastAction = $action.name&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;set $B.targeting = _action.target&gt;&gt;
		&lt;&lt;set $B.noself = _action.noself&gt;&gt;
		&lt;&lt;if _action.phase is &quot;confirm phase&quot;&gt;&gt;
			&lt;&lt;set $target = null&gt;&gt;
			&lt;&lt;set $B.targeting = null&gt;&gt;
		&lt;&lt;elseif _action.phase is &quot;spell phase&quot;&gt;&gt;
			&lt;&lt;set $B.mincost = _action.cost&gt;&gt;
			&lt;&lt;set $B.targeting = null&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;include &quot;actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#phase&quot;&gt;&gt;&lt;&lt;include _action.phase&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This code assigns a &lt;i&gt;clone&lt;/i&gt; of the action to the permanent {{{$action}}} variable, or in other words, a copy. As discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#chain&quot;&gt;the {{{&lt;&lt;chain&gt;&gt;}}} widget&lt;/a&gt;, what is done to one object variable is done to all variables that reference the same object. So if we were to manipulate {{{$action}}} (such as by modifying the {{{cost}}} attribute for variable-cost spells), we would run the risk of passing on that change to the permanent action in the character&#39;s array as well. The clone avoids this problem.

Various other variable adjustments are made, depending on if the action has special properties. If the action is a spell, the link also stores the minimum cost, which will be used later in the spell phase.

After processing is finished, the link forwards the player to the next phase, based on what the action&#39;s {{{phase}}} property specified.

&lt;h3 id=&quot;actions3&quot;&gt;Info Display&lt;/h3&gt;
We could stop here, and we&#39;d technically still have a functioning game. However, players wouldn&#39;t know what any the actions do! We need to display that information somehow. This is handled through the {{{actionInfo}}} widget.
{{{
&lt;&lt;widget &quot;actionInfo&quot;&gt;&gt;
&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; ($args[0] instanceof Action),&quot;ERROR in actionInfo: no arguments passed&quot;)&gt;&gt;
&lt;&lt;if $args[1] instanceof Puppet&gt;&gt;
	&lt;&lt;set _char = $args[1]&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _act = $args[0]&gt;&gt;
&lt;&lt;if !$args.includes(&quot;no name&quot;)&gt;&gt;&lt;b&gt;&lt;&lt;print _act.name&gt;&gt;&lt;/b&gt;&lt;&lt;/if&gt;&gt;
&lt;&lt;if def _act.uses&gt;&gt;&amp;nbsp;&lt;span class=&quot;usedisplay&quot;&gt;(Uses: &lt;&lt;print _act.uses&gt;&gt;/&lt;&lt;print _act.maxUses&gt;&gt;)&lt;/span&gt;&lt;&lt;/if&gt;&gt;
&lt;span style=&quot;float:right; margin-left:0.5em;&quot;&gt;
&lt;&lt;if $args.includes(&quot;full&quot;)&gt;&gt;
	&lt;&lt;if !$inbattle &amp;&amp; _char.defaultAction.name === _act.name&gt;&gt;
		&lt;b&gt;[Default]&lt;/b&gt;&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.crisis&gt;&gt;
		&lt;b&gt;[Crisis]&lt;/b&gt;&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.basic&gt;&gt;
		[Basic]&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.instant&gt;&gt;
		[Instant]&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.passive&gt;&gt;
		[Passive]
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _act instanceof ItemAction&gt;&gt;
	x&lt;&lt;print _v.stock&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;if !_act.passive &amp;&amp; Number.isInteger(_act.cost) &amp;&amp; ((!_act.crisis &amp;&amp; _act.cost &gt;= 0) || (_act.crisis &amp;&amp; _act &gt; 0))&gt;&gt;
		&lt;&lt;print _act.cost&gt;&gt;&lt;&lt;if _act.phase === &quot;spell phase&quot;&gt;&gt;+&lt;&lt;/if&gt;&gt; EN
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/span&gt;
&lt;&lt;if !$inbattle &amp;&amp; !_act.noDefault &amp;&amp; _char.defaultAction.name !== _act.name&gt;&gt;
	&lt;div style=&quot;font-size:9pt&quot;&gt;
	&lt;&lt;capture _act&gt;&gt;
	&lt;&lt;link &quot;[Set as default]&quot;&gt;&gt;
		&lt;&lt;set _char.defaultAction = _act&gt;&gt;
		&lt;&lt;replace &quot;#menuActionList&quot;&gt;&gt;&lt;&lt;actionList _display&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $args.includes(&quot;full&quot;)&gt;&gt;
	&lt;&lt;if _act instanceof ItemAction&gt;&gt;
		&lt;&lt;set _act = new Item(_act.name)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div&gt;&lt;&lt;print _act.info&gt;&gt;&lt;/div&gt;
	&lt;&lt;if _act.desc !== null&gt;&gt;&lt;div class=&quot;actdesc&quot;&gt;&lt;&lt;print _act.desc&gt;&gt;&lt;/div&gt;&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget is used for display of actions both in and out of battle, so there are many branches to account for. We will be focusing just on the in-battle branches.

There is additional branching functionality depending on if we want the widget to display the full information of the action, in which case the action is passed the argument &quot;full&quot;, or if we only want to display the minimum cruical information.
{{{
&lt;&lt;if def _act.uses&gt;&gt;&amp;nbsp;&lt;span class=&quot;usedisplay&quot;&gt;(Uses: &lt;&lt;print _act.uses&gt;&gt;/&lt;&lt;print _act.maxUses&gt;&gt;)&lt;/span&gt;&lt;&lt;/if&gt;&gt;
}}}
The action&#39;s uses are always displayed after the action name if it&#39;s a limited-use action, which we can check with {{{if def _act.uses}}}.
{{{
&lt;span style=&quot;float:right; margin-left:0.5em;&quot;&gt;
&lt;&lt;if $args.includes(&quot;full&quot;)&gt;&gt;
	(...)
	&lt;&lt;if _act.basic&gt;&gt;
		[Basic]&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.instant&gt;&gt;
		[Instant]&amp;nbsp;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _act.passive&gt;&gt;
		[Passive]
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We then create an element that is aligned to the right edge of the container. If we&#39;re displaying the full action details, we use it to display special tags such as whether the action is basic or instant.
{{{
&lt;&lt;if _act instanceof ItemAction&gt;&gt;
	x&lt;&lt;print _v.stock&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;if !_act.passive &amp;&amp; _act.cost !== null&gt;&gt;&lt;&lt;print _act.cost&gt;&gt;&lt;&lt;if _act.phase is &quot;spell phase&quot;&gt;&gt;+&lt;&lt;/if&gt;&gt; EN&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We will always display the cost of the action (or the stock if it&#39;s a usable item). If the action points to the spell phase, it has a variable cost, which is noted with a &quot;+&quot; marker after the cost number.
{{{
&lt;&lt;if $args.includes(&quot;full&quot;)&gt;&gt;
	&lt;&lt;if _act instanceof ItemAction&gt;&gt;
		&lt;&lt;set _act = new Item(_act.name)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div&gt;&lt;&lt;print _act.info&gt;&gt;&lt;/div&gt;
	&lt;&lt;if _act.desc !== null&gt;&gt;&lt;div class=&quot;actdesc&quot;&gt;&lt;&lt;print _act.desc&gt;&gt;&lt;/div&gt;&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
We then display the action&#39;s info and description, but only if we are displaying full information. For usable items, these properties are tied to the item rather than the action, so we need to create an Item object with the same name to correctly reference the data.

Why do we need all these handlers? Because the action list can be displayed two different ways, depending on the player&#39;s preference: compressed or uncompressed.
{{{
&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
	&lt;&lt;set _actionClass = &quot;compressed&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actionClass = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;div id=&quot;actionList&quot; @class=&quot;_actionClass&quot;&gt;
&lt;&lt;actionList $subject&gt;&gt;
&lt;/div&gt;
&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
&lt;br/&gt;
&lt;div id=&quot;actionInfo&quot;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;

(...)

&lt;&lt;if $COMPRESSED_ACTIONS === true &amp;&amp; $inbattle&gt;&gt;
	&lt;&lt;actionInfo _action &quot;no name&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;actionInfo _action &quot;no name&quot; &quot;full&quot;&gt;&gt;
	&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
}}}
The first block of code is in the &quot;actions&quot; passage. If actions are compressed, the action list&#39;s containing element will gain a new class that changes its display to a two-column grid, allowing it to display twice as many actions in the same space. We then display only minimal information for the action rather than a full description to save space.

However, players using the compressed display still need a way to see the full information somehow. How can we do that?
{{{
&lt;&lt;mouseover&gt;&gt;
(...)
&lt;&lt;onmouseover&gt;&gt;
	&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
		&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
			&lt;&lt;actionInfo _action &quot;full&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;onmouseout&gt;&gt;
	&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
		&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/mouseover&gt;&gt;
}}}
The answer: with the {{{mouseover}}} macro. This code is wrapped around the action name in {{{actionList}}}, and will make the action name a mouse-sensitive element. When the player mouses over the action name, we will populate the {{{#actionBox}}} element with the action&#39;s full information using {{{actionInfo}}}. When the mouse leaves the element, the info box will become blank again. (This is why we needed to wrap the {{{capture}}} macro around the whole name display code, rather than just the link.)

&lt;h3 id=&quot;crossbow&quot;&gt;How does Rogue&#39;s crossbow work?&lt;/h3&gt;
[img[setup.ImagePath + &quot;documentation/054.PNG&quot;]]
[img[setup.ImagePath + &quot;documentation/055.PNG&quot;]]

When Rogue uses the Crossbow ability, it&#39;s replaced by a new ability, Reload, which must be used before Crossbow can be used again. How is this accomplished?
{{{
&quot;Crossbow&quot;: {
	&quot;cost&quot;:		0,
	&quot;weight&quot;:	1,
	&quot;basic&quot;:	true,
	&quot;pierce&quot;:	true,
	&quot;info&quot;:	function (action) {return 	`Attack with a weight of ${action.weight} and ignore defense. Needs reloading after use.`},
	&quot;desc&quot;:		`Ah, the marvel of modern technology: while other fools tire themselves out swinging those heavy weapons, Rogue can send death flying through the air with just a twitch of the finger.`,
	&quot;useText&quot;: null,
	&quot;actText&quot;: function () {
		return `${subject().name} fires their crossbow with a &lt;i&gt;twang&lt;/i&gt;.`;
	},
	&quot;act&quot;: function () {
		return `&lt;&lt;echoDamage&gt;&gt;`+
		`&lt;&lt;find &quot;$subject.actions&quot; &quot;name&quot; &quot;\&#39;Crossbow\&#39;&quot;&gt;&gt;`+
		`&lt;&lt;set $subject.actions[_pos] = new Action(&quot;Reload&quot;)&gt;&gt;`;
	},
},

&quot;Reload&quot;: {
	&quot;cost&quot;:		2,
	&quot;phase&quot;:	&quot;confirm phase&quot;,
	&quot;basic&quot;:	true,
	&quot;invisible&quot;: true,
	&quot;info&quot;:	function (action) {return 	`Reload crossbow.`},
	&quot;desc&quot;:		`...Of course, crossbows also take an age and a half to reload.`,
	&quot;preview&quot;: &quot;&quot;,
	&quot;act&quot;: function () {
		var x = subject().actions.find(function(a) { return a &amp;&amp; a.name == &quot;Reload&quot; });
		subject().actions[subject().actions.indexOf(x)] = new Action(&quot;Crossbow&quot;);
	}
}
}}}
To begin with, observe that these are both defined as separate actions in the action database. This allows us to easily create either a &quot;Crossbow&quot; or &quot;Reload&quot; action as needed. Then, look at the behavior for the Reload action:
{{{
var x = subject().actions.find(function(a) { return a &amp;&amp; a.name == &quot;Reload&quot; });
subject().actions[subject().actions.indexOf(x)] = new Action(&quot;Crossbow&quot;);
}}}
This is a little clunky, but it allows us to locate exactly where the &quot;Reload&quot; action is in the {{{actions}}} array so we can replace it. The position of Crossbow and Reload are fixed in Rogue&#39;s actions, but for another character it might be different, or we might want to allow the player to move the order around. This ensures we&#39;ll always target the right action.

The principles behind this mechanic are useful if you want to make a game like &lt;i&gt;Final Fantasy VII&lt;/i&gt; where skills can be swapped out like equipment.

&lt;h3 id=&quot;items&quot;&gt;Items&lt;/h3&gt;
Items are coded almost exactly the same way as actions. The only real difference is that the link reads the item&#39;s {{{action}}} attribute, which is defined exactly the same way as a regular action.

&lt;h3 id=&quot;delayed&quot;&gt;Delayed Attacks&lt;/h3&gt;
You may want to have a delayed attack that requires one or more turns of &quot;charge time&quot; before being executed, during which the character can&#39;t do anything else. You can see an example of this in the Jump ability of &lt;i&gt;Final Fantasy&lt;/i&gt;&#39;s Dragoon class, or in the banishing and daybreak spells featured in the Marceline fight in &lt;i&gt;Cartoon Battle&lt;/i&gt;.

These are bit tricky to implement in this engine, because you will need to keep track of the target between turns, and &lt;a class=&quot;noExternal&quot; href=&quot;#chain&quot;&gt;Twine can&#39;t preserve object references.&lt;/a&gt; I recommend capturing a unique property of the target instead, such as their name or ID, and saving it to a property of the subject used exclusively for delayed attack targets. Then, on the turn it is to execute, you can find the target again by plugging that attribute into a {{{find}}} function.

In the default engine, there is no initiative order, so the delayed attack should happen immediately at the start of the turn. Run a check to see if any characters are executing a delayed attack (set a flag on the setup action so you can track this), then set the subject, target, and action to whatever is appropriate, and immediately forward the player to the action phase with {{{&lt;&lt;goto &quot;action phase&quot;&gt;&gt;}}}. However, you should &lt;b&gt;not&lt;/b&gt; use {{{&lt;&lt;newTurn&gt;&gt;}}} for this purpose, as that widget also contains a {{{&lt;&lt;goto&gt;&gt;}}}. Because {{{&lt;&lt;goto&gt;&gt;}}} does not end the passage and all code after it continues to execute, placing a {{{&lt;&lt;goto&gt;&gt;}}} before the end of {{{&lt;&lt;newTurn&gt;&gt;}}} will cause {{{&lt;&lt;goto&gt;&gt;}}} commands to pile up and execute simultaneously, preventing the player from seeing the effects of the action. &lt;b&gt;Use {{{&lt;&lt;specialcheck&gt;&gt;}}} for this purpose instead.&lt;/b&gt; Though it is called continuously, so long as you remember to unset the &quot;executing delayed attack&quot; flag, it will only trigger the delayed attack once. The continuous call is also advantageous in the case that multiple characters are using delayed attacks simultaneously, as opposed to {{{&lt;&lt;newTurn&gt;&gt;}}}, which is only called once.

In a system with initiative order, this is simpler, as you would simply execute the delayed attack on the character&#39;s turn.

&lt;h2 id=&quot;damage&quot;&gt;Calculating and applying damage&lt;/h2&gt;
Because these widgets are complicated, they are placed in their own twee file, &quot;Damage and Formulas&quot;.

The widgets for calculating and displaying damage are separate, due to the need to pre-calculate damage for the {{{&lt;&lt;preview&gt;&gt;}}} widget.

&lt;h3 id=&quot;damage.1&quot;&gt;Calculating damage&lt;/h3&gt;
{{{&lt;&lt;damageCalc&gt;&gt;}}}&#39;s control flow is as follows:
{{{
&lt;&lt;set _w = $action.weight&gt;&gt;
(...)
&lt;&lt;set _atk = ($subject.get($AttackStat) * (1 - $action.useSpecial)) + ($subject.get($SpecialStat) * $action.useSpecial)&gt;&gt;

/* Piercing? */
&lt;&lt;if $action.pierce&gt;&gt;
	&lt;&lt;set _def = Math.min(_target.get($DefenseStat),setup.MIN_STAT)&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _def = _target.get($DefenseStat)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
First, extract some attributes into shorter variable names, for convenience. The attack factor is a weighted average of the subject&#39;s Attack and Special stats, determined by the action&#39;s {{{useSpecial}}} attribute, which is a number between 0 and 1. An action with a {{{useSpecial}}} of 1 would be completely dependent on Special (as the Attack factor would be multiplied by 0), while an action with {{{useSpecial}}} of 0.25 would only have 25% of its power based on Special.

If the attack is piercing, tracked through the {{{$action.pierce}}} flag, we set {{{_def}}} to a minimum value. Pay attention to what that minimum value is; it can be 0 in a subtractive system, but you&#39;re going to run into division by zero errors if you try that in a divisive system.
{{{
&lt;&lt;if !$action.formula&gt;&gt;

&lt;&lt;switch setup.formula&gt;&gt;
	&lt;&lt;case &quot;subtractive&quot;&gt;&gt;
		&lt;&lt;set $dmg to ((setup.base+setup.damper*_atk)*_w)-setup.damper*_def&gt;&gt;
	&lt;&lt;case &quot;subtractive lumped&quot;&gt;&gt;
		&lt;&lt;set $dmg to (setup.base+setup.damper*(_atk-_def))*_w&gt;&gt;
	&lt;&lt;case &quot;rpgmaker&quot;&gt;&gt;
		&lt;&lt;set $dmg to (_atk*4-_def*2)*setup.damper*_w&gt;&gt;
	&lt;&lt;case &quot;divisive&quot;&gt;&gt;
		&lt;&lt;set $dmg to (setup.base*(_atk/_def))*_w&gt;&gt;
	&lt;&lt;default&gt;&gt;
		/* add your own here! */
&lt;&lt;/switch&gt;&gt;

&lt;&lt;else&gt;&gt;
	&lt;&lt;set $dmg = $action.formula()&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then damage is actually calculated through a call to &quot;damageCalc formula&quot;. I&#39;ve provided functionality for 4 possible formulas, though it&#39;s set to &quot;subtractive&quot; by default. The construction behind these damage formulas is discussed in [[the design page|Design]]. You may want to change it for your game. Actions can also have a unique formula, which will be used instead if one is detected.
{{{
&lt;&lt;set _factor = 1; _flatFactor = 0&gt;&gt;
&lt;&lt;if typeof($action.element) == &quot;string&quot;&gt;&gt;
	&lt;&lt;set _factor = _target.getElement($action.element,&quot;percent&quot;)&gt;&gt;
	&lt;&lt;set _flatFactor = _target.getElement($action.element,&quot;flat&quot;)&gt;&gt;
&lt;&lt;elseif $action.element instanceof Array&gt;&gt;
	&lt;&lt;set _factor = 0&gt;&gt;
	&lt;&lt;if setup.AVERAGE_ELEMENTS === true&gt;&gt;
		&lt;&lt;for _v range $action.element&gt;&gt;
			&lt;&lt;set _factor += _target.getElement(_v,&quot;percent&quot;)&gt;&gt;
			&lt;&lt;set _flatFactor += _target.getElement(_v,&quot;flat&quot;)&gt;&gt;
		&lt;&lt;/for&gt;&gt;
		&lt;&lt;set _factor = _factor*1.0/$action.element.length&gt;&gt;
		&lt;&lt;set _flatFactor = _flatFactor*1.0/$action.element.length&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;for _v range $action.element&gt;&gt;
			&lt;&lt;set _factor = Math.max(_target.getElement(_v,&quot;percent&quot;),_factor)&gt;&gt;
			&lt;&lt;set _flatFactor = Math.min(_target.getElement(_v,&quot;flat&quot;),_flatFactor)&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;set _baseDmg = $dmg&gt;&gt;
&lt;&lt;set $dmg *= _factor; $dmg -= _flatFactor&gt;&gt;
}}}
We then check for elemental effects. If the action has an element, we&#39;ll use it to find the target&#39;s affinity value for that element, then apply it to the damage value. (This is checked for both flat additive values and percent-based values.) If there wasn&#39;t an element or the target has no associated resistance value {{{_factor}}} will be undefined and cause an error when we attempt to apply it to {{{$dmg}}}, so we start by initializing it to a base value that doesn&#39;t affect anything.

There is also a second branch here for the handling of attacks with multiple elements. If you assign an array instead of a string to the action&#39;s {{{element}}} property, you can give the action multiple elements that will all be used to calculate the final result. This can work in one of two ways, depending on how you set the {{{AVERAGE_ELEMENTS}}} variable.
{{{
&lt;&lt;if setup.AVERAGE_ELEMENTS === true&gt;&gt;
	&lt;&lt;for _v range $action.element&gt;&gt;
		&lt;&lt;set _factor += _target.getElement(_v,&quot;percent&quot;)&gt;&gt;
		&lt;&lt;set _flatFactor += _target.getElement(_v,&quot;flat&quot;)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;set _factor = _factor*1.0/$action.element.length&gt;&gt;
	&lt;&lt;set _flatFactor = _flatFactor*1.0/$action.element.length&gt;&gt;
}}}
If {{{AVERAGE_ELEMENTS}}} is {{{true}}}, the resulting modifier factors will be the average of each element; for example, if the enemy takes 0.5x damage from Blue and 1x damage from Red, an attack with the property {{{[&quot;red&quot;,&quot;blue&quot;]}}} will inflict 0.75x damage. (Note that we have to multiply the variables by 1.0 in the averaging calculation to ensure the result comes out as a decimal number rather than an integer.)
{{{
&lt;&lt;else&gt;&gt;
	&lt;&lt;for _v range $action.element&gt;&gt;
		&lt;&lt;set _factor = Math.max(_target.getElement(_v,&quot;percent&quot;),_factor)&gt;&gt;
		&lt;&lt;set _flatFactor = Math.min(_target.getElement(_v,&quot;flat&quot;),_flatFactor)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
}}}
If {{{AVERAGE_ELEMENTS}}} is not {{{true}}}, we simply pick the best modifier (from the attacker&#39;s perspective). For example, if the enemy takes 0.5x damage from Blue and 1x damage from Red, an attack with the property {{{[&quot;red&quot;,&quot;blue&quot;]}}} will inflict 1x damage because that is the higher modifier, ignoring the resistance to Blue completely. (This is how RPG Maker handles multi-element attacks.)
{{{
&lt;&lt;if _baseDmg &lt; $dmg&gt;&gt;
	&lt;&lt;set _elntmsg = setup.elementMessages.weakpoint&gt;&gt;
&lt;&lt;elseif _baseDmg &gt; $dmg &amp;&amp; $dmg &gt; 0&gt;&gt;
	&lt;&lt;set _elntmsg = setup.elementMessages.resist&gt;&gt;
&lt;&lt;elseif $dmg &lt; _baseDmg &amp;&amp; $dmg == 0&gt;&gt;
	&lt;&lt;set _elntmsg = setup.elementMessages.immune&gt;&gt;
&lt;&lt;elseif $dmg &lt; _baseDmg &amp;&amp; $dmg &lt; 0&gt;&gt;
	&lt;&lt;set _elntmsg = setup.elementMessages.absorb&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
After we&#39;re done with the calculation, there is then a check for if the elemental attack hit a weakness or a resistance. If it&#39;s a weakness ({{{$dmg}}} is greater than the original damage), we store a message informing the player they hit a weak point; if it&#39;s a resistance ({{{$dmg}}} is less than the original damage), we store a message informing the player they hit a resistance; and so on. These messages are defined in {{{StoryInit}}}; by default, they use the messages from &lt;i&gt;Pokemon&lt;/i&gt;. This is a means of transparency to the player, to let them know when they&#39;ve hit a weakness or resistance. You can customize these messages or even remove them entirely if you see fit; you could even expand the code to create a unique message for every element, if you want!
{{{
&lt;&lt;if $subject.berserker is true&gt;&gt;
	&lt;&lt;set $dmg *= (1+setup.BERSERK_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $target.berserker is true&gt;&gt;
	&lt;&lt;set $dmg *= (1+setup.BERSERK_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $subject.defender is true&gt;&gt;
	&lt;&lt;set $dmg *= setup.DEFEND_FACTOR&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $target.defender is true&gt;&gt;
	&lt;&lt;set $dmg *= setup.DEFEND_FACTOR&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $target.shield is true&gt;&gt;
	&lt;&lt;set $dmg *= (1-setup.SHIELD_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then there&#39;s a call to &quot;damageCalc custom factors&quot;, additional factors for modifying the final damage value. In the default engine, that&#39;s these effects. (Note that there are two branches each for Berserker and Defender; that&#39;s because they affect both incoming and outgoing damage.)
{{{
&lt;&lt;if ($dmg &lt; _baseDmg &amp;&amp; $dmg &lt;= 0)&gt;&gt;
	/* If elemental factors pushed damage to 0 or below, we shouldn&#39;t bump it up to the minimum; do nothing */
&lt;&lt;elseif _noDmgFloor &amp;&amp; $dmg &lt; 0&gt;&gt;
	&lt;&lt;set $dmg = 0&gt;&gt;
	&lt;&lt;set _noDmgFloor = false&gt;&gt; /* preventing data bleed */
&lt;&lt;elseif $dmg &lt; setup.MIN_DMG&gt;&gt;
	&lt;&lt;set $dmg = setup.MIN_DMG&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Finally, the widget checks if the final damage value is lower than the minimum damage value. This should probably be a positive value; we don&#39;t want to accidentally heal people with our attacks by dealing negative damage, after all. (Unless they absorb the element, of course, so this check is bypassed if that&#39;s the case.) Some games will allow 0 damage to occur, but others have minimum damage values. For &lt;i&gt;Cartoon Battle&lt;/i&gt;, I chose to be nice and have attacks always deal at least 1 damage, even if that may as well be nothing with the HP values I chose.

There is also a branch here that will set damage to 0 instead of the usual minimum damage through the flag {{{_noDmgFloor}}}. By default, this is used by the &quot;Invincible&quot; status effect, which renders someone immune to damage.
{{{
&lt;&lt;set $dmg = Math.round($dmg)&gt;&gt;
}}}
Finally, we must use the {{{Math.round()}}} function to remove any decimal values.

&lt;h3 id=&quot;damage.2&quot;&gt;Applying damage&lt;/h3&gt;
{{{&lt;&lt;echoDamage&gt;&gt;}}} applies previously-calculated damage and alerts the player to this fact with a message.
{{{
&lt;&lt;if $args[0] instanceof Actor&gt;&gt;
	&lt;&lt;set $target = $args[0]&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The beginning allows you to apply these effects to a specific target other than the {{{$target}}} variable, by passing the character as the first argument to the widget. (Because Puppet and Enemy are subclasses of Actor, they will both fulfill the {{{instanceof Actor}}} evaluation.)
{{{
&lt;&lt;if !($args.includes(&quot;indirect&quot;) || target().dead) &amp;&amp; subject() instanceof Puppet &amp;&amp; target() instanceof Enemy &amp;&amp; target().protectedBy !== null&gt;&gt;
	&lt;&lt;set _temp = $target.name&gt;&gt;
	&lt;&lt;set $target = $enemies.find(function(t) { return t &amp;&amp; t.id === $target.protectedBy; })&gt;&gt;
	&lt;&lt;print $target.name+&quot; took the hit for &quot;+_temp+&quot;!\n&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Then there&#39;s a check for protected characters. If the target is protected by someone, we need to change the target to their protector, and also print a message informing the player of this fact.
{{{
&lt;&lt;if def $bestiary &amp;&amp; target() instanceof Enemy &amp;&amp; $action.element&gt;&gt;
	&lt;&lt;set $bestiary.fetch(target().name).statsKnown[$action.element] = true&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
This clause reveals the enemy&#39;s elemental affinity to the player if they are struck with an elemental attack. (For more information, see the Bestiary section in [[Additional Features]].)
{{{
&lt;&lt;if !($args.includes(&quot;nocalc&quot;) || $args.includes(&quot;indirect&quot;))&gt;&gt;
	&lt;&lt;damageCalc&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
For simplicity, {{{&lt;&lt;damageCalc&gt;&gt;}}} is run again here, but you may notice there&#39;s a clause to prevent this call if a &quot;nocalc&quot; argument is passed in. This allows functionality for special damaging attacks that don&#39;t use the normal damage formula, such as mass attack items. Indirect damage also bypasses this, as indirect damage has no subject and therefore cannot use the standard damage formula.
{{{
&lt;&lt;if !target().dead&gt;&gt;
}}}
Then we do a common-sense check to make sure the target isn&#39;t already defeated. There&#39;s no point in beating a dead goblin.
{{{
&lt;&lt;if target().shielded &amp;&amp; !$args.includes(&quot;unblockable&quot;)&gt;&gt;
	&lt;&lt;set _shield = target().effects.find(function (eff) { return eff &amp;&amp; eff.shield; })&gt;&gt;
	&lt;&lt;if ndef _shield&gt;&gt;
		&lt;&lt;run console.log(&quot;ERROR in echoDamage: target is shielded but has no shield effect&quot;)&gt;&gt;
	&lt;&lt;elseif _shield.onHit instanceof Function&gt;&gt;
		&lt;&lt;run _shield.uses -= 1&gt;&gt;
		&lt;&lt;print _shield.onHit(target())&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;run console.log(&quot;ERROR in echoDamage: shield effect has no onHit function&quot;)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
}}}
Certain status effects also interact with direct damage, denoted by providing the &quot;shielded&quot; flag. If the target has the flag, we use the {{{find}}} function to obtain the shielding effect from the character&#39;s effects. (Note that {{{find}}} terminates at the first match regardless of how many matches actually exist in the array, so you will need more complex code if you want a strict hierarchy.) We then do a common-sense check to make sure we actually got something; it&#39;s not impossible that a coding oversight could make a {{{shielded}}} flag persist even after the shield effect is removed. If we did, we reduce the shield&#39;s {{{uses}}} (the number of attacks it can block) by 1 and call the shield&#39;s {{{onHit}}} function.
{{{
&lt;&lt;if def _elntmsg&gt;&gt;&lt;b&gt;&lt;&lt;print _elntmsg&gt;&gt;&lt;/b&gt;&lt;&lt;/if&gt;&gt;
&lt;&lt;if $dmg &lt; 0&gt;&gt;
$target feeds on the energy, and recovers &lt;&lt;print $dmg*-1&gt;&gt; HP.
&lt;&lt;else&gt;&gt;
$target.name takes $dmg damage!
&lt;&lt;/if&gt;&gt;
}}}
If {{{_elntmsg}}} exists (which is to say, the element mattered), it&#39;s displayed before the damage message. You can move it elsewhere if you prefer. I also chose to make a totally separate message for absorbing an attack, because &lt;i&gt;[Name] takes -10 damage!&lt;/i&gt; would probably look very confusing to a player even if it does give you the information you need.
{{{
&lt;&lt;set $target.hp -= $dmg&gt;&gt;
(...)
&lt;&lt;deathcheck&gt;&gt;
}}}
And now we apply damage. Since absorbed damage is negative, {{{$target.hp -= $dmg}}} will work for all cases and doesn&#39;t require multiple clauses. After, we run {{{&lt;&lt;deathcheck&gt;&gt;}}} to apply the &quot;dead&quot; flag if the character has fallen below 0 HP.
{{{
&lt;&lt;if target().offbalance &amp;&amp; $dmg &gt;= 0&gt;&gt;
	&lt;&lt;addEffect $target &quot;Knocked Down&quot; -1&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
But wait, there&#39;s more! After taking damage, the character is checked for the &quot;Off-Balance&quot; effect. If they have it, they gain a new &quot;Knocked Down&quot; effect. (As discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#effects1&quot;&gt;Applying Effects&lt;/a&gt;, this will also remove the Off-Balance effect, but this functionality is built in to {{{&lt;&lt;addEffect&gt;&gt;}}}.) I chose to disallow this if the attack was absorbed, since logically you shouldn&#39;t be hurt by getting healed, but you could remove the clause if you think that&#39;s more logical.

Note that this check will not run for indirect damage, nor if the target has died from the attack.

&lt;h4 id=&quot;dmgreflection&quot;&gt;Damage Reflection&lt;/h4&gt;
Some RPGs feature &quot;damage reflection&quot;, which inflicts damage on an attacking character equal to the damage they dealt (or some proportion thereof). That&#39;s also handled through this widget.
{{{
&lt;&lt;if target().dmgreflection &amp;&amp; !_dmgreflecting &amp;&amp; target() !== subject() &amp;&amp; $dmg &gt; 0&gt;&gt;
	&lt;&lt;set $dmg = Math.round($dmg * target().dmgreflection)&gt;&gt;
	&lt;&lt;set _OG = {target: $target, subject: $subject}&gt;&gt;
	&lt;&lt;set $target = _OG.subject; $subject = _OG.target&gt;&gt;
	&lt;&lt;set _dmgreflecting = true&gt;&gt;
	&lt;&lt;echoDamage &quot;nocalc&quot;&gt;&gt;
	&lt;&lt;set $target = _OG.target; $subject = _OG.subject&gt;&gt;
	&lt;&lt;unset _OG; _dmgreflecting&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Immediately after damage is applied to the target, we check if the target has a defined {{{dmgreflection}}} property. If it does, we calculate a new {{{$dmg}}} proportional to the target&#39;s {{{dmgreflection}}} value. (So, for instance, a {{{dmgreflection}}} of 1 would reflect all of the original damage, a {{{dmgreflection}}} of 0.5 would reflect half, etc.) We make sure to deactivate this clause if the subject is attacking itself, because being hit with your own damage reflection does not make logical sense and is liable to generate an infinite loop.
{{{
&lt;&lt;set _OG = {target: $target, subject: $subject}&gt;&gt;
&lt;&lt;set $target = _OG.subject; $subject = _OG.target&gt;&gt;
&lt;&lt;set _dmgreflecting = true&gt;&gt;
&lt;&lt;echoDamage &quot;nocalc&quot;&gt;&gt;
&lt;&lt;set $target = _OG.target; $subject = _OG.subject&gt;&gt;
}}}
We then have to apply the damage to the attacker, the previous subject -- but wait! There are other effects that could occur after this action that are supposed to apply to the original target and subject. That means we have to store them in a temporary holder variable and set them back to the originals when we&#39;re done. We also set the {{{_dmgreflection}}} flag, which prevents further damage reflection within this action. This prevents an infinite loop from occurring if a damage reflector attacks another damage reflector.

We then apply the damage with a recursive call to {{{&lt;&lt;echoDamage&gt;&gt;}}}. You could bypass all of this by just applying the damage to the {{{subject}}} directly here, but the default engine chooses to run {{{&lt;&lt;echoDamage&gt;&gt;}}} for thoroughness, in case complications like the Bubble and Off-Balance effects are in play. (Note that reflected damage IS considered direct damage, for precisely this purpose.)

&lt;b&gt;NOTE:&lt;/b&gt; {{{&lt;&lt;deathcheck&gt;&gt;}}} is only run &lt;i&gt;after&lt;/i&gt; this section, which means a damage reflector will still reflect damage even if they&#39;re defeated by the attack. You can move it if you want different behavior.

&lt;h4 id=&quot;dmg.onhit&quot;&gt;onHit&lt;/h4&gt;
{{{
&lt;&lt;if target().onHit instanceof Array &amp;&amp; target().onHit.length &gt; 0 &amp;&amp; !_dmgreflecting &amp;&amp; target().id !== subject().id&gt;&gt;
/* If target has onHit functions, they are executed here. Note that the target and subject are not reversed here, so if you want the effect to target the attacker, use &quot;subject&quot; as the selector, and vice versa. */
	&lt;&lt;for _action range target().onHit&gt;&gt;
		&lt;&lt;if _action instanceof Function&gt;&gt;
			&lt;&lt;print _action()&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;run console.log(&quot;ERROR in onHit: onHit elements must be functions&quot;)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
After attack reflection, we check for {{{onHit}}} effects. {{{onHit}}} effects are functions added to a character&#39;s {{{onHit}}} property, and they will execute here. These can be things like a toxic slime monster poisoning anyone who touches it, or Experiment 01 compelling hatred on anyone who attacks. These functions cannot be triggered by damage reflection or by a character attacking itself.

&lt;i&gt;(Note that {{{onHit}}} functions are distinct from counterattacks. Counterattacks are full actions that are executed after the initial action is completely resolved. These functions are resolved within the current action as part of damage application.)&lt;/i&gt;

&lt;h4 id=&quot;dmg.shock&quot;&gt;Shock cures&lt;/h4&gt;
After {{{&lt;&lt;deathcheck&gt;&gt;}}} but before the knockdown check, we check for shock cures. &quot;Shock&quot;, in this case, refers to direct damage. In some RPGs, certain status effects like sleeping or confusion can be cured by direct damage, and this functionality is applied here.
{{{
&lt;&lt;if !$action.noShock&gt;&gt;
	&lt;&lt;for _effect range target().effects.filter(function (eff) { return eff &amp;&amp; Number.isInteger(eff.shock)})&gt;&gt;
		&lt;&lt;set _shock = random(1,100)&gt;&gt;
		&lt;&lt;if _shock &lt;= _effect.shock&gt;&gt;
			&lt;&lt;print target().removeEffect(_effect)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
First we check to make sure the action does not have a {{{noShock}}} flag. This flag will prevent the action from triggering shock cures if it is {{{true}}}. (As an example, most RPGs only wake sleeping characters when they are struck by physical attacks, not by magic.) If not, we run a loop over the target&#39;s effects that have a {{{shock}}} property that is an integer value. (Any noninteger values for {{{shock}}} will be converted through a getter function into a Boolean {{{false}}} and fail this check.) We then roll a percentile die and check if we rolled under the effect&#39;s {{{shock}}} value. If yes, the effect is cured, and we run {{{removeEffect}}}, making sure to {{{&lt;&lt;print&gt;&gt;}}} the resulting removal message so the player knows what happened. (This means that a {{{shock}}} value of 100 will always result in a cure from direct damage. A Boolean value of {{{true}}} assigned to the effect&#39;s {{{shock}}} property will be converted to this value.)

Because we use a loop for this check, all viable effects will be checked, meaning it is possible for multiple effects to be removed by the same attack.

&lt;h4 id=&quot;dmg.counters&quot;&gt;Setting up counterattacks&lt;/h4&gt;
This widget also sets up counterattacks.
{{{
	&lt;&lt;if !(_dmgMods.includes(&quot;indirect&quot;) || _dmgMods.includes(&quot;nocounter&quot;) || _counterActive || target().dead || target().noact || target().retaliations === 0 || target() === subject())
		&amp;&amp; _counters instanceof Array
		&amp;&amp; !_counters.includes(target().id)
		&amp;&amp; target().counter instanceof Action&gt;&gt;
		&lt;&lt;if target().counter.trigger&gt;&gt;
			&lt;&lt;run _counters.push(target().id)&gt;&gt;
			&lt;&lt;run $B.actionQueue.push([target().id,target().counter])&gt;&gt;
			&lt;&lt;if target().retaliations &gt; 0&gt;&gt;
				&lt;&lt;set target().retaliations -= 1&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
}}}
The first conditional does a lot of checks to see if we can use counters at all. To prevent infinite &quot;countering counters&quot; loops, we disallow this if there is already a {{{_counterActive}}}. Then, unlike with damage reflection, we will prevent the enemy from countering if they&#39;re dead or under a hold effect. The target must also have a nonzero number of retaliations, and the target must not be attacking itself. We will also disallow counters to indirect damage. With those checks passed, the {{{_counters}}} variable must exist and be an array, the target must not already be held in said array, and the target must have an Action stored in its {{{counter}}} attribute. Whew! That&#39;s a lot, but it&#39;s mostly just to confirm we don&#39;t have any {{{undefined}}} variables before proceeding.
{{{
&lt;&lt;run _counters.push(target().id)&gt;&gt;
&lt;&lt;run $B.actionQueue.push([target().id,target().counter])&gt;&gt;
&lt;&lt;if target().retaliations &gt; 0&gt;&gt;
	&lt;&lt;set target().retaliations -= 1&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
If all is well, we add the target&#39;s ID to the {{{_counters}}} array, and reduce their {{{retaliations}}} by 1. (Only if it&#39;s above 0 to start with, though -- if you set it to a negative number, the enemy can make unlimited counterattacks.) Note that the counterattack doesn&#39;t happen here -- we&#39;re only storing data that will be read later in &lt;a class=&quot;noExternal&quot; href=&quot;#actionqueue&quot;&gt;the action queue&lt;/a&gt;.
{{{
&lt;&lt;if target().counter.trigger&gt;&gt;
}}}
We also have this check. Counterattacks can also have a {{{trigger}}} attribute that determines when they will trigger. In &lt;i&gt;Pokemon&lt;/i&gt;, for instance, there are some counters that only trigger on attacks that make contact; ranged attacks are safe. Or perhaps you want a counter to trigger &lt;i&gt;only&lt;/i&gt; on ranged attacks? Only if the character is struck by an elemental weakness or resistance? There are lots of possibilities. You can define a custom {{{trigger}}} function in your counter action and have it return {{{true}}} only when the counter should be activated. By default, an undefined {{{trigger}}} always returns {{{true}}}, so this clause will always execute.

&lt;h2 id=&quot;effects&quot;&gt;Status Effects&lt;/h2&gt;
Status effects are a common feature of RPGs, and give them greater tactical depth. They do things like temporarily changing your stats, or affecting what actions you can use.

In Another RPG Engine, status effects for each character are stored in an array, defined in the story JavaScript as an attribute of the &lt;b&gt;Actor&lt;/b&gt; class. Most aspects of status effects are defined in the effect database, but the logic for applying an effect is handled through a set of functions defined in {{{effect-manager.js}}}.

&lt;h3 id=&quot;effects1&quot;&gt;Applying effects&lt;/h3&gt;
You would think that adding effects to a character is just a matter adding the effect to the character&#39;s {{{effects}}} array, using an {{{Array.push()}}} command. But what if we want some rules for how effects are applied? Do we want players to be able to apply multiple copies of the same effect, or can only one instance be active at a time? Perhaps we want that rule applied to some effects, but not all?

Resolving these questions is the purpose of the {{{addEffect}}} function.
{{{
Actor.prototype.addEffect = function (name,mods) {
}}}
Adding effects is, fundamentally, something we do to {{{Actor}}} objects, so we will add the effect addition function to {{{Actor}}}&#39;s &lt;i&gt;prototype&lt;/i&gt;. Object prototypes contain properties shared by all instances of an object; the details are rather complicated, but all you need to understand in this case is that this code is functionally the same as defining this as a method function in the class definition. Doing it this way is a bit more awkward, but allows you to modify these functions modually without needing to redo the entire class definition.

We&#39;re going to start with a few preliminary things:
{{{
E = new Effect(name);
}}}
We want to make an Effect object using just the effect&#39;s name. This is because the object&#39;s getter functions take care of some things for us based on the name, as can be seen in {{{database-effects.js}}}:
{{{
&quot;Injury&quot;: {
	&quot;stackable&quot;: true,
	&quot;statmod&quot;: true
}}}
Attributes such as {{{stackable}}} will be useful to divide effects by desired behavior.
{{{
if (!this.dead || E.persistAfterDeath)
}}}
Then a common sense check: no point in applying effects to dead people, unless you want that. Some games, such as &lt;i&gt;Final Fantasy XII&lt;/i&gt;, do have some status effects persist past unconsciousness and revival, and this feature is enabled through the {{{persistAfterDeath}}} attribute.
{{{
let found = false;
let power;
let subj;
subj = mods.actor instanceof Actor ? mods.actor : subject();
}}}
Our last preliminary action is to initialize these variables. We will reference them later.

&lt;h4 id=&quot;effects1.1&quot;&gt;Accounting for protective effects&lt;/h4&gt;
{{{
if (!(E.unblockable || mods.unblockable === true)) {
	if (!E.buff) {
		$.wiki(&#39;&lt;&lt;shieldCheck&gt;&gt;&#39;);
		if (temporary().hit === false) {
			return &quot;&quot;;
		}
	}

	this.effects.filter(function (e) { return e &amp;&amp; e.block })
		.sort(function(a,b) { return a.priority - b.priority; })
		.forEach(function (effect) {
			if (effect.blockCondition(E)) {
				this.addPopup({shake: false, type: &quot;block&quot;, content: &quot;BLOCKED&quot;});
				return effect.blockText(this)+&quot;\r\n&quot;;
			}
		},this);
}}}
First, we need to check if we can apply the effect at all. There are two things that can block an effect outright: &lt;i&gt;shield&lt;/i&gt; and &lt;i&gt;block&lt;/i&gt; effects.

As you should recall from [[Documentation (Basic)]], shield effects block a set number of attacks; this includes applications of negative effects, so we need to include a check for that. We do this through an invocation of {{{shieldCheck}}}, which will set the variable {{{_hit}}} to {{{false}}} if a shield blocked the attack. If it did, we end the function immediately by returning an empty string.

Block effects are different: they will block all applications of a certain type of effect as long as they are active. (In the default engine, there are three such effects: &lt;b&gt;Alert&lt;/b&gt;, which protects against Stunned; &lt;b&gt;Chi Shield&lt;/b&gt;, which protects against all negative ailments; and &lt;b&gt;Stasis&lt;/b&gt;, which prevents any changes to effects at all.) We check for these effects by filtering the character&#39;s effects array to only return effects with the {{{block}}} property, and then running over the results with a {{{forEach}}} loop. If the effect to be applied satisfies the effect&#39;s {{{blockCondition}}}, it is blocked, and we end the function immediately by returning the block effect&#39;s {{{blockText}}}.
{{{
.sort(function(a,b) { return a.priority - b.priority; })
}}}
But what happens if this character has &lt;i&gt;multiple&lt;/i&gt; block effects? How do we decide which ones we should test first? For example, since Stasis blocks all effects but Chi Shield only blocks some, it probably makes more sense for Stasis to take precedence. We can do this by sorting the array in order of the effects&#39; {{{priority}}} properties before the final loop.
{{{
let n = (E.synonym || E.name);
if (this.tolerances.get(n).current != 0 &amp;&amp; !mods.pierceImmunity) {
	(...)
	if (mods.pierceTol === true &amp;&amp; this.tolerances.get(n).current &gt; 0) {
		this.tolerances.get(n).currentVal = 0;
	}

	if (this.getTol(n) === -1) {
		this.addPopup({shake: false, type: &quot;block&quot;, content: &quot;IMMUNE&quot;});
		return `${this.name} is immune to ${name}.`+&quot;\r\n&quot;;
	}
	else if (this.getTol(n) &gt; 0) {
		this.decTol(n);
		this.addPopup({shake: true, type: &quot;block&quot;, content: &quot;RESISTED&quot;});
		return `${this.name}&#39;s tolerance to ${name} was weakened.`+&quot;\r\n&quot;;
	}
	else if (this.getTol(n) === 0) {
		this.resetTol(n);
	}
}
}}}
If the effect makes it through protective effects, it is then checked against the target&#39;s tolerances. {{{if this.tolerances.get(n).current != 0}}} checks if the target has a tolerance for the status effect at all; if they don&#39;t, we can ignore this entire check. (Recall from &lt;a class=&quot;noExternal&quot; href=&quot;#JS.tolerances&quot;&gt;the Tolerance class&lt;/a&gt; that a negative {{{current}}} value in a Tolerance conveys immunity, while a positive value conveys resistance; a value of 0 means the target has no tolerance.) Otherwise, we check what the current tolerance value is. If it&#39;s -1, the target has an immunity, and we end the function by returning a message informing the player of this fact. Otherwise, we go on to check if it&#39;s above 0. If it is, the same thing happens, but the target&#39;s tolerance is decreased by 1 through the {{{decTol}}} function. If a tolerance has been exhausted, the program skips to the {{{else}}} clause, resets the tolerance, and applies the effect as normal.

The preceding {{{let n = (E.synonym || E.name)}}} line is for when we want certain effects to have entangled tolerances. In the default engine, one example is the &quot;Forsaken&quot; effect: Because it is a derivative of the &quot;Curse&quot; ability, I chose to have the same tolerance apply to both. For this to work, we need to alter the variable used to check against the target&#39;s tolerances: if the effect is Forsaken, we check against Curse tolerance rather than Forsaken tolerance. In all other cases, {{{n}}} becomes the same as the effect&#39;s name, and everything proceeds as expected.

&lt;h4 id=&quot;effects1.2&quot;&gt;Numerical components&lt;/h4&gt;
{{{
power = typeof(mods.power) == &quot;number&quot; ? power = mods.power : E.calculatePower(this,subj);
}}}
Some effects only operate in binary, but some have variable, numerical components. For instance, take a stat-modifying effect. How do we calculate exactly how much the stat will be changed? You could implement it as a flat rate, such as a 50% boost or penalty. Many RPGs, such as the &lt;i&gt;Final Fantasy&lt;/i&gt; series, do this. But what if we wanted to do something more complex, where the numerical component depends on something like the caster&#39;s Special stat? In that case, we&#39;ll need to calculate it every time the effect is applied.

This is handled by a different function, this time applied to the {{{Effect}}} prototype:
{{{
Effect.prototype.calculatePower = function (target,subject) {
  (...)
  let power;
  let check = this.buff ? setup.min_buff : setup.min_debuff;

  if (subject.stats[&quot;Special&quot;] !== undefined) {
    if (this.statmod) {
      let def = this.buff ? 0 : target.get($SpecialStat);
      power = Math.round(
        (setup.effbase + setup.effdamper * (subject.get($SpecialStat) - def)) * action().effweight);
    } else if (this.dot) {
      return subject.get($SpecialStat);
    }
  }
  else {
    power = (this.effectData.power || 0);
  }

  return Math.max(power,check);
}
}}}
There are slightly different formulas for buffs, debuffs, and damage-over-time effects. Debuff power is reduced by the target&#39;s Special, while buffs are not. Damage-over-time effects simply return the subject&#39;s Special. (These are the default formulas, but they can be changed if you wish.)

If you&#39;d rather just set the effect&#39;s power as a flat number, you can do this by passing it as the {{{power}}} attribute of the {{{mods}}} object in {{{addEffect}}}.

&lt;h4 id=&quot;effects1.3&quot;&gt;Exclusivity&lt;/h4&gt;
The next checks are for effects that have limits on how many instances can be present at once. We start with the broadest exlusivity work our way to the most narrow.
{{{
if (E.unique) {
	this.ownParty.filter(function (a) { return a &amp;&amp; a.name !== this.name },this).forEach(function (actor) {
		actor.removeEffect(E.name,{pierce: true, unsticky: true, removeStack: true, noPopup: true});
	});
}
}}}
First, we check for {{{unique}}} effects. Unique effects are limited to one effect per the entire party. (In the default engine, only the &quot;Martyr&quot; effect has this property; because Martyr draws all attacks that would otherwise be directed against other characters, it would be illogical for multiple characters to have Martyr at once -- which one would take precedence?) This is done by simply looping over the character&#39;s party and running {{{removeEffect}}} for the named effect. ({{{removeEffect}}} does nothing if the passed effect name is not present, so we don&#39;t have to worry about errors.) This loop excludes the current character themselves so that the effect is not removed if they currently have it.
{{{
if (E.exclusive) {
	this.effects.filter(function (e) { return e &amp;&amp; e.exclusive}).forEach(function (effect) {
		this.removeEffect(effect,{pierce: true, unsticky: true, noPopup: true});
	},this);
}
}}}
Next, we check for {{{exclusive}}} effects. No two effects with this property can exist on the same character at once. This means that if we are applying a new exclusive effect, we have to remove any others that already exist on the character. We do this by filtering the character&#39;s {{{effects}}} to only exclusive effects, then run over the results and remove every one.
{{{
if (!E.stackable)
}}}
Then we have to do this check. Some effects are &quot;stackable&quot;, which means multiple copies of the same effect can exist on a character; these can be added without further complications. Non-stackable effects, however, require more work.
{{{
found = this.effects.find(function (e) { return e &amp;&amp; e.name === name});
if (found instanceof Effect) {
	found.duration += dur;
	if (found.dot) {
		E = new Effect(name,dur,power,{weight: action().effweight});
		if (E.damage(this) &gt; found.damage(this)) {
			found.power = power;
			found.weight = action().effweight;
		}
	} else if (power &gt; found.power) {
		found.onRemove(this); found.power = power; found.onApply(this);
	}
	(...)
	return E.addText(this.name)+&quot;\r\n&quot;;
}}}
Obviously, we start by searching for a matching effect. If we don&#39;t find anything, we can ignore the rest of this; but otherwise, we have more to do. The existing effect&#39;s duration will be increased by the duration of the effect to be applied, and its power will be replaced if the effect to be applied would have higher power. (We will need to run {{{onRemove()}}} and {{{onApply()}}} in-between adjusting the power, because we need to clear the effects of the old value before recalculating.)
{{{
if (found.dot) {
	E = new Effect(name,dur,power,{weight: action().effweight});
	if (E.damage(this) &gt; found.damage(this)) {
		found.power = power;
		found.weight = action().effweight;
	}
}
}}}
...For normal effects, that is. Damage-over-time effects are more complicated, because there are more factors at play than just their raw power. We have to create a fully-functional effect out of the effect to be applied, and simulate what its damage would be compared to the existing damage-over-time effect. Only if the resulting damage is higher will the power be replaced.
{{{
return E.addText(this.name)+&quot;\r\n&quot;;
}}}
Once that&#39;s all done, we still return the effect&#39;s {{{addText}}} as if it had been applied normally, so that the player doesn&#39;t get confused.
{{{
if (name === &quot;Off-Balance&quot; &amp;&amp; this.down) {
	return `${this.name} would have been pushed off-balance, but ${this.theyre} already knocked down!`+&quot;\r\n&quot;;
}

if (name === &quot;Knocked Down&quot;) {
	this.removeEffect(&quot;Off-Balance&quot;,{pierce: true, noPopup: true});
}

if (E.dot) mods.weight = action().effweight;
if (name === &quot;Protector&quot;) {
	mods.target = target();
	target().protectedBy = this.id;
}
}}}
Finally, we have some special handlers for certain effects. Getting knocked down removes Off-Balance, Protector needs to record both who&#39;s protected and who&#39;s doing the protecting, etc.
{{{
this.effects.push(E);
E.onApply(this);
}}}
It&#39;s only after all this is done that we finally {{{push}}} our new effect. We must also run {{{onApply()}}} to ensure that any effects it has, such as stat modifications, are applied.
{{{
var text = E.addText(this.name);
(...)
return text;
}}}
We end by returning the effect&#39;s addition message. Returning text in this way allows us to use it with the {{{&lt;&lt;print&gt;&gt;}}} macro to display it in Twine in a single line of code.

&lt;h3 id=&quot;effects.calc.dot&quot;&gt;Damage-over-time effects&lt;/h3&gt;
Damage-over-time calculation is handled through the effect database. Before the definitions for each effect, several functions are defined in the Effect class definition:
{{{
var physical = function (puppet) {
	return this.weight*(setup.base + (setup.damper * (this.power - puppet.get($DefenseStat))));
}
var special = function (puppet) {
	return this.weight*(setup.base + (setup.damper * (this.power - puppet.get($SpecialStat))));
}
var piercing = function (puppet) {
	return this.weight*(setup.base + (setup.damper * this.power));
}
var proportional = function (puppet) {
	return this.weight * puppet.maxhp;
}
var fixed = function (puppet) {
	return this.power;
}
}}}
In the default engine, there are five kinds of DoT behaviors: physical, special, piercing, proportional, and fixed. Physical damage, used by the &quot;Burning&quot; effect, is reduced by the target&#39;s Defense; special damage, used by the &quot;Poisoned&quot; effect, is reduced by the target&#39;s Special; piercing damage, used by the &quot;Peridition&quot; effect, ignores defenses; proportional damage inflicts damage based on a proportion of the target&#39;s max HP; and fixed damage is just whatever you set as the object&#39;s power value.

(Note that proportional damage &lt;b&gt;multiplies&lt;/b&gt; HP by its weight. The weight of a proportional effect is equal to the proportion it takes off; a weight of 0.125 or (1/8) will take an eighth of the character&#39;s HP per turn.)

The actual application of damage is performed through the {{{damage()}}} function of the DoT class, which is defined later in the database file:
{{{
window.DoT = class DoT extends Effect {
	constructor(name,time,power,weight){
		super(name,time,power);
		this.weight = weight;
		this._dot = true;
		this.damage = function (puppet) {
			var dmg = Math.round(this.dmgtype(puppet));
			if (dmg &lt; setup.min_DoT){
				dmg = setup.min_DoT;
			}
			return dmg;
		}
	}
}
}}}
This function is passed a target that is then used to calculate damage based on the formula type, followed by cleanup -- rounding to an integer, and checking against the minimum DoT damage. (This value is set to 1 by default, and can be changed in StoryInit.)

&lt;h3 id=&quot;effects.loss&quot;&gt;Loss-of-control Effects&lt;/h3&gt;
Loss-of-control effects are status effects that allow the character to continue acting, but take control away from you, causing them to instead act under an AI routine. You may be familiar with these from the &quot;Berserk&quot; and &quot;Confusion&quot; effects in many RPGs.

In this engine, we handle these effects through a passage included in {{{&lt;&lt;specialcheck&gt;&gt;}}}, which is called constantly during battle:
{{{
&lt;&lt;set _u = $puppets.find(function (p) { return (p.uncontrollable &amp;&amp; !(p.isDone || p.noact || p.dead)); })&gt;&gt;
&lt;&lt;if def _u&gt;&gt;
	&lt;&lt;set $subject = _u&gt;&gt;
	&lt;&lt;if subject().name == &quot;Mage&quot;&gt;&gt;
		&lt;&lt;set $action = new Action(&quot;Blast&quot;)&gt;&gt;
	&lt;&lt;elseif subject().name == &quot;Witch&quot;&gt;&gt;
		&lt;&lt;set $action = new Action(&quot;Pox&quot;)&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $action = clone(subject().defaultAction)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if subject().en &lt; $action.cost&gt;&gt;
		&lt;&lt;set subject().isDone = true&gt;&gt;
		&lt;&lt;goto &quot;Battle!&quot;&gt;&gt; /* necessary to find other potential uncontrollables */
	&lt;&lt;else&gt;&gt;
		&lt;&lt;if _u.confusion&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;any&quot;])&gt;&gt;
		&lt;&lt;elseif _u.charmed&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;allies&quot;])&gt;&gt;
		&lt;&lt;elseif _u.hatred&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;enemies&quot;])&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;goto &quot;action phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
This code finds the first puppet who has been marked &quot;uncontrollable&quot; (excluding, of course, puppets who are done, paralyzed, or dead). If no such puppet is found, {{{_u}}} will be undefined and the rest of this code will be ignored. If a puppet is found and stored in {{{_u}}}, we make it the active subject, set the active action to its default attack, and forward them to the action phase, forcing them to attack. (For most cases we can use the puppet&#39;s {{{defaultAction}}} for this, but Mage and Witch have nondamaging default actions, so we need special handlers for them.)
{{{
&lt;&lt;if subject().en &lt; $action.cost&gt;&gt;
	&lt;&lt;set subject().isDone = true&gt;&gt;
	&lt;&lt;goto &quot;Battle!&quot;&gt;&gt; /* necessary to find other potential uncontrollables */
}}}
Of course, we need to be mindful of action limitations. Basic attacks aren&#39;t free in the default system, so it&#39;s possible an uncontrollable character is unable to pay the cost. There are a lot of ways you can handle this eventuality, but for simplicity, I just end the character&#39;s turn. We then have to refresh the passage so we can run this check again, in case there&#39;s another uncontrollable puppet. (The {{{find}}} function only finds the &lt;i&gt;first&lt;/i&gt; element that matches its criteria, not all of them.)
{{{
&lt;&lt;if _u.confusion&gt;&gt;
	&lt;&lt;set $target = Hitlist.targetEnemy([&quot;any&quot;])&gt;&gt;
&lt;&lt;elseif _u.charmed&gt;&gt;
	&lt;&lt;set $target = Hitlist.targetEnemy([&quot;allies&quot;])&gt;&gt;
&lt;&lt;elseif _u.hatred&gt;&gt;
	&lt;&lt;set $target = Hitlist.targetEnemy([&quot;enemies&quot;])&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The puppet needs a target before they can attack, also. That&#39;s handled through the {{{Hitlist.targetEnemy}}} function (see &lt;a class=&quot;noExternal&quot; href=&quot;#targeting.basic&quot;&gt;Standard Targeting&lt;/a&gt;), with branches for specialized behavior depending on the exact effect the puppet is under. Confused puppets can target anyone, charmed puppets will only target their allies, and hateful puppets will only target their enemies. The effects will also take precedence in that order, a necessary feature if the puppet is under multiple loss-of-control effects simultaneously.

This is a pretty bare-bones functionality. For more discussion on these effects and what you can do with them, see [[Design]].

&lt;h2 id=&quot;targeting&quot;&gt;Targeting and Enemy AI&lt;/h2&gt;
Enemies need to be able to select attacks and targets just like players. But unlike with player choices, there&#39;s no person to make selections, so we need a program to do it instead.

We could just have enemies choose actions and targets randomly, but that wouldn&#39;t make for a very engaging game; the difficulty of a battle will vary depending on whether enemies target a more vulnerable character, if they gang up on one character or if they spread damage out... etc. If that&#39;s all random, the game isn&#39;t very fair; a player might do the exact same thing and get a completely different result, just because, say, Mage never got targeted through the simple luck of the draw. So we want to make enemies a bit more intelligent, to make the player&#39;s experience more even. We also need a way to determine behavior for player characters under &lt;a class=&quot;noExternal&quot; href=&quot;#effects.loss&quot;&gt;loss-of-control effects&lt;/a&gt;.

The functions used to accomplish this are stored in their own file, {{{targeting.js}}}.

&lt;h3 id=&quot;hitlist-class&quot;&gt;Making a Hitlist&lt;/h3&gt;
Targeting is governed through the {{{Hitlist}}} class, which is defined in {{{targeting.js}}}. {{{Hitlist}}}s are specialized arrays that contain a list of battling characters, with functions to select which of them becomes a target. However, rather than adding the characters as you would to a normal array, we use another function, {{{Hitlist.addTarget}}}. This function is called when a {{{Hitlist}}} is made, but can also be called at any point afterwards.
{{{
function addTarget (target,mods) {
	(...)
	if (target instanceof Actor) {
		var initChance = 1;
		(...)
		if (
				!target.dead &amp;&amp;
				!(mods.includes(&quot;noself&quot;) &amp;&amp; target == subject()) &amp;&amp;
				(target.martyr || mods.includes(&quot;ignore untargetable&quot;) || !target.untargetable)
				) {
			this.push({target: target, chance: initChance});
		}
	}
	(...)
}
}}}
The purpose of this function is to ensure that all targets are initialized using the same rules. Dead and untargetable targets are ignored, except for certain special cases. (We can pass {{{mods}}} to the function to take specify if these exceptions should apply; note that {{{mods}}} must be an array, or it won&#39;t work.) We can also see here that the {{{Hitlist}}} contains not just the character object itself, but a corresponding {{{chance}}} value for each as well. This value is used to determine the likelihood of being targeted; higher values are more likely. Everyone starts on even ground, with an initial chance of {{{1}}}. (Or their threat value, if &lt;a href=&quot;#targeting.threat&quot;&gt;threat targeting&lt;/a&gt; is used.)
{{{
returnTarget (mods,bypass) {
	(...)
	for (let t of this) {
		if (t.target.martyr &amp;&amp; !t.target.dead &amp;&amp; !(mods.includes(&quot;ignore martyr&quot;) || mods.includes(&quot;ally&quot;))) {
			return t.target;
		}
		if (t.target.dead || (t.target.untargetable &amp;&amp; !(mods.includes(&quot;ignore untargetable&quot;) || mods.includes(&quot;ally&quot;)))) {
			t.chance = 0;
		} else if (bypass !== true) {
			if (t.target.firefly) {
				t.chance *= setup.FIREFLY_FACTOR;
			}
			if (t.target.wallflower) {
				t.chance *= setup.WALLFLOWER_FACTOR;
			}
		}
	}

	i = 0;
	while (i &lt; this.length) {
		if (this[i].chance &gt; 0) i++;
		else this.splice(i, 1);
	}

	(...)

	var chance = this.map(function (t) { return t.chance });
	const total = chance.reduce((a, c) =&gt; a + c, 0);
	this.forEach((el, i) =&gt; el.chance = el.chance/total, this);

	var i, sum=0, r=Math.random();
	for (i of this) {
		sum += i[&quot;chance&quot;];
		if (r &lt;= sum) return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods);
	}
	temporary().targetfail = true;
	console.log(`ERROR in returnTarget: failed to find target. Likely cause is empty hitlist; check targeting logic.`);
	console.log(`Echoing hitlist for verification.`);
	console.log(this);
	return;
}
}}}
The other half of this is what we want to come &lt;i&gt;out&lt;/i&gt; of our {{{Hitlist}}}. For that, we use this function, {{{returnTarget}}}. If there&#39;s a martyr in the {{{Hitlist}}}, it will just return that immediately and we&#39;ll be done (unless you pass an &quot;ignore martyr&quot; mod). Otherwise, it will automatically apply the factors from Firefly and Wallflower, and remove any untargetables that managed to slip through.
{{{
var chance = this.map(function (t) { return t.chance });
const total = chance.reduce((a, c) =&gt; a + c, 0);
this.forEach((el, i) =&gt; el.chance = el.chance/total, this);

var i, sum=0, r=Math.random();
for (i of this) {
	sum += i[&quot;chance&quot;];
	if (r &lt;= sum) return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods);
}
}}}
Then it&#39;s time to actually choose a target. To make this easier on our random number generator, we standardize all the {{{chance}}} values to a proportion of the total {{{chance}}} of all targets. For instance, if we had a chance array of {{{[1,2,1]}}}, this would reduce it to {{{[0.25,0.5,0.25]}}}, corresponding to the percent chance of each being selected. With that, we can use {{{Math.random}}} to generate a random number between 0 and 1, then if it&#39;s less than or equal to a character&#39;s {{{chance}}} value, they&#39;re the target! (Note that we have to keep a running total of the {{{chance}}} values and compare against that rather than the individual {{{chance}}}s; otherwise, a high random value would result in nobody being selected.)
{{{
return Hitlist.protectionCheck(Hitlist.guardCheck(i.target),mods)
}}}
However, we don&#39;t just return the target straight: We also run them through two more functions, {{{Hitlist.guardCheck}}} and {{{Hitlist.protectionCheck}}}. These check if the character is being guarded by a front-row character or someone with the Protector effect, respectively, and reassign to the correct target if so.
{{{
temporary().targetfail = true;
console.log(`ERROR in returnTarget: failed to find target. Likely cause is empty hitlist; check targeting logic.`);
console.log(`Echoing hitlist for verification.`);
console.log(this);
return;
}}}
However, we must not succumb to the hubris of assuming our code will always work! In case something strange happens and a target couldn&#39;t be found (such as if we tried to call this on an empty hitlist), the loop will terminate without executing the {{{return}}} statement, and this code will run. It flags {{{_targetfail}}} to avoid errors on the player&#39;s end, and logs some details to the console for debugging.

The purpose of defining these functions here, instead of in enemy AI or other logic functions, is to standardize them. You don&#39;t have to remember to manually initialize everyone&#39;s {{{chance}}} values, or to exclude untargetables, or to run protection checks. You can populate and modify the {{{Histlist}}} with specific logic, and then trust that the fundamental selection rules will always work as intended.

Let&#39;s look at some of those logic functions now that we know the basics:

&lt;h3 id=&quot;targeting.basic&quot;&gt;Standard Targeting&lt;/h3&gt;
Regular targeting is handled by the {{{Hitlist.targetEnemy}}} function.

The first thing to note here is that this is a &lt;b&gt;static&lt;/b&gt; function, which means it functions differently than most method functions. Method functions are usually called on an existing object of their class, and can use {{{this}}} to reference that object. Static functions, by contrast, are attached to &lt;i&gt;the class itself&lt;/i&gt;, and can be used anywhere as long as that class is referenced. Practically, this means that you must always preface your function calls with {{{Hitlist.}}} for them to work.
{{{
if (deadCount() == puppets().length || enemies().filter(function (e) { return e.dead; }).length == enemies().length) {
	temporary().targetfail = true;
	return null;
}
}}}
In the function itself, the very first thing we have to do is check if all the characters in a party are already defeated. This can happen if the party is wiped in the middle of the turn or a multi-hit attack. Since dead characters can&#39;t be targeted, we&#39;ll run into an error if we try to run the widget in this state. So instead, we set a {{{_targetfail}}} flag and end the widget here.
{{{
var mods = [];
if (args instanceof Array) {
	mods = args;
} else if (typeof(args) == &quot;string&quot;) {
	mods = [args];
}
}}}
Then we do some processing on the arguments passed to the function. Later logic will assume {{{mods}}} is an array, but I give you a little leeway: if you only passed a single string, it will get turned into a one-element array for compatibility with the rest of the function.
{{{
if (subject().uncontrollable) {
	if (mods.includes(&quot;any&quot;)) {
		let selector = random(1,2);
		switch (selector) {
			case 1:
				party = V().puppets;
				break;
			case 2:
				party = V().enemies;
				break;
		}
	}
	else if (mods.includes(&quot;enemies&quot;)) {
		party = subject().otherParty;
	}
	else if (mods.includes(&quot;allies&quot;)) {
		party = subject().ownParty;
	}
}
}}}
Next, remember that we use this widget for both enemies &lt;i&gt;and&lt;/i&gt; puppets. If the subject is under a loss-of-control effect, their target party is variable. We determine the target party from the first argument passed to the widget, or we flip a coin if the argument is &quot;any&quot;.
{{{
if (!mods.includes(&quot;ignore untargetable&quot;)) {
	let untargetTest = party.filter(function (p) { return (p.dead || p.untargetable) });
	if (untargetTest.length == party.length) {
		mods.push(&quot;ignore untargetable&quot;);
	}
}
}}}
With the target party found, we have to do a quick check for untargetables. If the only living targets are untargetable, we have to add the mod &quot;ignore untargetable&quot; so they can be selected; otherwise, the attack will whiff.
{{{
var hitlist = new Hitlist(party,mods);
}}}
Then we make a {{{Hitlist}}} object using our party and mods.

From here, the widget runs through the targeting criteria in highest to lowest priority, so our special cases come first.

&lt;h4 id=&quot;targeting.basic.1&quot;&gt;Martyr check&lt;/h4&gt;
{{{
(Hitlist class definition:)
	martyrCheck () {
		var test = this.find(function (t) { return t &amp;&amp; t.target.martyr &amp;&amp; !t.target.dead });
		return typeof(test) === &quot;object&quot; ? test.target : false;
	}

(in targetEnemy:)
	if (!mods.includes(&quot;ignore martyr&quot;) &amp;&amp; hitlist.martyrCheck() instanceof Actor) {
		return hitlist.martyrCheck();
	}
}}}
In the default engine there&#39;s an effect, &quot;Martyr&quot;, that forces all attacks to target the recipient. This ought to bypass any normal enemy behavior, so we should implement it first. For this, we define a simple {{{martyrCheck}}} function in {{{Hitlist}}} that searches itself to find any battlers with the {{{martyr}}} flag. If so, that battler will be returned; if not, we return {{{false}}}. We can then use this function to quickly check if a martyr is present with the test {{{hitlist.martyrCheck() instanceof Actor}}}: it&#39;ll be {{{true}}} if one is, and {{{false}}} if one isn&#39;t. If it&#39;s {{{true}}}, we&#39;re done -- we return the martyr and we have our target.

(Note that due to the way {{{find}}} works, this will stop at the first position it finds even if there are multiple matches. As previously discussed in &lt;a class=&quot;noExternal&quot; href=&quot;#effects1&quot;&gt;the effect adder&lt;/a&gt;, there is a check to ensure only one Martyr can exist at a time.)

&lt;h4 id=&quot;targeting.basic.3&quot;&gt;Mercy&lt;/h4&gt;
{{{
var mercy = 0;
if (subject().mercy &lt; 1 || mods.includes(&quot;smart&quot;)) {
// if enemy&#39;s mercy is below 1, they will always use smart targeting
	mercy = 2;
}
else {
// 1 in (mercy) chance of random targeting, to give players a break
	mercy = random(1,subject().mercy);
}
}}}
The next thing we do is set the {{{mercy}}} variable. You might consider the game too hard if enemies always make the perfectly optimal choices. You can use the mercy mechanic to give players a bit of a break. If {{{mercy}}} is 1, the enemy won&#39;t behave intelligently and will just target randomly. You can customize each enemy&#39;s intelligence level with their &quot;mercy&quot; attribute, defined in the story JavaScript. It&#39;s a little unintuitive: the chance of bypassing smart targeting will be the inverse of their &quot;mercy&quot; value, so a higher value will make an enemy more merciless. If you set &quot;mercy&quot; to 1, the enemy will always target randomly. Conversely, if you set &quot;mercy&quot; to 0, the first {{{if}}} statement will ensure they always use smart targeting. You can also accomplish this by passing the string &quot;smart&quot; to this function.

In the default engine, all enemies have their &quot;mercy&quot; values set to 3, so they have a 1-in-3 chance of targeting randomly. You can give specific enemies different values by manually setting their &quot;mercy&quot; values in the enemy database.

&lt;h4 id=&quot;targeting.basic.4&quot;&gt;Smart targeting&lt;/h4&gt;
Smart targeting is handled via another {{{Histlist}}} function, {{{addFactors}}}. This function accepts a large number of potential mods, and adjusts targeting chances based on them.
{{{
if (mods.includes(&quot;least HP&quot;) &amp;&amp; t.target.hp &lt;= lowestHP) {
	t.chance += 1;
} else if (mods.includes(&quot;most HP&quot;) &amp;&amp; t.target.hp &gt;= greatestHP) {
	t.chance += 1;
} else if (mods.includes(&quot;most damage&quot;) &amp;&amp; t.target.lastDmg &gt;= mostDamaging) {
	t.chance += 1;
} (etc.)
else if (mods.includes(&quot;exclusive&quot;)) {
	t.chance = 0;
}
}}}
This function is roughly divided into two types of modifiers: exclusive and non-exclusive. Exclusive mods only care about a single character: the one with the most or least of something, be that HP or a particular stat. The highest and lowest of each stat in the party are found before this, and this {{{if}}} tree will compare each target against those values to see how they measure up. Anyone who doesn&#39;t match the criteria gets removed from the hitlist. (However, due to the sheer number of potential mods, it&#39;s unfeasible to check for every single one in the final {{{else if}}}, so you&#39;ll need to add the &quot;exclusive&quot; mod to remove other characters.)
{{{
else {
	if (!mods.includes(&quot;ignore downed&quot;) &amp;&amp; (t.target.offbalance || t.target.down)) {
		t.chance += 1;
	}
	if (mods.includes(&quot;effect&quot;) &amp;&amp; !(t.target.chi || t.target.stasis)
		&amp;&amp; t.target.get($SpecialStat) &lt; t.target.getBase($SpecialStat)) {
			t.chance += 1;
	}
	if (!mods.includes(&quot;ignore threat&quot;) &amp;&amp; t.target.lastDmg &gt;= mostDamaging) {
		t.chance += 1;
	}
	if (mods.includes(&quot;pierce&quot;) &amp;&amp; t.target.get($DefenseStat) &gt;= highestStat[V().DefenseStat]) {
		t.chance += 1;
	}
	else if (!mods.includes(&quot;ignore vulnerable&quot;) &amp;&amp; t.target.get($DefenseStat) &lt; t.target.getBase($DefenseStat)) {
		t.chance += 1;
	}
	if (mods.includes(&quot;ruthless&quot;)) {
		t.chance += (1-((t.target.hp)/t.target.maxhp))*setup.RUTHLESS_FACTOR;
	}
	else if (!mods.includes(&quot;ignore vulnerable&quot;)) {
		t.chance += (1-((t.target.hp)/t.target.maxhp));
	}
}
}}}
If no exclusive mods were found, we move on to non-exclusive mods. These will give characters higher chances to be targeted based on various factors. By default, all attacks will preferentially target Off-Balance characters to proc Knocked Down, preferentially target characters will debuffed Defense and lowered HP to finish them off, and preferentially target the character who inflicted the most damage last turn to prioritize the greatest threats. Piercing attacks will instead prefer the target with the highest Defense, and debuffing attacks will prefer targets with debuffed Special to get the most bang for their buck.

You can add more modifiers here as you wish.
{{{
switch (V().difficulty) {
	case &quot;hard&quot;:
	// Hard difficulty: If any puppets are vulnerable, non-vulnerable puppets will be ignored
		if (mercy &gt; 1) {
			hitlist.addFactors(mods);
			hitlist.onlyVulnerable();
		}
		break;

	case &quot;medium&quot;:
		// Medium difficulty: All puppets will be considered, but vulnerable puppets will get additional chances to be selected.
		if (mercy &gt; 1) {
			hitlist.addFactors(mods);
		}
		break;

		case &quot;easy&quot;:
			// Easy difficulty: Smart targeting is only used with the &quot;smart&quot; mod.
			if (mods.includes(&quot;smart&quot;)) {
				hitlist.addFactors(mods);
			}
			break;
}
}}}
Back to {{{targetEnemy}}}, we apply these factors, but with branching functionality based on the difficulty setting. On easy difficulty, we will only use smart factors if the attack has the &quot;smart&quot; mod, and on hard difficulty, we will not only use smart factors, we will &lt;i&gt;remove&lt;/i&gt; targets that &lt;i&gt;weren&#39;t&lt;/i&gt; noticed by smart targeting. This can make enemies very dangerous on hard mode, as they will only ever target the most vulnerable characters.

After that, we are finally done, and we can return our target.

&lt;h3 id=&quot;targeting.threat&quot;&gt;Threat-based/Aggro Targeting&lt;/h3&gt;
There&#39;s an alternative to normal targeting you may like to use, especially if you&#39;re using a system like &lt;i&gt;Dungeons &amp; Dragons&lt;/i&gt; where range and positioning is important.

&lt;b&gt;Threat-based targeting&lt;/b&gt;, enabled by activating the {{{THREAT_TARGETING}}} variable in {{{StoryInit}}}, uses a statistic, called &quot;threat&quot; here, to determine which character enemies attack. There are a lot of ways this can be done, and it may be instructive to look into aggro systems in other games if you&#39;d like to modify the default system.
{{{
if (setup.THREAT_TARGETING === true) {
	this.threat = new Map();
	V().puppets.forEach(function(puppet) {
		this.threat.set(puppet.name,puppet.initialThreat());
	}, this);
}
}}}
The very first thing we have to do is to initialize the threat statistic so we have one at all. That&#39;s taken care of through this code in &lt;a class=&quot;noExternal&quot; href=&quot;#JS.enemies&quot;&gt;the Enemy class constructor&lt;/a&gt;. If we&#39;ve enabled threat targeting, we create a {{{Map}}} with a numerical threat value keyed to every puppet on the field, and assign it as a property of the Enemy object.
{{{
initialThreat(){
	return 1;
}
}}}
&lt;code&gt;initialThreat&lt;/code&gt; is defined in the Puppet class. In theory, you may want to implement some more code here that modifies the initial threat based on some other variables, but by default it just returns a value of 1.
{{{
&lt;&lt;if setup.THREAT_TARGETING === true &amp;&amp; subject() instanceof Puppet &amp;&amp; target() instanceof Enemy&gt;&gt;
	&lt;&lt;include &quot;echoDamage threat gain&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;

(...)

&lt;&lt;set _threatGain = 1 * ($dmg / target().maxhp)&gt;&gt;
&lt;&lt;run target().threat.inc(subject().name,_threatGain)&gt;&gt;
}}}
Additional threat is generated when player characters inflict damage in {{{&lt;&lt;echoDamage&gt;&gt;}}}. Threat gain is equal to the proportion of maximum HP inflicted by the attack. You can also add special cases for various circumstances -- perhaps certain attacks draw more or less threat, or, as here, special traits like Firefly affect it -- or make a completely different formula. The threat formula is offloaded to its own passage, &quot;echoDamage threat gain&quot;, to make this easier.
{{{
&lt;&lt;if setup.THREAT_TARGETING === true &amp;&amp; target() instanceof Enemy &amp;&amp; subject() instanceof Puppet&gt;&gt;
	&lt;&lt;run target().threat.inc(subject().name,$action.threat)&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
You can also make actions provide a flat threat increase. In &lt;i&gt;Dragon Age&lt;/i&gt;, this typically included ranged attacks and spells, which makes sense, as those attacks are used by dangerous yet vulnerable targets that smart opponents should prioritize. You can also use this to make non-damaging attacks draw threat.
{{{
decayThreat () {
	if (setup.THREAT_TARGETING === true) {
		this.threat.forEach(function(value,key) {
			this.threat.set(key,value-setup.THREAT_DECAY);
			if (this.threat.get(key) &lt; 1) {
				this.threat.set(key,1);
			}
		}, this);
	}
}
}}}
Finally, we want a way for threat to change over time -- if a character stops attacking, logicially they should draw less attention. This method function, defined in the Enemy class and called at the end of the enemy turn, reduces threat by a small amount specified in {{{StoryInit}}} (10 by default).

Threat targeting otherwise functions the same as regular targeting, so with these variables set up you&#39;re good to go.

This threat system is based on the targeting system from &lt;i&gt;Dragon Age&lt;/i&gt;, and has a number of built-in assumptions and limitations. You can read more about the implications of this system and other possibilities in [[Design]].

&lt;h3 id=&quot;dispel&quot;&gt;Dispel Targeting&lt;/h3&gt;
Some enemies have abilities that can remove positive effects from player characters. Logically, these abilities should prioritize targets with buffs to dispel so they can get the most bang for their buck. This functionality is split across two functions: {{{dispelFactors}}} in {{{Hitlist}}}, and {{{dispelCheck}}} in {{{logic-functions.js}}}.

{{{dispelFactors}}} is very simple: It runs over the hitlist and boosts everyone&#39;s {{{chance}}} value by the {{{threat}}} value of all their buff effects. (The {{{threat}}} value is defined in the effect database, and allows you to value certain effects more highly.) It also takes an additional mod, &quot;exclusive dispel&quot;, which removes any character with no buffs if passed to the function. This will be run just before smart targeting in {{{Hitlist.targetEnemy}}} if you pass the &quot;dispel&quot; mod.

However, targeting logic is only run after an action is already selected. How does an enemy determine if the dispel should be used at all? If no one has any buffs, there&#39;s no reason to use it over another attack in the first place.
{{{
function dispelCheck (mods) {
	(...)
	var party = puppets().filter(function (a) { return a &amp;&amp; !a.dead });
	var martyr = party.find(function (p) { return p &amp;&amp; p.martyr === true });
	if (!(mods.includes(&quot;mass&quot;) || mods.includes(&quot;ignore martyr&quot;)) &amp;&amp; martyr instanceof Actor) {
		return martyr.effectCount(&quot;buff&quot;,mods);
	} else {
		var count = 0;
		for (let p of party) {
			if (mods.includes(&quot;ignore untargetable&quot;) || !p.untargetable) {
				count += p.effectCount(&quot;buff&quot;,mods);
			}
		}
		return count;
	}
}
}}}
This is handled by the function {{{dispelCheck}}}, which can be found in {{{logic-functions.js}}}, a set of functions that assist with enemy logic. This counts up the threat value of all buffs on all puppets and returns that total, allowing you to quickly check if a dispel is worth using based on how many effects are found. Since this simulates an attack, we also have to check for martyrs and exclude untargetables. (There is also a complementary {{{cureCheck}}} function that counts ailments among allies instead.)

&lt;h3 id=&quot;targeting.ally&quot;&gt;Ally Targeting&lt;/h3&gt;
Some enemy actions target their allies instead of the player characters. We need something to handle that too.
{{{
static targetAlly (args) {
	(...)
	var mods = [];
	if (args instanceof Array) {
		mods = args;
	} else if (typeof(args) == &quot;string&quot;) {
		mods = [args];
	}
	mods.push(&quot;ally&quot;);

	var party = subject().ownParty.filter(function (a) { return a !== null; });
	var hitlist = new Hitlist(party,mods);
	if (!mods.includes(&quot;random&quot;)) {
		hitlist.allyFactors(mods);
	}
	return hitlist.returnTarget(mods,true);
}
}}}
Fortunately, this functionality is much simpler. We basically just have to create a {{{Hitlist}}} object, and we&#39;re done. Note that we do, however, include the &quot;ally&quot; mod to alter some things. Ally targeting ignores martyrs, untargetability, and protection checks.
{{{
allyFactors (mods) {
	(...)
	if (mods.includes(&quot;pragmatic&quot;)) {
		for (let t of this) {
			if (t.target.hp &lt; (t.target.maxhp * Math.clamp(setup.PRAGMATIC_CUTOFF,0,1))) {
				t.chance = 0;
			}
		}
	}

	if (mods.includes(&quot;most vulnerable&quot;)) {
		var lowestHP = Math.min(...this.filter(function (t) { return t.chance &gt; 0 }).map(function (t) { return t.target.hp }));
	}
	for (let t of this) {
		if (mods.includes(&quot;most vulnerable&quot;) &amp;&amp; t.target.hp &lt;= lowestHP) {
			t.chance += 1;
		} else if (mods.includes(&quot;most vulnerable&quot;)) {
			t.chance = 0;
		} else {
			if (mods.includes(&quot;vulnerable&quot;)) {
				t.chance += (1-((t.target.hp)/t.target.maxhp))*2;
			}
			if (mods.includes(&quot;ailments&quot;)) {
				t.chance += t.target.effectCount(&quot;ailment&quot;,[&quot;threat&quot;,&quot;nosticky&quot;])
			}
		}
	}
}
}}}
As with enemy targeting, we have a function to add weight to certain targets, but it is a different function since the logic for applying support abilities is different from the logic you want for attacks. Fewer mods are used here: we can prioritize characters with reduced HP or characters with ailments, or limit ourselves to only the target with the lowest HP. As with {{{addFactors}}}, more clauses can be added to suit your needs.

There is also a &quot;pragmatic&quot; mod that will exclude characters that are below a certain proportion of HP -- the enemy may not want to use an expensive buff move on an ally that&#39;s about to die anyway. &lt;b&gt;Note that this can reduce the number of possible targets to 0, which will cause an error.&lt;/b&gt; Make sure to include a check in your enemy AI to ensure it will never be used in this case.

&lt;h2 id=&quot;menus&quot;&gt;Menu Functionality&lt;/h2&gt;
A lot of RPGs involve managing characters and resources both in and out of battle. To do so requires some kind of menu where you can see your characters, items, equipment, etc. The functionality for these features can be found in the &quot;party menu&quot; file.
{{{
&lt;span id=&quot;status&quot;&gt;
&lt;span style=&quot;display:inline-block; line-height:1.2; float:right; font-family:monospace&quot;&gt;
[A] ↑&lt;br/&gt;
[D] ↓
&lt;/span&gt;
&lt;&lt;for _n, _option range setup.MENU_OPTIONS&gt;&gt;
&lt;&lt;if _n != $menu_screen&gt;&gt;
&lt;&lt;capture _n, _option&gt;&gt;
&lt;span @id=&quot;&#39;menu&#39;+_n&quot;&gt;
&lt;&lt;link _option&gt;&gt;
	&lt;&lt;set $menu_screen = _n&gt;&gt;
	&lt;&lt;print &#39;&lt;&lt;goto \&quot;Menu: &#39;+_option+&#39;\&quot;&gt;&gt;&#39;&gt;&gt;
&lt;&lt;/link&gt;&gt;&lt;/span&gt;&lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
&lt;b&gt;_option&lt;/b&gt;
&lt;&lt;/if&gt;&gt;
&lt;br/&gt;
&lt;&lt;/for&gt;&gt;
&lt;span id=&quot;menu-return&quot;&gt;&lt;&lt;longreturn&gt;&gt;&lt;/span&gt;
&lt;/span&gt;
}}}
What makes the menu an actual menu is this little passage right here. This is {{{&lt;&lt;include&gt;&gt;}}}d at the top of every menu page, and creates a navbar the player can use to access different submenus. For modularity, this functionality is tied to {{{setup.MENU_OPTIONS}}}, a variable defined in StoryInit. You can modify it to easily add or remove menu screens without needing to change this passage, but note that you must follow its strict format: every menu passage must have the title &quot;Menu: &quot; followed by exactly what you wrote in {{{setup.MENU_OPTIONS}}}.

{{{&lt;&lt;longreturn&gt;&gt;}}} is a widget that can be found in &quot;Widgets (General)&quot;. It functions like the {{{&lt;&lt;return&gt;&gt;}}} macro, but skips over passages tagged &quot;noreturn&quot;. Since the player will be moving through multiple passages while navigating the menu, a regular {{{&lt;&lt;return&gt;&gt;}}} macro won&#39;t cut it -- it&#39;ll return them only to the previous menu passage, not the game area they opened the menu from. Make sure to tag all your menu passages &quot;noreturn&quot; so this works properly.

&lt;h3 id=&quot;menus.status&quot;&gt;Status&lt;/h3&gt;
It&#39;s typical for RPG menus to include a general status screen that tells you relevant information about your characters, such as their stats and abilities. That&#39;s handled by this screen.

I won&#39;t copy the full code for this passage here, because it&#39;s mostly formatting and graphical design. I don&#39;t recommend modifying it unless you want to change how it looks and you&#39;re sure you know what you&#39;re doing.

By default, this screen mimics the appearance of RPG Maker VX Ace&#39;s menu screen. Each character&#39;s entry displays their portrait (if they have one), then their name and level, then their HP and MP, and then their experience points. By clicking the character&#39;s name or using the numbered hotkeys, you can expand the small info box into a more detailed one that provides additional information. Again, this is based on RPG Maker VX Ace&#39;s status screen: the character&#39;s stats are displayed on the left, and their current equipment on the right. Similarly to the in-battle status screen, you can define additional screens here using the {{{menu}}} property of the {{{setup.STATUS_SCREENS}}} variable. By default, the engine displays information for equipment, elemental affinities, and ailment tolerances; you&#39;ll have to design your own panes if you want to add others.

The character&#39;s available abilities are also listed below the detailed status screen. There is not currently functionality for using abilities outside of battle, but this is planned in a future update.

&lt;h3 id=&quot;menus.inventory&quot;&gt;Inventory&lt;/h3&gt;
Most RPGs feature items and inventory management. It&#39;s therefore useful to give players a way to easily refer to their inventory.

Because of the sheer number of items it&#39;s possible to accumulate, this screen is more stripped-down compared to some of the others. The inventory list shows only the items and their stock values. To see more information, the player can click on an item to have its details appear at the top of the screen. This is accomplished by dividing the passage into two major parts, the inventory list and the detail display box:
{{{
&lt;span id=&quot;content&quot;&gt;&lt;&lt;nobr&gt;&gt;
&lt;&lt;set _filter = &quot;all&quot;&gt;&gt;
&lt;div id=&quot;itemdisplay&quot;&gt;
&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;
&lt;/div&gt;
&lt;div id=&quot;itemlist&quot;&gt;
&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;/span&gt;
}}}
Because we will be frequently updating these sections, it&#39;s helpful to offload their contents to separate passages so we can easily update them by {{{&lt;&lt;replace&gt;&gt;}}}ing them with themselves. Remember that Twine does not automatically update its passages after variable changes, so we need to refresh the content manually to reflect any changes we make.
{{{
&lt;div style=&quot;display:flex; justify-content:space-evenly;&quot;&gt;
&lt;&lt;if _filter == &quot;all&quot;&gt;&gt;
	&lt;b&gt;All&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;All&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;all&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _filter == &quot;usable&quot;&gt;&gt;
	&lt;b&gt;Usable&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Usable&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;usable&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _filter == &quot;equipment&quot;&gt;&gt;
	&lt;b&gt;Equipment&lt;/b&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;link &quot;Equipment&quot;&gt;&gt;
		&lt;&lt;set _filter = &quot;equipment&quot;&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
}}}
The first thing we include in &quot;inventory item list&quot; is a set of filtering options. This helps the player find an item they need if they have a lot of items. By default, the filters are all items, usable items, and equippable items. These buttons are links that change the {{{_filter}}} variable and refresh the item list when clicked.
{{{
&lt;div class=&quot;itemcontainer&quot;&gt;
&lt;&lt;set _p = 2&gt;&gt;
&lt;&lt;for _name, _item range $inventory&gt;&gt;
	&lt;&lt;if _filter == &quot;all&quot; || (_filter == &quot;usable&quot; &amp;&amp; _item.usable.includes(&quot;inmenu&quot;)) || (_filter == &quot;equipment&quot; &amp;&amp; _item.equippable)&gt;&gt;
	&lt;&lt;if _p == 1&gt;&gt;
		&lt;&lt;set _p = 2&gt;&gt;
	&lt;&lt;elseif _p == 2&gt;&gt;
		&lt;&lt;set _p = 1&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;div @class=&quot;&#39;item&#39;+_p&quot;&gt;
	&lt;b&gt;
	&lt;&lt;capture _item&gt;&gt;
	&lt;&lt;link &quot;_name&quot;&gt;&gt;
		&lt;&lt;set _display = _item&gt;&gt;
		&lt;&lt;replace &quot;#itemdisplay&quot;&gt;&gt;&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;/b&gt; &lt;span class=&quot;itemstock&quot;&gt;(_item.stock)&lt;/span&gt;
	&lt;/div&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;/div&gt;
}}}
We then display the item list itself. The actual layout of the list is handled in {{{menu.css}}}; this code only handles the filtering and detail links. We display the items by running a {{{&lt;&lt;for&gt;&gt;}}} loop across the player&#39;s inventory, but for every iteration of the loop, we check against the filter: if &quot;usable&quot; is clicked, only items usable in the menu are shown, and if &quot;equipment&quot; is clicked, only items with equipment data are shown. The item name is then made into a link; when clicked, it copies the item to the {{{_display}}} variable and refreshes the display section.
{{{
&lt;&lt;if ndef _display || _display === null&gt;&gt;
	&lt;div style=&quot;text-align: center; line-height: 70px; color: gray&quot;&gt;Click on an item to see info&lt;/div&gt;
&lt;&lt;else&gt;&gt;
&lt;b&gt;_display.name&lt;/b&gt;&lt;br/&gt;
&lt;&lt;if def _display.equippable&gt;&gt;&lt;i style=&quot;font-size:12px&quot;&gt;&lt;&lt;print _display.equippable.slot&gt;&gt;&lt;/i&gt;&lt;br/&gt;&lt;&lt;/if&gt;&gt;
_display.info&lt;br/&gt;
&lt;div class=&quot;actdesc&quot;&gt;_display.desc&lt;/div&gt;
&lt;&lt;if _display.usable.includes(&#39;inmenu&#39;) || _display.equippable&gt;&gt;
&lt;div style=&quot;display: flex; justify-content: space-evenly&quot;&gt;
	&lt;&lt;set _b = 0&gt;&gt;
	&lt;&lt;if _display.usable.includes(&#39;inmenu&#39;) &amp;&amp; _display.stock &gt; 0&gt;&gt;
		&lt;&lt;set _b++&gt;&gt;
		&lt;span @id=&quot;&#39;button&#39;+_b&quot;&gt;
			&lt;span id=&quot;usebutton&quot;&gt;
			&lt;&lt;include &quot;inventory use button&quot;&gt;&gt;
			&lt;/span&gt;
		&lt;/span&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _display.equippable &amp;&amp; _display.stock &gt; 0&gt;&gt;
		&lt;&lt;set _b++&gt;&gt;
		&lt;span @id=&quot;&#39;button&#39;+_b&quot;&gt;
			&lt;span id=&quot;equipbutton&quot;&gt;
			&lt;&lt;include &quot;equip button&quot;&gt;&gt;
			&lt;/span&gt;
		&lt;/span&gt;
	&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The display section simply prints the item&#39;s data in an easily-readable fashion, provided you&#39;ve selected an item to {{{_display}}}. (By default, it will direct you to click an item. We could simply not display the box at all until the player clicks on an item, but it&#39;s jarring for a new element to suddenly appear on the screen, especially when it appears at the top and pushes all the other elements on the page. Maintaining a default appearance for the box provides better aesthetic consistency and a smoother experience for the player.)

(Don&#39;t worry too much about the weird variables and IDs here, they&#39;re just to help direct the hotkeys in the rare circumstance that an item is both usable and equippable.)

The interesting part comes if the item is usable or equippable. In that case, we must provide functionality for the player to use or equip it. This functionality is, once again, offloaded to a set of child passages:
{{{
&lt;&lt;button &quot;USE&quot;&gt;&gt;
	&lt;&lt;set _itemcancel = true; _target = 1; _event = &quot;use&quot;&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;usebutton&quot;)&gt;&gt;&lt;&lt;replace &quot;#usebutton&quot;&gt;&gt;&lt;&lt;include &quot;inventory cancel button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;&lt;&lt;/if&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;equipbutton&quot;)&gt;&gt;&lt;&lt;replace &quot;#equipbutton&quot;&gt;&gt;&lt;&lt;include &quot;equip button&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;&lt;&lt;/if&gt;&gt;
	&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/button&gt;&gt;
}}}
When the &quot;USE&quot; or &quot;EQUIP&quot; buttons are pressed, several things happen. Most of them are handlers for hotkeys or the rare case that an item is both usable and equippable, but the important event is that the button and the item list are replaced with new passages. We want to replace the button the player just clicked with a cancel button so that they can back out if they want to select a different item; but also, now that the player has selected an item to use, we need to provide a way for the player to use it.
{{{
&lt;&lt;set _HPmeters = []&gt;&gt;
&lt;&lt;set _MPmeters = []&gt;&gt;
&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
	&lt;div class=&quot;menuactor&quot; @id=&quot;_i&quot; style=&quot;display:grid; grid-template-columns: 33% 1fr&quot;&gt;
		&lt;div class=&quot;menuactor-nameblock&quot; style=&quot;position:static; padding-left:14px; padding-top:5px; padding-bottom:0.5em; grid-row:1; grid-column:1; border-right:1px solid&quot;&gt;
			&lt;div class=&quot;menuactor-name&quot;&gt;
			&lt;&lt;capture _i, _puppet&gt;&gt;
			&lt;&lt;if _event == &quot;equip&quot;&gt;&gt;
				&lt;&lt;link _puppet.name&gt;&gt;
					&lt;&lt;run _puppet.equip(_display)&gt;&gt;
					&lt;&lt;unset _display&gt;&gt;
					&lt;&lt;replace &quot;#itemdisplay&quot;&gt;&gt;&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
			&lt;&lt;elseif _event == &quot;use&quot;&gt;&gt;
				&lt;&lt;link _puppet.name&gt;&gt;
					&lt;&lt;run _display.onUse(_puppet); console.log(&quot;item used&quot;); console.log(_puppet.maxhp); console.log($puppets.indexOf(_puppet).maxhp)&gt;&gt;
					&lt;&lt;unset _display&gt;&gt;
					&lt;&lt;replace &quot;#itemdisplay&quot;&gt;&gt;&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
					&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
				&lt;&lt;/link&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;/capture&gt;&gt;
			&lt;/div&gt;
			&lt;div class=&quot;menuactor-stats&quot; style=&quot;grid-row:unset; grid-column:unset; grid-template-columns:40% 3em 4em; border-right:none; top-padding:0&quot;&gt;
			&lt;&lt;for _k, _v range _puppet.stats&gt;&gt;
				&lt;div class=&quot;menuactor-statname&quot; style=&quot;margin-left:0&quot;&gt;_k&lt;/div&gt;
				&lt;div class=&quot;menuactor-statvalue&quot;&gt;_v.base&lt;/div&gt;
				&lt;&lt;if _v.bonus != 0&gt;&gt;
					&lt;div class=&quot;menuactor-statmod&quot;&gt;
					&lt;&lt;if _v.bonus &gt; 0&gt;&gt;
						@@.green;&lt;&lt;print &quot;\+&quot;+_v.bonus&gt;&gt;@@
					&lt;&lt;elseif _v.bonus &lt; 0&gt;&gt;
						@@.stat-lowered;&lt;&lt;print &quot;-&quot;+_v.bonus&gt;&gt;@@
					&lt;&lt;/if&gt;&gt;
					&lt;/div&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;&lt;if _event == &quot;equip&quot;&gt;&gt;
			&lt;div style=&quot;grid-row:1; grid-column:2; margin-left:1em; margin-top:0.5em; margin-bottom:0.5em; margin-right:1em&quot;&gt;
			&lt;&lt;for _k, _v range _puppet.equipment&gt;&gt;
				&lt;div class=&quot;menuactor-equipment-slot&quot;&gt;_k&lt;/div&gt;
				&lt;&lt;if _v === null&gt;&gt;&lt;span class=&quot;menuactor-equipment-name&quot;&gt;&amp;nbsp;&lt;/span&gt;
				&lt;&lt;else&gt;&gt;
					&lt;div class=&quot;menuactor-equipment-name&quot;&gt;_v.name&lt;br/&gt;
					&lt;span class=&quot;actdesc&quot;&gt;_v.info&lt;/span&gt;
					&lt;/div&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/for&gt;&gt;
			&lt;/div&gt;
		&lt;&lt;elseif _event == &quot;use&quot;&gt;&gt;
			&lt;&lt;set _id = &#39;hp&#39;+_i&gt;&gt;
			&lt;&lt;run _HPmeters.push(_id)&gt;&gt;
			&lt;&lt;newmeter _id 1&gt;&gt;
				&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
				&lt;&lt;animation false&gt;&gt;
				&lt;&lt;sizing 100% 0.5em&gt;&gt;
			&lt;&lt;/newmeter&gt;&gt;
			&lt;&lt;set _id = &#39;mp&#39;+_i&gt;&gt;
			&lt;&lt;run _MPmeters.push(_id)&gt;&gt;
			&lt;&lt;newmeter _id 1&gt;&gt;
				&lt;&lt;colors setup.MP_BAR_COLOR&gt;&gt;
				&lt;&lt;animation false&gt;&gt;
				&lt;&lt;sizing 100% 0.5em&gt;&gt;
			&lt;&lt;/newmeter&gt;&gt;
			&lt;div class=&quot;menuactor-hpmpblock&quot; style=&quot;top:0.75em; width:260px&quot;&gt;
				&lt;div class=&quot;hpmp&quot;&gt;HP: &lt;span style=&quot;float:right&quot;&gt;&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.hp&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxhp&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;
				&lt;&lt;showmeter _HPmeters[_i] `_puppet.hp / _puppet.maxhp`&gt;&gt;
				&lt;div class=&quot;hpmp&quot;&gt;MP: &lt;span style=&quot;float:right&quot;&gt;&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.en&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxen&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;
				&lt;&lt;showmeter _MPmeters[_i] `_puppet.en / _puppet.maxen`&gt;&gt;
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/for&gt;&gt;
}}}
We accomplish this by replacing the space occupied by the item list with &quot;inventory puppets&quot;. This code may look complicated, but most of it is actually copied from the status screen, with a few tweaks for formatting. What&#39;s important is this part:
{{{
&lt;&lt;capture _i, _puppet&gt;&gt;
&lt;&lt;if _event == &quot;equip&quot;&gt;&gt;
	&lt;&lt;link _puppet.name&gt;&gt;
		&lt;&lt;run _puppet.equip(_display)&gt;&gt;
		&lt;&lt;unset _display&gt;&gt;
		&lt;&lt;replace &quot;#itemdisplay&quot;&gt;&gt;&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;elseif _event == &quot;use&quot;&gt;&gt;
	&lt;&lt;link _puppet.name&gt;&gt;
		&lt;&lt;run _display.onUse(_puppet)&gt;&gt;
		&lt;&lt;unset _display&gt;&gt;
		&lt;&lt;replace &quot;#itemdisplay&quot;&gt;&gt;&lt;&lt;include &quot;inventory item display&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#itemlist&quot;&gt;&gt;&lt;&lt;include &quot;inventory item list&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/capture&gt;&gt;
}}}
Clicking on the character&#39;s name will use the item on them. However, we have to branch this functionality depending on if we&#39;re using or equipping the item, because those do different things. If we&#39;re equipping an item, we run {{{_puppet.equip}}}; if we&#39;re using an item, we run {{{_display.onUse}}}. In either case, we reset the {{{_display}}} variable and refresh the page so that the item list is displayed again.
{{{
&lt;&lt;if _event == &quot;equip&quot;&gt;&gt;
	&lt;div style=&quot;grid-row:1; grid-column:2; margin-left:1em; margin-top:0.5em; margin-bottom:0.5em; margin-right:1em&quot;&gt;
	&lt;&lt;for _k, _v range _puppet.equipment&gt;&gt;
		&lt;div class=&quot;menuactor-equipment-slot&quot;&gt;_k&lt;/div&gt;
		&lt;&lt;if _v === null&gt;&gt;&lt;span class=&quot;menuactor-equipment-name&quot;&gt;&amp;nbsp;&lt;/span&gt;
		&lt;&lt;else&gt;&gt;
			&lt;div class=&quot;menuactor-equipment-name&quot;&gt;_v.name&lt;br/&gt;
			&lt;span class=&quot;actdesc&quot;&gt;_v.info&lt;/span&gt;
			&lt;/div&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;elseif _event == &quot;use&quot;&gt;&gt;
	&lt;&lt;set _id = &#39;hp&#39;+_i&gt;&gt;
	&lt;&lt;run _HPmeters.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.PLAYER_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100% 0.5em&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
	&lt;&lt;set _id = &#39;mp&#39;+_i&gt;&gt;
	&lt;&lt;run _MPmeters.push(_id)&gt;&gt;
	&lt;&lt;newmeter _id 1&gt;&gt;
		&lt;&lt;colors setup.MP_BAR_COLOR&gt;&gt;
		&lt;&lt;animation false&gt;&gt;
		&lt;&lt;sizing 100% 0.5em&gt;&gt;
	&lt;&lt;/newmeter&gt;&gt;
	&lt;div class=&quot;menuactor-hpmpblock&quot; style=&quot;top:0.75em; width:260px&quot;&gt;
		&lt;div class=&quot;hpmp&quot;&gt;HP: &lt;span style=&quot;float:right&quot;&gt;&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.hp&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxhp&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;&lt;showmeter _HPmeters[_i] `_puppet.hp / _puppet.maxhp`&gt;&gt;
		&lt;div class=&quot;hpmp&quot;&gt;MP: &lt;span style=&quot;float:right&quot;&gt;&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.en&lt;/div&gt;/&lt;div class=&quot;hpmpvalue&quot;&gt;_puppet.maxen&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;&lt;showmeter _MPmeters[_i] `_puppet.en / _puppet.maxen`&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
I also chose to branch the display, because the player should see information relevant to their decision. If you&#39;re equipping people, it stands to reason that you&#39;ll want to see what they already have equipped; but if you&#39;re using a healing potion, you&#39;ll probably want to see how everyone&#39;s health is doing instead.

&lt;h3 id=&quot;partypicker&quot;&gt;Party Picker&lt;/h3&gt;
In some RPGs, you&#39;re only given a single party of characters to play with throughout the whole game. Some are a bit more ambitious, and give you additional reserve characters you can swap out with your active ones.
{{{
&lt;span id=&quot;content&quot;&gt;&lt;center style=&quot;font-weight:bold&quot;&gt;ACTIVE PUPPETS&lt;/center&gt;
&lt;&lt;nobr&gt;&gt;
&lt;div class=&quot;actors&quot; id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;party manager puppets&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;center style=&quot;font-weight:bold&quot;&gt;RESERVE PUPPETS&lt;/center&gt;
&lt;&lt;nobr&gt;&gt;
&lt;div class=&quot;actors&quot; id=&quot;reserve&quot;&gt;
&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;

&lt;&lt;unequipAll&gt;&gt;
&lt;/span&gt;
}}}
This functionality is provided through the &quot;Party Picker&quot; passage, which you can access from the landing. Like the &quot;Battle!&quot; passage, the actual passage the player visits is only a container for complex code outsourced to other passages.
{{{
&lt;&lt;for _i, _puppet range $puppets&gt;&gt;
	&lt;div class=&quot;actor&quot; @id=&quot;_i&quot; style=&quot;min-width:150px&quot;&gt;
	&lt;center&gt;
	&lt;&lt;capture _i&gt;&gt;
	&lt;&lt;link _puppet.name&gt;&gt;
		&lt;&lt;if def _s&gt;&gt;
			&lt;&lt;run $(&#39;#&#39; + _s).removeClass(&quot;selected&quot;)&gt;&gt;
			&lt;&lt;if _s != _i&gt;&gt;
				&lt;&lt;set _s = _i&gt;&gt;
				&lt;&lt;run $(&#39;#&#39; + _s).addClass(&quot;selected&quot;)&gt;&gt;
			&lt;&lt;else&gt;&gt;
				&lt;&lt;unset _s&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set _s = _i&gt;&gt;
			&lt;&lt;run $(&#39;#&#39; + _i).addClass(&quot;selected&quot;)&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;/center&gt;&lt;br/&gt;
	&lt;&lt;for _k, _v range _puppet.stats&gt;&gt;
		&lt;span class=&quot;statname&quot;&gt;&lt;&lt;print _k&gt;&gt;:&lt;/span&gt;
		&lt;&lt;statOOB _k _puppet&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/for&gt;&gt;
}}}
Active puppets are displayed through the &quot;party manager puppets&quot; passage. Here, similarly to the actorlist, we create stat blocks for every puppet with a for loop. The key here is that we&#39;re going to need a unique ID for every block. We can do this with the {{{@}}} operator and the {{{_i}}} index variable of the for loop: every &quot;actor&quot; block will be given the ID 0, 1, or 2 as the loop runs. (Thanks to Twinery user greyelf for helping me with this.)

Within each block, we&#39;re going to {{{&lt;&lt;capture&gt;&gt;}}} the index value {{{_i}}} and create a {{{&lt;&lt;link&gt;&gt;}}} out of each puppet&#39;s name. When clicked, we&#39;re going to assign a separate value, {{{_s}}}, the value of {{{_i}}}, and then use a jQuery function to add the &quot;selected&quot; class to the current block. (It&#39;s theoretically possible to use SugarCube&#39;s {{{&lt;&lt;addclass&gt;&gt;}}} macro instead, but passing variables as IDs is a bit more difficult there.) The &quot;selected&quot; class just turns the block a bright cyan color, thus making it clear to the player that the puppet is selected.
{{{
&lt;&lt;run $(&#39;#&#39; + _s).removeClass(&quot;selected&quot;)&gt;&gt;
}}}
We also need a quick line of code to remove the &quot;selected&quot; class from the &lt;i&gt;last&lt;/i&gt; selected puppet, in case the player has already selected one. Otherwise, the cyan coloring wouldn&#39;t disappear, and the player might be confused who they&#39;re selecting.

We also need to update the &quot;party manager reserve&quot;, for reasons that will be explained shortly.

The rest of the block can be anything; in the default engine, it&#39;s stats, since that&#39;s the major distinguishing feature of the default party members. You could include more info if you like; though you might need to change the size or display of the blocks to accommodate it.
{{{
&lt;center&gt;Reserve Puppets:&lt;/center&gt;&lt;br/&gt;
&lt;&lt;for _i, _puppet range $Reserve_Puppets&gt;&gt;
	&lt;span class=&quot;statname&quot;&gt;
	&lt;&lt;if def _s&gt;&gt;
		&lt;&lt;capture _puppet, _i&gt;&gt;
		&lt;&lt;link _puppet.name&gt;&gt;
			&lt;&lt;run $Reserve_Puppets[_i] = $puppets[_s]&gt;&gt;
			&lt;&lt;set $puppets[_s] = _puppet&gt;&gt;
			&lt;&lt;unset _s&gt;&gt;
			&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;party manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
			&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;party manager reserve&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		&lt;&lt;/capture&gt;&gt;
	&lt;&lt;else&gt;&gt;
		_puppet.name
	&lt;&lt;/if&gt;&gt;
	&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
&lt;&lt;/for&gt;&gt;
}}}
Finally, we need to let the player pick a party member from the reserve. As before, we iterate over a puppet array, but this time it&#39;s the {{{$Reserve_Puppets}}} array defined in {{{&lt;&lt;puppetsInit&gt;&gt;}}}. (To prevent the player from cloning people, {{{$Reserve_Puppets}}} shouldn&#39;t have any overlap with the active {{{$puppets}}} array.) If {{{_s}}} is defined (so, someone was selected), clicking their name will swap them with the selected character. Finally, we reset {{{_s}}} and refresh both character lists so the player can do it all again.

&lt;h3 id=&quot;equipmanager&quot;&gt;Equipment Manager&lt;/h3&gt;
Though the player can already manage equipment through the inventory screen, I created a dedicated equipment screen for additional convenience. The conceit here is that while the inventory method was item-centric, this screen is character-centric. You select a character and then the equipment you want to give them, rather than the other way around.
{{{
&lt;span id=&quot;content&quot;&gt;&lt;&lt;unequipAll&gt;&gt;

&lt;&lt;nobr&gt;&gt;
&lt;div id=&quot;puppets&quot;&gt;
&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;
&lt;/div&gt;
&lt;div id=&quot;equipment-list&quot;&gt;
&lt;&lt;equipmentlist&gt;&gt;
&lt;/div&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;/span&gt;
}}}
Similarly to our other menu passages, most of the functionality is offloaded to child passages. This passage is something of a hybrid of the status and inventory screens; we display the characters&#39; status boxes up top, and the equipment down below.

The &quot;equip manager puppets&quot; passage is nearly identical to the status screen, but with equipment and stats displayed in place of HP/MP. When a character&#39;s name is clicked, a selector variable is similarly stored, which influences {{{&lt;&lt;equipmentlist&gt;&gt;}}}. That&#39;s a widget, not a passage, and can be found in &quot;Widgets (Menu)&quot;.
{{{
&lt;&lt;if def _s&gt;&gt;
&lt;div style=&quot;line-height:1.4&quot;&gt;
&lt;&lt;set _count = 0&gt;&gt;
&lt;&lt;for _k, _v range $inventory&gt;&gt;
&lt;&lt;if _v.equippable &amp;&amp; _v.stock &gt; 0&gt;&gt;
&lt;br/&gt;
&lt;&lt;set _count++&gt;&gt;
&lt;&lt;if (def _s &amp;&amp; _v.checkRestriction($puppets[_s])) || ndef _s&gt;&gt;
&lt;div @id=&quot;_k&quot;&gt;
&lt;b&gt;
&lt;&lt;if def _s&gt;&gt;
	&lt;&lt;capture _v, _k&gt;&gt;
	&lt;&lt;link _k&gt;&gt;
		&lt;&lt;run $puppets[_s].equip(_v)&gt;&gt;
		&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#equipment&quot;&gt;&gt;&lt;&lt;equipmentlist&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
_k
&lt;&lt;/if&gt;&gt;
&lt;/b&gt;
&lt;span style=&quot;float:right&quot;&gt;(_v.stock)&lt;/span&gt;&lt;br/&gt;
&lt;i style=&quot;font-size:12px&quot;&gt;&lt;&lt;print _v.equippable.slot&gt;&gt;&lt;/i&gt;&lt;br/&gt;
&lt;&lt;if _v.equippable.restrictedTo.length &gt; 0&gt;&gt;
&lt;span style=&quot;font-size:12px; color:gray&quot;&gt;Restriction: &lt;&lt;for _char range _v.equippable.restrictedTo&gt;&gt;&lt;&lt;print _char&gt;&gt;&lt;&lt;/for&gt;&gt;&lt;/span&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;print _v.desc&gt;&gt;&lt;br/&gt;
&lt;span class=&quot;actdesc&quot;&gt;&lt;&lt;print _v.info&gt;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _count == 0&gt;&gt;
You don&#39;t have any equipment.
&lt;&lt;/if&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;
}}}
This widget runs through the entire inventory ({{{&lt;&lt;for _k, _v range $inventory&gt;&gt;}}}) but will &lt;b&gt;only&lt;/b&gt; display equippable items, thanks to the {{{&lt;&lt;if _v.equippable &amp;&amp; _v.stock &gt; 0&gt;&gt;}}} filter. Every time it finds an equippable item, it&#39;ll make a note of it through the {{{_count}}} variable; this is just so that we can confirm if the player has no equipment. (This is a courteous message to provide, as the player may just be confused if they try to pull up their equipment and see nothing at all.)

From there, it creates the link the player can use to equip the item.
{{{
&lt;&lt;if (def _s &amp;&amp; _v.checkRestriction($puppets[_s])) || ndef _s&gt;&gt;
}}}
In English, this says: &lt;b&gt;If a character has been selected and that character isn&#39;t restricted from using this item &lt;i&gt;OR&lt;/i&gt; no character is selected, execute the following code.&lt;/b&gt; This removes items the selected character can&#39;t wear from the listing entirely, reducing the amount of chaff a player has to scroll through.
{{{
&lt;&lt;if def _s&gt;&gt;
	&lt;&lt;capture _v, _k&gt;&gt;
	&lt;&lt;link _k&gt;&gt;
		&lt;&lt;run $puppets[_s].equip(_v)&gt;&gt;
		&lt;&lt;replace &quot;#puppets&quot;&gt;&gt;&lt;&lt;include &quot;equip manager puppets&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;equipmentlist&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
&lt;&lt;else&gt;&gt;
_k
&lt;&lt;/if&gt;&gt;
}}}
This says: &lt;b&gt;If a character has been selected, display the item&#39;s name as a link; otherwise, display the name as plain text.&lt;/b&gt; Clicking the link will equip the item to the character, reset the selection, and update the screen so the player can see the difference.

Notice that this widget displays the full information of all equippable items -- something that was too expansive for the inventory screen, but a useful feature here, as it allows you to directly compare multiple pieces of equipment at once. Notice also that unlike the inventory screen, it does &lt;b&gt;not&lt;/b&gt; reset the selector variable; this allows the player to equip multiple pieces of equipment all at once instead of having to go through the entire menu each time. So while this screen may not provide any truly unique functionality, it can still make the player&#39;s life easier.

&lt;h3 id=&quot;itemshop&quot;&gt;Item Shop&lt;/h3&gt;
The item shop allows the player to alter the composition of their inventory.
{{{
Points: $currency&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;for _k, _v range $inventory&gt;&gt;
&lt;&lt;if _v.usable == 0 || _v.usable == 1&gt;&gt;
&lt;div&gt;
&lt;b&gt;_k&lt;/b&gt; (Stock: _v.maxstock)
&lt;div style=&quot;display:inline-block; float:right&quot;&gt;
&lt;&lt;capture _v&gt;&gt;
	&lt;&lt;if $currency &gt;= _v.value &amp;&amp; _v.maxstock &lt; 9&gt;&gt;
	[&lt;&lt;link &quot;BUY&quot;&gt;&gt;
		&lt;&lt;replace &quot;#items&quot;&gt;&gt;
			&lt;&lt;run _v.maxstock++&gt;&gt;
			&lt;&lt;run $currency -= _v.value&gt;&gt;
			&lt;&lt;include &quot;item shop display&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if $currency &gt;= _v.value and _v.maxstock &gt; 0&gt;&gt; / &lt;&lt;/if&gt;&gt;
	&lt;&lt;if _v.maxstock &gt; 0&gt;&gt;
	[&lt;&lt;link &quot;SELL&quot;&gt;&gt;
		&lt;&lt;replace &quot;#items&quot;&gt;&gt;
			&lt;&lt;run _v.maxstock--&gt;&gt;
			&lt;&lt;run $currency += _v.value&gt;&gt;
			&lt;&lt;include &quot;item shop display&quot;&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;]
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/capture&gt;&gt;
 &lt;b&gt;Cost: _v.value&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;&lt;print _v.info&gt;&gt;&lt;br/&gt;
&lt;span class=&quot;actdesc&quot;&gt;&lt;&lt;print _v.desc&gt;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
}}}
This code is very similar to the point-buy interface, which is explained in [[Additional Features]]. We display every one of the player&#39;s items with a {{{for}}} loop, similar to the {{{&lt;&lt;itemlist&gt;&gt;}}} widget. However, we also include BUY and SELL buttons. These buttons add or subtract from the item&#39;s stock and adjust the player&#39;s money based on the cost of the item, then refresh the item display to display the new value.

This functionality is rudementary, and designed for &lt;i&gt;Cartoon Battle&lt;/i&gt;&#39;s limited inventory system. For more complicated shop mechanics, such as shops that contain different items than those in the player&#39;s inventory, you may require separate tabs for buying and selling. If you have a lot of items to display, you may also want to defer the info and description displays.

&lt;h2 id=&quot;hotkeys&quot;&gt;Hotkeys&lt;/h2&gt;
The engine&#39;s hotkeys are made through &lt;a href=&quot;https://twinelab.net/custom-macros-for-sugarcube-2/#/./event-macros&quot; target=&quot;_blank&quot;&gt;Chapel&#39;s event macro set.&lt;/a&gt; They are defined in StoryInit, but the code is compartmentalized into the &quot;hotkey definitions&quot; passage for modularity. After reading this section, you should have everything you need to edit the engine&#39;s hotkeys or add your own. The website &lt;a href=&quot;https://keycode.info/&quot; target=&quot;_blank&quot;&gt;keycode.info&lt;/a&gt; may be helpful for finding the keycode for your desired hotkeys.

There are way too many hotkeys to go over everything, and most of the code is very similar anyway. I&#39;ll use the Q key as our representative example.

I chose the Q key as the &quot;confirm&quot; key for the engine. This key does four things:
&lt;ol&gt;
&lt;li&gt;Select the &quot;Act&quot; link for the selected character in the command phase.&lt;/li&gt;
&lt;li&gt;Select the default action for the character in the action selection phase.&lt;/li&gt;
&lt;li&gt;Confirm the selection in the confirm phase.&lt;/li&gt;
&lt;li&gt;Trigger any &quot;Continue&quot; buttons that occur in other battle phases, such as the buttons to advance battle after the action and enemy phases.&lt;/li&gt;
&lt;/ol&gt;
Let&#39;s look at how each of these features are built.
{{{
&lt;&lt;which 81&gt;&gt; /* Q pressed */
	&lt;&lt;if $inbattle&gt;&gt;
		&lt;&lt;switch $B.phase&gt;&gt;
			&lt;&lt;case &quot;command&quot;&gt;&gt;
				&lt;&lt;if $subject !== null&gt;&gt;
					&lt;&lt;set _id = &quot;#actbtn a&quot;&gt;&gt;
					&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;case &quot;actions&quot;&gt;&gt;
				&lt;&lt;if def $subject.defaultAction &amp;&amp; $subject.defaultAction !== null&gt;&gt;
					&lt;&lt;set _action = $subject.defaultAction&gt;&gt;
					&lt;&lt;actionLink&gt;&gt;
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;case &quot;confirm&quot;&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; &quot;#confirmLink a&quot;&gt;&gt;
			&lt;&lt;default&gt;&gt;
				&lt;&lt;trigger &#39;click&#39; &quot;button.macro-button&quot;&gt;&gt;
		&lt;&lt;/switch&gt;&gt;
	&lt;&lt;elseif passage() == &quot;Menu: Inventory&quot; &amp;&amp; def _display &amp;&amp; _itemcancel !== true&gt;&gt;
		&lt;&lt;set _id = &#39;#button1 button&#39;&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
	&lt;&lt;/if&gt;&gt;
}}}
We start with {{{&lt;&lt;which 81&gt;&gt;}}}. The {{{&lt;&lt;which&gt;&gt;}}} macro tells the program to look for a key, and {{{81}}} is the code for the Q key. (It&#39;s handy to add comments for the corresponding key when you work with keycodes, to make things clearer for yourself or the end user.)

Because we want this key to have special functionality for battles, we check for the {{{$inbattle}}} flag before we tell it to execute any code. We also want the key to have different functionality depending on the phase of battle, so we create a {{{&lt;&lt;switch&gt;&gt;}}} for {{{$B.phase}}}.

Our first function is: &lt;i&gt;Select the &quot;Act&quot; link for the selected character in the command phase.&lt;/i&gt;
{{{
&lt;&lt;case &quot;command&quot;&gt;&gt;
	&lt;&lt;if $subject !== null&gt;&gt;
		&lt;&lt;set _id = &quot;#act&quot;+$puppets.indexOf($subject)+&quot; a&quot;&gt;&gt;
		&lt;&lt;trigger &#39;click&#39; _id&gt;&gt;
	&lt;&lt;/if&gt;&gt;
}}}
This one is pretty simple. &lt;a class=&quot;noExternal&quot; href=&quot;#commands&quot;&gt;We&#39;ve already designed all the code for the Act button in the Battle Phases passage&lt;/a&gt;; instead of copying all that over, we just need to make the link act as if it was clicked. We can do this through the {{{&lt;&lt;trigger&gt;&gt;}}} macro, but it needs to know what to target. Going back to {{{commands}}}, you can see we created IDs for each character&#39;s Act buttons for this exact purpose:
{{{
&lt;span @id=&quot;&#39;act&#39;+_i&quot;&gt;&lt;&lt;act $puppets[_i]&gt;&gt;&lt;/span&gt;
}}}
Each character&#39;s Act button has a unique ID that contains their index in the {{{$puppets}}} array. Because the {{{$subject}}} variable is an object from the {{{$puppets}}} array in the command phase, we can plug it into {{{indexOf}}} to find the selected character&#39;s index, and from there, pass the correct ID to the {{{&lt;&lt;trigger&gt;&gt;}}} macro.

There&#39;s just one wrinkle: We placed that ID on a {{{&lt;span&gt;}}} element surrounding the link, not on the link itself. If we were to just leave it at that, the {{{&lt;&lt;trigger&gt;&gt;}}} would only click that {{{&lt;span&gt;}}} element, which of course would do nothing. We need to provide {{{&lt;&lt;trigger&gt;&gt;}}} with one more bit of information: the specific element it needs to target. In this case, that&#39;s a link, which is an anchor {{{&lt;a&gt;}}} element. By appending that to the target argument (separated by a space), the {{{&lt;&lt;trigger&gt;&gt;}}} macro now knows to simulate a click on the anchor element &lt;i&gt;within&lt;/i&gt; the element tagged &quot;#act&quot;.

Lastly, things are going to get weird if {{{$subject}}} is {{{null}}}, so just to be safe, we also have to wrap this in an {{{&lt;&lt;if&gt;&gt;}}} that checks against that.

That&#39;s our first function done. Our next one is: &lt;i&gt;Select the default action for the character in the action selection phase.&lt;/i&gt;

The setup we have to do for this function is to &lt;i&gt;create&lt;/i&gt; a default action to reference in the first place. All of the default characters have one that&#39;s set in their constructors, but you can change this or even allow the player to select it themselves. (I caution against doing this with actions that can be changed or swapped out, such as Rogue&#39;s &quot;Crossbow&quot; and &quot;Reload&quot; actions, as the {{{defaultAction}}} property stores a separate copy that &lt;b&gt;will not be updated to reflect changes in the {{{actions}}} property&lt;/b&gt; unless you do so manually.)
{{{
&lt;&lt;case &quot;actions&quot;&gt;&gt;
	&lt;&lt;if def $subject.defaultAction &amp;&amp; $subject.defaultAction !== null&gt;&gt;
		&lt;&lt;set _action = $subject.defaultAction&gt;&gt;
		&lt;&lt;actionLink&gt;&gt;
	&lt;&lt;/if&gt;&gt;
}}}
For this one, I did choose to copy the action button code rather than use a {{{&lt;&lt;trigger&gt;&gt;}}}. You could make unique IDs for every single action link and do a search to find the one that matches the default action, but that was too much work for me. (This is why action button code is condensed into a widget: It allows for easy consistency between the two places it can be called.)

The player will get no notification if the action can&#39;t be used for whatever reason; the code simply won&#39;t execute. I doubt players will be too confused by this, as they can look at the action button itself to see why they can&#39;t use it, but you could also set an audio or visual indicator to play when this happens, as most video games do.

As before, we wrap the whole thing in an {{{&lt;&lt;if&gt;&gt;}}} to make sure our crucial variable exists before we start executing code on it.

Our next function is: &lt;i&gt;Confirm the selection in the confirm phase.&lt;/i&gt;
{{{
&lt;&lt;case &quot;confirm&quot;&gt;&gt;
	&lt;&lt;trigger &#39;click&#39; &quot;#confirmLink a&quot;&gt;&gt;
}}}
This one is trivial compared to the others. You may be tempted to forego the {{{&lt;&lt;trigger&gt;&gt;}}} entirely and just use {{{&lt;&lt;goto &quot;action phase&quot;&gt;&gt;}}}, and that will work in the default engine, but there may be cases where you want the confirm link to perform additional code or processing, so we make sure to trigger it just to be safe.

Out last function is: &lt;i&gt;Trigger any &quot;Continue&quot; buttons that occur in other battle phases, such as the buttons to advance battle after the action and enemy phases.&lt;/i&gt;
{{{
&lt;&lt;default&gt;&gt;
	&lt;&lt;trigger click &quot;button.macro-button&quot;&gt;&gt;
}}}
For this one we do want to use {{{&lt;&lt;trigger&gt;&gt;}}} -- it&#39;s easier to use than before, as we&#39;re targeting general elements instead of an ID we have to make ourselves. In Twine, there is one additional wrinkle here: We want to make sure we&#39;re only activating the buttons inside the Twine game, and not anything outside of it. This is an important distinction, because the UI sidebar also contains {{{&lt;button&gt;}}} elements that will be activated by something that targets all buttons. Fortunately, SugarCube automatically labels all macros and elements within the game area with classes labeling them as such, so we only need to add a {{{.macro-button}}} extension to limit our trigger to buttons within the game area.

&lt;h3 id=&quot;hotkeys.summary&quot;&gt;Summary&lt;/h3&gt;
To do anything with key presses, create an {{{&lt;&lt;event keydown&gt;&gt;}}}.

Create functions for each key under {{{&lt;&lt;which [keycode]&gt;&gt;}}}. Any code within will be executed on the key press, the same as if the user had clicked a {{{&lt;&lt;link&gt;&gt;}}}.

Use {{{&lt;&lt;trigger&gt;&gt;}}} to trigger existing events on the page, but remember that the code is effectively &quot;blind&quot; and can only see specific elements if you give them an ID. Remember also that SugarCube&#39;s macros generate their own elements that you can&#39;t directly modify, so append an element target to your ID if you want to trigger one.

The UI bar contains HTML elements that can be affected by hotkeys. If you want to restrict hotkeys to elements within the game area, inspect them with the Inspect functionality (right-click or Ctrl+Shift+I) to see their unique classes and append them to your target. (Typically, these classes are some variation of &quot;macro&quot; or &quot;internal&quot;.)

&lt;h2 id=&quot;widgets&quot;&gt;Other Widgets&lt;/h2&gt;
This section will cover miscellaneous widgets and their purpose.

&lt;h3 id=&quot;chain&quot;&gt;The {{{&lt;&lt;chain&gt;&gt;}}} widget&lt;/h3&gt;
Twine has a difficult quirk: object addresses are not preserved through passages.

[img[setup.ImagePath + &quot;documentation/variable_types.PNG&quot;]]

Normally, when you define a variable, the value of the variable is stored in the computer&#39;s memory at the variable&#39;s address. When you define an object, the variable you set as its name does not store the object itself, only the memory address. The object variable therefore serves as a pointer to the actual object. This means that you can pass the object&#39;s name to other variables and still have those new variables point to the same object.

For instance, if we wanted to store the currently acting character in a &quot;subject&quot; variable, we might do this:
{{{
&lt;&lt;set $subject = $puppets[1]&gt;&gt;
}}}
If we did this in a standard coding engine, {{{$subject}}} would refer to the same object as {{{$puppets[1]}}}, and everything we did to {{{$subject}}} would also affect {{{$puppets[1]}}}.

Twine, for various reasons, does not work this way. Every time the user travels to a new passage, a new copy of every object is generated, and this breaks shared object references. In our example, {{{$subject}}} would now point to a completely new object, and acting on it would not affect our {{{$puppets[1]}}} object.
{{{
&lt;&lt;widget &quot;chain&quot;&gt;&gt;
&lt;&lt;if $target !== null&gt;&gt;
&lt;&lt;run getActor(&quot;target&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $subject !== null&gt;&gt;
&lt;&lt;run getActor(&quot;subject&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $B.actor !== null&gt;&gt;
&lt;&lt;run getActor(&quot;actor&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

window.getActor = function getActor(x) {
	var targets = [];
	var id;
	var actor;
	switch(x) {
		case &quot;target&quot;: id = V().target.id; break;
		case &quot;subject&quot;: id = V().subject.id; break;
		case &quot;actor&quot;: id = V().B.actor.id; break;
		default: console.log(&quot;ERROR in getActor: invalid argument&quot;);
	}
    switch(id.charAt(0)) {
        case &quot;p&quot;: targets = State.variables.puppets; break;
        case &quot;e&quot;: targets = State.variables.enemies; break;
		default: console.log(&quot;ERROR: Target ID does not match any known party.&quot;);
    }
    actor = targets.find(function(t) { return t &amp;&amp; t.id === id; });
	switch(x) {
		case &quot;target&quot;: V().target = actor; break;
		case &quot;subject&quot;: V().subject = actor; break;
		case &quot;actor&quot;: V().B.actor = actor; break;
		default: console.log(&quot;ERROR in getActor: invalid argument&quot;);
	}
	return;
}
}}}
The {{{&lt;&lt;chain&gt;&gt;}}} widget (found in the &quot;General Widgets&quot; passage) and the {{{getActor()}}} function (found in 0config.js) are a workaround for this issue. It is based on the fact that shared object references still work &lt;i&gt;within the same passage&lt;/i&gt;. If we were to run {{{&lt;&lt;set $subject = $puppets[1]&gt;&gt;}}} at the start of every passage, {{{$subject}}} would behave the way we want.

This is essentially what {{{getActor()}}} does. Every character is assigned an ID based on a randomly generated value when their instance is created; by reading this attribute in the stored object, we can find the matching character at any time using the {{{find}}} function, which returns the entry in an array matching a key value (in this case, {{{id}}}).

One additional wrinkle is that we need to know the correct array to search -- {{{$puppets}}} or {{{$enemies}}}. To facilitate this, there&#39;s a special feature in the ID generation code that adds a fixed symbol at the start of the ID depending on whether the character is a puppet or enemy; all we need to do is check that marker and we know which array to search.
{{{
&lt;&lt;if $inbattle&gt;&gt;
	&lt;&lt;chain&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
{{{&lt;&lt;chain&gt;&gt;}}} is then added to PassageReady, a special passage that runs at the beginning of every passage. This lets {{{$subject}}}, {{{$target}}}, and {{{$B.actor}}} retain their object links through passages, which greatly simplifies many widgets.

&lt;h3 id=&quot;refreshPuppets&quot;&gt;{{{&lt;&lt;refreshPuppets&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;refreshPuppets&quot;&gt;&gt;
&lt;&lt;for _puppet range $puppets&gt;&gt;
	&lt;&lt;set _puppet.isDone = false&gt;&gt;
	&lt;&lt;set _puppet.inspired = false&gt;&gt;
	&lt;&lt;set _puppet.lastUsed = null&gt;&gt;
	&lt;&lt;if !$lastingDamage || $reviveAfterBattle&gt;&gt;
		&lt;&lt;set _puppet.dead = false&gt;&gt;
		&lt;&lt;set _puppet.hp = Math.round(_puppet.maxhp * setup.RESPAWN_HP)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if !$lastingDamage&gt;&gt;
		&lt;&lt;set _puppet.hp = _puppet.maxhp&gt;&gt;
		&lt;&lt;set _puppet.en = 5&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if !$actionRefillAfterBattle&gt;&gt;
		&lt;&lt;for _action range _puppet.actions.filter(function (a) { return a.uses !== undefined })&gt;&gt;
			&lt;&lt;run _action.refill()&gt;&gt;
		&lt;&lt;/for&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;for _effect range _puppet.effects.filter(function (eff) { return !eff.persistAfterBattle })&gt;&gt;
		&lt;&lt;run _puppet.removeEffect(_effect,{pierce: true, unsticky: true})&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;for _k, _v range _puppet.tolerances&gt;&gt;
		&lt;&lt;run _puppet.resetTol(_k)&gt;&gt;
	&lt;&lt;/for&gt;&gt;
	&lt;&lt;if def _puppet._respawn&gt;&gt;
		&lt;&lt;run _puppet._respawn.refill()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if def _puppet._retaliations&gt;&gt;
		&lt;&lt;run _puppet._retaliations.refill()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _x = _puppet.actions.find(function (a) { return a &amp;&amp; a.name == &quot;Reload&quot; })&gt;&gt;
	&lt;&lt;if def _x&gt;&gt;
		&lt;&lt;set $subject = _puppet; _x.act()&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
{{{&lt;&lt;refreshPuppets&gt;&gt;}}} is defined in &quot;Widgets (General)&quot;. This widget is used to standardize the states of player characters before and after battles. Flags such as {{{isDone}}} are reset, non-persistent status effects are cleared, {{{FillStat}}}s are refilled, and Rogue&#39;s crossbow is reloaded if it&#39;s empty.

There is modifiable behavior depending on if you want puppets to restore HP after battle and to what extent. By default, puppets will be restored to full HP and have their EN reset to baseline. If you don&#39;t want this to happen, you can use the {{{lastingDamage}}} variable to bypass it.

For additional nuance, you can also decide whether you want puppets to be revived after battle, regardless of if they&#39;re normally healed. You can enable this even with {{{lastingDamage}}} active through the {{{reviveAfterBattle}}} variable. By default, puppets will be revived to a proportion of the max HP determined by {{{RESPAWN_HP}}}. Note that this comes before the standard HP reset, meaning that they will be restored to full HP anyway if lasting damage is not enabled. There is also a separate variable that determines if you want limited-use actions to be refilled after battle.

&lt;h3 id=&quot;deathcheck&quot;&gt;{{{&lt;&lt;deathcheck&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;if $args.length &gt; 0&gt;&gt;
	&lt;&lt;set _targ = $args[0]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _targ = target()&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _targ.hp &lt;= 0 &amp;&amp; !_targ.dead&gt;&gt;
	&lt;&lt;if _targ.specialdeath &amp;&amp; !$B.specialdeath.includes(_targ._deathMessage)&gt;&gt;
		&lt;&lt;run $B.specialdeath.push(_targ._deathMessage)&gt;&gt;
	&lt;&lt;elseif !_targ.immortal&gt;&gt;
		&lt;&lt;set _targ.dead to true&gt;&gt;
		&lt;&lt;if _targ._deathMessage !== null&gt;&gt;
			&lt;&lt;print _targ.deathMessage&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;if _targ instanceof Enemy&gt;&gt;
			&lt;&lt;run $B.kills.push(_targ)&gt;&gt;
			&lt;&lt;if typeof(subject().kills) == &#39;number&#39;&gt;&gt;
				&lt;&lt;set subject().kills++&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;&lt;set $B.XPreward += _targ.xp; $B.moneyReward += _targ.gp&gt;&gt;
		&lt;&lt;elseif _targ instanceof Puppet&gt;&gt;
			&lt;&lt;run _targ.defeats++&gt;&gt;
		&lt;&lt;/if&gt;&gt;

		/* Remove all effects unless they are meant to persist past unconsciousness */
		&lt;&lt;for _k, _effect range _targ.effects.filter(function (eff) { return !eff.persistAfterDeath; })&gt;&gt;
			&lt;&lt;run _targ.removeEffect(_effect,{pierce: true, unsticky: true})&gt;&gt;
		&lt;&lt;/for&gt;&gt;

		/* If defeated character was protected, their protector&#39;s protection effect must be removed */
		&lt;&lt;if _targ.protectedBy !== null&gt;&gt;
			&lt;&lt;switch _targ.protectedBy.charAt(0)&gt;&gt;
				&lt;&lt;case &quot;p&quot;&gt;&gt;
					&lt;&lt;set _targets = $puppets&gt;&gt;
				&lt;&lt;case &quot;e&quot;&gt;&gt;
					&lt;&lt;set _targets = $enemies&gt;&gt;
				&lt;&lt;default&gt;&gt;
					&lt;&lt;run console.log(&quot;ERROR in deathcheck: protected character&#39;s protector has invalid ID&quot;)&gt;&gt;
			&lt;&lt;/switch&gt;&gt;
			&lt;&lt;set _temp = _targets.find(function(t) { return t &amp;&amp; t.id === _targ.protectedBy; })&gt;&gt;
			&lt;&lt;find &quot;_temp.effects&quot; &quot;name&quot; &quot;\&#39;Protector\&#39;&quot;&gt;&gt;
			&lt;&lt;print _temp.removeEffect(_temp.effects[_pos],{pierce: true})&gt;&gt;
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;elseif _targ.immortal&gt;&gt;
		&lt;&lt;if _targ._deathMessage !== null&gt;&gt;
			&lt;&lt;print _targ.deathMessage&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget applies the &quot;dead&quot; tag to defeated characters, and adds their names to the &quot;kills&quot; array in case that&#39;s something you want to keep track of.
{{{
&lt;&lt;if _targ.specialdeath &amp;&amp; !$B.specialdeath.includes(_targ._deathMessage)&gt;&gt;
	&lt;&lt;run $B.specialdeath.push(_targ._deathMessage)&gt;&gt;
}}}
The first thing is a check for characters with special death messages. You might want certain enemies to have a full passage&#39;s worth of description when they&#39;re defeated, such as if they&#39;re a climactic villain. If you set their {{{specialdeath}}} attribute to {{{true}}}, the player will be directed to the passage with a name matching their {{{deathMessage}}}. (To prevent possible stacking of these passages, which can occur if this code is triggered multiple times at once, such as from multi-hit attacks, there is also a check that their special death isn&#39;t in the queue already.)

Otherwise, as long as the target isn&#39;t flagged as immortal, the normal death message will be displayed and the target will be flagged as dead. (Note that this requires the target be set correctly! Usually this won&#39;t be a problem, as the damage widgets require a target as well. However, you&#39;ll need to update the {{{$target}}} value or pass an argument any time a character could be damaged, such as from damage-over-time effects.) If the target &lt;i&gt;is&lt;/i&gt; immortal, only their death message is displayed.
{{{
&lt;&lt;if _targ instanceof Enemy&gt;&gt;
	&lt;&lt;run $B.kills.push(_targ)&gt;&gt;
	&lt;&lt;if typeof(subject().kills) == &#39;number&#39;&gt;&gt;
		&lt;&lt;set subject().kills++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set $B.XPreward += _targ.xp; $B.moneyReward += _targ.gp&gt;&gt;
&lt;&lt;elseif _targ instanceof Puppet&gt;&gt;
	&lt;&lt;run _targ.defeats++&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
If the target was an Enemy, we add them to the &quot;kills&quot; array held by the battle controller, if that&#39;s something you want to keep track of. (For example, in &lt;i&gt;Cartoon Battle&lt;/i&gt;, there were achievements based on which enemy you defeated last.) We also increment the subject&#39;s &quot;kills&quot; attribute, though we have to check to make sure it&#39;s the correct data type just in case something weird has happened and we&#39;ll produce an error by trying to increment it. (One possible example might be an enemy killing another enemy; enemies do not have a defined &lt;code&gt;kills&lt;/code&gt; attribute by default, so this will generate an error.) Finally, we add the enemy&#39;s XP and GP rewards to the total that will be read at the end of battle.

If the target was a Puppet, we increment their &quot;defeats&quot; counter.
{{{
&lt;&lt;if _targ.protectedBy !== null&gt;&gt;
	&lt;&lt;switch _targ.protectedBy.charAt(0)&gt;&gt;
		&lt;&lt;case &quot;p&quot;&gt;&gt;
			&lt;&lt;set _targets = $puppets&gt;&gt;
		&lt;&lt;case &quot;e&quot;&gt;&gt;
			&lt;&lt;set _targets = $enemies&gt;&gt;
		&lt;&lt;default&gt;&gt;
			&lt;&lt;run console.log(&quot;ERROR in deathcheck: protected character&#39;s protector has invalid ID&quot;)&gt;&gt;
	&lt;&lt;/switch&gt;&gt;
	&lt;&lt;set _temp = _targets.find(function(t) { return t &amp;&amp; t.id === _targ.protectedBy; })&gt;&gt;
	&lt;&lt;find &quot;_temp.effects&quot; &quot;name&quot; &quot;\&#39;Protector\&#39;&quot;&gt;&gt;
	&lt;&lt;print _temp.removeEffect(_temp.effects[_pos],{pierce: true})&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
There is also a special handler here for the &quot;Protector&quot; status effect. If the person the protector is protecting dies, it no longer makes sense to keep the effect. We use the target&#39;s {{{protectedBy}}} attribute to see if they were being protected by anyone and find their protector if so, then we find the Protector effect in their {{{effects}}} array and remove it.

&lt;h3 id=&quot;statusDoc&quot;&gt;{{{&lt;&lt;status&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;status&quot;&gt;&gt;
&lt;&lt;link &quot;[*]&quot;&gt;&gt;
	&lt;&lt;if $args[0] eq $B.actor&gt;&gt;
		&lt;&lt;set $B.actor = null&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $B.actor to $args[0]&gt;&gt;
		&lt;&lt;if ndef $stScreen&gt;&gt;
			&lt;&lt;set $stScreen = 1&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;replace &quot;#status&quot;&gt;&gt;&lt;&lt;include &quot;status&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget creates that little [*] button you use to get information on characters.

You may recall from the &quot;actorlist&quot; passage that the widget is called like this:
{{{
&lt;&lt;status _enemy&gt;&gt;
}}}
That passes the character&#39;s data to the widget as {{{$args[0]}}}. So, when the {{{&lt;&lt;link&gt;&gt;}}} macro is activated (i.e., when the [*] is clicked), the widget first checks if the passed information matches what&#39;s already stored in {{{$B.actor}}}. If it does, {{{$B.actor}}} is set to null, which clears the information in the status pane. This is how the status button is &quot;toggleable&quot;: if you click it once, you get that character&#39;s information; if you click it again for the same character, the pane clears.

By default, {{{$actor}}} is set to the information for the new character, and the {{{$stScreen}}} value is set to 1 (defaulting to the pane displaying stats). A {{{&lt;&lt;replace&gt;&gt;}}} macro is then used to refresh the status pane to display the new character.

Recall that {{{$B.actor}}} is one of the variables run by {{{&lt;&lt;chain&gt;&gt;}}}, so the status pane will update to reflect changes to the character.

&lt;h3 id=&quot;endofbattle&quot;&gt;{{{&lt;&lt;endofbattle&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;endofbattle&quot;&gt;&gt;
&lt;&lt;set $inbattle = false&gt;&gt;

&lt;&lt;for _id range $B.playerBars&gt;&gt;
	&lt;&lt;run Meter.del(_id)&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;for _id range $B.enemyBars&gt;&gt;
	&lt;&lt;run Meter.del(_id)&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;if deadCount() == $puppets.length&gt;&gt;
	&lt;&lt;set $B.defeated = true&gt;&gt;
&lt;&lt;elseif deadCount() == $puppets.length-1&gt;&gt;
	&lt;&lt;set $B.SoleSurvivor = true&gt;&gt;
&lt;&lt;elseif deadCount() == 0&gt;&gt;
	&lt;&lt;set $B.Perfect = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !$B.defeated&gt;&gt;
	&lt;&lt;set $encounters[$scenario] = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $B.style&gt;&gt;
	&lt;&lt;addclass &quot;body&quot; $B.style&gt;&gt;
	&lt;&lt;removeclass &quot;html&quot; $B.style&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;refreshPuppets&gt;&gt;

&lt;&lt;include &quot;custom end of battle&quot;&gt;&gt;

&lt;&lt;unset $B; $enemies&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget is called to clean up variables after battle. It resets {{{$inbattle}}} to {{{false}}}, clears the health meters, battle controller, and {{{$enemies}}} variable since we no longer need them, flags the encounter as done in the {{{$encounters}}} object, resets the style if there was one, and restores puppets to their resting states (see {{{&lt;&lt;refreshPuppets&gt;&gt;}}}).

There is also a block that records how many puppets were defeated in the battle. This was used for calculating some achievements in &lt;i&gt;Cartoon Battle&lt;/i&gt;; you may use it for whatever purposes you wish. Note, however, that since {{{$B}}} is cleared at the end of this widget, you will have to record these flags to another variable in &quot;custom end of battle&quot; if you wish to use them past this point.

By default, the only thing in &quot;custom end of battle&quot; is a call to the {{{&lt;&lt;restock&gt;&gt;}}} widget, which replenishes all items.

&lt;h3 id=&quot;backbtn&quot;&gt;{{{&lt;&lt;backbtn&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;backbtn&quot;&gt;&gt;
&lt;span class=&quot;btn back right&quot; id=&quot;battlebackbtn&quot;&gt;[[Back [R]|Battle!][$B.phase = &quot;command&quot;; $B.targeting = null; $action = null; $target = null; $subject = null; $removed_effects = [];]]&lt;/span&gt;
&lt;&lt;/widget&gt;&gt;
}}}
The {{{&lt;&lt;backbtn&gt;&gt;}}} widget (an abbreviation for &quot;back button&quot;) is the gray &quot;BACK&quot; button you see in battle. It&#39;s just a link back to the battle hub, plus a whole host of variable assignments to reset any flags triggered while selecting actions, such as {{{$target}}}. If this wasn&#39;t done, flags might be able to &quot;bleed over&quot; into other actions when they weren&#39;t supposed to -- enabling you to select characters to attack outside of the targeting phase, for instance.

&lt;h3 id=&quot;victorycheck&quot;&gt;{{{&lt;&lt;victorycheck&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;victorycheck&quot;&gt;&gt;
&lt;&lt;set _victory to 0&gt;&gt;
&lt;&lt;set _defeat to 0&gt;&gt;
&lt;&lt;for _enemy range $enemies&gt;&gt;
	&lt;&lt;if _enemy.dead&gt;&gt;
		&lt;&lt;set _victory++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _victory eq $enemies.length&gt;&gt;
	&lt;&lt;set $B.victory = true&gt;&gt;
	&lt;&lt;goto &quot;Victory&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;for _puppet range $puppets&gt;&gt;
	&lt;&lt;if _puppet.dead&gt;&gt;
		&lt;&lt;set _defeat++&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;if _defeat eq $puppets.length&gt;&gt;
	&lt;&lt;set $B.defeat = true&gt;&gt;
	&lt;&lt;goto &quot;Defeat&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
You need to have some handler to determine when your player wins or loses the game. This widget, called at the start of the &quot;Battle!&quot; passage (so, constantly throughout the battle) runs over the enemy and ally parties and uses a temporary variable to track how many have been defeated. If the dead characters equal the length of the array (that is to say, all the characters have been defeated), the player is immediately moved to a new passage: &quot;Victory&quot; for the enemies&#39; defeat, and &quot;Defeat&quot; for the player&#39;s defeat.

Note that the check and move for the &quot;victory&quot; handler is performed before the &quot;defeat&quot; check. This means that if the player and enemy are defeated simultaneously, the win will default to the player. This situation is very rare, as it requires an action that hurts both sides, but if you plan to implement actions like that, it is a good idea to think about how you want that situation to be handled.
{{{
&lt;&lt;set $B.victory = true&gt;&gt;
(...)
&lt;&lt;set $B.defeat = true&gt;&gt;
}}}
Additionally, we need to explicitly set a flag when victory or defeat has happened. This is because of &lt;a class=&quot;noExternal&quot; href=&quot;#auto-end&quot;&gt;the auto-endturn feature&lt;/a&gt;; because it also uses a forced passage change, it is possible for the {{{&lt;&lt;goto &quot;Victory&quot;&gt;&gt;}}} and {{{&lt;&lt;goto &quot;end of round&quot;&gt;&gt;}}} commands to stack, sending the player in a loop that causes strange effects.

&lt;h3 id=&quot;stat&quot;&gt;{{{&lt;&lt;stat&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;stat&quot;&gt;&gt;
/* Designed by greyelf */
	/* Check that a Stat Name was passed to the widget. */
	&lt;&lt;if $args.length is 0&gt;&gt;
		ERROR
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _current to $B.actor.get($args[0]) &gt;&gt;
		&lt;&lt;set _base to $B.actor.getBase($args[0]) + $B.actor.getBonus($args[0]) &gt;&gt;

		/* Check if the Stat has been raised. */
		&lt;&lt;if _current &gt; _base &gt;&gt;
			@@.stat-raised;_current@@

		/* Check if the Stat has been lowered. */
		&lt;&lt;elseif _current &lt; _base &gt;&gt;
			@@.stat-lowered;_current@@

		/* The Stat has not changed. */
		&lt;&lt;else&gt;&gt;
			_current
		&lt;&lt;/if&gt;&gt;

	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget was provided by Twinery user greyelf in response to one of my questions. It enables the conditional coloring of the stats that display in the status pane depending on if they&#39;ve been raised or lowered by stat mod effects.

The {{{@@}}} symbols here modify webpage elements. The first line adds the given class to the current element, and the second line (after the semicolon) populates the current element with text. In this case, it always populates the element with {{{_current}}}, but adds the {{{.stat-raised}}} class if the stat has been raised, and adds the {{{.stat-lowered}}} class if the stat has been lowered. The rules for these classes are defined in the story stylesheet; they color the text blue and red, respectively.

&lt;h3 id=&quot;itemdrop&quot;&gt;{{{&lt;&lt;itemDrop&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;itemDrop&quot;&gt;&gt;
&lt;&lt;set _item = new Item($args[0])&gt;&gt;
&lt;&lt;if def $args[1] &amp;&amp; typeof($args[1]) == &#39;number&#39;&gt;&gt;
	&lt;&lt;set _amt = $args[1]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _amt = 1&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set _added = $inventory.addItem($args[0],_amt)&gt;&gt;
&lt;center&gt;
&lt;div class=&quot;itembox&quot;&gt;
&lt;b&gt;_item.name&lt;span style=&quot;float:right&quot;&gt;x&lt;&lt;print _amt&gt;&gt;&lt;/span&gt;&lt;/b&gt;&lt;br/&gt;
&lt;&lt;print _item.info&gt;&gt;&lt;br/&gt;
&lt;span class=&quot;actdesc&quot;&gt;&lt;&lt;print _item.desc&gt;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;&lt;if _added === false&gt;&gt;
	&lt;i&gt;You can&#39;t hold any more of these! Use or sell some and then come back.&lt;/i&gt;
&lt;&lt;/if&gt;&gt;
&lt;/center&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget provides a standardized method for informing the player they&#39;ve received an item. Pass the name of the item as the first argument and the amount as the second. If no amount is set, it will default to 1. The widget then displays the item&#39;s information in a fancy box, and notifies the player if they&#39;ve run out of inventory space.

&lt;h3 id=&quot;musicwidgets&quot;&gt;Music widgets&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;playMusic&quot;&gt;&gt;
&lt;&lt;if $args.length &gt; 0 &amp;&amp; typeof($args[0]) == &#39;string&#39;&gt;&gt;
    &lt;&lt;if !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
		&lt;&lt;audio &quot;:playing&quot; stop&gt;&gt;
	&lt;&lt;/if&gt;&gt;
    &lt;&lt;set $music = new Music($args[0])&gt;&gt;
    &lt;&lt;set _trackId = $args[0].split(&#39; &#39;).join(&#39;_&#39;)&gt;&gt;
    &lt;&lt;if !$args.includes(&quot;instant&quot;) &amp;&amp; !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
        &lt;&lt;script&gt;&gt;
		/* code provided by The Mad Exile */
        var selector = State.temporary.trackId;
        setTimeout(function () {
            SimpleAudio.select(selector)
                .loop(true)
                .volume(1)
                .play();
        }, 500); /* in milliseconds */
        &lt;&lt;/script&gt;&gt;
    &lt;&lt;else&gt;&gt;
        &lt;&lt;audio _trackId volume 1 play loop&gt;&gt;
    &lt;&lt;/if&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;musicInfo&quot;)&gt;&gt;
		&lt;&lt;replace &quot;#musicInfo&quot;&gt;&gt;&lt;&lt;include &quot;music info&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;else&gt;&gt;
    &lt;&lt;run console.log(&quot;ERROR in playMusic: non-string argument passed&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;clearMusic&quot;&gt;&gt;
	&lt;&lt;audio &quot;:playing&quot; volume 1 stop&gt;&gt;
	&lt;&lt;unset $music&gt;&gt;
	&lt;&lt;if document.getElementById(&quot;musicInfo&quot;)&gt;&gt;
		&lt;&lt;replace &quot;#musicInfo&quot;&gt;&gt;&lt;&lt;include &quot;music info&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
These widgets handle the playing and stopping of background music. Their main purpose is to sync the current track with the {{{music}}} variable, which is used to display information for the currently playing track in the sidebar, but there are some other functions as well.
{{{
&lt;&lt;if !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
	&lt;&lt;audio &quot;:playing&quot; stop&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
The start of the widget stops all currently playing audio aside from the called track, because generally, you only want one background music track playing at a time. (If you plan to use other audio, such as sound effects, you may want to create a &quot;BGM&quot; audio group and limit your {{{stop}}} command to that group.)
{{{
&lt;&lt;set $music = new Music($args[0])&gt;&gt;
}}}
The {{{Music}}} class is defined in the {{{database-music.js}}} file. There, you can create a database mapping composer, license, album, and etc. to the track name, instead of needing to set all of that information manually every time you change a track.
{{{
&lt;&lt;set _trackId = $args[0].split(&#39; &#39;).join(&#39;_&#39;)&gt;&gt;
}}}
Track names in SugarCube cannot contain spaces. Standard practice is to substitute underscores instead. This code allows the program to correctly call the track ID while allowing you to input the name with spaces, for convenience.
{{{
&lt;&lt;script&gt;&gt;
/* code provided by The Mad Exile */
var selector = State.temporary.trackId;
setTimeout(function () {
	SimpleAudio.select(selector)
		.loop(true)
		.volume(1)
		.play();
}, 500); /* in milliseconds */
&lt;&lt;/script&gt;&gt;
}}}
This is raw JavaScript code that makes a call to the {{{SimpleAudio}}} feature, which controls audio in SugarCube. The important feature here is that it adds a half-second delay. Audio processing can sometimes happen too fast in Twine, starting the track before the passage has finished rendering. This short delay typically allows the audio to sync up more nicely with the passage loading times, especially when calling battle music.
{{{
&lt;&lt;if !$args.includes(&quot;instant&quot;) &amp;&amp; !SimpleAudio.tracks.get(_trackId).isPlaying()&gt;&gt;
(...)
&lt;&lt;else&gt;&gt;
	&lt;&lt;audio _trackId volume 1 play loop&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
If you don&#39;t want it, though, you can pass the &quot;instant&quot; argument to the widget, which will call the normal {{{&lt;&lt;audio&gt;&gt;}}} macro.
{{{
&lt;&lt;if document.getElementById(&quot;musicInfo&quot;)&gt;&gt;
	&lt;&lt;replace &quot;#musicInfo&quot;&gt;&gt;&lt;&lt;include &quot;music info&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
&lt;&lt;/if&gt;&gt;
}}}
Finally, we refresh the music info in the sidebar to update it to display our new track.

{{{&lt;&lt;clearMuisc&gt;&gt;}}} is much simpler, and just stops the current audio while erasing the {{{music}}} variable.

&lt;h3 id=&quot;find&quot;&gt;{{{&lt;&lt;find&gt;&gt;}}}&lt;/h3&gt;
{{{
&lt;&lt;widget &quot;find&quot;&gt;&gt;
/* args0 is target array, args1 is attribute, args2 is key value */
/* Note that if your key is a string, it must be in quotes in the final code, which means you must send it to the widget with an extra pair of literal quotes (preceeded by the escape slash) */
&lt;&lt;print &#39;&lt;&lt;set _pos = &#39;+$args[0]+&#39;.map(function(x) { return(x.&#39;+$args[1]+&#39;) }).indexOf(&#39;+$args[2]+&#39;)&gt;&gt;&#39;&gt;&gt;
&lt;&lt;/widget&gt;&gt;
}}}
This widget was made early in the engine&#39;s design, before I knew about JavaScript&#39;s {{{Array.find}}} function. It essentially replicates this functionality, but in most cases you are better off just using {{{find}}}.

What you see here is a JavaScript function that searches through an array of objects and returns the index of a given attribute that matches a given value. The array, the attribute, and the value are given as arguments to the widget, in that order. After it&#39;s done, it&#39;ll store the index value in {{{_pos}}} for you to use elsewhere. If it didn&#39;t find anything, {{{_pos}}} will be set to -1.

Why is it wrapped in a {{{&lt;&lt;print&gt;&gt;}}} statement? This is something the Twine community calls the &quot;Stupid Print Trick&quot;, because it looks stupid, but it actually works. If you use the {{{&lt;&lt;print&gt;&gt;}}} statement to print code, that code will be executed. Because {{{&lt;&lt;print&gt;&gt;}}} can concatenate strings, this is handy for creating code with variable parameters. The only trick is that every one of the arguments has to be a string literal (surrounded by quotes), or it won&#39;t work. The other caveat is that if you&#39;re searching for a string value, that value must &lt;i&gt;display in the code&lt;/i&gt; as a string literal, which requires you to add an extra pair of quotes. You must do this by using the escape slash {{{\}}} character so they&#39;re parsed as literal.

If you didn&#39;t understand that, don&#39;t worry! Just follow the directions in the comment and you should be fine.</tw-passagedata><tw-passagedata pid="185" name="Start" tags="text" position="600,2350" size="100,100">Welcome to Another RPG Engine, an RPG engine made in Twine. This engine is designed for deterministic multi-character battles, like you might see in RPG Maker or Japanese-style RPGs. I created a simple game with this engine called &lt;i&gt;&lt;a href=&quot;https://anotherrpgenthusiast.itch.io/cartoon-battle&quot; target=&quot;_blank&quot;&gt;Cartoon Battle&lt;/a&gt;&lt;/i&gt; that I encourage you to try. I may make more complex games using this engine in the future!

Click on the links above to learn about aspects of the engine in more detail.

Download the source code and discuss the game at &lt;a href=&quot;https://anotherrpgenthusiast.itch.io/another-rpg-engine&quot; target=&quot;_blank&quot;&gt;itch.io&lt;/a&gt;. You can also discuss the game on &lt;a href=&quot;https://archiveofourown.org/works/19398175&quot; target=&quot;_blank&quot;&gt;Archive of Our Own&lt;/a&gt; if that&#39;s more your wheelhouse, and you can post your games there or on itch.io!

Example battles:
* [[Princess Bubblegum (Adventure Time)|Preparation][$scenario = &quot;at1&quot;]]
* [[Mystery Twins (Gravity Falls)|Preparation][$scenario = &quot;gf1&quot;]]
* [[Watterson Kids (The Amazing World of Gumball)|Preparation][$scenario = &quot;gum1&quot;]]
* [[Crystal Gems (Steven Universe)|Preparation][$scenario = &quot;su1&quot;]]

[[Here is the party menu|Menu: Status][$menu_screen = 0]] if you&#39;d like to change your puppets or their equipment.

Animation tests:
* [[Single hit attack|Anim Test][$subtest = &quot;Sword&quot;]]
* [[Multi-hit attack|Anim Test][$subtest = &quot;Knife&quot;]]
* [[AoE|Anim Test][$subtest = &quot;Red Tide&quot;]]
* [[Grenade|Anim Test][$subtest = &quot;Grenade&quot;]]
* [[Weakpoint|Anim Test][$subtest = &quot;Azure Frost&quot;]]
* [[Immunity|Anim Test][$subtest = &quot;White Light&quot;]]
* [[Heal|Anim Test][$subtest = &quot;Gold Sparks&quot;]]
* [[Shield Effect|Anim Test][$subtest = &quot;block&quot;]]
* [[Ailment|Anim Test][$subtest = &quot;Insult&quot;]]
* [[Hit and ailment|Anim Test][$subtest = &quot;Flurry&quot;]]
* [[Remove ailment|Anim Test][$subtest = &quot;Antidote&quot;]]
* Regeneration ([[light|Anim Test][$subtest = &quot;regen&quot;]], [[dark|Anim Test][$subtest = &quot;regen dark&quot;]])
* [[Thorns|Anim Test][$subtest = &quot;Thorns&quot;]]
* [[Killing blow|Anim Test][$subtest = &quot;death&quot;]]

Here is a link to the [[Point-buy interface example]] for testing.

Here is a link to the [[Item Shop]] for testing.

Here is a link to the [[Decurse Station]] for testing.

&lt;&lt;link &quot;Start Music&quot;&gt;&gt;&lt;&lt;playMusic &quot;Happy 8bit Loop 01&quot;&gt;&gt;&lt;&lt;goto &quot;Start&quot;&gt;&gt;&lt;&lt;/link&gt;&gt;

You can change the difficulty through the Settings button in the sidebar. Keep in mind that this is more of a randomness setting than a difficulty setting.&lt;span style=&quot;font-size:12px&quot;&gt;
* Hard: smart targeting will only target vulnerable characters
* Medium: smart targeting will preferentially target vulnerable characters, but other targets can be considered
* Easy: disables smart targeting
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="186" name="navbar" tags="nobr" position="725,2350" size="100,100">&lt;div id=&quot;navbar&quot;&gt;
  &lt;span&gt;&lt;b&gt;Version: &lt;&lt;print setup.version&gt;&gt;&lt;/b&gt; ([[Changelog]])&lt;/span&gt;
  &lt;div&gt;
  &lt;span style=&quot;font-weight:bold&quot;&gt;&lt;&lt;if passage() == &quot;Start&quot;&gt;&gt;Home&lt;&lt;else&gt;&gt;[[Home|Start]]&lt;&lt;/if&gt;&gt;&lt;/span&gt;
  &lt;span&gt;&lt;&lt;if passage() == &quot;Installation&quot;&gt;&gt;&lt;b&gt;Installation&lt;/b&gt;&lt;&lt;else&gt;&gt;[[Installation]]&lt;&lt;/if&gt;&gt;&lt;/span&gt;
  &lt;span&gt;Documentation (&lt;&lt;if passage() == &quot;Documentation (Basic)&quot;&gt;&gt;&lt;b&gt;Basic&lt;/b&gt;&lt;&lt;else&gt;&gt;[[Basic|Documentation (Basic)]]&lt;&lt;/if&gt;&gt;, &lt;&lt;if passage() == &quot;Documentation (Advanced)&quot;&gt;&gt;&lt;b&gt;Advanced&lt;/b&gt;&lt;&lt;else&gt;&gt;[[Advanced|Documentation (Advanced)]]&lt;&lt;/if&gt;&gt;)&lt;/span&gt;
  &lt;span&gt;&lt;&lt;if passage() == &quot;Design&quot;&gt;&gt;&lt;b&gt;Design&lt;/b&gt;&lt;&lt;else&gt;&gt;[[Design]]&lt;&lt;/if&gt;&gt;&lt;/span&gt;
  &lt;span&gt;&lt;&lt;if passage() == &quot;Additional Features&quot;&gt;&gt;&lt;b&gt;Additional Features&lt;/b&gt;&lt;&lt;else&gt;&gt;[[Additional Features]]&lt;&lt;/if&gt;&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;</tw-passagedata><tw-passagedata pid="187" name="PassageDone-custom" tags="nobr" position="850,2350" size="100,100">/* Custom PassageDone code, appended to the core passage. */</tw-passagedata><tw-passagedata pid="188" name="PassageFooter-custom" tags="nobr" position="975,2350" size="100,100">/* Custom PassageFooter code, appended to the core passage. */
&lt;&lt;if tags().includes(&quot;info&quot;)&gt;&gt;
&lt;hr/&gt;
&lt;center&gt;&lt;a href=&quot;#navbar&quot;&gt;BACK TO TOP&lt;/a&gt;&lt;/center&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="189" name="PassageHeader-custom" tags="nobr" position="1100,2350" size="100,100">/* Custom PassageHeader code, appended to the core passage. */
&lt;&lt;if tags().includes(&quot;text&quot;)&gt;&gt;
	&lt;&lt;include &quot;navbar&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="190" name="PassageReady-custom" tags="" position="1225,2350" size="100,100">/* Custom PassageReady code, appended to the core passage. */</tw-passagedata><tw-passagedata pid="191" name="StoryAuthor" tags="" position="100,2475" size="100,100">Made in &lt;a href=&quot;https://anotherrpgenthusiast.itch.io/another-rpg-engine&quot;&gt;Another RPG Engine&lt;/a&gt;
/* Please keep this link if you make games in the engine! */</tw-passagedata><tw-passagedata pid="192" name="StoryCaption" tags="" position="225,2475" size="100,100">&lt;&lt;nobr&gt;&gt;
&lt;&lt;if $debug&gt;&gt;
  &lt;&lt;if $inbattle&gt;&gt;
    &lt;&lt;for _i, _puppet range $puppets&gt;&gt;
      &lt;&lt;set _linkText = &quot;Puppet &quot;+_i+&quot; Crisis&quot;&gt;&gt;
      &lt;&lt;capture _puppet&gt;&gt;
      &lt;&lt;link _linkText&gt;&gt;
        &lt;&lt;set _puppet.crisisPoints = 100&gt;&gt;
        &lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
      &lt;&lt;/link&gt;&gt;
      &lt;&lt;/capture&gt;&gt;&lt;br/&gt;
      &lt;&lt;set _linkText = &quot;Kill Puppet &quot;+_i&gt;&gt;
      &lt;&lt;capture _puppet&gt;&gt;
      &lt;&lt;link _linkText&gt;&gt;
        &lt;&lt;set _puppet.dead = true&gt;&gt;
        &lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
      &lt;&lt;/link&gt;&gt;
      &lt;&lt;/capture&gt;&gt;&lt;br/&gt;
    &lt;&lt;/for&gt;&gt;
    &lt;&lt;for _i, _enemy range $enemies&gt;&gt;
      &lt;&lt;set _linkText = &quot;Kill Enemy &quot;+_i&gt;&gt;
      &lt;&lt;capture _enemy&gt;&gt;
      &lt;&lt;link _linkText&gt;&gt;
        &lt;&lt;set _enemy.dead = true&gt;&gt;
        &lt;&lt;goto &quot;Player Phase&quot;&gt;&gt;
      &lt;&lt;/link&gt;&gt;
      &lt;&lt;/capture&gt;&gt;&lt;br/&gt;
    &lt;&lt;/for&gt;&gt;
  &lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/nobr&gt;&gt;
&lt;&lt;include &quot;hotkey info&quot;&gt;&gt;
&lt;&lt;include &quot;music info&quot;&gt;&gt;</tw-passagedata><tw-passagedata pid="193" name="StoryMenu" tags="" position="350,2475" size="100,100">&lt;&lt;nobr&gt;&gt;
&lt;a href=&quot;https://archiveofourown.org/works/19398175/chapters/46161772&quot; target=&quot;_blank&quot;&gt;AO3&lt;/a&gt;
&lt;a href=&quot;https://github.com/AnotherRPGEnthusiast/Another-RPG-Engine&quot; target=&quot;_blank&quot;&gt;GITHUB&lt;/a&gt;
&lt;&lt;/nobr&gt;&gt;</tw-passagedata><tw-passagedata pid="194" name="battle display mods actorlist" tags="nobr" position="475,2475" size="100,100">/* Called at the start of actorlist. Use this for any modifications you want to make to the default display, such as reversing the order of a party.
  The container class for enemies is _enemiesClass, and the container class for puppets is _puppetsClass.
  Add your class to the variable with a leading space, as the variable is one string that will contain all the classes.
*/

&lt;&lt;if $scenario is &quot;reverse display&quot;&gt;&gt;
  &lt;&lt;set _enemiesClass += &quot; reverse&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="195" name="battle interruptions" tags="nobr" position="600,2475" size="100,100">/* Special scenarios that interrupt the normal display, such as the Crystal Gems defending Steven. By default, this has margins both above and below to make it its own block (see story stylesheet). You may want to adjust this if you plan to make an interruption at a different point. */

/* You may wish to make separate passages for each of these, but the example will be stored here. */

&lt;&lt;if $scenario == &quot;su1&quot; and $B.event == false and $B.turn == &quot;player&quot; and ($target instanceof Enemy)&gt;&gt;

/* When vs. the Crystal Gems, the Gems will take hits for Steven if you try to attack him. */

&lt;&lt;if target().name == &quot;Steven&quot;&gt;&gt;
	&lt;&lt;if $enemies[1].dead is false&gt;&gt;
	/* Garnet is the first to defend him */
&lt;&lt;timed 0s&gt;&gt;
&lt;&lt;replace &quot;#interrupt&quot;&gt;&gt;
@@.interruption;
$enemies[1].name&#39;s head snaps towards you and she jumps in the way of your attack, leaving Steven unharmed.@@
&lt;&lt;/replace&gt;&gt;
&lt;&lt;/timed&gt;&gt;
		&lt;&lt;set _t to 1&gt;&gt;
	&lt;&lt;elseif $enemies[0].dead is false&gt;&gt;
   	/* If Garnet is poofed, Pearl plays defense */
&lt;&lt;timed 0s&gt;&gt;
&lt;&lt;replace &quot;#interrupt&quot;&gt;&gt;
@@.interruption;
$enemies[0].name screams, &quot;STEVEN!!!&quot; and throws herself into your attack without hesitation.@@
&lt;&lt;/replace&gt;&gt;
&lt;&lt;/timed&gt;&gt;
   		&lt;&lt;set _t to 0&gt;&gt;
  	&lt;&lt;elseif $enemies[2].dead is false&gt;&gt;
   	/* If Garnet and Pearl are poofed, Amethyst plays defense */
&lt;&lt;timed 0s&gt;&gt;
&lt;&lt;replace &quot;#interrupt&quot;&gt;&gt;
@@.interruption;
$enemies[2].name yells, &quot;Pick on someone your own size!&quot; and throws herself in front of Steven.@@
&lt;&lt;/replace&gt;&gt;
&lt;&lt;/timed&gt;&gt;
   		&lt;&lt;set _t to 2&gt;&gt;
  	&lt;&lt;else&gt;&gt;
   		&lt;&lt;set _t to 3&gt;&gt; /* this is Steven&#39;s index; he is vulnerable */
  	&lt;&lt;/if&gt;&gt;
  	&lt;&lt;set $target to $enemies[_t]&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $bully to false&gt;&gt; /* If you didn&#39;t target Steven, lose out on Bully achievement */
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="196" name="Confirm Text" tags="nobr" position="725,2475" size="100,100">/* Displayed on the confirm phase. Recommended to repeat the action&#39;s name and provide some useful information. Custom text for certain actions can also be added. */

&lt;&lt;print $subject.name&gt;&gt; will

&lt;&lt;if $action.name is &quot;rest&quot;&gt;&gt;
	&lt;b&gt;rest&lt;/b&gt; this turn.
&lt;&lt;elseif $action.name is &quot;struggle&quot;&gt;&gt;
	spend &lt;&lt;print setup.STRUGGLE_COST&gt;&gt; Energy to get back on &lt;&lt;print subject().their&gt;&gt; feet.
&lt;&lt;elseif $action.item is true&gt;&gt;
	use &lt;&lt;switch $action.name.first().toLowerCase()&gt;&gt;&lt;&lt;case &#39;a&#39; &#39;e&#39; &#39;i&#39; &#39;o&#39; &#39;u&#39;&gt;&gt;an&lt;&lt;default&gt;&gt;a&lt;&lt;/switch&gt;&gt; $action.name.
&lt;&lt;elseif $action.name is &quot;spare&quot;&gt;&gt;
	accept the enemy&#39;s surrender.
&lt;&lt;else&gt;&gt;
	use &lt;b&gt;$action.name&lt;/b&gt;&lt;&lt;if $target isnot null&gt;&gt; on &lt;b&gt;$target.name&lt;/b&gt;&lt;&lt;/if&gt;&gt;.
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="197" name="custom battle preparation" tags="" position="850,2475" size="100,100">/* Additional code to perform during battle setup. */

&lt;&lt;restock&gt;&gt;</tw-passagedata><tw-passagedata pid="198" name="custom end of action effects" tags="nobr" position="975,2475" size="100,100">/* Appended to the action phase, immediately after mark attacks and potential surrender failure. Include any custom code or messages you want here. */

&lt;&lt;if !_markActive&gt;&gt;
	&lt;&lt;markAttack&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !_counterActive&gt;&gt;
	&lt;&lt;hunterCheck&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="199" name="custom end of battle" tags="nobr" position="1100,2475" size="100,100">&lt;&lt;restock&gt;&gt;</tw-passagedata><tw-passagedata pid="200" name="custom endTurn" tags="nobr" position="1225,2475" size="100,100">/* Custom code to be run at the end of the endTurn widget. */</tw-passagedata><tw-passagedata pid="201" name="custom newTurn" tags="nobr" position="100,2600" size="100,100"></tw-passagedata><tw-passagedata pid="202" name="postAction custom" tags="nobr" position="225,2600" size="100,100">/* Appended to the Action Phase, immediately after mark attacks and potential surrender failure. Include any custom code or messages you want here. */

&lt;&lt;if !_markActive&gt;&gt;
	&lt;&lt;markAttack&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if !_counterActive&gt;&gt;
	&lt;&lt;hunterCheck&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="203" name="custom refreshPuppet" tags="nobr" position="350,2600" size="100,100">/* Appended to EVERY LOOP of refreshPuppets. Use variable _puppet to refer to the current puppet. */

&lt;&lt;set _puppet.en = 5&gt;&gt;
&lt;&lt;set _x = _puppet.actions.find(function (a) { return a &amp;&amp; a.name == &quot;Reload&quot; })&gt;&gt;
&lt;&lt;if def _x&gt;&gt;
  &lt;&lt;set $subject = _puppet; _x.act()&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="204" name="damageCalc custom factors" tags="nobr" position="475,2600" size="100,100">/* Any additional logic you want to add to damage calculation. Run after element logic, immediately before damage rounding. */

&lt;&lt;if _target.invincible&gt;&gt;
	&lt;&lt;set $dmg = 0; _noDmgFloor = true&gt;&gt;
&lt;&lt;else&gt;&gt;

&lt;&lt;if $subject.berserker is true&gt;&gt;
	&lt;&lt;set $dmg *= (1+setup.BERSERK_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _target.berserker is true&gt;&gt;
	&lt;&lt;set $dmg *= (1+setup.BERSERK_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if $subject.defender is true&gt;&gt;
	&lt;&lt;set $dmg *= setup.DEFEND_FACTOR&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _target.defender is true&gt;&gt;
	&lt;&lt;set $dmg *= setup.DEFEND_FACTOR&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _target.shield is true&gt;&gt;
	&lt;&lt;set $dmg *= (1-setup.SHIELD_FACTOR)&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="205" name="Database: Encounters" tags="nobr widget" position="600,2600" size="100,100">/* This passage allows you to define encounters -- that is, unique parties of enemies. To define individual enemies and characters, see the database JS files. */

&lt;&lt;widget &quot;callEncounter&quot;&gt;&gt;
/* The order characters are added to the array matters: they are displayed in that order from left to right when the stat blocks instantiate. */

&lt;&lt;switch $args[0]&gt;&gt;

&lt;&lt;case &quot;at1&quot;&gt;&gt;
/* Currently Bubblegum&#39;s name is too long and makes her box wider than normal. That&#39;s fitting though, maybe I should let it stay. */
&lt;&lt;populateEnemies `[&quot;Jake&quot;,&quot;Princess Bubblegum&quot;,&quot;Finn&quot;]`&gt;&gt;
&lt;&lt;for _c = 1; _c &lt;= $enemies.length; _c++&gt;&gt;
	&lt;&lt;set $enemies[_c-1].col = _c&gt;&gt;
&lt;&lt;/for&gt;&gt;

&lt;&lt;case &quot;gf1&quot;&gt;&gt;
&lt;&lt;populateEnemies `[&quot;Dipper&quot;,&quot;Mabel&quot;]`&gt;&gt;

&lt;&lt;case &quot;gum1&quot;&gt;&gt;
&lt;&lt;populateEnemies `[&quot;Gumball&quot;,&quot;Anais&quot;,&quot;Darwin&quot;]`&gt;&gt;

&lt;&lt;case &quot;su1&quot;&gt;&gt;
&lt;&lt;populateEnemies `[&quot;Pearl&quot;,&quot;Garnet&quot;,&quot;Amethyst&quot;,&quot;Steven&quot;]`&gt;&gt;

&lt;&lt;case &quot;gum2&quot;&gt;&gt;
&lt;&lt;populateEnemies `[&quot;Nicole&quot;]`&gt;&gt;

&lt;&lt;/switch&gt;&gt;

&lt;&lt;if ndef $enemies || $enemies.length == 0&gt;&gt;
	/* Dummy enemy so the display doesn&#39;t break. */
	&lt;&lt;set $enemies to [new Enemy()]&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if def $bestiary&gt;&gt;
	&lt;&lt;for _enemy range $enemies&gt;&gt;
		&lt;&lt;if def $bestiary.fetch(_enemy.name)&gt;&gt;
			&lt;&lt;set $bestiary.fetch(_enemy.name).encountered = true&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;populateEnemies&quot;&gt;&gt;
/* Quick way of populating enemy array. Pass array of names in order corresponding to enemy array order, including nulls for empty spaces. */
/* The passed array must be quoted with backticks. */
&lt;&lt;run console.assert($args[0] instanceof Array,&quot;ERROR in populateEnemies: invalid argument&quot;)&gt;&gt;
&lt;&lt;set $enemies = []&gt;&gt;
&lt;&lt;set _array = $args[0]&gt;&gt;
&lt;&lt;for _n, _name range _array&gt;&gt;
	&lt;&lt;if typeof(_name) == &#39;string&#39;&gt;&gt;
		&lt;&lt;set $enemies.push(new Enemy(_name))&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $enemies.push(_name)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="206" name="accuracy formula" tags="nobr" position="725,2600" size="100,100">&lt;&lt;if $action.accuracy === true&gt;&gt;
	&lt;&lt;set _hit = true&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _acc = $action.accuracy&gt;&gt;
	&lt;&lt;if subject().stats.hasOwnProperty(StatName(&quot;Accuracy&quot;))&gt;&gt;
		&lt;&lt;set _acc = Math.max(_acc + (subject().get(StatName(&quot;Accuracy&quot;))-100),setup.MIN_ACCURACY)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if _target.stats.hasOwnProperty(StatName(&quot;Evasion&quot;))&gt;&gt;
		&lt;&lt;set _acc = Math.max(_acc - _target.get(StatName(&quot;Evasion&quot;)),setup.MIN_ACCURACY)&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;set _toHit = random(1,100)&gt;&gt;
	&lt;&lt;if _toHit &lt;= _acc&gt;&gt;
		&lt;&lt;set _hit = true&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set _hit = false&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="207" name="crisis formula" tags="nobr" position="850,2600" size="100,100">&lt;&lt;if Number.isInteger(_target.crisisPoints) &amp;&amp; $dmg &gt; 0&gt;&gt;
  &lt;&lt;switch _target.crisisMode&gt;&gt;
    &lt;&lt;default&gt;&gt;
      &lt;&lt;set _target.crisisPoints += Math.round(($dmg/_target.maxHP)*100*_target.crisisFactor)&gt;&gt;
  &lt;&lt;/switch&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="208" name="crit formula" tags="nobr" position="975,2600" size="100,100">&lt;&lt;set _critChance = $action.critRate&gt;&gt;
&lt;&lt;set _toCrit = random(1,100)&gt;&gt;
&lt;&lt;if subject().stats.hasOwnProperty(StatName(&quot;Skill&quot;))&gt;&gt;
  &lt;&lt;set _critChance += subject().get(StatName(&quot;Skill&quot;))&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;&lt;if _toCrit &lt;= _critChance&gt;&gt;
  &lt;&lt;print setup.CRIT_MESSAGE+&quot; &quot;&gt;&gt;
  &lt;&lt;set $dmg *= $action.critMultiplier&gt;&gt;
  &lt;&lt;set _crit = true&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="209" name="damageCalc formula" tags="nobr" position="1100,2600" size="100,100">/* Define the damage formula or formulae you want to use here. */

&lt;&lt;if !$action.formula&gt;&gt;
/* Only use the default formula if the action does not have a custom formula (so, the formula property is falsy) */
&lt;&lt;switch setup.formula&gt;&gt;
	&lt;&lt;case &quot;subtractive&quot;&gt;&gt;
		&lt;&lt;set $dmg = $action.base + ((setup.base+setup.damper*_atk)*_w)-setup.damper*_def&gt;&gt;
	&lt;&lt;case &quot;subtractive lumped&quot;&gt;&gt;
		&lt;&lt;set $dmg = $action.base + (setup.base+setup.damper*(_atk-_def))*_w&gt;&gt;
	&lt;&lt;case &quot;rpgmaker&quot;&gt;&gt;
		&lt;&lt;set $dmg = $action.base + (_atk*4-_def*2)*setup.damper*_w&gt;&gt;
	&lt;&lt;case &quot;divisive&quot;&gt;&gt;
		&lt;&lt;set $dmg = $action.base + (setup.base*(_atk/_def))*_w&gt;&gt;
	&lt;&lt;case &quot;fixed&quot;&gt;&gt;
		&lt;&lt;set $dmg = $action.base&gt;&gt;
	&lt;&lt;default&gt;&gt;
		/* add your own here! */
&lt;&lt;/switch&gt;&gt;

&lt;&lt;else&gt;&gt;
	&lt;&lt;set $dmg = $action.formula()&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="210" name="heal formula" tags="nobr" position="1225,2600" size="100,100">&lt;&lt;if Number.isInteger(action().special)&gt;&gt;
  &lt;&lt;set $heal = action().special&gt;&gt;
&lt;&lt;else&gt;&gt;
  &lt;&lt;set $heal = 0&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="211" name="manaBurnCalc" tags="widget nobr" position="100,2725" size="100,100">/* Formula for mana burns. */

&lt;&lt;widget &quot;manaBurnCalc&quot;&gt;&gt;
  &lt;&lt;set $dmg = action().special&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="212" name="echoDamage threat gain" tags="nobr" position="225,2725" size="100,100">/* Default: Dragon Age style. Attacker gains threat equal to the percentage of maximum HP dealt. */
&lt;&lt;set _threatGain = 1 * ($dmg / target().maxHP)&gt;&gt;
&lt;&lt;run target().threat.inc(subject().name,_threatGain)&gt;&gt;</tw-passagedata><tw-passagedata pid="213" name="Tick Formula" tags="nobr" position="350,2725" size="100,100">&lt;&lt;run console.assert(subject() instanceof Actor,`ERROR in Tick Formula: no subject`)&gt;&gt;
&lt;&lt;run console.assert($action instanceof Action,`ERROR in Tick Formula: no action`)&gt;&gt;

&lt;&lt;set subject().ticks += ($action.recoveryTime - subject().get(StatName(&quot;spd&quot;)))&gt;&gt;</tw-passagedata><tw-passagedata pid="214" name="loss of control effects" tags="nobr" position="475,2725" size="100,100">&lt;&lt;set _u = $puppets.find(function (p) { return p &amp;&amp; (p.uncontrollable &amp;&amp; !(!p.active || p.noact || p.dead)); })&gt;&gt;
&lt;&lt;if def _u&gt;&gt;
	&lt;&lt;set $subject = _u&gt;&gt;
	&lt;&lt;if subject().name == &quot;Mage&quot;&gt;&gt;
		&lt;&lt;set $action = new Action(&quot;Blast&quot;)&gt;&gt;
	&lt;&lt;elseif subject().name == &quot;Witch&quot;&gt;&gt;
		&lt;&lt;set $action = new Action(&quot;Pox&quot;)&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $action = clone(subject().actions.find(function (act) { return act &amp;&amp; act.name === subject().defaultAction })&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;&lt;if subject().en &lt; $action.cost&gt;&gt;
		&lt;&lt;set subject().active = false&gt;&gt;
		&lt;&lt;goto &quot;Player Phase&quot;&gt;&gt; /* necessary to find other potential uncontrollables */
	&lt;&lt;else&gt;&gt;
		&lt;&lt;if _u.confusion&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;any&quot;])&gt;&gt;
		&lt;&lt;elseif _u.charmed&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;allies&quot;])&gt;&gt;
		&lt;&lt;elseif _u.hatred&gt;&gt;
			&lt;&lt;set $target = Hitlist.targetEnemy([&quot;enemies&quot;])&gt;&gt;
		&lt;&lt;/if&gt;&gt;
		&lt;&lt;goto &quot;Action Phase&quot;&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="215" name="special battle lines" tags="nobr" position="600,2725" size="100,100">/* Displays in-between the two party listings in actorlist. */</tw-passagedata><tw-passagedata pid="216" name="Widget: Special Checks" tags="widget nobr" position="725,2725" size="100,100">&lt;&lt;widget &quot;specialcheck&quot;&gt;&gt;
/* Called on the &quot;Player Phase&quot; passage. Use this to direct a player to any special scenes or scenarios you want to occur upon specific triggers, such as a character reacting to another character&#39;s defeat or changing into a different form. */

&lt;&lt;include &quot;loss of control effects&quot;&gt;&gt;
&lt;&lt;include &quot;delayed actions&quot;&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="217" name="Stash Phase" tags="battle nobr" position="850,2725" size="100,100">&lt;&lt;replace &quot;#actorlist&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
Select an item to use from stash. &lt;&lt;backbtn&gt;&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
	&lt;&lt;set _actionClass = &quot;compressed&quot;&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set _actionClass = &quot;&quot;&gt;&gt;
&lt;&lt;/if&gt;&gt;
&lt;div id=&quot;actionList&quot; @class=&quot;_actionClass&quot;&gt;
&lt;&lt;stashlist $subject&gt;&gt;
&lt;/div&gt;
&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
&lt;br/&gt;
&lt;div id=&quot;actionInfo&quot;&gt;
	&lt;&lt;include &quot;action box default&quot;&gt;&gt;
&lt;/div&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="218" name="Widget: stashlist" tags="widget nobr" position="975,2725" size="100,100">&lt;&lt;widget &quot;stashlist&quot;&gt;&gt;
&lt;&lt;run console.assert($args.length &gt; 0 &amp;&amp; ($args[0] instanceof Puppet),&quot;ERROR in stashlist: no Puppet&quot;)&gt;&gt;
&lt;&lt;run console.assert($args[0].stash !== undefined,&quot;ERROR in stashlist: stash is undefined&quot;)&gt;&gt;
&lt;&lt;set _char = $args[0]&gt;&gt;
&lt;&lt;for _action range _char.stash&gt;&gt;
	&lt;div class=&quot;actionDisplay&quot;&gt;
	&lt;&lt;capture _action&gt;&gt;
	&lt;&lt;mouseover&gt;&gt;
	&lt;span class=&quot;actionName&quot;&gt;
	&lt;b&gt;
		&lt;&lt;link _action.name&gt;&gt;
			&lt;&lt;actionLink _action&gt;&gt;
		&lt;&lt;/link&gt;&gt;
	&lt;/b&gt;
	&lt;/span&gt;
	&lt;&lt;onmouseover&gt;&gt;
		&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;
				&lt;&lt;actionInfo _action &quot;full&quot;&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;onmouseout&gt;&gt;
		&lt;&lt;if $COMPRESSED_ACTIONS === true&gt;&gt;
			&lt;&lt;replace &#39;#actionBox&#39;&gt;&gt;&lt;&lt;include &quot;action box default&quot;&gt;&gt;&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/mouseover&gt;&gt;
	&lt;&lt;/capture&gt;&gt;
	&lt;&lt;if $COMPRESSED_ACTIONS === true &amp;&amp; $inbattle&gt;&gt;
		&lt;&lt;actionInfo _action &quot;no name&quot;&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;actionInfo _action &quot;no name&quot; &quot;full&quot;&gt;&gt;
		&lt;br/&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;/div&gt;
&lt;&lt;/for&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="219" name="User-defined variables" tags="" position="1100,2725" size="100,100">/* Appended to the default StoryInit passage. Add any additional code you want here. */

&lt;&lt;cacheaudio &quot;Happy_8bit_Loop_01&quot; setup.SoundPath+&quot;8bitloop.wav&quot;&gt;&gt; /* This is to set up the audio for the example music in the engine help file. Feel free to remove it. */

&lt;&lt;set setup.formula to &quot;subtractive&quot;&gt;&gt;
/*
Can choose between multiple premade damage formulas here.
subtractive: (base + damper * a.get($AttackStat)) * weight - damper * b.get($DefenseStat)
subtractive lumped: (base + damper * (a.get($AttackStat) - b.get($DefenseStat))) * weight
rpgmaker: (a.get($AttackStat) * 4 - b.get($DefenseStat) * 2) * damper * weight
divisive: (base * (a.get($AttackStat)/b.get($DefenseStat))) * weight
*/

&lt;&lt;set setup.LEVEL_CAP = 10&gt;&gt;

&lt;&lt;set setup.PORTRAIT_SIZE = 50&gt;&gt; /* Portrait size in px, used for save game display */

&lt;&lt;set setup.STAT_MIN = {};
	setup.STAT_MIN[StatName(&quot;atk&quot;)] = 0;
	setup.STAT_MIN[StatName(&quot;spc&quot;)] = 0;
&gt;&gt;

&lt;&lt;if setup.formula == &quot;subtractive&quot;&gt;&gt;
	&lt;&lt;set setup.STAT_MIN[StatName(&quot;def&quot;)] = 0&gt;&gt;
&lt;&lt;else&gt;&gt;
	&lt;&lt;set setup.STAT_MIN[StatName(&quot;def&quot;)] = 1&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set setup.STAT_MAX = {};
	setup.STAT_MAX[StatName(&quot;atk&quot;)] = 999;
	setup.STAT_MAX[StatName(&quot;def&quot;)] = 999;
	setup.STAT_MAX[StatName(&quot;spc&quot;)] = 999;
&gt;&gt;

&lt;&lt;if setup.THREAT_TARGETING === true&gt;&gt;
	&lt;&lt;set setup.STATUS_SCREENS.battle.push(&quot;aggression&quot;)&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* &lt;&lt;set setup.BATTLE_GRID = true&gt;&gt; */

&lt;&lt;if setup.BATTLE_GRID === true&gt;&gt;
	&lt;&lt;set setup.ROW_SIZE = 3&gt;&gt;
	&lt;&lt;set setup.COLUMN_SIZE = 3&gt;&gt;
	&lt;&lt;set setup.MENU_OPTIONS.push(&quot;Formation&quot;)&gt;&gt;
	&lt;&lt;set setup.SCALE_NAMES = true&gt;&gt;
&lt;&lt;/if&gt;&gt;

/* Defining starting inventory. */
&lt;&lt;set $inventory = new Inventory([
	new Item(&quot;Antidote&quot;,1),
	new Item(&quot;Fire Extinguisher&quot;,1),
	new Item(&quot;Canned Air&quot;,1),
	new Item(&quot;Healing Crystal&quot;,1),
	new Item(&quot;Nanites&quot;,1),
	new Item(&quot;Painkiller&quot;,1),
	new Item(&quot;Asprin&quot;,1),
	new Item(&quot;Panacea&quot;,1),
	new Item(&quot;Bottled Chi&quot;,1),
	new Item(&quot;Stimulant&quot;,2),
	new Item(&quot;Adrenaline&quot;,1),
	new Item(&quot;Stoneskin&quot;,1),
	new Item(&quot;Nootropic&quot;,1),
	new Item(&quot;Throwing Knife&quot;,5),
	new Item(&quot;Powdered Glass&quot;,1),
	new Item(&quot;Grenade&quot;,0),
	new Item(&quot;Flamethrower&quot;,0),
	new Item(&quot;Gas Bomb&quot;,0),
	new Item(&quot;Calamity Bomb&quot;,0),
	new Item(&quot;Flashbang&quot;,0),
	new Item(&quot;Apple of Life&quot;,1),
	new Item(&quot;Symbol of Destruction&quot;,1),
	new Item(&quot;Aura of Protection&quot;,1),
	new Item(&quot;Color of Defeat&quot;,1),
	new Item(&quot;Color of Growth&quot;,2),
	new Item(&quot;Cursed Ring&quot;,3),
	new Item(&quot;Zweihander&quot;,1)
	])&gt;&gt;

&lt;&lt;set setup.BERSERK_FACTOR = 0.5&gt;&gt;
&lt;&lt;set setup.DEFEND_FACTOR = 0.5&gt;&gt;
&lt;&lt;set setup.SHIELD_FACTOR = 0.3&gt;&gt;

/* Initialize bestiary (if you want one) */
&lt;&lt;set $bestiary = new Bestiary()&gt;&gt;

&lt;&lt;run customMods()&gt;&gt;

&lt;&lt;if def $bestiary&gt;&gt;
	&lt;&lt;run setup.MENU_OPTIONS.push(&quot;Bestiary&quot;)&gt;&gt;

	&lt;&lt;for _entry range $bestiary&gt;&gt;
		&lt;&lt;set _entry.revealAll()&gt;&gt;
	&lt;&lt;/for&gt;&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;set $currentArea = &quot;Example Area&quot;&gt;&gt;

/* Define the starting party and area here. */
&lt;&lt;set $puppets = [new Puppet(&quot;Rogue&quot;),new Puppet(&quot;Fighter&quot;),new Puppet(&quot;Artist&quot;)]&gt;&gt;
&lt;&lt;set $puppets[0].col = 1; $puppets[1].col = 2; $puppets[2].col = 3&gt;&gt;
&lt;&lt;set $puppets[0].position = [2,1]&gt;&gt;

&lt;&lt;set $Reserve_Puppets = [new Puppet(&quot;Bard&quot;),new Puppet(&quot;Archer&quot;),new Puppet(&quot;Cleric&quot;),new Puppet(&quot;Witch&quot;),new Puppet(&quot;Mage&quot;)]&gt;&gt;</tw-passagedata></tw-storydata>
	<script id="script-sugarcube" type="text/javascript">
	/*! SugarCube JS */
	if(document.documentElement.getAttribute("data-init")==="loading"){(function(window,document,jQuery,undefined){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_arr=[],_n=!0,_d=!1;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{_n||null==_i.return||_i.return()}finally{if(_d)throw _e}}return _arr}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _typeof(obj){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}var errorPrologRegExp=/^(?:(?:uncaught\s+(?:exception:\s+)?)?\w*(?:error|exception|_err):\s+)+/i,Alert=function(){function mesg(where,error,isFatal,isUncaught){var mesg="Error",nice="A".concat(isFatal?" fatal":"n"," error has occurred.");nice+=isFatal?" Aborting.":" You may be able to continue, but some parts may not work properly.";var isObject=null!==error&&"object"===_typeof(error),what=(isObject&&"message"in error?String(error.message).replace(errorPrologRegExp,""):String(error)).trim()||"unknown error";null!=where&&(mesg+=" [".concat(where,"]")),mesg+=": ".concat(what,"."),isObject&&"stack"in error&&(mesg+="\n\nStack Trace:\n".concat(error.stack)),mesg&&(nice+="\n\n".concat(mesg)),isUncaught||console[isFatal?"error":"warn"](mesg),window.alert(nice)}var origOnError;return origOnError=window.onerror,window.onerror=function(what,source,lineNum,colNum,error){"complete"===document.readyState?mesg(null,null!=error?error:what,!1,!0):(mesg(null,null!=error?error:what,!0,!0),window.onerror=origOnError,"function"==typeof window.onerror&&window.onerror.apply(this,arguments))},Object.freeze(Object.defineProperties({},{error:{value:function(where,error){mesg(where,error)}},fatal:{value:function(where,error){mesg(where,error,!0)}}}))}(),Patterns=(wsMap=new Map([[" ","\\u0020"],["\f","\\f"],["\n","\\n"],["\r","\\r"],["\t","\\t"],["\v","\\v"],[" ","\\u00a0"],[" ","\\u1680"],["᠎","\\u180e"],[" ","\\u2000"],[" ","\\u2001"],[" ","\\u2002"],[" ","\\u2003"],[" ","\\u2004"],[" ","\\u2005"],[" ","\\u2006"],[" ","\\u2007"],[" ","\\u2008"],[" ","\\u2009"],[" ","\\u200a"],["\u2028","\\u2028"],["\u2029","\\u2029"],[" ","\\u202f"],[" ","\\u205f"],["　","\\u3000"],["\ufeff","\\ufeff"]]),wsRe=/^\s$/,missing="",wsMap.forEach((function(pat,char){wsRe.test(char)||(missing+=pat)})),space=missing?"[\\s".concat(missing,"]"):"\\s",spaceNoTerminator="[\\u0020\\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]",notSpace="\\s"===space?"\\S":space.replace(/^\[/,"[^"),anyChar="(?:.|".concat("[\\n\\r\\u2028\\u2029]",")"),anyLetter="[0-9A-Z_a-z\\-\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u00ff\\u0150\\u0170\\u0151\\u0171]",anyLetterStrict=anyLetter.replace("\\-",""),identifier="".concat("[$A-Z_a-z]").concat("[$0-9A-Z_a-z]","*"),variable="[$_]"+identifier,htmlTagName="[A-Za-z](?:".concat(cENChar="(?:[\\x2D.0-9A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])","*-").concat(cENChar,"*|[0-9A-Za-z]*)"),twStyle="(".concat(anyLetter,"+)\\(([^\\)\\|\\n]+)\\):"),cssStyle="".concat(spaceNoTerminator,"*(").concat(anyLetter,"+)").concat(spaceNoTerminator,"*:([^;\\|\\n]+);"),idOrClass="".concat(spaceNoTerminator,"*((?:").concat("[#.]").concat(anyLetter,"+").concat(spaceNoTerminator,"*)+);"),inlineCss="".concat(twStyle,"|").concat(cssStyle,"|").concat(idOrClass),Object.freeze({space:space,spaceNoTerminator:spaceNoTerminator,lineTerminator:"[\\n\\r\\u2028\\u2029]",notSpace:notSpace,anyChar:anyChar,anyLetter:anyLetter,anyLetterStrict:anyLetterStrict,identifierFirstChar:"[$A-Z_a-z]",identifierNextChar:"[$0-9A-Z_a-z]",identifier:identifier,variableSigil:"[$_]",variable:variable,macroName:"[A-Za-z][\\w-]*|[=-]",templateName:"[A-Za-z][\\w-]*",htmlTagName:htmlTagName,cssIdOrClassSigil:"[#.]",cssImage:"\\[[<>]?[Ii][Mm][Gg]\\[(?:\\s|\\S)*?\\]\\]+",inlineCss:inlineCss,url:"(?:file|https?|mailto|ftp|javascript|irc|news|data):[^\\s'\"]+"})),wsMap,wsRe,missing,cENChar,twStyle,cssStyle,idOrClass,space,spaceNoTerminator,notSpace,anyChar,anyLetter,anyLetterStrict,identifier,variable,htmlTagName,inlineCss;!function(){var startWSRe,endWSRe,_trimString=(startWSRe=new RegExp("^".concat(Patterns.space).concat(Patterns.space,"*")),endWSRe=new RegExp("".concat(Patterns.space).concat(Patterns.space,"*$")),function(str,where){var val=String(str);if(!val)return val;switch(where){case"start":return startWSRe.test(val)?val.replace(startWSRe,""):val;case"end":return endWSRe.test(val)?val.replace(endWSRe,""):val;default:throw new Error('_trimString called with incorrect where parameter value: "'.concat(where,'"'))}});function _createPadString(length,padding){var targetLength=Number.parseInt(length,10)||0;if(targetLength<1)return"";var padString=void 0===padding?"":String(padding);for(""===padString&&(padString=" ");padString.length<targetLength;){var curPadLength=padString.length,remainingLength=targetLength-curPadLength;padString+=curPadLength>remainingLength?padString.slice(0,remainingLength):padString}return padString.length>targetLength&&(padString=padString.slice(0,targetLength)),padString}Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,writable:!0,value:function flat(){if(null==this)throw new TypeError("Array.prototype.flat called on null or undefined");var depth=0===arguments.length?1:Number(arguments[0])||0;return depth<1?Array.prototype.slice.call(this):Array.prototype.reduce.call(this,(function(acc,cur){return cur instanceof Array?acc.push.apply(acc,_toConsumableArray(flat.call(cur,depth-1))):acc.push(cur),acc}),[])}}),Array.prototype.flatMap||Object.defineProperty(Array.prototype,"flatMap",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.flatMap called on null or undefined");return Array.prototype.map.apply(this,arguments).flat()}}),Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.includes called on null or undefined");if(0===arguments.length)return!1;var length=this.length>>>0;if(0===length)return!1;var needle=arguments[0],i=Number(arguments[1])||0;for(i<0&&(i=Math.max(0,length+i));i<length;++i){var value=this[i];if(value===needle||value!=value&&needle!=needle)return!0}return!1}}),Object.entries||Object.defineProperty(Object,"entries",{configurable:!0,writable:!0,value:function(obj){if("object"!==_typeof(obj)||null===obj)throw new TypeError("Object.entries object parameter must be an object");return Object.keys(obj).map((function(key){return[key,obj[key]]}))}}),Object.fromEntries||Object.defineProperty(Object,"fromEntries",{configurable:!0,writable:!0,value:function(iter){return Array.from(iter).reduce((function(acc,pair){if(Object(pair)!==pair)throw new TypeError("Object.fromEntries iterable parameter must yield objects");return pair[0]in acc?Object.defineProperty(acc,pair[0],{configurable:!0,enumerable:!0,writable:!0,value:pair[1]}):acc[pair[0]]=pair[1],acc}),{})}}),Object.getOwnPropertyDescriptors||Object.defineProperty(Object,"getOwnPropertyDescriptors",{configurable:!0,writable:!0,value:function(obj){if(null==obj)throw new TypeError("Object.getOwnPropertyDescriptors object parameter is null or undefined");var O=Object(obj);return Reflect.ownKeys(O).reduce((function(acc,key){var desc=Object.getOwnPropertyDescriptor(O,key);return void 0!==desc&&(key in acc?Object.defineProperty(acc,key,{configurable:!0,enumerable:!0,writable:!0,value:desc}):acc[key]=desc),acc}),{})}}),Object.values||Object.defineProperty(Object,"values",{configurable:!0,writable:!0,value:function(obj){if("object"!==_typeof(obj)||null===obj)throw new TypeError("Object.values object parameter must be an object");return Object.keys(obj).map((function(key){return obj[key]}))}}),String.prototype.padStart||Object.defineProperty(String.prototype,"padStart",{configurable:!0,writable:!0,value:function(length,padding){if(null==this)throw new TypeError("String.prototype.padStart called on null or undefined");var baseString=String(this),baseLength=baseString.length,targetLength=Number.parseInt(length,10);return targetLength<=baseLength?baseString:_createPadString(targetLength-baseLength,padding)+baseString}}),String.prototype.padEnd||Object.defineProperty(String.prototype,"padEnd",{configurable:!0,writable:!0,value:function(length,padding){if(null==this)throw new TypeError("String.prototype.padEnd called on null or undefined");var baseString=String(this),baseLength=baseString.length,targetLength=Number.parseInt(length,10);return targetLength<=baseLength?baseString:baseString+_createPadString(targetLength-baseLength,padding)}}),String.prototype.trimStart||Object.defineProperty(String.prototype,"trimStart",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.trimStart called on null or undefined");return _trimString(this,"start")}}),String.prototype.trimLeft||Object.defineProperty(String.prototype,"trimLeft",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.trimLeft called on null or undefined");return _trimString(this,"start")}}),String.prototype.trimEnd||Object.defineProperty(String.prototype,"trimEnd",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.trimEnd called on null or undefined");return _trimString(this,"end")}}),String.prototype.trimRight||Object.defineProperty(String.prototype,"trimRight",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.trimRight called on null or undefined");return _trimString(this,"end")}})}(),function(){var _nativeMathRandom=Math.random,_regExpMetaCharsRe,_hasRegExpMetaCharsRe,_formatRegExp,_hasFormatRegExp;function _random(){var min,max;switch(arguments.length){case 0:throw new Error("_random called with insufficient parameters");case 1:min=0,max=arguments[0];break;default:min=arguments[0],max=arguments[1]}if(min>max){var _ref=[max,min];min=_ref[0],max=_ref[1]}return Math.floor(_nativeMathRandom()*(max-min+1))+min}function _randomIndex(length,boundsArgs){var min,max;switch(boundsArgs.length){case 1:min=0,max=length-1;break;case 2:min=0,max=Math.trunc(boundsArgs[1]);break;default:min=Math.trunc(boundsArgs[1]),max=Math.trunc(boundsArgs[2])}return Number.isNaN(min)?min=0:!Number.isFinite(min)||min>=length?min=length-1:min<0&&(min=length+min)<0&&(min=0),Number.isNaN(max)?max=0:(!Number.isFinite(max)||max>=length||max<0&&(max=length+max)<0)&&(max=length-1),_random(min,max)}function _getCodePointStartAndEnd(str,pos){var code=str.charCodeAt(pos);if(Number.isNaN(code))return{char:"",start:-1,end:-1};if(code<55296||code>57343)return{char:str.charAt(pos),start:pos,end:pos};if(code>=55296&&code<=56319){var nextPos=pos+1;if(nextPos>=str.length)throw new Error("high surrogate without trailing low surrogate");var nextCode=str.charCodeAt(nextPos);if(nextCode<56320||nextCode>57343)throw new Error("high surrogate without trailing low surrogate");return{char:str.charAt(pos)+str.charAt(nextPos),start:pos,end:nextPos}}if(0===pos)throw new Error("low surrogate without leading high surrogate");var prevPos=pos-1,prevCode=str.charCodeAt(prevPos);if(prevCode<55296||prevCode>56319)throw new Error("low surrogate without leading high surrogate");return{char:str.charAt(prevPos)+str.charAt(pos),start:prevPos,end:pos}}Object.defineProperty(Array,"random",{configurable:!0,writable:!0,value:function(array){if("object"!==_typeof(array)||null===array||!Object.prototype.hasOwnProperty.call(array,"length"))throw new TypeError("Array.random array parameter must be an array or array-lke object");var length=array.length>>>0;if(0!==length){var index=0===arguments.length?_random(0,length-1):_randomIndex(length,Array.prototype.slice.call(arguments,1));return array[index]}}}),Object.defineProperty(Array.prototype,"concatUnique",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.concatUnique called on null or undefined");var result=Array.from(this);if(0===arguments.length)return result;var items=Array.prototype.reduce.call(arguments,(function(prev,cur){return prev.concat(cur)}),[]),addSize=items.length;if(0===addSize)return result;for(var indexOf=Array.prototype.indexOf,push=Array.prototype.push,i=0;i<addSize;++i){var value=items[i];-1===indexOf.call(result,value)&&push.call(result,value)}return result}}),Object.defineProperty(Array.prototype,"count",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.count called on null or undefined");for(var indexOf=Array.prototype.indexOf,needle=arguments[0],pos=Number(arguments[1])||0,count=0;-1!==(pos=indexOf.call(this,needle,pos));)++count,++pos;return count}}),Object.defineProperty(Array.prototype,"countWith",{configurable:!0,writable:!0,value:function(predicate,thisArg){if(null==this)throw new TypeError("Array.prototype.countWith called on null or undefined");if("function"!=typeof predicate)throw new Error("Array.prototype.countWith predicate parameter must be a function");var length=this.length>>>0;if(0===length)return 0;for(var count=0,i=0;i<length;++i)predicate.call(thisArg,this[i],i,this)&&++count;return count}}),Object.defineProperty(Array.prototype,"delete",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.delete called on null or undefined");if(0===arguments.length)return[];var length=this.length>>>0;if(0===length)return[];for(var needles=Array.prototype.concat.apply([],arguments),needlesLength=needles.length,indices=[],i=0;i<length;++i)for(var value=this[i],j=0;j<needlesLength;++j){var needle=needles[j];if(value===needle||value!=value&&needle!=needle){indices.push(i);break}}for(var result=[],_i=0,iend=indices.length;_i<iend;++_i)result[_i]=this[indices[_i]];for(var splice=Array.prototype.splice,_i2=indices.length-1;_i2>=0;--_i2)splice.call(this,indices[_i2],1);return result}}),Object.defineProperty(Array.prototype,"deleteAt",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.deleteAt called on null or undefined");if(0===arguments.length)return[];var length=this.length>>>0;if(0===length)return[];for(var splice=Array.prototype.splice,cpyIndices=_toConsumableArray(new Set(Array.prototype.concat.apply([],arguments).map((function(x){return x<0?Math.max(0,length+x):x}))).values()),delIndices=_toConsumableArray(cpyIndices).sort((function(a,b){return b-a})),result=[],i=0,iend=cpyIndices.length;i<iend;++i)result[i]=this[cpyIndices[i]];for(var _i3=0,_iend=delIndices.length;_i3<_iend;++_i3)splice.call(this,delIndices[_i3],1);return result}}),Object.defineProperty(Array.prototype,"deleteWith",{configurable:!0,writable:!0,value:function(predicate,thisArg){if(null==this)throw new TypeError("Array.prototype.deleteWith called on null or undefined");if("function"!=typeof predicate)throw new Error("Array.prototype.deleteWith predicate parameter must be a function");var length=this.length>>>0;if(0===length)return[];for(var splice=Array.prototype.splice,indices=[],result=[],i=0;i<length;++i)predicate.call(thisArg,this[i],i,this)&&(result.push(this[i]),indices.push(i));for(var _i4=indices.length-1;_i4>=0;--_i4)splice.call(this,indices[_i4],1);return result}}),Object.defineProperty(Array.prototype,"first",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.first called on null or undefined");if(0!==this.length>>>0)return this[0]}}),Object.defineProperty(Array.prototype,"includesAll",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.includesAll called on null or undefined");if(1===arguments.length)return Array.isArray(arguments[0])?Array.prototype.includesAll.apply(this,arguments[0]):Array.prototype.includes.apply(this,arguments);for(var i=0,iend=arguments.length;i<iend;++i)if(!Array.prototype.some.call(this,(function(val){return val===this.val||val!=val&&this.val!=this.val}),{val:arguments[i]}))return!1;return!0}}),Object.defineProperty(Array.prototype,"includesAny",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.includesAny called on null or undefined");if(1===arguments.length)return Array.isArray(arguments[0])?Array.prototype.includesAny.apply(this,arguments[0]):Array.prototype.includes.apply(this,arguments);for(var i=0,iend=arguments.length;i<iend;++i)if(Array.prototype.some.call(this,(function(val){return val===this.val||val!=val&&this.val!=this.val}),{val:arguments[i]}))return!0;return!1}}),Object.defineProperty(Array.prototype,"last",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.last called on null or undefined");var length=this.length>>>0;if(0!==length)return this[length-1]}}),Object.defineProperty(Array.prototype,"pluck",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.pluck called on null or undefined");var length=this.length>>>0;if(0!==length){var index=0===arguments.length?_random(0,length-1):_randomIndex(length,Array.prototype.slice.call(arguments));return Array.prototype.splice.call(this,index,1)[0]}}}),Object.defineProperty(Array.prototype,"pluckMany",{configurable:!0,writable:!0,value:function(wantSize){if(null==this)throw new TypeError("Array.prototype.pluckMany called on null or undefined");var length=this.length>>>0;if(0===length)return[];var want=Math.trunc(wantSize);if(!Number.isInteger(want))throw new Error("Array.prototype.pluckMany want parameter must be an integer");if(want<1)return[];want>length&&(want=length);var splice=Array.prototype.splice,result=[],max=length-1;do{result.push(splice.call(this,_random(0,max--),1)[0])}while(result.length<want);return result}}),Object.defineProperty(Array.prototype,"pushUnique",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.pushUnique called on null or undefined");var addSize=arguments.length;if(0===addSize)return this.length>>>0;for(var indexOf=Array.prototype.indexOf,push=Array.prototype.push,i=0;i<addSize;++i){var value=arguments[i];-1===indexOf.call(this,value)&&push.call(this,value)}return this.length>>>0}}),Object.defineProperty(Array.prototype,"random",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.random called on null or undefined");var length=this.length>>>0;if(0!==length){var index=0===arguments.length?_random(0,length-1):_randomIndex(length,Array.prototype.slice.call(arguments));return this[index]}}}),Object.defineProperty(Array.prototype,"randomMany",{configurable:!0,writable:!0,value:function(wantSize){if(null==this)throw new TypeError("Array.prototype.randomMany called on null or undefined");var length=this.length>>>0;if(0===length)return[];var want=Math.trunc(wantSize);if(!Number.isInteger(want))throw new Error("Array.prototype.randomMany want parameter must be an integer");if(want<1)return[];want>length&&(want=length);var picked=new Map,result=[],max=length-1;do{var i=void 0;do{i=_random(0,max)}while(picked.has(i));picked.set(i,!0),result.push(this[i])}while(result.length<want);return result}}),Object.defineProperty(Array.prototype,"shuffle",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.shuffle called on null or undefined");var length=this.length>>>0;if(0===length)return this;for(var i=length-1;i>0;--i){var j=Math.floor(_nativeMathRandom()*(i+1));if(i!==j){var swap=this[i];this[i]=this[j],this[j]=swap}}return this}}),Object.defineProperty(Array.prototype,"unshiftUnique",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.unshiftUnique called on null or undefined");var addSize=arguments.length;if(0===addSize)return this.length>>>0;for(var indexOf=Array.prototype.indexOf,unshift=Array.prototype.unshift,i=0;i<addSize;++i){var value=arguments[i];-1===indexOf.call(this,value)&&unshift.call(this,value)}return this.length>>>0}}),Object.defineProperty(Function.prototype,"partial",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Function.prototype.partial called on null or undefined");var slice=Array.prototype.slice,fn=this,bound=slice.call(arguments,0);return function(){for(var applied=[],argc=0,i=0;i<bound.length;++i)applied.push(bound[i]===undefined?arguments[argc++]:bound[i]);return fn.apply(this,applied.concat(slice.call(arguments,argc)))}}}),Object.defineProperty(Math,"clamp",{configurable:!0,writable:!0,value:function(num,min,max){var value=Number(num);return Number.isNaN(value)?NaN:value.clamp(min,max)}}),Object.defineProperty(Math,"easeInOut",{configurable:!0,writable:!0,value:function(num){return 1-(Math.cos(Number(num)*Math.PI)+1)/2}}),Object.defineProperty(Number.prototype,"clamp",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Number.prototype.clamp called on null or undefined");if(2!==arguments.length)throw new Error("Number.prototype.clamp called with an incorrect number of parameters");var min=Number(arguments[0]),max=Number(arguments[1]);if(min>max){var _ref2=[max,min];min=_ref2[0],max=_ref2[1]}return Math.min(Math.max(this,min),max)}}),RegExp.escape||(_regExpMetaCharsRe=/[\\^$*+?.()|[\]{}]/g,_hasRegExpMetaCharsRe=new RegExp(_regExpMetaCharsRe.source),Object.defineProperty(RegExp,"escape",{configurable:!0,writable:!0,value:function(str){var val=String(str);return val&&_hasRegExpMetaCharsRe.test(val)?val.replace(_regExpMetaCharsRe,"\\$&"):val}})),_formatRegExp=/{(\d+)(?:,([+-]?\d+))?}/g,_hasFormatRegExp=new RegExp(_formatRegExp.source),Object.defineProperty(String,"format",{configurable:!0,writable:!0,value:function(format){function padString(str,align,pad){if(!align)return str;var plen=Math.abs(align)-str.length;if(plen<1)return str;var padding=String(pad).repeat(plen);return align<0?str+padding:padding+str}if(arguments.length<2)return 0===arguments.length?"":format;var args=2===arguments.length&&Array.isArray(arguments[1])?_toConsumableArray(arguments[1]):Array.prototype.slice.call(arguments,1);return 0===args.length?format:_hasFormatRegExp.test(format)?(_formatRegExp.lastIndex=0,format.replace(_formatRegExp,(function(match,index,align){var retval=args[index];if(null==retval)return"";for(;"function"==typeof retval;)retval=retval();switch(_typeof(retval)){case"string":break;case"object":retval=JSON.stringify(retval);break;default:retval=String(retval)}return padString(retval,align?Number.parseInt(align,10):0," ")}))):format}}),Object.defineProperty(String.prototype,"contains",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.contains called on null or undefined");return-1!==String.prototype.indexOf.apply(this,arguments)}}),Object.defineProperty(String.prototype,"count",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.count called on null or undefined");var needle=String(arguments[0]||"");if(""===needle)return 0;for(var indexOf=String.prototype.indexOf,step=needle.length,pos=Number(arguments[1])||0,count=0;-1!==(pos=indexOf.call(this,needle,pos));)++count,pos+=step;return count}}),Object.defineProperty(String.prototype,"first",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.first called on null or undefined");return _getCodePointStartAndEnd(String(this),0).char}}),Object.defineProperty(String.prototype,"last",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.last called on null or undefined");var str=String(this);return _getCodePointStartAndEnd(str,str.length-1).char}}),Object.defineProperty(String.prototype,"splice",{configurable:!0,writable:!0,value:function(startAt,delCount,replacement){if(null==this)throw new TypeError("String.prototype.splice called on null or undefined");var length=this.length>>>0;if(0===length)return"";var start=Number(startAt);Number.isSafeInteger(start)?start<0&&(start+=length)<0&&(start=0):start=0,start>length&&(start=length);var count=Number(delCount);(!Number.isSafeInteger(count)||count<0)&&(count=0);var res=this.slice(0,start);return void 0!==replacement&&(res+=replacement),start+count<length&&(res+=this.slice(start+count)),res}}),Object.defineProperty(String.prototype,"splitOrEmpty",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.splitOrEmpty called on null or undefined");return""===String(this)?[]:String.prototype.split.apply(this,arguments)}}),Object.defineProperty(String.prototype,"toLocaleUpperFirst",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.toLocaleUpperFirst called on null or undefined");var str=String(this),_getCodePointStartAnd3=_getCodePointStartAndEnd(str,0),char=_getCodePointStartAnd3.char,end=_getCodePointStartAnd3.end;return-1===end?"":char.toLocaleUpperCase()+str.slice(end+1)}}),Object.defineProperty(String.prototype,"toUpperFirst",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.toUpperFirst called on null or undefined");var str=String(this),_getCodePointStartAnd4=_getCodePointStartAndEnd(str,0),char=_getCodePointStartAnd4.char,end=_getCodePointStartAnd4.end;return-1===end?"":char.toUpperCase()+str.slice(end+1)}}),Object.defineProperty(Date.prototype,"toJSON",{configurable:!0,writable:!0,value:function(){return["(revive:date)",this.toISOString()]}}),Object.defineProperty(Function.prototype,"toJSON",{configurable:!0,writable:!0,value:function(){return["(revive:eval)","(".concat(this.toString(),")")]}}),Object.defineProperty(Map.prototype,"toJSON",{configurable:!0,writable:!0,value:function(){return["(revive:map)",_toConsumableArray(this)]}}),Object.defineProperty(RegExp.prototype,"toJSON",{configurable:!0,writable:!0,value:function(){return["(revive:eval)",this.toString()]}}),Object.defineProperty(Set.prototype,"toJSON",{configurable:!0,writable:!0,value:function(){return["(revive:set)",_toConsumableArray(this)]}}),Object.defineProperty(JSON,"reviveWrapper",{configurable:!0,writable:!0,value:function(code,data){if("string"!=typeof code)throw new TypeError("JSON.reviveWrapper code parameter must be a string");return["(revive:eval)",[code,data]]}}),Object.defineProperty(JSON,"_real_stringify",{value:JSON.stringify}),Object.defineProperty(JSON,"stringify",{configurable:!0,writable:!0,value:function(_value,replacer,space){return JSON._real_stringify(_value,(function(key,val){var value=val;if("function"==typeof replacer)try{value=replacer(key,value)}catch(ex){}return void 0===value&&(value=["(revive:eval)","undefined"]),value}),space)}}),Object.defineProperty(JSON,"_real_parse",{value:JSON.parse}),Object.defineProperty(JSON,"parse",{configurable:!0,writable:!0,value:function value(text,reviver){return JSON._real_parse(text,(function(key,val){var value=val;if(Array.isArray(value)&&2===value.length)switch(value[0]){case"(revive:set)":value=new Set(value[1]);break;case"(revive:map)":value=new Map(value[1]);break;case"(revive:date)":value=new Date(value[1]);break;case"(revive:eval)":try{if(Array.isArray(value[1])){var $ReviveData$=value[1][1];value=eval(value[1][0])}else value=eval(value[1])}catch(ex){}}else if("string"==typeof value&&"@@revive@@"===value.slice(0,10))try{value=eval(value.slice(10))}catch(ex){}if("function"==typeof reviver)try{value=reviver(key,value)}catch(ex){}return value}))}}),Object.defineProperty(Array.prototype,"contains",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.contains called on null or undefined");return Array.prototype.includes.apply(this,arguments)}}),Object.defineProperty(Array.prototype,"containsAll",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.containsAll called on null or undefined");return Array.prototype.includesAll.apply(this,arguments)}}),Object.defineProperty(Array.prototype,"containsAny",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.containsAny called on null or undefined");return Array.prototype.includesAny.apply(this,arguments)}}),Object.defineProperty(Array.prototype,"flatten",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("Array.prototype.flatten called on null or undefined");return Array.prototype.flat.call(this,1/0)}}),Object.defineProperty(String.prototype,"readBracketedList",{configurable:!0,writable:!0,value:function(){if(null==this)throw new TypeError("String.prototype.readBracketedList called on null or undefined");for(var match,re=new RegExp("(?:\\[\\[((?:\\s|\\S)*?)\\]\\])|([^\"'\\s]\\S*)","gm"),names=[];null!==(match=re.exec(this));)match[1]?names.push(match[1]):match[2]&&names.push(match[2]);return names}})}();var Browser=(userAgent=navigator.userAgent.toLowerCase(),winPhone=userAgent.includes("windows phone"),isMobile=Object.freeze({Android:!winPhone&&userAgent.includes("android"),BlackBerry:/blackberry|bb10/.test(userAgent),iOS:!winPhone&&/ip(?:hone|ad|od)/.test(userAgent),Opera:!winPhone&&("object"===_typeof(window.operamini)||userAgent.includes("opera mini")),Windows:winPhone||/iemobile|wpdesktop/.test(userAgent),any:function(){return isMobile.Android||isMobile.BlackBerry||isMobile.iOS||isMobile.Opera||isMobile.Windows}}),isGecko=!isMobile.Windows&&!/khtml|trident|edge/.test(userAgent)&&userAgent.includes("gecko"),isIE=!userAgent.includes("opera")&&/msie|trident/.test(userAgent),ieVersion=isIE?(ver=/(?:msie\s+|rv:)(\d+\.\d)/.exec(userAgent))?Number(ver[1]):0:null,isOpera=userAgent.includes("opera")||userAgent.includes(" opr/"),operaVersion=isOpera?function(){var ver=new RegExp("".concat(/khtml|chrome/.test(userAgent)?"opr":"version","\\/(\\d+\\.\\d+)")).exec(userAgent);return ver?Number(ver[1]):0}():null,isVivaldi=userAgent.includes("vivaldi"),Object.freeze({userAgent:userAgent,isMobile:isMobile,isGecko:isGecko,isIE:isIE,ieVersion:ieVersion,isOpera:isOpera,operaVersion:operaVersion,isVivaldi:isVivaldi})),ver,userAgent,winPhone,isMobile,isGecko,isIE,ieVersion,isOpera,operaVersion,isVivaldi,Has=(hasAudioElement=function(){try{return"function"==typeof document.createElement("audio").canPlayType}catch(ex){}return!1}(),hasFile=function(){try{return"Blob"in window&&"File"in window&&"FileList"in window&&"FileReader"in window&&(!Browser.isOpera||Browser.operaVersion>=15)}catch(ex){}return!1}(),hasGeolocation=function(){try{return"geolocation"in navigator&&"function"==typeof navigator.geolocation.getCurrentPosition&&"function"==typeof navigator.geolocation.watchPosition}catch(ex){}return!1}(),hasMutationObserver=function(){try{return"MutationObserver"in window&&"function"==typeof window.MutationObserver}catch(ex){}return!1}(),hasPerformance=function(){try{return"performance"in window&&"function"==typeof window.performance.now}catch(ex){}return!1}(),hasTouch=function(){try{return"ontouchstart"in window||!!window.DocumentTouch&&document instanceof window.DocumentTouch||!!navigator.maxTouchPoints||!!navigator.msMaxTouchPoints}catch(ex){}return!1}(),hasTransitionEndEvent=function(){try{for(var teMap=new Map([["transition","transitionend"],["MSTransition","msTransitionEnd"],["WebkitTransition","webkitTransitionEnd"],["MozTransition","transitionend"]]),teKeys=_toConsumableArray(teMap.keys()),el=document.createElement("div"),i=0;i<teKeys.length;++i)if(el.style[teKeys[i]]!==undefined)return teMap.get(teKeys[i])}catch(ex){}return!1}(),Object.freeze({audio:hasAudioElement,fileAPI:hasFile,geolocation:hasGeolocation,mutationObserver:hasMutationObserver,performance:hasPerformance,touch:hasTouch,transitionEndEvent:hasTransitionEndEvent})),hasAudioElement,hasFile,hasGeolocation,hasMutationObserver,hasPerformance,hasTouch,hasTransitionEndEvent,Visibility=(vendor=function(){try{return Object.freeze([{hiddenProperty:"hidden",stateProperty:"visibilityState",changeEvent:"visibilitychange"},{hiddenProperty:"webkitHidden",stateProperty:"webkitVisibilityState",changeEvent:"webkitvisibilitychange"},{hiddenProperty:"mozHidden",stateProperty:"mozVisibilityState",changeEvent:"mozvisibilitychange"},{hiddenProperty:"msHidden",stateProperty:"msVisibilityState",changeEvent:"msvisibilitychange"}].find((function(vnd){return vnd.hiddenProperty in document})))}catch(ex){}return undefined}(),Object.freeze(Object.defineProperties({},{vendor:{get:function(){return vendor}},state:{get:function(){return vendor&&document[vendor.stateProperty]||"visible"}},isEnabled:{value:function(){return Boolean(vendor)}},isHidden:{value:function(){return Boolean(vendor&&document[vendor.hiddenProperty])}},hiddenProperty:{value:vendor&&vendor.hiddenProperty},stateProperty:{value:vendor&&vendor.stateProperty},changeEvent:{value:vendor&&vendor.changeEvent}}))),vendor,Fullscreen=function(){var _hasPromise,vendor=function(){try{return Object.freeze([{isEnabled:"fullscreenEnabled",element:"fullscreenElement",requestFn:"requestFullscreen",exitFn:"exitFullscreen",changeEvent:"fullscreenchange",errorEvent:"fullscreenerror"},{isEnabled:"webkitFullscreenEnabled",element:"webkitFullscreenElement",requestFn:"webkitRequestFullscreen",exitFn:"webkitExitFullscreen",changeEvent:"webkitfullscreenchange",errorEvent:"webkitfullscreenerror"},{isEnabled:"mozFullScreenEnabled",element:"mozFullScreenElement",requestFn:"mozRequestFullScreen",exitFn:"mozCancelFullScreen",changeEvent:"mozfullscreenchange",errorEvent:"mozfullscreenerror"},{isEnabled:"msFullscreenEnabled",element:"msFullscreenElement",requestFn:"msRequestFullscreen",exitFn:"msExitFullscreen",changeEvent:"MSFullscreenChange",errorEvent:"MSFullscreenError"}].find((function(vnd){return vnd.isEnabled in document})))}catch(ex){}return undefined}(),_returnsPromise=(_hasPromise=null,function(){if(null!==_hasPromise)return _hasPromise;if(_hasPromise=!1,vendor)try{var value=document.exitFullscreen();value.catch((function(){})),_hasPromise=value instanceof Promise}catch(ex){}return _hasPromise});function _selectElement(requestedEl){var selectedEl=requestedEl||document.documentElement;return selectedEl===document.documentElement&&("msRequestFullscreen"===vendor.requestFn||Browser.isOpera&&Browser.operaVersion<15)&&(selectedEl=document.body),selectedEl}function isFullscreen(){return Boolean(vendor&&document[vendor.element])}function requestFullscreen(options,requestedEl){var _this=this;if(!vendor)return Promise.reject(new Error("fullscreen not supported"));var element=_selectElement(requestedEl);if("function"!=typeof element[vendor.requestFn])return Promise.reject(new Error("fullscreen not supported"));if(isFullscreen())return Promise.resolve();if(_returnsPromise())return element[vendor.requestFn](options);var namespace=".Fullscreen_requestFullscreen";return new Promise((function(resolve,reject){jQuery(element).off(namespace).one("".concat(vendor.errorEvent).concat(namespace," ").concat(vendor.changeEvent).concat(namespace),(function(ev){jQuery(_this).off(namespace),ev.type===vendor.errorEvent?reject(new Error("unknown fullscreen request error")):resolve()})),element[vendor.requestFn](options)}))}function exitFullscreen(){var _this2=this;if(!vendor||"function"!=typeof document[vendor.exitFn])return Promise.reject(new TypeError("fullscreen not supported"));if(!isFullscreen())return Promise.reject(new TypeError("fullscreen mode not active"));if(_returnsPromise())return document[vendor.exitFn]();var namespace=".Fullscreen_exitFullscreen";return new Promise((function(resolve,reject){jQuery(document).off(namespace).one("".concat(vendor.errorEvent).concat(namespace," ").concat(vendor.changeEvent).concat(namespace),(function(ev){jQuery(_this2).off(namespace),ev.type===vendor.errorEvent?reject(new Error("unknown fullscreen exit error")):resolve()})),document[vendor.exitFn]()}))}return Object.freeze(Object.defineProperties({},{vendor:{get:function(){return vendor}},element:{get:function(){return vendor?document[vendor.element]:null}},isEnabled:{value:function(){return Boolean(vendor&&document[vendor.isEnabled])}},isFullscreen:{value:isFullscreen},request:{value:requestFullscreen},exit:{value:exitFullscreen},toggle:{value:function(options,requestedEl){return isFullscreen()?exitFullscreen():requestFullscreen(options,requestedEl)}},onChange:{value:function(handlerFn,requestedEl){if(vendor){var element=_selectElement(requestedEl);$(element).on(vendor.changeEvent,handlerFn)}}},offChange:{value:function(handlerFn,requestedEl){if(vendor){var element=_selectElement(requestedEl);handlerFn?$(element).off(vendor.changeEvent,handlerFn):$(element).off(vendor.changeEvent)}}},onError:{value:function(handlerFn,requestedEl){if(vendor){var element=_selectElement(requestedEl);$(element).on(vendor.errorEvent,handlerFn)}}},offError:{value:function(handlerFn,requestedEl){if(vendor){var element=_selectElement(requestedEl);handlerFn?$(element).off(vendor.errorEvent,handlerFn):$(element).off(vendor.errorEvent)}}}}))}(),_ref3=Object.freeze(Object.defineProperties({},{clone:{value:function clone(orig){return"object"!==_typeof(orig)||null===orig?orig:orig instanceof String?String(orig):orig instanceof Number?Number(orig):orig instanceof Boolean?Boolean(orig):"function"==typeof orig.clone?orig.clone(!0):orig.nodeType&&"function"==typeof orig.cloneNode?orig.cloneNode(!0):(orig instanceof Array?copy=new Array(orig.length):orig instanceof Date?copy=new Date(orig.getTime()):orig instanceof Map?(copy=new Map,orig.forEach((function(val,key){return copy.set(key,clone(val))}))):orig instanceof RegExp?copy=new RegExp(orig):orig instanceof Set?(copy=new Set,orig.forEach((function(val){return copy.add(clone(val))}))):copy=Object.create(Object.getPrototypeOf(orig)),Object.keys(orig).forEach((function(name){return copy[name]=clone(orig[name])})),copy);var copy}},convertBreaks:{value:function(source){for(var node,output=document.createDocumentFragment(),para=document.createElement("p");null!==(node=source.firstChild);){if(node.nodeType===Node.ELEMENT_NODE)switch(node.nodeName.toUpperCase()){case"BR":if(null!==node.nextSibling&&node.nextSibling.nodeType===Node.ELEMENT_NODE&&"BR"===node.nextSibling.nodeName.toUpperCase()){source.removeChild(node.nextSibling),source.removeChild(node),output.appendChild(para),para=document.createElement("p");continue}if(!para.hasChildNodes()){source.removeChild(node);continue}break;case"ADDRESS":case"ARTICLE":case"ASIDE":case"BLOCKQUOTE":case"CENTER":case"DIV":case"DL":case"FIGURE":case"FOOTER":case"FORM":case"H1":case"H2":case"H3":case"H4":case"H5":case"H6":case"HEADER":case"HR":case"MAIN":case"NAV":case"OL":case"P":case"PRE":case"SECTION":case"TABLE":case"UL":para.hasChildNodes()&&(output.appendChild(para),para=document.createElement("p")),output.appendChild(node);continue}para.appendChild(node)}para.hasChildNodes()&&output.appendChild(para),source.appendChild(output)}},safeActiveElement:{value:function(){try{return document.activeElement||null}catch(ex){return null}}},setDisplayTitle:{value:function(title){if("string"!=typeof title)throw new TypeError("story display title must be a string (received: ".concat(Util.getType(title),")"));var render=document.createDocumentFragment();new Wikifier(render,title);var text=function(source){for(var node,copy=source.cloneNode(!0),frag=document.createDocumentFragment();null!==(node=copy.firstChild);){if(node.nodeType===Node.ELEMENT_NODE)switch(node.nodeName.toUpperCase()){case"BR":case"DIV":case"P":frag.appendChild(document.createTextNode(" "))}frag.appendChild(node)}return frag.textContent}(render).trim();document.title=Config.passages.displayTitles&&""!==State.passage&&State.passage!==Config.passages.start?"".concat(State.passage," | ").concat(text):text;var storyTitle=document.getElementById("story-title");null!==storyTitle&&jQuery(storyTitle).empty().append(render)}},setPageElement:{value:function(idOrElement,titles,defaultText){var el="object"===_typeof(idOrElement)?idOrElement:document.getElementById(idOrElement);if(null==el)return null;var ids=Array.isArray(titles)?titles:[titles];jQuery(el).empty();for(var i=0,iend=ids.length;i<iend;++i)if(Story.has(ids[i]))return new Wikifier(el,Story.get(ids[i]).processText().trim()),el;if(null!=defaultText){var text=String(defaultText).trim();""!==text&&new Wikifier(el,text)}return el}},throwError:{value:function(place,message,source){var $wrapper=jQuery(document.createElement("div")),$toggle=jQuery(document.createElement("button")),$source=jQuery(document.createElement("pre")),mesg="".concat(L10n.get("errorTitle"),": ").concat(message||"unknown error");return $toggle.addClass("error-toggle").ariaClick({label:L10n.get("errorToggle")},(function(){$toggle.hasClass("enabled")?($toggle.removeClass("enabled"),$source.attr({"aria-hidden":!0,hidden:"hidden"})):($toggle.addClass("enabled"),$source.removeAttr("aria-hidden hidden"))})).appendTo($wrapper),jQuery(document.createElement("span")).addClass("error").text(mesg).appendTo($wrapper),jQuery(document.createElement("code")).text(source).appendTo($source),$source.addClass("error-source").attr({"aria-hidden":!0,hidden:"hidden"}).appendTo($wrapper),$wrapper.addClass("error-view").appendTo(place),console.warn("".concat(mesg,"\n\t").concat(source.replace(/\n/g,"\n\t"))),!1}},stringFrom:{value:function stringFrom(value){switch(_typeof(value)){case"function":return"[function]";case"number":if(Number.isNaN(value))return"[number NaN]";break;case"object":if(null===value)return"[null]";if(value instanceof Array)return value.map((function(val){return stringFrom(val)})).join(", ");if(value instanceof Set)return Array.from(value).map((function(val){return stringFrom(val)})).join(", ");if(value instanceof Map){var result=Array.from(value).map((function(_ref4){var _ref5=_slicedToArray(_ref4,2),key=_ref5[0],val=_ref5[1];return"".concat(stringFrom(key)," → ").concat(stringFrom(val))}));return"{ ".concat(result.join(", ")," }")}if(value instanceof Date)return value.toLocaleString();if(value instanceof Element){if(value===document.documentElement||value===document.head||value===document.body)throw new Error("illegal operation; attempting to convert the <html>, <head>, or <body> tags to string is not allowed");return value.outerHTML}return value instanceof Node?value.textContent:"function"==typeof value.toString?value.toString():Object.prototype.toString.call(value);case"symbol":var desc=void 0!==value.description?' "'.concat(value.description,'"'):"";return"[symbol".concat(desc,"]");case"undefined":return"[undefined]"}return String(value)}}})),clone=_ref3.clone,convertBreaks=_ref3.convertBreaks,safeActiveElement=_ref3.safeActiveElement,setDisplayTitle=_ref3.setDisplayTitle,setPageElement=_ref3.setPageElement,throwError=_ref3.throwError,stringFrom=_ref3.stringFrom;!function(){function onKeypressFn(ev){13!==ev.which&&32!==ev.which||(ev.preventDefault(),jQuery(safeActiveElement()||this).trigger("click"))}function onClickFnWrapper(fn){return function(){var $this=jQuery(this);$this.ariaIsDisabled()||($this.is("[aria-pressed]")&&$this.attr("aria-pressed","true"===$this.attr("aria-pressed")?"false":"true"),fn.apply(this,arguments))}}function oneClickFnWrapper(fn){return onClickFnWrapper((function(){jQuery(this).off(".aria-clickable").removeAttr("role tabindex aria-controls aria-pressed").filter("button").prop("disabled",!0),fn.apply(this,arguments)}))}jQuery.fn.extend({ariaClick:function(options,handler){if(0===this.length||0===arguments.length)return this;var opts=options,fn=handler;return null==fn&&(fn=opts,opts=undefined),"string"!=typeof(opts=jQuery.extend({namespace:undefined,one:!1,selector:undefined,data:undefined,role:undefined,controls:undefined,pressed:undefined,label:undefined},opts)).namespace?opts.namespace="":"."!==opts.namespace[0]&&(opts.namespace=".".concat(opts.namespace)),"boolean"==typeof opts.pressed&&(opts.pressed=opts.pressed?"true":"false"),this.filter("button").prop("type","button"),null!=opts.role?this.attr("role",opts.role):this.not("[role]").filter("a,[data-passage]").attr("role","link").end().not("a").not("[data-passage]").attr("role","button").end().end().end(),this.attr("tabindex",0),null!=opts.controls&&this.attr("aria-controls",opts.controls),null!=opts.pressed&&this.attr("aria-pressed",opts.pressed),null!=opts.label&&this.attr({"aria-label":opts.label,title:opts.label}),this.not("button").on("keypress.aria-clickable".concat(opts.namespace),opts.selector,onKeypressFn),this.on("click.aria-clickable".concat(opts.namespace),opts.selector,opts.data,opts.one?oneClickFnWrapper(fn):onClickFnWrapper(fn)),this},ariaDisabled:function(disable){if(0===this.length||0===arguments.length)return this;var $nonDisableable=this.not("button,fieldset,input,menuitem,optgroup,option,select,textarea"),$disableable=this.filter("button,fieldset,input,menuitem,optgroup,option,select,textarea");return disable?($nonDisableable.each((function(){this.setAttribute("disabled",""),this.setAttribute("aria-disabled","true")})),$disableable.each((function(){this.disabled=!0,this.setAttribute("aria-disabled","true")}))):($nonDisableable.each((function(){this.removeAttribute("disabled"),this.removeAttribute("aria-disabled")})),$disableable.each((function(){this.disabled=!1,this.removeAttribute("aria-disabled")}))),this},ariaIsDisabled:function(){return this.is("[disabled]")}})}(),jQuery.extend({wikiWithOptions:function(options){for(var _len=arguments.length,sources=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)sources[_key-1]=arguments[_key];if(0!==sources.length){var frag=document.createDocumentFragment();sources.forEach((function(content){return new Wikifier(frag,content,options)}));var errors=_toConsumableArray(frag.querySelectorAll(".error")).map((function(errEl){return errEl.textContent.replace(errorPrologRegExp,"")}));if(errors.length>0)throw new Error(errors.join("; "))}},wiki:function(){for(var _len2=arguments.length,sources=new Array(_len2),_key2=0;_key2<_len2;_key2++)sources[_key2]=arguments[_key2];this.wikiWithOptions.apply(this,[undefined].concat(sources))}}),jQuery.fn.extend({wikiWithOptions:function(options){for(var _len3=arguments.length,sources=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++)sources[_key3-1]=arguments[_key3];if(0===this.length||0===sources.length)return this;var frag=document.createDocumentFragment();return sources.forEach((function(content){return new Wikifier(frag,content,options)})),this.append(frag),this},wiki:function(){for(var _len4=arguments.length,sources=new Array(_len4),_key4=0;_key4<_len4;_key4++)sources[_key4]=arguments[_key4];return this.wikiWithOptions.apply(this,[undefined].concat(sources))}});var Util=function(){var toString,utilGetType="[object Object]"===(toString=Object.prototype.toString).call(new Map)?function(O){if(null===O)return"null";if(O instanceof Map)return"Map";if(O instanceof Set)return"Set";var baseType=_typeof(O);return"object"===baseType?toString.call(O).slice(8,-1):baseType}:function(O){if(null===O)return"null";var baseType=_typeof(O);return"object"===baseType?toString.call(O).slice(8,-1):baseType};function utilToEnum(obj){var pEnum=Object.create(null);if(obj instanceof Array)obj.forEach((function(val,i){return pEnum[String(val)]=i}));else if(obj instanceof Set)Array.from(obj).forEach((function(val,i){return pEnum[String(val)]=i}));else if(obj instanceof Map)obj.forEach((function(val,key){return pEnum[String(key)]=val}));else{if("object"!==_typeof(obj)||null===obj||Object.getPrototypeOf(obj)!==Object.prototype)throw new TypeError("Util.toEnum obj parameter must be an Array, Map, Set, or generic object");Object.assign(pEnum,obj)}return Object.freeze(pEnum)}function utilToStringTag(obj){return Object.prototype.toString.call(obj).slice(8,-1)}var _illegalSlugCharsRe=/[\x00-\x20!-/:-@[-^`{-\x9f]+/g,_isInvalidSlugRe=/^-*$/;var _illegalFilenameCharsRE=/[\x00-\x1f"#$%&'*+,/:;<=>?\\^`|\x7f-\x9f]+/g;var _markupCharsRe=/[!"#$&'*\-/<=>?@[\\\]^_`{|}~]/g,_hasMarkupCharsRe=new RegExp(_markupCharsRe.source),_markupCharsMap=utilToEnum({"!":"&#33;",'"':"&quot;","#":"&#35;",$:"&#36;","&":"&amp;","'":"&#39;","*":"&#42;","-":"&#45;","/":"&#47;","<":"&lt;","=":"&#61;",">":"&gt;","?":"&#63;","@":"&#64;","[":"&#91;","\\":"&#92;","]":"&#93;","^":"&#94;",_:"&#95;","`":"&#96;","{":"&#123;","|":"&#124;","}":"&#125;","~":"&#126;"});var _htmlCharsRe=/[&<>"'`]/g,_hasHtmlCharsRe=new RegExp(_htmlCharsRe.source),_htmlCharsMap=utilToEnum({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"});function utilEscape(str){if(null==str)return"";var val=String(str);return val&&_hasHtmlCharsRe.test(val)?val.replace(_htmlCharsRe,(function(ch){return _htmlCharsMap[ch]})):val}var _escapedHtmlRe=/&(?:amp|#38|#x26|lt|#60|#x3c|gt|#62|#x3e|quot|#34|#x22|apos|#39|#x27|#96|#x60);/gi,_hasEscapedHtmlRe=new RegExp(_escapedHtmlRe.source,"i"),_escapedHtmlMap=utilToEnum({"&amp;":"&","&#38;":"&","&#x26;":"&","&lt;":"<","&#60;":"<","&#x3c;":"<","&gt;":">","&#62;":">","&#x3e;":">","&quot;":'"',"&#34;":'"',"&#x22;":'"',"&apos;":"'","&#39;":"'","&#x27;":"'","&#96;":"`","&#x60;":"`"});function utilUnescape(str){if(null==str)return"";var val=String(str);return val&&_hasEscapedHtmlRe.test(val)?val.replace(_escapedHtmlRe,(function(entity){return _escapedHtmlMap[entity.toLowerCase()]})):val}var _nowSource=Has.performance?performance:Date;var _cssTimeRe=/^([+-]?(?:\d*\.)?\d+)([Mm]?[Ss])$/;var utilScrubEventKey=function(){var separatorKey,decimalKey;if("undefined"!=typeof Intl&&"function"==typeof Intl.NumberFormat){var match=(new Intl.NumberFormat).format(111111.5).match(/(\D*)\d+(\D*)/);match&&(separatorKey=match[1],decimalKey=match[2])}return separatorKey||decimalKey||(separatorKey=",",decimalKey="."),function(key){switch(key){case"Scroll":return"ScrollLock";case"Spacebar":return" ";case"Left":return"ArrowLeft";case"Right":return"ArrowRight";case"Up":return"ArrowUp";case"Down":return"ArrowDown";case"Del":return"Delete";case"Crsel":return"CrSel";case"Exsel":return"ExSel";case"Esc":return"Escape";case"Apps":return"ContextMenu";case"Nonconvert":return"NonConvert";case"MediaNextTrack":return"MediaTrackNext";case"MediaPreviousTrack":return"MediaTrackPrevious";case"VolumeUp":return"AudioVolumeUp";case"VolumeDown":return"AudioVolumeDown";case"VolumeMute":return"AudioVolumeMute";case"Zoom":return"ZoomToggle";case"SelectMedia":case"MediaSelect":return"LaunchMediaPlayer";case"Add":return"+";case"Divide":return"/";case"Multiply":return"*";case"Subtract":return"-";case"Decimal":return decimalKey;case"Separator":return separatorKey}return key}}(),utilHasMediaQuery="function"!=typeof window.matchMedia?function(){return!1}:function(mediaQuery){return window.matchMedia(mediaQuery).matches};return Object.freeze(Object.defineProperties({},{getType:{value:utilGetType},isBoolean:{value:function(obj){return"boolean"==typeof obj||"string"==typeof obj&&("true"===obj||"false"===obj)}},isIterable:{value:function(obj){return null!=obj&&"function"==typeof obj[Symbol.iterator]}},isNumeric:{value:function(obj){var num;switch(_typeof(obj)){case"number":num=obj;break;case"string":num=Number(obj);break;default:return!1}return!Number.isNaN(num)&&Number.isFinite(num)}},sameValueZero:{value:function(a,b){return a===b||a!=a&&b!=b}},toEnum:{value:utilToEnum},toStringTag:{value:utilToStringTag},slugify:{value:function(str){var base=String(str).trim(),_legacy=base.replace(/[^\w\s\u2013\u2014-]+/g,"").replace(/[_\s\u2013\u2014-]+/g,"-").toLocaleLowerCase();return _isInvalidSlugRe.test(_legacy)?base.replace(_illegalSlugCharsRe,"").replace(/[_\s\u2013\u2014-]+/g,"-"):_legacy}},sanitizeFilename:{value:function(str){return String(str).trim().replace(_illegalFilenameCharsRE,"")}},escapeMarkup:{value:function(str){if(null==str)return"";var val=String(str);return val&&_hasMarkupCharsRe.test(val)?val.replace(_markupCharsRe,(function(ch){return _markupCharsMap[ch]})):val}},escape:{value:utilEscape},unescape:{value:utilUnescape},charAndPosAt:{value:function(text,position){var str=String(text),pos=Math.trunc(position),code=str.charCodeAt(pos);if(Number.isNaN(code))return{char:"",start:-1,end:-1};var retval={char:str.charAt(pos),start:pos,end:pos};if(code<55296||code>57343)return retval;if(code>=55296&&code<=56319){var nextPos=pos+1;if(nextPos>=str.length)return retval;var nextCode=str.charCodeAt(nextPos);return nextCode<56320||nextCode>57343||(retval.char=retval.char+str.charAt(nextPos),retval.end=nextPos),retval}if(0===pos)return retval;var prevPos=pos-1,prevCode=str.charCodeAt(prevPos);return prevCode<55296||prevCode>56319||(retval.char=str.charAt(prevPos)+retval.char,retval.start=prevPos),retval}},now:{value:function(){return _nowSource.now()}},fromCssTime:{value:function(cssTime){var match=_cssTimeRe.exec(String(cssTime));if(null===match)throw new SyntaxError('invalid time value syntax: "'.concat(cssTime,'"'));var msec=Number(match[1]);if(1===match[2].length&&(msec*=1e3),Number.isNaN(msec)||!Number.isFinite(msec))throw new RangeError('invalid time value: "'.concat(cssTime,'"'));return msec}},toCssTime:{value:function(msec){if("number"!=typeof msec||Number.isNaN(msec)||!Number.isFinite(msec)){var what;switch(_typeof(msec)){case"string":what='"'.concat(msec,'"');break;case"number":what=String(msec);break;default:what=utilToStringTag(msec)}throw new Error("invalid milliseconds: ".concat(what))}return"".concat(msec,"ms")}},fromCssProperty:{value:function(cssName){if(!cssName.includes("-"))switch(cssName){case"bgcolor":return"backgroundColor";case"float":return"cssFloat";default:return cssName}return("-ms-"===cssName.slice(0,4)?cssName.slice(1):cssName).split("-").map((function(part,i){return 0===i?part:part.toUpperFirst()})).join("")}},parseUrl:{value:function(url){var el=document.createElement("a"),queryObj=Object.create(null);el.href=url,el.search&&el.search.replace(/^\?/,"").splitOrEmpty(/(?:&(?:amp;)?|;)/).forEach((function(query){var _query$split2=_slicedToArray(query.split("="),2),key=_query$split2[0],value=_query$split2[1];queryObj[key]=value}));var pathname=el.host&&"/"!==el.pathname[0]?"/".concat(el.pathname):el.pathname;return{href:el.href,protocol:el.protocol,host:el.host,hostname:el.hostname,port:el.port,path:"".concat(pathname).concat(el.search),pathname:pathname,query:el.search,search:el.search,queries:queryObj,searches:queryObj,hash:el.hash}}},newExceptionFrom:{value:function(original,exceptionType,override){if("object"!==_typeof(original)||null===original)throw new Error("Util.newExceptionFrom original parameter must be an object");if("function"!=typeof exceptionType)throw new Error("Util.newExceptionFrom exceptionType parameter must be an error type constructor");var ex=new exceptionType(original.message);void 0!==original.name&&(ex.name=original.name),void 0!==original.code&&(ex.code=original.code),void 0!==original.columnNumber&&(ex.columnNumber=original.columnNumber),void 0!==original.description&&(ex.description=original.description),void 0!==original.fileName&&(ex.fileName=original.fileName),void 0!==original.lineNumber&&(ex.lineNumber=original.lineNumber),void 0!==original.number&&(ex.number=original.number),void 0!==original.stack&&(ex.stack=original.stack);var overrideType=_typeof(override);if("undefined"!==overrideType)if("object"===overrideType&&null!==override)Object.assign(ex,override);else{if("string"!==overrideType)throw new Error("Util.newExceptionFrom override parameter must be an object or string");ex.message=override}return ex}},scrubEventKey:{value:utilScrubEventKey},hasMediaQuery:{value:utilHasMediaQuery},random:{value:Math.random},entityEncode:{value:utilEscape},entityDecode:{value:utilUnescape},evalExpression:{value:function(){return Scripting.evalJavaScript.apply(Scripting,arguments)}},evalStatements:{value:function(){return Scripting.evalJavaScript.apply(Scripting,arguments)}}}))}(),SimpleStore=(_adapters=[],_initialized=null,Object.freeze(Object.defineProperties({},{adapters:{value:_adapters},create:{value:function(storageId,persistent){if(_initialized)return _initialized.create(storageId,persistent);for(var i=0;i<_adapters.length;++i)if(_adapters[i].init(storageId,persistent))return(_initialized=_adapters[i]).create(storageId,persistent);throw new Error("no valid storage adapters found")}}}))),_adapters,_initialized,_ok,_WebStorageAdapter;SimpleStore.adapters.push((_ok=!1,_WebStorageAdapter=function(){function _WebStorageAdapter(storageId,persistent){_classCallCheck(this,_WebStorageAdapter);var prefix="".concat(storageId,"."),engine=null,name=null;persistent?(engine=window.localStorage,name="localStorage"):(engine=window.sessionStorage,name="sessionStorage"),Object.defineProperties(this,{_engine:{value:engine},_prefix:{value:prefix},_prefixRe:{value:new RegExp("^".concat(RegExp.escape(prefix)))},name:{value:name},id:{value:storageId},persistent:{value:!!persistent}})}return _createClass(_WebStorageAdapter,[{key:"length",get:function(){return this.keys().length}},{key:"size",value:function(){return this.keys().length}},{key:"keys",value:function(){for(var keys=[],i=0;i<this._engine.length;++i){var key=this._engine.key(i);this._prefixRe.test(key)&&keys.push(key.replace(this._prefixRe,""))}return keys}},{key:"has",value:function(key){return!("string"!=typeof key||!key)&&this._engine.hasOwnProperty(this._prefix+key)}},{key:"get",value:function(key){if("string"!=typeof key||!key)return null;var value=this._engine.getItem(this._prefix+key);return null==value?null:_WebStorageAdapter._deserialize(value)}},{key:"set",value:function(key,value){if("string"!=typeof key||!key)return!1;try{this._engine.setItem(this._prefix+key,_WebStorageAdapter._serialize(value))}catch(ex){if(/quota.?(?:exceeded|reached)/i.test(ex.name+ex.message))throw Util.newExceptionFrom(ex,Error,"".concat(this.name," quota exceeded"));throw ex}return!0}},{key:"delete",value:function(key){return!("string"!=typeof key||!key||(this._engine.removeItem(this._prefix+key),0))}},{key:"clear",value:function(){for(var keys=this.keys(),i=0,iend=keys.length;i<iend;++i)this.delete(keys[i]);return!0}}],[{key:"_serialize",value:function(obj){return LZString.compressToUTF16(JSON.stringify(obj))}},{key:"_deserialize",value:function(str){return JSON.parse(LZString.decompressFromUTF16(str))}}]),_WebStorageAdapter}(),Object.freeze(Object.defineProperties({},{init:{value:function(){function hasWebStorage(storeId){try{var store=window[storeId],tid="_sc_".concat(String(Date.now()));store.setItem(tid,tid);var result=store.getItem(tid)===tid;return store.removeItem(tid),result}catch(ex){}return!1}return _ok=hasWebStorage("localStorage")&&hasWebStorage("sessionStorage")}},create:{value:function(storageId,persistent){if(!_ok)throw new Error("adapter not initialized");return new _WebStorageAdapter(storageId,persistent)}}})))),SimpleStore.adapters.push(function(){var _MAX_EXPIRY="Tue, 19 Jan 2038 03:14:07 GMT",_MIN_EXPIRY="Thu, 01 Jan 1970 00:00:00 GMT",_ok=!1,_CookieAdapter=function(){function _CookieAdapter(storageId,persistent){_classCallCheck(this,_CookieAdapter);var prefix="".concat(storageId).concat(persistent?"!":"*",".");Object.defineProperties(this,{_prefix:{value:prefix},_prefixRe:{value:new RegExp("^".concat(RegExp.escape(prefix)))},name:{value:"cookie"},id:{value:storageId},persistent:{value:!!persistent}})}return _createClass(_CookieAdapter,[{key:"length",get:function(){return this.keys().length}},{key:"size",value:function(){return this.keys().length}},{key:"keys",value:function(){if(""===document.cookie)return[];for(var cookies=document.cookie.split(/;\s*/),keys=[],i=0;i<cookies.length;++i){var kvPair=cookies[i].split("="),key=decodeURIComponent(kvPair[0]);if(this._prefixRe.test(key))""!==decodeURIComponent(kvPair[1])&&keys.push(key.replace(this._prefixRe,""))}return keys}},{key:"has",value:function(key){return!("string"!=typeof key||!key)&&null!==_CookieAdapter._getCookie(this._prefix+key)}},{key:"get",value:function(key){if("string"!=typeof key||!key)return null;var value=_CookieAdapter._getCookie(this._prefix+key);return null===value?null:_CookieAdapter._deserialize(value)}},{key:"set",value:function(key,value){if("string"!=typeof key||!key)return!1;try{if(_CookieAdapter._setCookie(this._prefix+key,_CookieAdapter._serialize(value),this.persistent?"Tue, 19 Jan 2038 03:14:07 GMT":undefined),!this.has(key))throw new Error("unknown validation error during set")}catch(ex){throw Util.newExceptionFrom(ex,Error,"cookie error: ".concat(ex.message))}return!0}},{key:"delete",value:function(key){if("string"!=typeof key||!key||!this.has(key))return!1;try{if(_CookieAdapter._setCookie(this._prefix+key,undefined,_MIN_EXPIRY),this.has(key))throw new Error("unknown validation error during delete")}catch(ex){throw Util.newExceptionFrom(ex,Error,"cookie error: ".concat(ex.message))}return!0}},{key:"clear",value:function(){for(var keys=this.keys(),i=0,iend=keys.length;i<iend;++i)this.delete(keys[i]);return!0}}],[{key:"_getCookie",value:function(prefixedKey){if(!prefixedKey||""===document.cookie)return null;for(var cookies=document.cookie.split(/;\s*/),i=0;i<cookies.length;++i){var kvPair=cookies[i].split("=");if(prefixedKey===decodeURIComponent(kvPair[0]))return decodeURIComponent(kvPair[1])||null}return null}},{key:"_setCookie",value:function(prefixedKey,value,expiry){if(prefixedKey){var payload="".concat(encodeURIComponent(prefixedKey),"=");null!=value&&(payload+=encodeURIComponent(value)),null!=expiry&&(payload+="; expires=".concat(expiry)),payload+="; path=/",document.cookie=payload}}},{key:"_serialize",value:function(obj){return LZString.compressToBase64(JSON.stringify(obj))}},{key:"_deserialize",value:function(str){return JSON.parse(LZString.decompressFromBase64(str))}}]),_CookieAdapter}();return Object.freeze(Object.defineProperties({},{init:{value:function(storageId){try{var tid="_sc_".concat(String(Date.now()));_CookieAdapter._setCookie(tid,_CookieAdapter._serialize(tid),undefined),_ok=_CookieAdapter._deserialize(_CookieAdapter._getCookie(tid))===tid,_CookieAdapter._setCookie(tid,undefined,_MIN_EXPIRY)}catch(ex){_ok=!1}return _ok&&function(storageId){if(""===document.cookie)return;for(var oldPrefix="".concat(storageId,"."),oldPrefixRe=new RegExp("^".concat(RegExp.escape(oldPrefix))),persistPrefix="".concat(storageId,"!."),sessionPrefix="".concat(storageId,"*."),sessionTestRe=/\.(?:state|rcWarn)$/,cookies=document.cookie.split(/;\s*/),i=0;i<cookies.length;++i){var kvPair=cookies[i].split("="),key=decodeURIComponent(kvPair[0]);if(oldPrefixRe.test(key)){var value=decodeURIComponent(kvPair[1]);""!==value&&function(){var persist=!sessionTestRe.test(key);_CookieAdapter._setCookie(key,undefined,_MIN_EXPIRY),_CookieAdapter._setCookie(key.replace(oldPrefixRe,(function(){return persist?persistPrefix:sessionPrefix})),value,persist?_MAX_EXPIRY:undefined)}()}}}(storageId),_ok}},create:{value:function(storageId,persistent){if(!_ok)throw new Error("adapter not initialized");return new _CookieAdapter(storageId,persistent)}}}))}());var DebugView=function(){function DebugView(parent,type,name,title){_classCallCheck(this,DebugView),Object.defineProperties(this,{parent:{value:parent},view:{value:document.createElement("span")},break:{value:document.createElement("wbr")}}),jQuery(this.view).attr({title:title,"aria-label":title,"data-type":null!=type?type:"","data-name":null!=name?name:""}).addClass("debug"),jQuery(this.break).addClass("debug hidden"),this.parent.appendChild(this.view),this.parent.appendChild(this.break)}return _createClass(DebugView,[{key:"output",get:function(){return this.view}},{key:"type",get:function(){return this.view.getAttribute("data-type")},set:function(type){this.view.setAttribute("data-type",null!=type?type:"")}},{key:"name",get:function(){return this.view.getAttribute("data-name")},set:function(name){this.view.setAttribute("data-name",null!=name?name:"")}},{key:"title",get:function(){return this.view.title},set:function(title){this.view.title=title}},{key:"append",value:function(el){return jQuery(this.view).append(el),this}},{key:"modes",value:function(options){if(null==options){var current={};return this.view.className.splitOrEmpty(/\s+/).forEach((function(name){"debug"!==name&&(current[name]=!0)})),current}if("object"===_typeof(options))return Object.keys(options).forEach((function(name){this[options[name]?"addClass":"removeClass"](name)}),jQuery(this.view)),this;throw new Error("DebugView.prototype.modes options parameter must be an object or null/undefined")}},{key:"remove",value:function(){var $view=jQuery(this.view);this.view.hasChildNodes()&&$view.contents().appendTo(this.parent),$view.remove(),jQuery(this.break).remove()}}],[{key:"isEnabled",value:function(){return"enabled"===jQuery(document.documentElement).attr("data-debug-view")}},{key:"enable",value:function(){jQuery(document.documentElement).attr("data-debug-view","enabled"),jQuery.event.trigger(":debugviewupdate")}},{key:"disable",value:function(){jQuery(document.documentElement).removeAttr("data-debug-view"),jQuery.event.trigger(":debugviewupdate")}},{key:"toggle",value:function(){"enabled"===jQuery(document.documentElement).attr("data-debug-view")?DebugView.disable():DebugView.enable()}}]),DebugView}(),NodeTyper=function(){var NodeTyper=function(){function NodeTyper(config){if(_classCallCheck(this,NodeTyper),"object"!==_typeof(config)||null===config)throw new Error("config parameter must be an object (received: ".concat(Util.getType(config),")"));if(!(config.hasOwnProperty("targetNode")&&config.targetNode instanceof Node))throw new Error('config parameter object "targetNode" property must be a node');Object.defineProperties(this,{node:{value:config.targetNode},childNodes:{value:[]},nodeValue:{writable:!0,value:""},appendTo:{writable:!0,value:config.parentNode||null},classNames:{writable:!0,value:config.classNames||null},finished:{writable:!0,value:!1}});var childNode,node=this.node;for(node.nodeValue&&(this.nodeValue=node.nodeValue,node.nodeValue="");null!==(childNode=node.firstChild);)this.childNodes.push(new NodeTyper({targetNode:childNode,parentNode:node,classNames:this.classNames})),node.removeChild(childNode)}return _createClass(NodeTyper,[{key:"finish",value:function(){for(;this.type(!0););return!1}},{key:"type",value:function(flush){if(this.finished)return!1;if(this.appendTo){if(this.appendTo.appendChild(this.node),this.appendTo=null,this.node.nodeType!==Node.ELEMENT_NODE&&this.node.nodeType!==Node.TEXT_NODE||"none"===jQuery(this.node.parentNode).css("display"))return this.finish();this.node.parentNode&&this.classNames&&jQuery(this.node.parentNode).addClass(this.classNames)}if(this.nodeValue){if(flush)this.node.nodeValue+=this.nodeValue,this.nodeValue="";else{var _Util$charAndPosAt=Util.charAndPosAt(this.nodeValue,0),char=_Util$charAndPosAt.char,start=_Util$charAndPosAt.start,end=_Util$charAndPosAt.end;this.node.nodeValue+=char,this.nodeValue=this.nodeValue.slice(1+end-start)}return!0}this.classNames&&(jQuery(this.node.parentNode).removeClass(this.classNames),this.classNames=null);for(var childNodes=this.childNodes;childNodes.length>0;){if(childNodes[0].type())return!0;childNodes.shift()}return this.finished=!0,!1}}]),NodeTyper}();return NodeTyper}(),PRNGWrapper=function(){function PRNGWrapper(seed,useEntropy){_classCallCheck(this,PRNGWrapper),Object.defineProperties(this,new Math.seedrandom(seed,useEntropy,(function(prng,seed){return{_prng:{value:prng},seed:{writable:!0,value:seed},pull:{writable:!0,value:0},random:{value:function(){return++this.pull,this._prng()}}}})))}return _createClass(PRNGWrapper,null,[{key:"marshal",value:function(prng){if(!prng||!prng.hasOwnProperty("seed")||!prng.hasOwnProperty("pull"))throw new Error("PRNG is missing required data");return{seed:prng.seed,pull:prng.pull}}},{key:"unmarshal",value:function(prngObj){if(!prngObj||!prngObj.hasOwnProperty("seed")||!prngObj.hasOwnProperty("pull"))throw new Error("PRNG object is missing required data");for(var prng=new PRNGWrapper(prngObj.seed,!1),i=prngObj.pull;i>0;--i)prng.random();return prng}}]),PRNGWrapper}(),StyleWrapper=(_imageMarkupRe=new RegExp(Patterns.cssImage,"g"),_hasImageMarkupRe=new RegExp(Patterns.cssImage),function(){function StyleWrapper(style){if(_classCallCheck(this,StyleWrapper),null==style)throw new TypeError("StyleWrapper style parameter must be an HTMLStyleElement object");Object.defineProperties(this,{style:{value:style}})}return _createClass(StyleWrapper,[{key:"isEmpty",value:function(){return 0===this.style.cssRules.length}},{key:"set",value:function(rawCss){this.clear(),this.add(rawCss)}},{key:"add",value:function(rawCss){var css=rawCss;_hasImageMarkupRe.test(css)&&(_imageMarkupRe.lastIndex=0,css=css.replace(_imageMarkupRe,(function(wikiImage){var markup=Wikifier.helpers.parseSquareBracketedMarkup({source:wikiImage,matchStart:0});if(markup.hasOwnProperty("error")||markup.pos<wikiImage.length)return wikiImage;var source=markup.source;if("data:"!==source.slice(0,5)&&Story.has(source)){var passage=Story.get(source);passage.tags.includes("Twine.image")&&(source=passage.text.trim())}return'url("'.concat(source.replace(/"/g,"%22"),'")')}))),this.style.styleSheet?this.style.styleSheet.cssText+=css:this.style.appendChild(document.createTextNode(css))}},{key:"clear",value:function(){this.style.styleSheet?this.style.styleSheet.cssText="":jQuery(this.style).empty()}}]),StyleWrapper}()),_imageMarkupRe,_hasImageMarkupRe,Diff=(Op=Util.toEnum({Delete:0,SpliceArray:1,Copy:2,CopyDate:3}),Object.freeze(Object.defineProperties({},{Op:{value:Op},diff:{value:function diff(orig,dest){for(var aOpRef,objToString=Object.prototype.toString,origIsArray=orig instanceof Array,keys=[].concat(Object.keys(orig),Object.keys(dest)).sort().filter((function(val,i,arr){return 0===i||arr[i-1]!==val})),diffed={},keyIsAOpRef=function(key){return key===aOpRef},i=0,klen=keys.length;i<klen;++i){var key=keys[i],origP=orig[key],destP=dest[key];if(orig.hasOwnProperty(key))if(dest.hasOwnProperty(key)){if(origP===destP)continue;if(_typeof(origP)===_typeof(destP))if("function"==typeof origP)origP.toString()!==destP.toString()&&(diffed[key]=[Op.Copy,destP]);else if("object"!==_typeof(origP)||null===origP)diffed[key]=[Op.Copy,destP];else{var origPType=objToString.call(origP);if(origPType===objToString.call(destP))if(origP instanceof Date)Number(origP)!==Number(destP)&&(diffed[key]=[Op.Copy,clone(destP)]);else if(origP instanceof Map)diffed[key]=[Op.Copy,clone(destP)];else if(origP instanceof RegExp)origP.toString()!==destP.toString()&&(diffed[key]=[Op.Copy,clone(destP)]);else if(origP instanceof Set)diffed[key]=[Op.Copy,clone(destP)];else if("[object Object]"!==origPType)diffed[key]=[Op.Copy,clone(destP)];else{var recurse=diff(origP,destP);null!==recurse&&(diffed[key]=recurse)}else diffed[key]=[Op.Copy,clone(destP)]}else diffed[key]=[Op.Copy,"object"!==_typeof(destP)||null===destP?destP:clone(destP)]}else if(origIsArray&&Util.isNumeric(key)){var nKey=Number(key);if(!aOpRef){aOpRef="";do{aOpRef+="~"}while(keys.some(keyIsAOpRef));diffed[aOpRef]=[Op.SpliceArray,nKey,nKey]}nKey<diffed[aOpRef][1]&&(diffed[aOpRef][1]=nKey),nKey>diffed[aOpRef][2]&&(diffed[aOpRef][2]=nKey)}else diffed[key]=Op.Delete;else diffed[key]=[Op.Copy,"object"!==_typeof(destP)||null===destP?destP:clone(destP)]}return Object.keys(diffed).length>0?diffed:null}},patch:{value:function patch(orig,diffed){for(var keys=Object.keys(diffed||{}),patched=clone(orig),i=0,klen=keys.length;i<klen;++i){var key=keys[i],diffedP=diffed[key];if(diffedP===Op.Delete)delete patched[key];else if(diffedP instanceof Array)switch(diffedP[0]){case Op.SpliceArray:patched.splice(diffedP[1],diffedP[2]-diffedP[1]+1);break;case Op.Copy:patched[key]=clone(diffedP[1]);break;case Op.CopyDate:patched[key]=new Date(diffedP[1])}else patched[key]=patch(patched[key],diffedP)}return patched}}}))),Op,L10n=(_patternRe=/\{\w+\}/g,_hasPatternRe=new RegExp(_patternRe.source),Object.freeze(Object.defineProperties({},{init:{value:function(){strings&&Object.keys(strings).length>0&&Object.keys(l10nStrings).forEach((function(id){try{var value;switch(id){case"identity":value=strings.identity;break;case"aborting":value=strings.aborting;break;case"cancel":value=strings.cancel;break;case"close":value=strings.close;break;case"ok":value=strings.ok;break;case"errorTitle":value=strings.errors.title;break;case"errorNonexistentPassage":value=strings.errors.nonexistentPassage;break;case"errorSaveMissingData":value=strings.errors.saveMissingData;break;case"errorSaveIdMismatch":value=strings.errors.saveIdMismatch;break;case"warningDegraded":value=strings.warnings.degraded;break;case"debugViewTitle":value=strings.debugView.title;break;case"debugViewToggle":value=strings.debugView.toggle;break;case"uiBarToggle":value=strings.uiBar.toggle;break;case"uiBarBackward":value=strings.uiBar.backward;break;case"uiBarForward":value=strings.uiBar.forward;break;case"uiBarJumpto":value=strings.uiBar.jumpto;break;case"jumptoTitle":value=strings.jumpto.title;break;case"jumptoTurn":value=strings.jumpto.turn;break;case"jumptoUnavailable":value=strings.jumpto.unavailable;break;case"savesTitle":value=strings.saves.title;break;case"savesDisallowed":value=strings.saves.disallowed;break;case"savesIncapable":value=strings.saves.incapable;break;case"savesLabelAuto":value=strings.saves.labelAuto;break;case"savesLabelDelete":value=strings.saves.labelDelete;break;case"savesLabelExport":value=strings.saves.labelExport;break;case"savesLabelImport":value=strings.saves.labelImport;break;case"savesLabelLoad":value=strings.saves.labelLoad;break;case"savesLabelClear":value=strings.saves.labelClear;break;case"savesLabelSave":value=strings.saves.labelSave;break;case"savesLabelSlot":value=strings.saves.labelSlot;break;case"savesUnavailable":value=strings.saves.unavailable;break;case"savesUnknownDate":value=strings.saves.unknownDate;break;case"settingsTitle":value=strings.settings.title;break;case"settingsOff":value=strings.settings.off;break;case"settingsOn":value=strings.settings.on;break;case"settingsReset":value=strings.settings.reset;break;case"restartTitle":value=strings.restart.title;break;case"restartPrompt":value=strings.restart.prompt;break;case"shareTitle":value=strings.share.title;break;case"alertTitle":break;case"autoloadTitle":value=strings.autoload.title;break;case"autoloadCancel":value=strings.autoload.cancel;break;case"autoloadOk":value=strings.autoload.ok;break;case"autoloadPrompt":value=strings.autoload.prompt;break;case"macroBackText":value=strings.macros.back.text;break;case"macroReturnText":value=strings.macros.return.text}value&&(l10nStrings[id]=value.replace(/%\w+%/g,(function(pat){return"{".concat(pat.slice(1,-1),"}")})))}catch(ex){}}))}},get:{value:function(ids,overrides){if(!ids)return"";var selectedId,id=((Array.isArray(ids)?ids:[ids]).some((function(id){return!!l10nStrings.hasOwnProperty(id)&&(selectedId=id,!0)})),selectedId);if(!id)return"";for(var processed=l10nStrings[id],iteration=0;_hasPatternRe.test(processed);){if(++iteration>50)throw new Error("L10n.get exceeded maximum replacement iterations, probable infinite loop");_patternRe.lastIndex=0,processed=processed.replace(_patternRe,(function(pat){var subId=pat.slice(1,-1);return overrides&&overrides.hasOwnProperty(subId)?overrides[subId]:l10nStrings.hasOwnProperty(subId)?l10nStrings[subId]:void 0}))}return processed}}}))),_patternRe,_hasPatternRe,strings={errors:{},warnings:{},debugView:{},uiBar:{},jumpto:{},saves:{},settings:{},restart:{},share:{},autoload:{},macros:{back:{},return:{}}},l10nStrings={identity:"game",aborting:"Aborting",cancel:"Cancel",close:"Close",ok:"OK",errorTitle:"Error",errorToggle:"Toggle the error view",errorNonexistentPassage:'the passage "{passage}" does not exist',errorSaveDiskLoadFailed:"failed to load save file from disk",errorSaveMissingData:"save is missing required data. Either the loaded file is not a save or the save has become corrupted",errorSaveIdMismatch:"save is from the wrong {identity}",_warningIntroLacking:"Your browser either lacks or has disabled",_warningOutroDegraded:", so this {identity} is running in a degraded mode. You may be able to continue, however, some parts may not work properly.",warningNoWebStorage:"{_warningIntroLacking} the Web Storage API{_warningOutroDegraded}",warningDegraded:"{_warningIntroLacking} some of the capabilities required by this {identity}{_warningOutroDegraded}",debugBarToggle:"Toggle the debug bar",debugBarNoWatches:"— no watches set —",debugBarAddWatch:"Add watch",debugBarDeleteWatch:"Delete watch",debugBarWatchAll:"Watch all",debugBarWatchNone:"Delete all",debugBarLabelAdd:"Add",debugBarLabelWatch:"Watch",debugBarLabelTurn:"Turn",debugBarLabelViews:"Views",debugBarViewsToggle:"Toggle the debug views",debugBarWatchToggle:"Toggle the watch panel",uiBarToggle:"Toggle the UI bar",uiBarBackward:"Go backward within the {identity} history",uiBarForward:"Go forward within the {identity} history",uiBarJumpto:"Jump to a specific point within the {identity} history",jumptoTitle:"Jump To",jumptoTurn:"Turn",jumptoUnavailable:"No jump points currently available…",savesTitle:"Saves",savesDisallowed:"Saving has been disallowed on this passage.",savesIncapable:"{_warningIntroLacking} the capabilities required to support saves, so saves have been disabled for this session.",savesLabelAuto:"Autosave",savesLabelDelete:"Delete",savesLabelExport:"Save to Disk…",savesLabelImport:"Load from Disk…",savesLabelLoad:"Load",savesLabelClear:"Delete All",savesLabelSave:"Save",savesLabelSlot:"Slot",savesUnavailable:"No save slots found…",savesUnknownDate:"unknown",settingsTitle:"Settings",settingsOff:"Off",settingsOn:"On",settingsReset:"Reset to Defaults",restartTitle:"Restart",restartPrompt:"Are you sure that you want to restart? Unsaved progress will be lost.",shareTitle:"Share",alertTitle:"Alert",autoloadTitle:"Autoload",autoloadCancel:"Go to start",autoloadOk:"Load autosave",autoloadPrompt:"An autosave exists. Load it now or go to the start?",macroBackText:"Back",macroReturnText:"Return"},Config=(_debug=!1,_addVisitedLinkClass=!1,_cleanupWikifierOutput=!1,_loadDelay=0,_audioPauseOnFadeToZero=!0,_audioPreloadMetadata=!0,_historyControls=!0,_historyMaxStates=40,_macrosIfAssignmentError=!0,_macrosMaxLoopIterations=1e3,_macrosTypeSkipKey=" ",_macrosTypeVisitedPassages=!0,_passagesDisplayTitles=!1,_passagesNobr=!1,_savesId="untitled-story",_savesSlots=8,_savesTryDiskOnMobile=!0,_uiStowBarInitially=800,_uiUpdateStoryElements=!0,_errHistoryModeDeprecated="Config.history.mode has been deprecated and is no longer used by SugarCube, please remove it from your code",Object.freeze({get debug(){return _debug},set debug(value){_debug=Boolean(value)},get addVisitedLinkClass(){return _addVisitedLinkClass},set addVisitedLinkClass(value){_addVisitedLinkClass=Boolean(value)},get cleanupWikifierOutput(){return _cleanupWikifierOutput},set cleanupWikifierOutput(value){_cleanupWikifierOutput=Boolean(value)},get loadDelay(){return _loadDelay},set loadDelay(value){if(!Number.isSafeInteger(value)||value<0)throw new RangeError("Config.loadDelay must be a non-negative integer");_loadDelay=value},audio:Object.freeze({get pauseOnFadeToZero(){return _audioPauseOnFadeToZero},set pauseOnFadeToZero(value){_audioPauseOnFadeToZero=Boolean(value)},get preloadMetadata(){return _audioPreloadMetadata},set preloadMetadata(value){_audioPreloadMetadata=Boolean(value)}}),history:Object.freeze({get controls(){return _historyControls},set controls(value){var controls=Boolean(value);if(1===_historyMaxStates&&controls)throw new Error("Config.history.controls must be false when Config.history.maxStates is 1");_historyControls=controls},get maxStates(){return _historyMaxStates},set maxStates(value){if(!Number.isSafeInteger(value)||value<1)throw new RangeError("Config.history.maxStates must be a positive integer");_historyMaxStates=value,_historyControls&&1===value&&(_historyControls=!1)},get mode(){throw new Error(_errHistoryModeDeprecated)},set mode(_){throw new Error(_errHistoryModeDeprecated)},get tracking(){throw new Error("Config.history.tracking has been deprecated, use Config.history.maxStates instead")},set tracking(_){throw new Error("Config.history.tracking has been deprecated, use Config.history.maxStates instead")}}),macros:Object.freeze({get ifAssignmentError(){return _macrosIfAssignmentError},set ifAssignmentError(value){_macrosIfAssignmentError=Boolean(value)},get maxLoopIterations(){return _macrosMaxLoopIterations},set maxLoopIterations(value){if(!Number.isSafeInteger(value)||value<1)throw new RangeError("Config.macros.maxLoopIterations must be a positive integer");_macrosMaxLoopIterations=value},get typeSkipKey(){return _macrosTypeSkipKey},set typeSkipKey(value){_macrosTypeSkipKey=String(value)},get typeVisitedPassages(){return _macrosTypeVisitedPassages},set typeVisitedPassages(value){_macrosTypeVisitedPassages=Boolean(value)}}),navigation:Object.freeze({get override(){return _navigationOverride},set override(value){if(!(null==value||value instanceof Function))throw new TypeError("Config.navigation.override must be a function or null/undefined (received: ".concat(Util.getType(value),")"));_navigationOverride=value}}),passages:Object.freeze({get descriptions(){return _passagesDescriptions},set descriptions(value){if(null!=value){var valueType=Util.getType(value);if("boolean"!==valueType&&"Object"!==valueType&&"function"!==valueType)throw new TypeError("Config.passages.descriptions must be a boolean, object, function, or null/undefined (received: ".concat(valueType,")"))}_passagesDescriptions=value},get displayTitles(){return _passagesDisplayTitles},set displayTitles(value){_passagesDisplayTitles=Boolean(value)},get nobr(){return _passagesNobr},set nobr(value){_passagesNobr=Boolean(value)},get onProcess(){return _passagesOnProcess},set onProcess(value){if(null!=value){var valueType=Util.getType(value);if("function"!==valueType)throw new TypeError("Config.passages.onProcess must be a function or null/undefined (received: ".concat(valueType,")"))}_passagesOnProcess=value},get start(){return _passagesStart},set start(value){if(null!=value){var valueType=Util.getType(value);if("string"!==valueType)throw new TypeError("Config.passages.start must be a string or null/undefined (received: ".concat(valueType,")"))}_passagesStart=value},get transitionOut(){return _passagesTransitionOut},set transitionOut(value){if(null!=value){var valueType=Util.getType(value);if("string"!==valueType&&("number"!==valueType||!Number.isSafeInteger(value)||value<0))throw new TypeError("Config.passages.transitionOut must be a string, non-negative integer, or null/undefined (received: ".concat(valueType,")"))}_passagesTransitionOut=value}}),saves:Object.freeze({get autoload(){return _savesAutoload},set autoload(value){if(null!=value){var valueType=Util.getType(value);if("boolean"!==valueType&&"string"!==valueType&&"function"!==valueType)throw new TypeError("Config.saves.autoload must be a boolean, string, function, or null/undefined (received: ".concat(valueType,")"))}_savesAutoload=value},get autosave(){return _savesAutosave},set autosave(value){if(null!=value){var valueType=Util.getType(value);if("string"===valueType)return void(_savesAutosave=[value]);if("boolean"!==valueType&&("Array"!==valueType||!value.every((function(item){return"string"==typeof item})))&&"function"!==valueType)throw new TypeError("Config.saves.autosave must be a boolean, Array<string>, function, or null/undefined (received: ".concat(valueType).concat("Array"===valueType?"<any>":"",")"))}_savesAutosave=value},get id(){return _savesId},set id(value){if("string"!=typeof value||""===value)throw new TypeError("Config.saves.id must be a non-empty string (received: ".concat(Util.getType(value),")"));_savesId=value},get isAllowed(){return _savesIsAllowed},set isAllowed(value){if(!(null==value||value instanceof Function))throw new TypeError("Config.saves.isAllowed must be a function or null/undefined (received: ".concat(Util.getType(value),")"));_savesIsAllowed=value},get slots(){return _savesSlots},set slots(value){if(!Number.isSafeInteger(value)||value<0)throw new TypeError("Config.saves.slots must be a non-negative integer (received: ".concat(Util.getType(value),")"));_savesSlots=value},get tryDiskOnMobile(){return _savesTryDiskOnMobile},set tryDiskOnMobile(value){_savesTryDiskOnMobile=Boolean(value)},get version(){return _savesVersion},set version(value){_savesVersion=value},get onLoad(){throw new Error("Config.saves.onLoad has been deprecated, use the Save.onLoad API instead")},set onLoad(value){console.warn("Config.saves.onLoad has been deprecated, use the Save.onLoad API instead"),Save.onLoad.add(value)},get onSave(){throw new Error("Config.saves.onSave has been deprecated, use the Save.onSave API instead")},set onSave(value){console.warn("Config.saves.onSave has been deprecated, use the Save.onSave API instead"),Save.onSave.add(value)}}),ui:Object.freeze({get stowBarInitially(){return _uiStowBarInitially},set stowBarInitially(value){var valueType=Util.getType(value);if("boolean"!==valueType&&("number"!==valueType||!Number.isSafeInteger(value)||value<0))throw new TypeError("Config.ui.stowBarInitially must be a boolean or non-negative integer (received: ".concat(valueType,")"));_uiStowBarInitially=value},get updateStoryElements(){return _uiUpdateStoryElements},set updateStoryElements(value){_uiUpdateStoryElements=Boolean(value)}})})),_navigationOverride,_passagesDescriptions,_passagesStart,_passagesOnProcess,_passagesTransitionOut,_savesAutoload,_savesAutosave,_savesIsAllowed,_savesVersion,_debug,_addVisitedLinkClass,_cleanupWikifierOutput,_loadDelay,_audioPauseOnFadeToZero,_audioPreloadMetadata,_historyControls,_historyMaxStates,_macrosIfAssignmentError,_macrosMaxLoopIterations,_macrosTypeSkipKey,_macrosTypeVisitedPassages,_passagesDisplayTitles,_passagesNobr,_savesId,_savesSlots,_savesTryDiskOnMobile,_uiStowBarInitially,_uiUpdateStoryElements,_errHistoryModeDeprecated,SimpleAudio=function(){var _hasPromise,_gestureEventNames=Object.freeze(["click","contextmenu","dblclick","keyup","mouseup","pointerup","touchend"]),_specialIds=Object.freeze([":not",":all",":looped",":muted",":paused",":playing"]),_formatSpecRe=/^([\w-]+)\s*\|\s*(\S.*)$/,_badIdRe=/[:\s]/,_tracks=new Map,_groups=new Map,_lists=new Map,_subscribers=new Map,_masterRate=1,_masterVolume=1,_masterMute=!1,_masterMuteOnHidden=!1,_playReturnsPromise=(_hasPromise=null,function(){if(null!==_hasPromise)return _hasPromise;if(_hasPromise=!1,Has.audio)try{var audio=document.createElement("audio");audio.muted=!0;var value=audio.play();value.catch((function(){})),_hasPromise=value instanceof Promise}catch(ex){}return _hasPromise}),AudioTrack=function(){function AudioTrack(obj){if(_classCallCheck(this,AudioTrack),obj instanceof Array)this._create(obj);else{if(!(obj instanceof AudioTrack))throw new Error("sources parameter must be either an array, of URIs or source objects, or an AudioTrack instance");this._copy(obj)}}return _createClass(AudioTrack,[{key:"_create",value:function(sourceList){var dataUriRe=/^data:\s*audio\/(?:x-)?([^;,]+)\s*[;,]/i,extRe=/\.([^./\\]+)$/,formats=AudioTrack.formats,usedSources=[],audio=document.createElement("audio");audio.preload="none",sourceList.forEach((function(src){var srcUri=null;switch(_typeof(src)){case"string":var match;if("data:"===src.slice(0,5)){if(null===(match=dataUriRe.exec(src)))throw new Error("source data URI missing media type")}else if(null===(match=extRe.exec(Util.parseUrl(src).pathname)))throw new Error("source URL missing file extension");formats[match[1]]&&(srcUri=src);break;case"object":if(null===src)throw new Error("source object cannot be null");if(!src.hasOwnProperty("src"))throw new Error('source object missing required "src" property');if(!src.hasOwnProperty("format"))throw new Error('source object missing required "format" property');formats[src.format]&&(srcUri=src.src);break;default:throw new Error("invalid source value (type: ".concat(_typeof(src),")"))}if(null!==srcUri){var source=document.createElement("source");source.src=srcUri,audio.appendChild(source),usedSources.push(srcUri)}})),audio.hasChildNodes()&&Config.audio.preloadMetadata&&(audio.preload="metadata"),this._finalize(audio,usedSources,clone(sourceList))}},{key:"_copy",value:function(obj){this._finalize(obj.audio.cloneNode(!0),clone(obj.sources),clone(obj.originals))}},{key:"_finalize",value:function(audio,sources,originals){var _this3=this;Object.defineProperties(this,{audio:{configurable:!0,value:audio},sources:{value:Object.freeze(sources)},originals:{value:Object.freeze(originals)},_error:{writable:!0,value:!1},_faderId:{writable:!0,value:null},_mute:{writable:!0,value:!1},_rate:{writable:!0,value:1},_volume:{writable:!0,value:1}}),jQuery(this.audio).on("loadstart.AudioTrack",(function(){return _this3._error=!1})).on("error.AudioTrack",(function(){return _this3._error=!0})).find("source:last-of-type").on("error.AudioTrack",(function(){return _this3._trigger("error")})),function(id,callback){if("function"!=typeof callback)throw new Error("callback parameter must be a function");_subscribers.set(id,callback)}(this,(function(mesg){if(_this3.audio)switch(mesg){case"loadwithscreen":if(_this3.hasSource()){var lockId=LoadScreen.lock();_this3.one("canplaythrough.AudioTrack_loadwithscreen error.AudioTrack_loadwithscreen",(function(){jQuery(this).off(".AudioTrack_loadwithscreen"),LoadScreen.unlock(lockId)})).load()}break;case"load":_this3.load();break;case"mute":_this3._updateAudioMute();break;case"rate":_this3._updateAudioRate();break;case"stop":_this3.stop();break;case"volume":_this3._updateAudioVolume();break;case"unload":_this3.unload()}else unsubscribe(_this3)})),this._updateAudioMute(),this._updateAudioRate(),this._updateAudioVolume()}},{key:"_trigger",value:function(eventName){jQuery(this.audio).triggerHandler(eventName)}},{key:"_destroy",value:function(){unsubscribe(this),this.audio&&(jQuery(this.audio).off(),this.unload(),this._error=!0,delete this.audio)}},{key:"clone",value:function(){return new AudioTrack(this)}},{key:"load",value:function(){var _this4=this;if(this.fadeStop(),this.audio.pause(),!this.audio.hasChildNodes()){if(0===this.sources.length)return;this.sources.forEach((function(srcUri){var source=document.createElement("source");source.src=srcUri,_this4.audio.appendChild(source)}))}"auto"!==this.audio.preload&&(this.audio.preload="auto"),this.isLoading()||this.audio.load()}},{key:"unload",value:function(){this.fadeStop(),this.stop();var audio=this.audio;for(audio.preload="none";audio.hasChildNodes();)audio.removeChild(audio.firstChild);audio.load()}},{key:"play",value:function(){var _this5=this;if(!this.hasSource())return Promise.reject(new Error("none of the candidate sources were acceptable"));if(this.isUnloaded())return Promise.reject(new Error("no sources are loaded"));if(this.isFailed())return Promise.reject(new Error("failed to load any of the sources"));"auto"!==this.audio.preload&&(this.audio.preload="auto");var namespace=".AudioTrack_play";return _playReturnsPromise()?this.audio.play():new Promise((function(resolve,reject){_this5.isPlaying()?resolve():(jQuery(_this5.audio).off(namespace).one("error".concat(namespace," playing").concat(namespace," timeupdate").concat(namespace),(function(ev){jQuery(_this5).off(namespace),"error"===ev.type?reject(new Error("unknown audio play error")):resolve()})),_this5.audio.play())}))}},{key:"playWhenAllowed",value:function(){var _this6=this;this.play().catch((function(){var gestures=_gestureEventNames.map((function(name){return"".concat(name,".AudioTrack_playWhenAllowed")})).join(" ");jQuery(document).one(gestures,(function(){jQuery(document).off(".AudioTrack_playWhenAllowed"),_this6.audio.play()}))}))}},{key:"pause",value:function(){this.audio.pause()}},{key:"stop",value:function(){this.audio.pause(),this.time(0),this._trigger(":stopped")}},{key:"fade",value:function(duration,toVol,fromVol){var _this7=this;if("number"!=typeof duration)throw new TypeError("duration parameter must be a number");if("number"!=typeof toVol)throw new TypeError("toVolume parameter must be a number");if(null!=fromVol&&"number"!=typeof fromVol)throw new TypeError("fromVolume parameter must be a number");if(!this.hasSource())return Promise.reject(new Error("none of the candidate sources were acceptable"));if(this.isUnloaded())return Promise.reject(new Error("no sources are loaded"));if(this.isFailed())return Promise.reject(new Error("failed to load any of the sources"));this.fadeStop();var from=Math.clamp(null==fromVol?this.volume():fromVol,0,1),to=Math.clamp(toVol,0,1);return from!==to?(this.volume(from),jQuery(this.audio).off("timeupdate.AudioTrack_fade").one("timeupdate.AudioTrack_fade",(function(){var min,max;from<to?(min=from,max=to):(min=to,max=from);var time=Math.max(duration,1),delta=(to-from)/(time/.025);_this7._trigger(":fading"),_this7._faderId=setInterval((function(){_this7.isPlaying()?(_this7.volume(Math.clamp(_this7.volume()+delta,min,max)),Config.audio.pauseOnFadeToZero&&0===_this7.volume()&&_this7.pause(),_this7.volume()===to&&(_this7.fadeStop(),_this7._trigger(":faded"))):_this7.fadeStop()}),25)})),this.play()):void 0}},{key:"fadeIn",value:function(duration,fromVol){return this.fade(duration,1,fromVol)}},{key:"fadeOut",value:function(duration,fromVol){return this.fade(duration,0,fromVol)}},{key:"fadeStop",value:function(){null!==this._faderId&&(clearInterval(this._faderId),this._faderId=null)}},{key:"loop",value:function(_loop){return null==_loop?this.audio.loop:(this.audio.loop=!!_loop,this)}},{key:"mute",value:function(_mute){return null==_mute?this._mute:(this._mute=!!_mute,this._updateAudioMute(),this)}},{key:"_updateAudioMute",value:function(){this.audio.muted=this._mute||_masterMute}},{key:"rate",value:function(_rate){if(null==_rate)return this._rate;if("number"!=typeof _rate)throw new TypeError("rate parameter must be a number");return this._rate=Math.clamp(_rate,.2,5),this._updateAudioRate(),this}},{key:"_updateAudioRate",value:function(){this.audio.playbackRate=Math.clamp(this._rate*_masterRate,.2,5)}},{key:"time",value:function(_time){var _this8=this;if(null==_time)return this.audio.currentTime;if("number"!=typeof _time)throw new TypeError("time parameter must be a number");return this.hasMetadata()?this.audio.currentTime=_time:jQuery(this.audio).off("loadedmetadata.AudioTrack_time").one("loadedmetadata.AudioTrack_time",(function(){return _this8.audio.currentTime=_time})),this}},{key:"volume",value:function(_volume){if(null==_volume)return this._volume;if("number"!=typeof _volume)throw new TypeError("volume parameter must be a number");return this._volume=Math.clamp(_volume,0,1),this._updateAudioVolume(),this}},{key:"_updateAudioVolume",value:function(){this.audio.volume=Math.clamp(this._volume*_masterVolume,0,1)}},{key:"duration",value:function(){return this.audio.duration}},{key:"remaining",value:function(){return this.audio.duration-this.audio.currentTime}},{key:"isFailed",value:function(){return this._error}},{key:"isLoading",value:function(){return this.audio.networkState===HTMLMediaElement.NETWORK_LOADING}},{key:"isUnloaded",value:function(){return!this.audio.hasChildNodes()}},{key:"isUnavailable",value:function(){return!this.hasSource()||this.isUnloaded()||this.isFailed()}},{key:"isPlaying",value:function(){return!this.audio.paused&&this.hasSomeData()}},{key:"isPaused",value:function(){return this.audio.paused&&(this.audio.duration===1/0||this.audio.currentTime>0)&&!this.audio.ended}},{key:"isStopped",value:function(){return this.audio.paused&&0===this.audio.currentTime}},{key:"isEnded",value:function(){return this.audio.ended}},{key:"isFading",value:function(){return null!==this._faderId}},{key:"isSeeking",value:function(){return this.audio.seeking}},{key:"hasSource",value:function(){return this.sources.length>0}},{key:"hasNoData",value:function(){return this.audio.readyState===HTMLMediaElement.HAVE_NOTHING}},{key:"hasMetadata",value:function(){return this.audio.readyState>=HTMLMediaElement.HAVE_METADATA}},{key:"hasSomeData",value:function(){return this.audio.readyState>=HTMLMediaElement.HAVE_CURRENT_DATA}},{key:"hasData",value:function(){return this.audio.readyState===HTMLMediaElement.HAVE_ENOUGH_DATA}},{key:"on",value:function(){for(var _len5=arguments.length,args=new Array(_len5),_key5=0;_key5<_len5;_key5++)args[_key5]=arguments[_key5];return jQuery.fn.on.apply(jQuery(this.audio),args),this}},{key:"one",value:function(){for(var _len6=arguments.length,args=new Array(_len6),_key6=0;_key6<_len6;_key6++)args[_key6]=arguments[_key6];return jQuery.fn.one.apply(jQuery(this.audio),args),this}},{key:"off",value:function(){for(var _len7=arguments.length,args=new Array(_len7),_key7=0;_key7<_len7;_key7++)args[_key7]=arguments[_key7];return jQuery.fn.off.apply(jQuery(this.audio),args),this}}]),AudioTrack}();Object.defineProperties(AudioTrack,{formats:{value:function(){var audio=document.createElement("audio"),types=new Map;function canPlay(mimeType){return types.has(mimeType)||types.set(mimeType,""!==audio.canPlayType(mimeType).replace(/^no$/i,"")),types.get(mimeType)}return Object.assign(Object.create(null),{aac:canPlay("audio/aac"),caf:canPlay("audio/x-caf")||canPlay("audio/caf"),flac:canPlay("audio/x-flac")||canPlay("audio/flac"),mp3:canPlay('audio/mpeg; codecs="mp3"')||canPlay("audio/mpeg")||canPlay("audio/mp3")||canPlay("audio/mpa"),mpeg:canPlay("audio/mpeg"),m4a:canPlay("audio/x-m4a")||canPlay("audio/m4a")||canPlay("audio/aac"),mp4:canPlay("audio/x-mp4")||canPlay("audio/mp4")||canPlay("audio/aac"),ogg:canPlay("audio/ogg"),oga:canPlay("audio/ogg"),opus:canPlay('audio/ogg; codecs="opus"')||canPlay("audio/opus"),wav:canPlay('audio/wave; codecs="1"')||canPlay('audio/wav; codecs="1"')||canPlay("audio/wave")||canPlay("audio/wav"),wave:canPlay('audio/wave; codecs="1"')||canPlay('audio/wav; codecs="1"')||canPlay("audio/wave")||canPlay("audio/wav"),weba:canPlay("audio/webm"),webm:canPlay("audio/webm")})}()}});var AudioList=function(){function AudioList(obj){if(_classCallCheck(this,AudioList),obj instanceof Array)this._create(obj);else{if(!(obj instanceof AudioList))throw new Error("tracks parameter must be either an array, of track objects, or an AudioTrack instance");this._copy(obj)}}return _createClass(AudioList,[{key:"_create",value:function(trackList){var _this9=this;this._finalize(trackList.map((function(trackObj){if("object"!==_typeof(trackObj))throw new Error("tracks parameter array members must be objects");var own,rate,track,volume;if(trackObj instanceof AudioTrack)own=!0,rate=trackObj.rate(),track=trackObj.clone(),volume=trackObj.volume();else{if(!trackObj.hasOwnProperty("track"))throw new Error('track object missing required "track" property');if(!(trackObj.track instanceof AudioTrack))throw new Error('track object\'s "track" property must be an AudioTrack object');own=trackObj.hasOwnProperty("own")&&trackObj.own,rate=trackObj.hasOwnProperty("rate")?trackObj.rate:trackObj.track.rate(),track=trackObj.track,volume=trackObj.hasOwnProperty("volume")?trackObj.volume:trackObj.track.volume()}return track.stop(),track.loop(!1),track.mute(!1),track.rate(rate),track.volume(volume),track.on("ended.AudioList",(function(){return _this9._onEnd()})),{own:own,track:track,volume:volume,rate:rate}})))}},{key:"_copy",value:function(obj){this._finalize(clone(obj.tracks))}},{key:"_finalize",value:function(tracks){Object.defineProperties(this,{tracks:{configurable:!0,value:Object.freeze(tracks)},queue:{configurable:!0,value:[]},current:{writable:!0,value:null},_rate:{writable:!0,value:1},_volume:{writable:!0,value:1},_mute:{writable:!0,value:!1},_loop:{writable:!0,value:!1},_shuffle:{writable:!0,value:!1}})}},{key:"_destroy",value:function(){this.stop(),this.tracks.filter((function(trackObj){return trackObj.own})).forEach((function(trackObj){return trackObj.track._destroy()})),delete this.tracks,delete this.queue}},{key:"load",value:function(){this.tracks.forEach((function(trackObj){return trackObj.track.load()}))}},{key:"unload",value:function(){this.stop(),this.tracks.forEach((function(trackObj){return trackObj.track.unload()}))}},{key:"play",value:function(){return null!==this.current&&!this.current.track.isUnavailable()&&!this.current.track.isEnded()||(0===this.queue.length&&this._fillQueue(),this._next())?this.current.track.play():Promise.reject(new Error("no tracks were available"))}},{key:"playWhenAllowed",value:function(){var _this10=this;this.play().catch((function(){var gestures=_gestureEventNames.map((function(name){return"".concat(name,".AudioList_playWhenAllowed")})).join(" ");jQuery(document).one(gestures,(function(){jQuery(document).off(".AudioList_playWhenAllowed"),_this10.play()}))}))}},{key:"pause",value:function(){null!==this.current&&this.current.track.pause()}},{key:"stop",value:function(){null!==this.current&&(this.current.track.stop(),this.current=null),this._drainQueue()}},{key:"skip",value:function(){this._next()?this.current.track.play():this._loop&&this.play()}},{key:"fade",value:function(duration,toVol,fromVol){if("number"!=typeof duration)throw new TypeError("duration parameter must be a number");if("number"!=typeof toVol)throw new TypeError("toVolume parameter must be a number");if(null!=fromVol&&"number"!=typeof fromVol)throw new TypeError("fromVolume parameter must be a number");if(0===this.queue.length&&this._fillQueue(),null!==this.current&&!this.current.track.isUnavailable()&&!this.current.track.isEnded()||this._next()){var adjFromVol,adjToVol=Math.clamp(toVol,0,1)*this.current.volume;return null!=fromVol&&(adjFromVol=Math.clamp(fromVol,0,1)*this.current.volume),this._volume=toVol,this.current.track.fade(duration,adjToVol,adjFromVol)}}},{key:"fadeIn",value:function(duration,fromVol){return this.fade(duration,1,fromVol)}},{key:"fadeOut",value:function(duration,fromVol){return this.fade(duration,0,fromVol)}},{key:"fadeStop",value:function(){null!==this.current&&this.current.track.fadeStop()}},{key:"loop",value:function(_loop2){return null==_loop2?this._loop:(this._loop=!!_loop2,this)}},{key:"mute",value:function(_mute2){return null==_mute2?this._mute:(this._mute=!!_mute2,null!==this.current&&this.current.track.mute(this._mute),this)}},{key:"rate",value:function(_rate2){if(null==_rate2)return this._rate;if("number"!=typeof _rate2)throw new TypeError("rate parameter must be a number");return this._rate=Math.clamp(_rate2,.2,5),null!==this.current&&this.current.track.rate(this._rate*this.current.rate),this}},{key:"shuffle",value:function(_shuffle){var _this11=this;if(null==_shuffle)return this._shuffle;if(this._shuffle=!!_shuffle,this.queue.length>0&&(this._fillQueue(),!this._shuffle&&null!==this.current&&this.queue.length>1)){var _this$queue,firstIdx=this.queue.findIndex((function(trackObj){return trackObj===_this11.current}));if(-1!==firstIdx)(_this$queue=this.queue).push.apply(_this$queue,_toConsumableArray(this.queue.splice(0,firstIdx+1)))}return this}},{key:"volume",value:function(_volume2){if(null==_volume2)return this._volume;if("number"!=typeof _volume2)throw new TypeError("volume parameter must be a number");return this._volume=Math.clamp(_volume2,0,1),null!==this.current&&this.current.track.volume(this._volume*this.current.volume),this}},{key:"duration",value:function(){if(arguments.length>0)throw new Error("duration takes no parameters");return this.tracks.map((function(trackObj){return trackObj.track.duration()})).reduce((function(prev,cur){return prev+cur}),0)}},{key:"remaining",value:function(){if(arguments.length>0)throw new Error("remaining takes no parameters");var remainingTime=this.queue.map((function(trackObj){return trackObj.track.duration()})).reduce((function(prev,cur){return prev+cur}),0);return null!==this.current&&(remainingTime+=this.current.track.remaining()),remainingTime}},{key:"time",value:function(){if(arguments.length>0)throw new Error("time takes no parameters");return this.duration()-this.remaining()}},{key:"isPlaying",value:function(){return null!==this.current&&this.current.track.isPlaying()}},{key:"isPaused",value:function(){return null===this.current||this.current.track.isPaused()}},{key:"isStopped",value:function(){return 0===this.queue.length&&null===this.current}},{key:"isEnded",value:function(){return 0===this.queue.length&&(null===this.current||this.current.track.isEnded())}},{key:"isFading",value:function(){return null!==this.current&&this.current.track.isFading()}},{key:"_next",value:function(){var nextTrack;for(null!==this.current&&(this.current.track.stop(),this.current=null);nextTrack=this.queue.shift();)if(!nextTrack.track.isUnavailable()){this.current=nextTrack;break}return null!==this.current&&(this.current.track.mute(this._mute),this.current.track.rate(this._rate*this.current.rate),this.current.track.volume(this._volume*this.current.volume),this.current.track.loop(!1),!0)}},{key:"_onEnd",value:function(){if(0===this.queue.length){if(!this._loop)return;this._fillQueue()}this._next()&&this.current.track.play()}},{key:"_drainQueue",value:function(){this.queue.splice(0)}},{key:"_fillQueue",value:function(){var _this$queue2;this._drainQueue(),(_this$queue2=this.queue).push.apply(_this$queue2,_toConsumableArray(this.tracks.filter((function(trackObj){return!trackObj.track.isUnavailable()})))),0!==this.queue.length&&this._shuffle&&(this.queue.shuffle(),this.queue.length>1&&this.queue[0]===this.current&&this.queue.push(this.queue.shift()))}}]),AudioList}(),AudioRunner=function(){function AudioRunner(list){if(_classCallCheck(this,AudioRunner),!(list instanceof Set||list instanceof AudioRunner))throw new TypeError("list parameter must be a Set or a AudioRunner instance");Object.defineProperties(this,{trackIds:{value:new Set(list instanceof AudioRunner?list.trackIds:list)}})}return _createClass(AudioRunner,[{key:"load",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.load)}},{key:"unload",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.unload)}},{key:"play",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.play)}},{key:"playWhenAllowed",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.playWhenAllowed)}},{key:"pause",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.pause)}},{key:"stop",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.stop)}},{key:"fade",value:function(duration,toVol,fromVol){if(null==duration||null==toVol)throw new Error("fade requires parameters");AudioRunner._run(this.trackIds,AudioTrack.prototype.fade,duration,toVol,fromVol)}},{key:"fadeIn",value:function(duration,fromVol){if(null==duration)throw new Error("fadeIn requires a parameter");AudioRunner._run(this.trackIds,AudioTrack.prototype.fadeIn,duration,fromVol)}},{key:"fadeOut",value:function(duration,fromVol){if(null==duration)throw new Error("fadeOut requires a parameter");AudioRunner._run(this.trackIds,AudioTrack.prototype.fadeOut,duration,fromVol)}},{key:"fadeStop",value:function(){AudioRunner._run(this.trackIds,AudioTrack.prototype.fadeStop)}},{key:"loop",value:function(_loop3){if(null==_loop3)throw new Error("loop requires a parameter");return AudioRunner._run(this.trackIds,AudioTrack.prototype.loop,_loop3),this}},{key:"mute",value:function(_mute3){if(null==_mute3)throw new Error("mute requires a parameter");return AudioRunner._run(this.trackIds,AudioTrack.prototype.mute,_mute3),this}},{key:"rate",value:function(_rate3){if(null==_rate3)throw new Error("rate requires a parameter");return AudioRunner._run(this.trackIds,AudioTrack.prototype.rate,_rate3),this}},{key:"time",value:function(_time2){if(null==_time2)throw new Error("time requires a parameter");return AudioRunner._run(this.trackIds,AudioTrack.prototype.time,_time2),this}},{key:"volume",value:function(_volume3){if(null==_volume3)throw new Error("volume requires a parameter");return AudioRunner._run(this.trackIds,AudioTrack.prototype.volume,_volume3),this}},{key:"on",value:function(){for(var _len8=arguments.length,args=new Array(_len8),_key8=0;_key8<_len8;_key8++)args[_key8]=arguments[_key8];return AudioRunner._run.apply(AudioRunner,[this.trackIds,AudioTrack.prototype.on].concat(args)),this}},{key:"one",value:function(){for(var _len9=arguments.length,args=new Array(_len9),_key9=0;_key9<_len9;_key9++)args[_key9]=arguments[_key9];return AudioRunner._run.apply(AudioRunner,[this.trackIds,AudioTrack.prototype.one].concat(args)),this}},{key:"off",value:function(){for(var _len10=arguments.length,args=new Array(_len10),_key10=0;_key10<_len10;_key10++)args[_key10]=arguments[_key10];return AudioRunner._run.apply(AudioRunner,[this.trackIds,AudioTrack.prototype.off].concat(args)),this}}],[{key:"_run",value:function(ids,fn){for(var _len11=arguments.length,args=new Array(_len11>2?_len11-2:0),_key11=2;_key11<_len11;_key11++)args[_key11-2]=arguments[_key11];ids.forEach((function(id){var track=_tracks.get(id);track&&fn.apply(track,args)}))}}]),AudioRunner}();var _runnerParseSelector=function(){var notWsRe=/\S/g,parenRe=/[()]/g;function processNegation(str,startPos){var match;if(notWsRe.lastIndex=startPos,null===(match=notWsRe.exec(str))||"("!==match[0])throw new Error('invalid ":not()" syntax: missing parentheticals');parenRe.lastIndex=notWsRe.lastIndex;for(var start=notWsRe.lastIndex,result={str:"",nextMatch:-1},depth=1;null!==(match=parenRe.exec(str));)if("("===match[0]?++depth:--depth,depth<1){result.nextMatch=parenRe.lastIndex,result.str=str.slice(start,result.nextMatch-1);break}return result}return function parseSelector(idArg){for(var match,ids=[],idRe=/:?[^\s:()]+/g;null!==(match=idRe.exec(idArg));){var id=match[0];if(":not"===id){if(0===ids.length)throw new Error('invalid negation: no group ID preceded ":not()"');var parent=ids[ids.length-1];if(":"!==parent.id[0])throw new Error('invalid negation of track "'.concat(parent.id,'": only groups may be negated with ":not()"'));var negation=processNegation(idArg,idRe.lastIndex);if(-1===negation.nextMatch)throw new Error('unknown error parsing ":not()"');idRe.lastIndex=negation.nextMatch,parent.not=parseSelector(negation.str)}else ids.push({id:id})}return ids}}();function masterMute(mute){if(null==mute)return _masterMute;publish("mute",_masterMute=!!mute)}function unsubscribe(id){_subscribers.delete(id)}function publish(mesg,data){_subscribers.forEach((function(fn){return fn(mesg,data)}))}function _newTrack(sources){return new AudioTrack(sources.map((function(source){if("data:"!==source.slice(0,5)&&Story.has(source)){var passage=Story.get(source);if(passage.tags.includes("Twine.audio"))return passage.text.trim()}var match=_formatSpecRe.exec(source);return null===match?source:{format:match[1],src:match[2]}})))}return Object.freeze(Object.defineProperties({},{tracks:{value:Object.freeze(Object.defineProperties({},{add:{value:function(){if(arguments.length<2){var errors=[];throw arguments.length<1&&errors.push("track ID"),arguments.length<2&&errors.push("sources"),new Error("no ".concat(errors.join(" or ")," specified"))}var id=String(arguments[0]).trim(),what='track ID "'.concat(id,'"');if(_badIdRe.test(id))throw new Error("invalid ".concat(what,": track IDs must not contain colons or whitespace"));var track,sources=Array.isArray(arguments[1])?Array.from(arguments[1]):Array.from(arguments).slice(1);try{track=_newTrack(sources)}catch(ex){throw new Error("".concat(what,": error during track initialization: ").concat(ex.message))}if(Config.debug&&!track.hasSource())throw new Error("".concat(what,": no supported audio sources found"));_tracks.has(id)&&_tracks.get(id)._destroy(),_tracks.set(id,track)}},delete:{value:function(id){return _tracks.has(id)&&_tracks.get(id)._destroy(),_tracks.delete(id)}},clear:{value:function(){_tracks.forEach((function(track){return track._destroy()})),_tracks.clear()}},has:{value:function(id){return _tracks.has(id)}},get:{value:function(id){return _tracks.get(id)||null}}}))},groups:{value:Object.freeze(Object.defineProperties({},{add:{value:function(){if(arguments.length<2){var errors=[];throw arguments.length<1&&errors.push("group ID"),arguments.length<2&&errors.push("track IDs"),new Error("no ".concat(errors.join(" or ")," specified"))}var id=String(arguments[0]).trim(),what='group ID "'.concat(id,'"');if(":"!==id[0]||_badIdRe.test(id.slice(1)))throw new Error("invalid ".concat(what,": group IDs must start with a colon and must not contain colons or whitespace"));if(_specialIds.includes(id))throw new Error("cannot clobber special ".concat(what));var group,trackIds=Array.isArray(arguments[1])?Array.from(arguments[1]):Array.from(arguments).slice(1);try{group=new Set(trackIds.map((function(trackId){if(!_tracks.has(trackId))throw new Error('track "'.concat(trackId,'" does not exist'));return trackId})))}catch(ex){throw new Error("".concat(what,": error during group initialization: ").concat(ex.message))}_groups.set(id,Object.freeze(Array.from(group)))}},delete:{value:function(id){return _groups.delete(id)}},clear:{value:function(){_groups.clear()}},has:{value:function(id){return _groups.has(id)}},get:{value:function(id){return _groups.get(id)||null}}}))},lists:{value:Object.freeze(Object.defineProperties({},{add:{value:function(){if(arguments.length<2){var errors=[];throw arguments.length<1&&errors.push("list ID"),arguments.length<2&&errors.push("track IDs"),new Error("no ".concat(errors.join(" or ")," specified"))}var id=String(arguments[0]).trim(),what='list ID "'.concat(id,'"');if(_badIdRe.test(id))return this.error("invalid ".concat(what,": list IDs must not contain colons or whitespace"));var list,descriptors=Array.isArray(arguments[1])?Array.from(arguments[1]):Array.from(arguments).slice(1);try{list=new AudioList(descriptors.map((function(desc){if(null===desc)throw new Error("track descriptor must be a string or object (type: null)");switch(_typeof(desc)){case"string":desc={id:desc};break;case"object":if(!desc.hasOwnProperty("id")&&!desc.hasOwnProperty("sources"))throw new Error('track descriptor must contain one of either an "id" or a "sources" property');if(desc.hasOwnProperty("id")&&desc.hasOwnProperty("sources"))throw new Error('track descriptor must contain either an "id" or a "sources" property, not both');break;default:throw new Error("track descriptor must be a string or object (type: ".concat(_typeof(desc),")"))}var own,track,volume;if(desc.hasOwnProperty("id")){if("string"!=typeof desc.id)throw new Error('"id" property must be a string');if(!_tracks.has(desc.id))throw new Error('track "'.concat(desc.id,'" does not exist'));track=_tracks.get(desc.id)}else if(desc.hasOwnProperty("sources")){if(!Array.isArray(desc.sources)||0===desc.sources.length)throw new Error('"sources" property must be a non-empty array');if(desc.hasOwnProperty("own"))throw new Error('"own" property is not allowed with the "sources" property');try{track=_newTrack(desc.sources),own=!0}catch(ex){throw new Error("error during track initialization: ".concat(ex.message))}if(Config.debug&&!track.hasSource())throw new Error("no supported audio sources found")}if(desc.hasOwnProperty("own")){if("boolean"!=typeof desc.own)throw new Error('"own" property must be a boolean');(own=desc.own)&&(track=track.clone())}if(desc.hasOwnProperty("volume")){if("number"!=typeof desc.volume||Number.isNaN(desc.volume)||!Number.isFinite(desc.volume)||desc.volume<0)throw new Error('"volume" property must be a non-negative finite number');volume=desc.volume}return{own:null!=own&&own,track:track,volume:null!=volume?volume:track.volume()}})))}catch(ex){throw new Error("".concat(what,": error during playlist initialization: ").concat(ex.message))}_lists.has(id)&&_lists.get(id)._destroy(),_lists.set(id,list)}},delete:{value:function(id){return _lists.has(id)&&_lists.get(id)._destroy(),_lists.delete(id)}},clear:{value:function(){_lists.forEach((function(list){return list._destroy()})),_lists.clear()}},has:{value:function(id){return _lists.has(id)}},get:{value:function(id){return _lists.get(id)||null}}}))},select:{value:function(){if(0===arguments.length)throw new Error("no track selector specified");var selector=String(arguments[0]).trim(),trackIds=new Set;try{var renderIds=function renderIds(idObj){var ids,id=idObj.id;switch(id){case":all":ids=allIds;break;case":looped":ids=allIds.filter((function(id){return _tracks.get(id).loop()}));break;case":muted":ids=allIds.filter((function(id){return _tracks.get(id).mute()}));break;case":paused":ids=allIds.filter((function(id){return _tracks.get(id).isPaused()}));break;case":playing":ids=allIds.filter((function(id){return _tracks.get(id).isPlaying()}));break;default:ids=":"===id[0]?_groups.get(id):[id]}if(idObj.hasOwnProperty("not")){var negated=idObj.not.map((function(idObj){return renderIds(idObj)})).flat(1/0);ids=ids.filter((function(id){return!negated.includes(id)}))}return ids},allIds=Array.from(_tracks.keys());_runnerParseSelector(selector).forEach((function(idObj){return renderIds(idObj).forEach((function(id){if(!_tracks.has(id))throw new Error('track "'.concat(id,'" does not exist'));trackIds.add(id)}))}))}catch(ex){throw new Error("error during runner initialization: ".concat(ex.message))}return new AudioRunner(trackIds)}},load:{value:function(){publish("load")}},loadWithScreen:{value:function(){publish("loadwithscreen")}},mute:{value:masterMute},muteOnHidden:{value:function(mute){if(!Visibility.isEnabled())return!1;if(null==mute)return _masterMuteOnHidden;var namespace=".SimpleAudio_masterMuteOnHidden";if(_masterMuteOnHidden=!!mute){var visibilityChange="".concat(Visibility.changeEvent).concat(namespace);jQuery(document).off(namespace).on(visibilityChange,(function(){return masterMute(Visibility.isHidden())})),Visibility.isHidden()&&masterMute(!0)}else jQuery(document).off(namespace)}},rate:{value:function(rate){if(null==rate)return _masterRate;if("number"!=typeof rate||Number.isNaN(rate)||!Number.isFinite(rate))throw new Error("rate must be a finite number");publish("rate",_masterRate=Math.clamp(rate,.2,5))}},stop:{value:function(){publish("stop")}},unload:{value:function(){publish("unload")}},volume:{value:function(volume){if(null==volume)return _masterVolume;if("number"!=typeof volume||Number.isNaN(volume)||!Number.isFinite(volume))throw new Error("volume must be a finite number");publish("volume",_masterVolume=Math.clamp(volume,0,1))}}}))}(),State=function(){var _history=[],_active=momentCreate(),_activeIndex=-1,_expired=[],_prng=null,_tempVariables={};function stateMarshal(noDelta){var stateObj={index:_activeIndex};return noDelta?stateObj.history=clone(_history):stateObj.delta=historyDeltaEncode(_history),_expired.length>0&&(stateObj.expired=_toConsumableArray(_expired)),null!==_prng&&(stateObj.seed=_prng.seed),stateObj}function stateUnmarshal(stateObj,noDelta){if(null==stateObj)throw new Error("state object is null or undefined");if(!stateObj.hasOwnProperty(noDelta?"history":"delta")||0===stateObj[noDelta?"history":"delta"].length)throw new Error("state object has no history or history is empty");if(!stateObj.hasOwnProperty("index"))throw new Error("state object has no index");if(null!==_prng&&!stateObj.hasOwnProperty("seed"))throw new Error("state object has no seed, but PRNG is enabled");if(null===_prng&&stateObj.hasOwnProperty("seed"))throw new Error("state object has seed, but PRNG is disabled");_history=noDelta?clone(stateObj.history):historyDeltaDecode(stateObj.delta),_activeIndex=stateObj.index,_expired=stateObj.hasOwnProperty("expired")?_toConsumableArray(stateObj.expired):[],stateObj.hasOwnProperty("seed")&&(_prng.seed=stateObj.seed),momentActivate(_activeIndex)}function momentCreate(title,variables){return{title:null==title?"":String(title),variables:null==variables?{}:clone(variables)}}function momentActivate(moment){if(null==moment)throw new Error("moment activation attempted with null or undefined");switch(_typeof(moment)){case"object":_active=clone(moment);break;case"number":if(historyIsEmpty())throw new Error("moment activation attempted with index on empty history");if(moment<0||moment>=historySize())throw new RangeError("moment activation attempted with out-of-bounds index; need [0, ".concat(historySize()-1,"], got ").concat(moment));_active=clone(_history[moment]);break;default:throw new TypeError('moment activation attempted with a "'.concat(_typeof(moment),'"; must be an object or valid history stack index'))}return null!==_prng&&(_prng=PRNGWrapper.unmarshal({seed:_prng.seed,pull:_active.pull})),session.set("state",stateMarshal()),jQuery.event.trigger(":historyupdate"),_active}function historyLength(){return _activeIndex+1}function historySize(){return _history.length}function historyIsEmpty(){return 0===_history.length}function historyTop(){return _history.length>0?_history[_history.length-1]:null}function historyGoTo(index){return!(null==index||index<0||index>=historySize()||index===_activeIndex)&&(momentActivate(_activeIndex=index),!0)}function historyDeltaEncode(historyArr){if(!Array.isArray(historyArr))return null;if(0===historyArr.length)return[];for(var delta=[historyArr[0]],i=1,iend=historyArr.length;i<iend;++i)delta.push(Diff.diff(historyArr[i-1],historyArr[i]));return delta}function historyDeltaDecode(delta){if(!Array.isArray(delta))return null;if(0===delta.length)return[];for(var historyArr=[clone(delta[0])],i=1,iend=delta.length;i<iend;++i)historyArr.push(Diff.patch(historyArr[i-1],delta[i]));return historyArr}function prngInit(seed,useEntropy){var scriptSection;if(!historyIsEmpty())throw scriptSection="the Story JavaScript",new Error("State.prng.init must be called during initialization, within either ".concat(scriptSection," or the StoryInit special passage"));_prng=new PRNGWrapper(seed,useEntropy),_active.pull=_prng.pull}function metadataDelete(key){if("string"!=typeof key)throw new TypeError("State.metadata.delete key parameter must be a string (received: ".concat(_typeof(key),")"));var store=storage.get("metadata");store&&store.hasOwnProperty(key)&&(1===Object.keys(store).length?storage.delete("metadata"):(delete store[key],storage.set("metadata",store)))}return Object.freeze(Object.defineProperties({},{reset:{value:function(){session.delete("state"),_history=[],_active=momentCreate(),_activeIndex=-1,_expired=[],_prng=null===_prng?null:new PRNGWrapper(_prng.seed,!1)}},restore:{value:function(){if(session.has("state")){var stateObj=session.get("state");return null!=stateObj&&(stateUnmarshal(stateObj),!0)}return!1}},marshalForSave:{value:function(){return stateMarshal(!0)}},unmarshalForSave:{value:function(stateObj){return stateUnmarshal(stateObj,!0)}},expired:{get:function(){return _expired}},turns:{get:function(){return _expired.length+historyLength()}},passages:{get:function(){return _expired.concat(_history.slice(0,historyLength()).map((function(moment){return moment.title})))}},hasPlayed:{value:function(title){return null!=title&&""!==title&&(!!_expired.includes(title)||!!_history.slice(0,historyLength()).some((function(moment){return moment.title===title})))}},active:{get:function(){return _active}},activeIndex:{get:function(){return _activeIndex}},passage:{get:function(){return _active.title}},variables:{get:function(){return _active.variables}},history:{get:function(){return _history}},length:{get:historyLength},size:{get:historySize},isEmpty:{value:historyIsEmpty},current:{get:function(){return _history.length>0?_history[_activeIndex]:null}},top:{get:historyTop},bottom:{get:function(){return _history.length>0?_history[0]:null}},index:{value:function(index){return historyIsEmpty()||index<0||index>_activeIndex?null:_history[index]}},peek:{value:function(offset){if(historyIsEmpty())return null;var lengthOffset=1+(offset?Math.abs(offset):0);return lengthOffset>historyLength()?null:_history[historyLength()-lengthOffset]}},has:{value:function(title){if(historyIsEmpty()||null==title||""===title)return!1;for(var i=_activeIndex;i>=0;--i)if(_history[i].title===title)return!0;return!1}},create:{value:function(title){for(0,historyLength()<historySize()&&_history.splice(historyLength(),historySize()-historyLength()),_history.push(momentCreate(title,_active.variables)),_prng&&(historyTop().pull=_prng.pull);historySize()>Config.history.maxStates;)_expired.push(_history.shift().title);return momentActivate(_activeIndex=historySize()-1),historyLength()}},goTo:{value:historyGoTo},go:{value:function(offset){return null!=offset&&0!==offset&&historyGoTo(_activeIndex+offset)}},deltaEncode:{value:historyDeltaEncode},deltaDecode:{value:historyDeltaDecode},prng:{value:Object.freeze(Object.defineProperties({},{init:{value:prngInit},isEnabled:{value:function(){return null!==_prng}},pull:{get:function(){return _prng?_prng.pull:NaN}},seed:{get:function(){return _prng?_prng.seed:null}}}))},random:{value:function(){return _prng?_prng.random():Math.random()}},clearTemporary:{value:function(){TempVariables=_tempVariables={}}},temporary:{get:function(){return _tempVariables}},getVar:{value:function(varExpression){try{return Scripting.evalTwineScript(varExpression)}catch(ex){}}},setVar:{value:function(varExpression,value){try{return Scripting.evalTwineScript("".concat(varExpression," = evalTwineScript$Data$"),null,value),!0}catch(ex){}return!1}},metadata:{value:Object.freeze(Object.defineProperties({},{clear:{value:function(){storage.delete("metadata")}},delete:{value:metadataDelete},entries:{value:function(){var store=storage.get("metadata");return store&&Object.entries(store)}},get:{value:function(key){if("string"!=typeof key)throw new TypeError("State.metadata.get key parameter must be a string (received: ".concat(_typeof(key),")"));var store=storage.get("metadata");return store&&store.hasOwnProperty(key)?store[key]:undefined}},has:{value:function(key){if("string"!=typeof key)throw new TypeError("State.metadata.has key parameter must be a string (received: ".concat(_typeof(key),")"));var store=storage.get("metadata");return store&&store.hasOwnProperty(key)}},keys:{value:function(){var store=storage.get("metadata");return store&&Object.keys(store)}},set:{value:function(key,value){if("string"!=typeof key)throw new TypeError("State.metadata.set key parameter must be a string (received: ".concat(_typeof(key),")"));if(void 0===value)metadataDelete(key);else{var store=storage.get("metadata")||{};store[key]=value,storage.set("metadata",store)}}},size:{get:function(){var store=storage.get("metadata");return store?Object.keys(store).length:0}}}))},initPRNG:{value:prngInit},restart:{value:function(){return Engine.restart()}},backward:{value:function(){return Engine.backward()}},forward:{value:function(){return Engine.forward()}},display:{value:function(){return Engine.display.apply(Engine,arguments)}},show:{value:function(){return Engine.show.apply(Engine,arguments)}},play:{value:function(){return Engine.play.apply(Engine,arguments)}}}))}(),Scripting=function(){function addAccessibleClickHandler(targets,selector,handler,one,namespace){if(arguments.length<2)throw new Error("addAccessibleClickHandler insufficient number of parameters");var fn,opts;if("function"==typeof selector?(fn=selector,opts={namespace:one,one:!!handler}):(fn=handler,opts={namespace:namespace,one:!!one,selector:selector}),"function"!=typeof fn)throw new TypeError("addAccessibleClickHandler handler parameter must be a function");return jQuery(targets).ariaClick(opts,fn)}function insertElement(place,type,id,classNames,text,title){var $el=jQuery(document.createElement(type));return id&&$el.attr("id",id),classNames&&$el.addClass(classNames),title&&$el.attr("title",title),text&&$el.text(text),place&&$el.appendTo(place),$el[0]}function insertText(place,text){jQuery(place).append(document.createTextNode(text))}function removeChildren(node){jQuery(node).empty()}function removeElement(node){jQuery(node).remove()}function fade(el,options){var current,intervalId,direction="in"===options.fade?1:-1,proxy=el.cloneNode(!0);function setOpacity(el,opacity){el.style.zoom=1,el.style.filter="alpha(opacity=".concat(Math.floor(100*opacity),")"),el.style.opacity=opacity}el.parentNode.replaceChild(proxy,el),"in"===options.fade?(current=0,proxy.style.visibility="visible"):current=1,setOpacity(proxy,current),intervalId=window.setInterval((function(){current+=.05*direction,setOpacity(proxy,Math.easeInOut(current)),(1===direction&&current>=1||-1===direction&&current<=0)&&(el.style.visibility="in"===options.fade?"visible":"hidden",proxy.parentNode.replaceChild(el,proxy),proxy=null,window.clearInterval(intervalId),options.onComplete&&options.onComplete())}),25)}function scrollWindowTo(el,incrementBy){var increment=null!=incrementBy?Number(incrementBy):.1;Number.isNaN(increment)||!Number.isFinite(increment)||increment<0?increment=.1:increment>1&&(increment=1);var intervalId,start=window.scrollY?window.scrollY:document.body.scrollTop,end=function(el){var posTop=function(el){var curtop=0;for(;el.offsetParent;)curtop+=el.offsetTop,el=el.offsetParent;return curtop}(el),posBottom=posTop+el.offsetHeight,winTop=window.scrollY?window.scrollY:document.body.scrollTop,winHeight=window.innerHeight?window.innerHeight:document.body.clientHeight,winBottom=winTop+winHeight;return posTop>=winTop&&posBottom>winBottom&&el.offsetHeight<winHeight?posTop-(winHeight-el.offsetHeight)+20:posTop}(el),distance=Math.abs(start-end),direction=start>end?-1:1,progress=0;intervalId=window.setInterval((function(){progress+=increment,window.scroll(0,start+direction*(distance*Math.easeInOut(progress))),progress>=1&&window.clearInterval(intervalId)}),25)}function toStringOrDefault(value){return stringFrom(value)}function either(){if(0!==arguments.length)return Array.prototype.concat.apply([],arguments).random()}function forget(key){if("string"!=typeof key)throw new TypeError("forget key parameter must be a string (received: ".concat(Util.getType(key),")"));State.metadata.delete(key)}function hasVisited(){if(0===arguments.length)throw new Error("hasVisited called with insufficient parameters");if(State.isEmpty())return!1;for(var needles=Array.prototype.concat.apply([],arguments),played=State.passages,i=0,iend=needles.length;i<iend;++i)if(!played.includes(needles[i]))return!1;return!0}function lastVisited(){if(0===arguments.length)throw new Error("lastVisited called with insufficient parameters");if(State.isEmpty())return-1;for(var needles=Array.prototype.concat.apply([],arguments),played=State.passages,uBound=played.length-1,turns=State.turns,i=0,iend=needles.length;i<iend&&turns>-1;++i){var lastIndex=played.lastIndexOf(needles[i]);turns=Math.min(turns,-1===lastIndex?-1:uBound-lastIndex)}return turns}function memorize(key,value){if("string"!=typeof key)throw new TypeError("memorize key parameter must be a string (received: ".concat(Util.getType(key),")"));State.metadata.set(key,value)}function passage(){return State.passage}function previous(){var passages=State.passages;if(arguments.length>0){var offset=Number(arguments[0]);if(!Number.isSafeInteger(offset)||offset<1)throw new RangeError("previous offset parameter must be a positive integer greater than zero");return passages.length>offset?passages[passages.length-1-offset]:""}for(var i=passages.length-2;i>=0;--i)if(passages[i]!==State.passage)return passages[i];return""}function random(){var min,max;switch(arguments.length){case 0:throw new Error("random called with insufficient parameters");case 1:min=0,max=Math.trunc(arguments[0]);break;default:min=Math.trunc(arguments[0]),max=Math.trunc(arguments[1])}if(!Number.isInteger(min))throw new Error("random min parameter must be an integer");if(!Number.isInteger(max))throw new Error("random max parameter must be an integer");if(min>max){var _ref6=[max,min];min=_ref6[0],max=_ref6[1]}return Math.floor(State.random()*(max-min+1))+min}function randomFloat(){var min,max;switch(arguments.length){case 0:throw new Error("randomFloat called with insufficient parameters");case 1:min=0,max=Number(arguments[0]);break;default:min=Number(arguments[0]),max=Number(arguments[1])}if(Number.isNaN(min)||!Number.isFinite(min))throw new Error("randomFloat min parameter must be a number");if(Number.isNaN(max)||!Number.isFinite(max))throw new Error("randomFloat max parameter must be a number");if(min>max){var _ref7=[max,min];min=_ref7[0],max=_ref7[1]}return State.random()*(max-min)+min}function recall(key,defaultValue){if("string"!=typeof key)throw new TypeError("recall key parameter must be a string (received: ".concat(Util.getType(key),")"));return State.metadata.has(key)?State.metadata.get(key):defaultValue}function tags(){if(0===arguments.length)return Story.get(State.passage).tags.slice(0);for(var passages=Array.prototype.concat.apply([],arguments),tags=[],i=0,iend=passages.length;i<iend;++i)tags=tags.concat(Story.get(passages[i]).tags);return tags}function temporary(){return State.temporary}function time(){return null===Engine.lastPlay?0:Util.now()-Engine.lastPlay}function turns(){return State.turns}function variables(){return State.variables}function visited(){if(State.isEmpty())return 0;for(var needles=Array.prototype.concat.apply([],0===arguments.length?[State.passage]:arguments),played=State.passages,count=State.turns,i=0,iend=needles.length;i<iend&&count>0;++i)count=Math.min(count,played.count(needles[i]));return count}function visitedTags(){if(0===arguments.length)throw new Error("visitedTags called with insufficient parameters");if(State.isEmpty())return 0;for(var needles=Array.prototype.concat.apply([],arguments),nLength=needles.length,played=State.passages,seen=new Map,count=0,i=0,iend=played.length;i<iend;++i){var title=played[i];if(seen.has(title))seen.get(title)&&++count;else{var _tags2=Story.get(title).tags;if(_tags2.length>0){for(var found=0,j=0;j<nLength;++j)_tags2.includes(needles[j])&&++found;found===nLength?(++count,seen.set(title,!0)):seen.set(title,!1)}}}return count}var _ref8=function(){function slugifyUrl(url){return Util.parseUrl(url).path.replace(/^[^\w]+|[^\w]+$/g,"").replace(/[^\w]+/g,"-").toLocaleLowerCase()}function addScript(url){return new Promise((function(resolve,reject){jQuery(document.createElement("script")).one("load abort error",(function(ev){jQuery(ev.target).off(),"load"===ev.type?resolve(ev.target):reject(new Error('importScripts failed to load the script "'.concat(url,'".')))})).appendTo(document.head).attr({id:"script-imported-".concat(slugifyUrl(url)),type:"text/javascript",src:url})}))}function addStyle(url){return new Promise((function(resolve,reject){jQuery(document.createElement("link")).one("load abort error",(function(ev){jQuery(ev.target).off(),"load"===ev.type?resolve(ev.target):reject(new Error('importStyles failed to load the stylesheet "'.concat(url,'".')))})).appendTo(document.head).attr({id:"style-imported-".concat(slugifyUrl(url)),rel:"stylesheet",href:url})}))}function sequence(callbacks){return callbacks.reduce((function(seq,fn){return seq.then(fn)}),Promise.resolve())}return{importScripts:function(){for(var _len12=arguments.length,urls=new Array(_len12),_key12=0;_key12<_len12;_key12++)urls[_key12]=arguments[_key12];return Promise.all(urls.map((function(oneOrSeries){return Array.isArray(oneOrSeries)?sequence(oneOrSeries.map((function(url){return function(){return addScript(url)}}))):addScript(oneOrSeries)})))},importStyles:function(){for(var _len13=arguments.length,urls=new Array(_len13),_key13=0;_key13<_len13;_key13++)urls[_key13]=arguments[_key13];return Promise.all(urls.map((function(oneOrSeries){return Array.isArray(oneOrSeries)?sequence(oneOrSeries.map((function(url){return function(){return addStyle(url)}}))):addStyle(oneOrSeries)})))}}}(),importScripts=_ref8.importScripts,importStyles=_ref8.importStyles,parse=function(){var tokenTable=Util.toEnum({$:"State.variables.",_:"State.temporary.",to:"=",eq:"==",neq:"!=",is:"===",isnot:"!==",gt:">",gte:">=",lt:"<",lte:"<=",and:"&&",or:"||",not:"!",def:'"undefined" !== typeof',ndef:'"undefined" === typeof'}),parseRe=new RegExp(["(?:\"\"|''|``)",'(?:"(?:\\\\.|[^"\\\\])+")',"(?:'(?:\\\\.|[^'\\\\])+')","(`(?:\\\\.|[^`\\\\])+`)","(?:[=+\\-*\\/%<>&\\|\\^~!?:,;\\(\\)\\[\\]{}]+)","([^\"'=+\\-*\\/%<>&\\|\\^~!?:,;\\(\\)\\[\\]{}\\s]+)"].join("|"),"g"),notSpaceRe=/\S/,varTest=new RegExp("^".concat(Patterns.variable)),withColonTestRe=/^\s*:/,withNotTestRe=/^\s+not\b/;function parse(rawCodeString){if(0!==parseRe.lastIndex)throw new RangeError("Scripting.parse last index is non-zero at start");for(var match,code=rawCodeString;null!==(match=parseRe.exec(code));)if(match[1]){var rawTemplate=match[1],parsedTemplate=parseTemplate(rawTemplate);parsedTemplate!==rawTemplate&&(code=code.splice(match.index,rawTemplate.length,parsedTemplate),parseRe.lastIndex+=parsedTemplate.length-rawTemplate.length)}else if(match[2]){var token=match[2];if("$"===token||"_"===token)continue;if(varTest.test(token))token=token[0];else if("is"===token){var start=parseRe.lastIndex,ahead=code.slice(start);withNotTestRe.test(ahead)&&(code=code.splice(start,ahead.search(notSpaceRe)),token="isnot")}else{var _ahead=code.slice(parseRe.lastIndex);if(withColonTestRe.test(_ahead))continue}tokenTable[token]&&(code=code.splice(match.index,token.length,tokenTable[token]),parseRe.lastIndex+=tokenTable[token].length-token.length)}return code}var templateGroupStartRe=/\$\{/g,templateGroupParseRe=new RegExp(["(?:\"\"|'')",'(?:"(?:\\\\.|[^"\\\\])+")',"(?:'(?:\\\\.|[^'\\\\])+')","(\\{)","(\\})"].join("|"),"g");function parseTemplate(rawTemplateLiteral){if(0!==templateGroupStartRe.lastIndex)throw new RangeError("Scripting.parse last index is non-zero at start of template literal");for(var startMatch,template=rawTemplateLiteral;null!==(startMatch=templateGroupStartRe.exec(template));){var startIdx=startMatch.index+2,endIdx=startIdx,depth=1,endMatch=void 0;for(templateGroupParseRe.lastIndex=startIdx;null!==(endMatch=templateGroupParseRe.exec(template));)if(endMatch[1]?++depth:endMatch[2]&&--depth,0===depth){endIdx=endMatch.index;break}if(endIdx>startIdx){var parseIndex=parseRe.lastIndex,rawGroup=template.slice(startIdx,endIdx);parseRe.lastIndex=0;var parsedGroup=parse(rawGroup);parseRe.lastIndex=parseIndex,template=template.splice(startIdx,rawGroup.length,parsedGroup),templateGroupStartRe.lastIndex+=parsedGroup.length-rawGroup.length}}return template}return parse}();function evalJavaScript(code,output,data){return function(code,output,evalJavaScript$Data$){return eval(code)}.call(output?{output:output}:null,String(code),output,data)}function evalTwineScript(code,output,data){return function(code,output,evalTwineScript$Data$){return eval(code)}.call(output?{output:output}:null,parse(String(code)),output,data)}return Object.freeze(Object.defineProperties({},{parse:{value:parse},evalJavaScript:{value:evalJavaScript},evalTwineScript:{value:evalTwineScript}}))}(),_ref9=function(){var Lexer=function(){function Lexer(source,initialState){if(_classCallCheck(this,Lexer),arguments.length<2)throw new Error("Lexer constructor called with too few parameters (source:string , initialState:function)");Object.defineProperties(this,{source:{value:source},initial:{value:initialState},state:{writable:!0,value:initialState},start:{writable:!0,value:0},pos:{writable:!0,value:0},depth:{writable:!0,value:0},items:{writable:!0,value:[]},data:{writable:!0,value:{}}})}return _createClass(Lexer,[{key:"reset",value:function(){this.state=this.initial,this.start=0,this.pos=0,this.depth=0,this.items=[],this.data={}}},{key:"run",value:function(){for(;null!==this.state;)this.state=this.state(this);return this.items}},{key:"nextItem",value:function(){for(;0===this.items.length&&null!==this.state;)this.state=this.state(this);return this.items.shift()}},{key:"next",value:function(){return this.pos>=this.source.length?-1:this.source[this.pos++]}},{key:"peek",value:function(){return this.pos>=this.source.length?-1:this.source[this.pos]}},{key:"backup",value:function(num){this.pos-=num||1}},{key:"forward",value:function(num){this.pos+=num||1}},{key:"ignore",value:function(){this.start=this.pos}},{key:"accept",value:function(valid){var ch=this.next();return-1!==ch&&(!!valid.includes(ch)||(this.backup(),!1))}},{key:"acceptRe",value:function(validRe){var ch=this.next();return-1!==ch&&(!!validRe.test(ch)||(this.backup(),!1))}},{key:"acceptRun",value:function(valid){for(;;){var ch=this.next();if(-1===ch)return;if(!valid.includes(ch))break}this.backup()}},{key:"acceptRunRe",value:function(validRe){for(;;){var ch=this.next();if(-1===ch)return;if(!validRe.test(ch))break}this.backup()}},{key:"emit",value:function(type){this.items.push({type:type,text:this.source.slice(this.start,this.pos),start:this.start,pos:this.pos}),this.start=this.pos}},{key:"error",value:function(type,message){if(arguments.length<2)throw new Error("Lexer.prototype.error called with too few parameters (type:number , message:string)");return this.items.push({type:type,message:message,text:this.source.slice(this.start,this.pos),start:this.start,pos:this.pos}),null}}],[{key:"enumFromNames",value:function(names){var obj=names.reduce((function(obj,name,i){return obj[name]=i,obj}),{});return Object.freeze(Object.assign(Object.create(null),obj))}}]),Lexer}();return{EOF:-1,Lexer:Lexer}}(),EOF=_ref9.EOF,Lexer=_ref9.Lexer,Wikifier=function(){var _optionsStack,lookaheadRe,idOrClassRe,_callDepth=0,Wikifier=function(){function Wikifier(destination,source,options){_classCallCheck(this,Wikifier),Wikifier.Parser.Profile.isEmpty()&&Wikifier.Parser.Profile.compile(),Object.defineProperties(this,{source:{value:String(source)},options:{writable:!0,value:Object.assign({profile:"all"},options)},nextMatch:{writable:!0,value:0},output:{writable:!0,value:null},_rawArgs:{writable:!0,value:""}}),null==destination?this.output=document.createDocumentFragment():destination.jquery?this.output=destination[0]:this.output=destination;try{++_callDepth,this.subWikify(this.output),1===_callDepth&&Config.cleanupWikifierOutput&&convertBreaks(this.output)}finally{--_callDepth}}return _createClass(Wikifier,[{key:"subWikify",value:function(output,terminator,options){var newOptions,oldOptions,oldOutput=this.output;this.output=output,Wikifier.Option.length>0&&(newOptions=Object.assign(newOptions||{},Wikifier.Option.options)),null!==options&&"object"===_typeof(options)&&(newOptions=Object.assign(newOptions||{},options)),newOptions&&(oldOptions=this.options,this.options=Object.assign({},this.options,newOptions));var terminatorMatch,parserMatch,parsersProfile=Wikifier.Parser.Profile.get(this.options.profile),terminatorRegExp=terminator?new RegExp("(?:".concat(terminator,")"),this.options.ignoreTerminatorCase?"gim":"gm"):null;do{if(parsersProfile.parserRegExp.lastIndex=this.nextMatch,terminatorRegExp&&(terminatorRegExp.lastIndex=this.nextMatch),parserMatch=parsersProfile.parserRegExp.exec(this.source),(terminatorMatch=terminatorRegExp?terminatorRegExp.exec(this.source):null)&&(!parserMatch||terminatorMatch.index<=parserMatch.index))return terminatorMatch.index>this.nextMatch&&this.outputText(this.output,this.nextMatch,terminatorMatch.index),this.matchStart=terminatorMatch.index,this.matchLength=terminatorMatch[0].length,this.matchText=terminatorMatch[0],this.nextMatch=terminatorRegExp.lastIndex,this.output=oldOutput,void(oldOptions&&(this.options=oldOptions));if(parserMatch){parserMatch.index>this.nextMatch&&this.outputText(this.output,this.nextMatch,parserMatch.index),this.matchStart=parserMatch.index,this.matchLength=parserMatch[0].length,this.matchText=parserMatch[0],this.nextMatch=parsersProfile.parserRegExp.lastIndex;for(var matchingParser=void 0,i=1,iend=parserMatch.length;i<iend;++i)if(parserMatch[i]){matchingParser=i-1;break}if(parsersProfile.parsers[matchingParser].handler(this),null!=TempState.break)break}}while(terminatorMatch||parserMatch);null==TempState.break?this.nextMatch<this.source.length&&(this.outputText(this.output,this.nextMatch,this.source.length),this.nextMatch=this.source.length):this.output.lastChild&&this.output.lastChild.nodeType===Node.ELEMENT_NODE&&"BR"===this.output.lastChild.nodeName.toUpperCase()&&jQuery(this.output.lastChild).remove(),this.output=oldOutput,oldOptions&&(this.options=oldOptions)}},{key:"outputText",value:function(destination,startPos,endPos){jQuery(destination).append(document.createTextNode(this.source.substring(startPos,endPos)))}},{key:"rawArgs",value:function(){return this._rawArgs}},{key:"fullArgs",value:function(){return Scripting.parse(this._rawArgs)}}],[{key:"wikifyEval",value:function(text){var output=document.createDocumentFragment();new Wikifier(output,text);var errors=output.querySelector(".error");if(null!==errors)throw new Error(errors.textContent.replace(errorPrologRegExp,""));return output}},{key:"createInternalLink",value:function(destination,passage,text,callback){var $link=jQuery(document.createElement("a"));return null!=passage&&($link.attr("data-passage",passage),Story.has(passage)?($link.addClass("link-internal"),Config.addVisitedLinkClass&&State.hasPlayed(passage)&&$link.addClass("link-visited")):$link.addClass("link-broken"),$link.ariaClick({one:!0},(function(){"function"==typeof callback&&callback(),Engine.play(passage)}))),text&&$link.append(document.createTextNode(text)),destination&&$link.appendTo(destination),$link[0]}},{key:"createExternalLink",value:function(destination,url,text){var $link=jQuery(document.createElement("a")).attr("target","_blank").addClass("link-external").text(text).appendTo(destination);return null!=url&&$link.attr({href:url,tabindex:0}),$link[0]}},{key:"isExternalLink",value:function(link){return!Story.has(link)&&(new RegExp("^".concat(Patterns.url),"gim").test(link)||/[/.?#]/.test(link))}}]),Wikifier}();return Object.defineProperty(Wikifier,"Option",{value:(_optionsStack=[],Object.freeze(Object.defineProperties({},{length:{get:function(){return _optionsStack.length}},options:{get:function(){return Object.assign.apply(Object,[{}].concat(_toConsumableArray(_optionsStack)))}},clear:{value:function(){_optionsStack=[]}},get:{value:function(idx){return _optionsStack[idx]}},pop:{value:function(){return _optionsStack.pop()}},push:{value:function(options){if("object"!==_typeof(options)||null===options)throw new TypeError("Wikifier.Option.push options parameter must be an object (received: ".concat(Util.getType(options),")"));return _optionsStack.push(options)}}})))}),Object.defineProperty(Wikifier,"Parser",{value:function(){var _profiles,_parsers=[];function parsersHas(name){return!!_parsers.find((function(parser){return parser.name===name}))}return Object.freeze(Object.defineProperties({},{parsers:{get:function(){return _parsers}},add:{value:function(parser){if("object"!==_typeof(parser))throw new Error("Wikifier.Parser.add parser parameter must be an object");if(!parser.hasOwnProperty("name"))throw new Error('parser object missing required "name" property');if("string"!=typeof parser.name)throw new Error('parser object "name" property must be a string');if(!parser.hasOwnProperty("match"))throw new Error('parser object missing required "match" property');if("string"!=typeof parser.match)throw new Error('parser object "match" property must be a string');if(!parser.hasOwnProperty("handler"))throw new Error('parser object missing required "handler" property');if("function"!=typeof parser.handler)throw new Error('parser object "handler" property must be a function');if(parser.hasOwnProperty("profiles")&&!Array.isArray(parser.profiles))throw new Error('parser object "profiles" property must be an array');if(parsersHas(parser.name))throw new Error('cannot clobber existing parser "'.concat(parser.name,'"'));_parsers.push(parser)}},delete:{value:function(name){var parser=_parsers.find((function(parser){return parser.name===name}));parser&&_parsers.delete(parser)}},isEmpty:{value:function(){return 0===_parsers.length}},has:{value:parsersHas},get:{value:function(name){return _parsers.find((function(parser){return parser.name===name}))||null}},Profile:{value:Object.freeze(Object.defineProperties({},{profiles:{get:function(){return _profiles}},compile:{value:function(){var all=_parsers,core=all.filter((function(parser){return!Array.isArray(parser.profiles)||parser.profiles.includes("core")}));return _profiles=Object.freeze({all:{parsers:all,parserRegExp:new RegExp(all.map((function(parser){return"(".concat(parser.match,")")})).join("|"),"gm")},core:{parsers:core,parserRegExp:new RegExp(core.map((function(parser){return"(".concat(parser.match,")")})).join("|"),"gm")}})}},isEmpty:{value:function(){return"object"!==_typeof(_profiles)||0===Object.keys(_profiles).length}},has:{value:function(profile){return"object"===_typeof(_profiles)&&_profiles.hasOwnProperty(profile)}},get:{value:function(profile){if("object"!==_typeof(_profiles)||!_profiles.hasOwnProperty(profile))throw new Error('nonexistent parser profile "'.concat(profile,'"'));return _profiles[profile]}}}))}}))}()}),Object.defineProperties(Wikifier,{helpers:{value:{}},getValue:{value:State.getVar},setValue:{value:State.setVar},parse:{value:Scripting.parse},evalExpression:{value:Scripting.evalTwineScript},evalStatements:{value:Scripting.evalTwineScript},textPrimitives:{value:Patterns}}),Object.defineProperties(Wikifier.helpers,{inlineCss:{value:(lookaheadRe=new RegExp(Patterns.inlineCss,"gm"),idOrClassRe=new RegExp("(".concat(Patterns.cssIdOrClassSigil,")(").concat(Patterns.anyLetter,"+)"),"g"),function(w){var matched,css={classes:[],id:"",styles:{}};do{lookaheadRe.lastIndex=w.nextMatch;var match=lookaheadRe.exec(w.source);if(matched=match&&match.index===w.nextMatch){if(match[1])css.styles[Util.fromCssProperty(match[1])]=match[2].trim();else if(match[3])css.styles[Util.fromCssProperty(match[3])]=match[4].trim();else if(match[5]){var subMatch=void 0;for(idOrClassRe.lastIndex=0;null!==(subMatch=idOrClassRe.exec(match[5]));)"."===subMatch[1]?css.classes.push(subMatch[2]):css.id=subMatch[2]}w.nextMatch=lookaheadRe.lastIndex}}while(matched);return css})},evalText:{value:function(text){var result;try{switch(_typeof(result=Scripting.evalTwineScript(text))){case"string":""===result.trim()&&(result=text);break;case"number":result=String(result);break;default:result=text}}catch(ex){result=text}return result}},evalPassageId:{value:function(passage){return null==passage||Story.has(passage)?passage:Wikifier.helpers.evalText(passage)}},hasBlockContext:{value:function(nodes){for(var hasGCS="function"==typeof window.getComputedStyle,i=nodes.length-1;i>=0;--i){var node=nodes[i];switch(node.nodeType){case Node.ELEMENT_NODE:var tagName=node.nodeName.toUpperCase();if("BR"===tagName)return!0;var styles=hasGCS?window.getComputedStyle(node,null):node.currentStyle;if(styles&&styles.display){if("none"===styles.display)continue;return"block"===styles.display}switch(tagName){case"ADDRESS":case"ARTICLE":case"ASIDE":case"BLOCKQUOTE":case"CENTER":case"DIV":case"DL":case"FIGURE":case"FOOTER":case"FORM":case"H1":case"H2":case"H3":case"H4":case"H5":case"H6":case"HEADER":case"HR":case"MAIN":case"NAV":case"OL":case"P":case"PRE":case"SECTION":case"TABLE":case"UL":return!0}return!1;case Node.COMMENT_NODE:continue;default:return!1}}return!0}},createShadowSetterCallback:{value:function(){var macroParser=null;function getMacroContextShadowView(){for(var macro=macroParser||function(){if(!macroParser&&!(macroParser=Wikifier.Parser.get("macro")))throw new Error('cannot find "macro" parser');return macroParser}(),view=new Set,context=macro.context;null!==context;context=context.parent)context._shadows&&context._shadows.forEach((function(name){return view.add(name)}));return _toConsumableArray(view)}return function(code){var shadowStore={};return getMacroContextShadowView().forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;shadowStore[varName]=store[varKey]})),function(){var shadowNames=Object.keys(shadowStore),valueCache=shadowNames.length>0?{}:null;try{return shadowNames.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;store.hasOwnProperty(varKey)&&(valueCache[varKey]=store[varKey]),store[varKey]=shadowStore[varName]})),Scripting.evalJavaScript(code)}finally{shadowNames.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;shadowStore[varName]=store[varKey],valueCache.hasOwnProperty(varKey)?store[varKey]=valueCache[varKey]:delete store[varKey]}))}}}}()},parseSquareBracketedMarkup:{value:function(){var Item=Lexer.enumFromNames(["Error","DelimLTR","DelimRTL","InnerMeta","ImageMeta","LinkMeta","Link","RightMeta","Setter","Source","Text"]),Delim=Lexer.enumFromNames(["None","LTR","RTL"]);function slurpQuote(lexer,endQuote){loop:for(;;)switch(lexer.next()){case"\\":var ch=lexer.next();if(ch!==EOF&&"\n"!==ch)break;case EOF:case"\n":return EOF;case endQuote:break loop}return lexer.pos}function lexLeftMeta(lexer){if(!lexer.accept("["))return lexer.error(Item.Error,"malformed square-bracketed markup");if(lexer.accept("["))lexer.data.isLink=!0,lexer.emit(Item.LinkMeta);else{if(lexer.accept("<>"),!(lexer.accept("Ii")&&lexer.accept("Mm")&&lexer.accept("Gg")&&lexer.accept("[")))return lexer.error(Item.Error,"malformed square-bracketed markup");lexer.data.isLink=!1,lexer.emit(Item.ImageMeta)}return lexer.depth=2,lexCoreComponents}function lexCoreComponents(lexer){for(var what=lexer.data.isLink?"link":"image",delim=Delim.None;;)switch(lexer.next()){case EOF:case"\n":return lexer.error(Item.Error,"unterminated ".concat(what," markup"));case'"':if(slurpQuote(lexer,'"')===EOF)return lexer.error(Item.Error,"unterminated double quoted string in ".concat(what," markup"));break;case"|":delim===Delim.None&&(delim=Delim.LTR,lexer.backup(),lexer.emit(Item.Text),lexer.forward(),lexer.emit(Item.DelimLTR));break;case"-":delim===Delim.None&&">"===lexer.peek()&&(delim=Delim.LTR,lexer.backup(),lexer.emit(Item.Text),lexer.forward(2),lexer.emit(Item.DelimLTR));break;case"<":delim===Delim.None&&"-"===lexer.peek()&&(delim=Delim.RTL,lexer.backup(),lexer.emit(lexer.data.isLink?Item.Link:Item.Source),lexer.forward(2),lexer.emit(Item.DelimRTL));break;case"[":++lexer.depth;break;case"]":if(--lexer.depth,1===lexer.depth)switch(lexer.peek()){case"[":return++lexer.depth,lexer.backup(),delim===Delim.RTL?lexer.emit(Item.Text):lexer.emit(lexer.data.isLink?Item.Link:Item.Source),lexer.forward(2),lexer.emit(Item.InnerMeta),lexer.data.isLink?lexSetter:lexImageLink;case"]":return--lexer.depth,lexer.backup(),delim===Delim.RTL?lexer.emit(Item.Text):lexer.emit(lexer.data.isLink?Item.Link:Item.Source),lexer.forward(2),lexer.emit(Item.RightMeta),null;default:return lexer.error(Item.Error,"malformed ".concat(what," markup"))}}}function lexImageLink(lexer){for(var what=lexer.data.isLink?"link":"image";;)switch(lexer.next()){case EOF:case"\n":return lexer.error(Item.Error,"unterminated ".concat(what," markup"));case'"':if(slurpQuote(lexer,'"')===EOF)return lexer.error(Item.Error,"unterminated double quoted string in ".concat(what," markup link component"));break;case"[":++lexer.depth;break;case"]":if(--lexer.depth,1===lexer.depth)switch(lexer.peek()){case"[":return++lexer.depth,lexer.backup(),lexer.emit(Item.Link),lexer.forward(2),lexer.emit(Item.InnerMeta),lexSetter;case"]":return--lexer.depth,lexer.backup(),lexer.emit(Item.Link),lexer.forward(2),lexer.emit(Item.RightMeta),null;default:return lexer.error(Item.Error,"malformed ".concat(what," markup"))}}}function lexSetter(lexer){for(var what=lexer.data.isLink?"link":"image";;)switch(lexer.next()){case EOF:case"\n":return lexer.error(Item.Error,"unterminated ".concat(what," markup"));case'"':if(slurpQuote(lexer,'"')===EOF)return lexer.error(Item.Error,"unterminated double quoted string in ".concat(what," markup setter component"));break;case"'":if(slurpQuote(lexer,"'")===EOF)return lexer.error(Item.Error,"unterminated single quoted string in ".concat(what," markup setter component"));break;case"[":++lexer.depth;break;case"]":if(--lexer.depth,1===lexer.depth)return"]"!==lexer.peek()?lexer.error(Item.Error,"malformed ".concat(what," markup")):(--lexer.depth,lexer.backup(),lexer.emit(Item.Setter),lexer.forward(2),lexer.emit(Item.RightMeta),null)}}return function(w){var lexer=new Lexer(w.source,lexLeftMeta);lexer.start=lexer.pos=w.matchStart;var markup={},items=lexer.run(),last=items.last();return last&&last.type===Item.Error?markup.error=last.message:items.forEach((function(item){var text=item.text.trim();switch(item.type){case Item.ImageMeta:markup.isImage=!0,"<"===text[1]?markup.align="left":">"===text[1]&&(markup.align="right");break;case Item.LinkMeta:markup.isLink=!0;break;case Item.Link:"~"===text[0]?(markup.forceInternal=!0,markup.link=text.slice(1)):markup.link=text;break;case Item.Setter:markup.setter=text;break;case Item.Source:markup.source=text;break;case Item.Text:markup.text=text}})),markup.pos=lexer.pos,markup}}()}}),Wikifier}();!function(){function _verbatimTagHandler(w){this.lookahead.lastIndex=w.matchStart;var match=this.lookahead.exec(w.source);match&&match.index===w.matchStart&&(w.nextMatch=this.lookahead.lastIndex,jQuery(document.createDocumentFragment()).append(match[1]).appendTo(w.output))}Wikifier.Parser.add({name:"quoteByBlock",profiles:["block"],match:"^<<<\\n",terminator:"^<<<\\n",handler:function(w){Wikifier.helpers.hasBlockContext(w.output.childNodes)?w.subWikify(jQuery(document.createElement("blockquote")).appendTo(w.output).get(0),this.terminator):jQuery(w.output).append(document.createTextNode(w.matchText))}}),Wikifier.Parser.add({name:"quoteByLine",profiles:["block"],match:"^>+",lookahead:/^>+/gm,terminator:"\\n",handler:function(w){if(Wikifier.helpers.hasBlockContext(w.output.childNodes)){var matched,i,destStack=[w.output],curLevel=0,newLevel=w.matchLength;do{if(newLevel>curLevel)for(i=curLevel;i<newLevel;++i)destStack.push(jQuery(document.createElement("blockquote")).appendTo(destStack[destStack.length-1]).get(0));else if(newLevel<curLevel)for(i=curLevel;i>newLevel;--i)destStack.pop();curLevel=newLevel,w.subWikify(destStack[destStack.length-1],this.terminator),jQuery(document.createElement("br")).appendTo(destStack[destStack.length-1]),this.lookahead.lastIndex=w.nextMatch;var match=this.lookahead.exec(w.source);(matched=match&&match.index===w.nextMatch)&&(newLevel=match[0].length,w.nextMatch+=match[0].length)}while(matched)}else jQuery(w.output).append(document.createTextNode(w.matchText))}}),Wikifier.Parser.add({name:"macro",profiles:["core"],match:"<<",lookahead:new RegExp("<<(/?".concat(Patterns.macroName,")(?:\\s*)((?:(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)|(?://.*\\n)|(?:`(?:\\\\.|[^`\\\\])*`)|(?:\"(?:\\\\.|[^\"\\\\])*\")|(?:'(?:\\\\.|[^'\\\\])*')|(?:\\[(?:[<>]?[Ii][Mm][Gg])?\\[[^\\r\\n]*?\\]\\]+)|[^>]|(?:>(?!>)))*)>>"),"gm"),working:{source:"",name:"",arguments:"",index:0},context:null,handler:function(w){var matchStart=this.lookahead.lastIndex=w.matchStart;if(this.parseTag(w)){var macro,nextMatch=w.nextMatch,name=this.working.name,rawArgs=this.working.arguments;try{if(!(macro=Macro.get(name))){if(Macro.tags.has(name)){var tags=Macro.tags.get(name);return throwError(w.output,"child tag <<".concat(name,">> was found outside of a call to its parent macro").concat(1===tags.length?"":"s"," <<").concat(tags.join(">>, <<"),">>"),w.source.slice(matchStart,w.nextMatch))}return throwError(w.output,"macro <<".concat(name,">> does not exist"),w.source.slice(matchStart,w.nextMatch))}var payload=null;if(void 0!==macro.tags&&!(payload=this.parseBody(w,macro)))return w.nextMatch=nextMatch,throwError(w.output,"cannot find a closing tag for macro <<".concat(name,">>"),"".concat(w.source.slice(matchStart,w.nextMatch),"…"));if("function"!=typeof macro.handler)return throwError(w.output,"macro <<".concat(name,">> handler function ").concat(void 0===macro.handler?"does not exist":"is not a function"),w.source.slice(matchStart,w.nextMatch));var args=payload?payload[0].args:this.createArgs(rawArgs,this.skipArgs(macro,macro.name));if(void 0!==macro._MACRO_API){this.context=new MacroContext({macro:macro,name:name,args:args,payload:payload,source:w.source.slice(matchStart,w.nextMatch),parent:this.context,parser:w});try{macro.handler.call(this.context)}finally{this.context=this.context.parent}}else{var prevRawArgs=w._rawArgs;w._rawArgs=rawArgs;try{macro.handler(w.output,name,args,w,payload)}finally{w._rawArgs=prevRawArgs}}}catch(ex){return throwError(w.output,"cannot execute ".concat(macro&&macro.isWidget?"widget":"macro"," <<").concat(name,">>: ").concat(ex.message),w.source.slice(matchStart,w.nextMatch))}finally{this.working.source="",this.working.name="",this.working.arguments="",this.working.index=0}}else w.outputText(w.output,w.matchStart,w.nextMatch)},parseTag:function(w){var match=this.lookahead.exec(w.source);return!(!match||match.index!==w.matchStart||!match[1])&&(w.nextMatch=this.lookahead.lastIndex,this.working.source=w.source.slice(match.index,this.lookahead.lastIndex),this.working.name=match[1],this.working.arguments=match[2],this.working.index=match.index,!0)},parseBody:function(w,macro){for(var openTag=this.working.name,closeTag="/".concat(openTag),closeAlt="end".concat(openTag),bodyTags=!!Array.isArray(macro.tags)&&macro.tags,payload=[],end=-1,opened=1,curSource=this.working.source,curTag=this.working.name,curArgument=this.working.arguments,contentStart=w.nextMatch;-1!==(w.matchStart=w.source.indexOf(this.match,w.nextMatch));)if(this.parseTag(w)){var tagSource=this.working.source,tagName=this.working.name,tagArgs=this.working.arguments,tagBegin=this.working.index,tagEnd=w.nextMatch,hasArgs=""!==tagArgs.trim();switch(tagName){case openTag:++opened;break;case closeAlt:case closeTag:if(hasArgs)throw w.nextMatch=tagBegin+2+tagName.length,new Error('malformed closing tag: "'.concat(tagSource,'"'));--opened;break;default:if(hasArgs&&(tagName.startsWith("/")||tagName.startsWith("end"))){this.lookahead.lastIndex=w.nextMatch=tagBegin+2+tagName.length;continue}if(1===opened&&bodyTags)for(var i=0,iend=bodyTags.length;i<iend;++i)tagName===bodyTags[i]&&(payload.push({source:curSource,name:curTag,arguments:curArgument,args:this.createArgs(curArgument,this.skipArgs(macro,curTag)),contents:w.source.slice(contentStart,tagBegin)}),curSource=tagSource,curTag=tagName,curArgument=tagArgs,contentStart=tagEnd)}if(0===opened){payload.push({source:curSource,name:curTag,arguments:curArgument,args:this.createArgs(curArgument,this.skipArgs(macro,curTag)),contents:w.source.slice(contentStart,tagBegin)}),end=tagEnd;break}}else this.lookahead.lastIndex=w.nextMatch=w.matchStart+this.match.length;return-1!==end?(w.nextMatch=end,payload):null},createArgs:function(rawArgsString,skipArgs){var args=skipArgs?[]:this.parseArgs(rawArgsString);return Object.defineProperties(args,{raw:{value:rawArgsString},full:{value:Scripting.parse(rawArgsString)}}),args},skipArgs:function(macro,tagName){if(void 0!==macro.skipArgs){var sa=macro.skipArgs;return"boolean"==typeof sa&&sa||Array.isArray(sa)&&sa.includes(tagName)}return void 0!==macro.skipArg0&&(macro.skipArg0&&macro.name===tagName)},parseArgs:function(){var Item=Lexer.enumFromNames(["Error","Bareword","Expression","String","SquareBracket"]),spaceRe=new RegExp(Patterns.space),notSpaceRe=new RegExp(Patterns.notSpace),varTest=new RegExp("^".concat(Patterns.variable));function slurpQuote(lexer,endQuote){loop:for(;;)switch(lexer.next()){case"\\":var ch=lexer.next();if(ch!==EOF&&"\n"!==ch)break;case EOF:case"\n":return EOF;case endQuote:break loop}return lexer.pos}function lexSpace(lexer){var offset=lexer.source.slice(lexer.pos).search(notSpaceRe);if(offset===EOF)return null;switch(0!==offset&&(lexer.pos+=offset,lexer.ignore()),lexer.next()){case"`":return lexExpression;case'"':return lexDoubleQuote;case"'":return lexSingleQuote;case"[":return lexSquareBracket;default:return lexBareword}}function lexExpression(lexer){return slurpQuote(lexer,"`")===EOF?lexer.error(Item.Error,"unterminated backquote expression"):(lexer.emit(Item.Expression),lexSpace)}function lexDoubleQuote(lexer){return slurpQuote(lexer,'"')===EOF?lexer.error(Item.Error,"unterminated double quoted string"):(lexer.emit(Item.String),lexSpace)}function lexSingleQuote(lexer){return slurpQuote(lexer,"'")===EOF?lexer.error(Item.Error,"unterminated single quoted string"):(lexer.emit(Item.String),lexSpace)}function lexSquareBracket(lexer){var what;if(lexer.accept("<>IiMmGg")?(what="image",lexer.acceptRun("<>IiMmGg")):what="link",!lexer.accept("["))return lexer.error(Item.Error,"malformed ".concat(what," markup"));lexer.depth=2;loop:for(;;)switch(lexer.next()){case"\\":var ch=lexer.next();if(ch!==EOF&&"\n"!==ch)break;case EOF:case"\n":return lexer.error(Item.Error,"unterminated ".concat(what," markup"));case"[":++lexer.depth;break;case"]":if(--lexer.depth,lexer.depth<0)return lexer.error(Item.Error,"unexpected right square bracket ']'");if(1===lexer.depth){if("]"===lexer.next()){--lexer.depth;break loop}lexer.backup()}}return lexer.emit(Item.SquareBracket),lexSpace}function lexBareword(lexer){var offset=lexer.source.slice(lexer.pos).search(spaceRe);return lexer.pos=offset===EOF?lexer.source.length:lexer.pos+offset,lexer.emit(Item.Bareword),offset===EOF?null:lexSpace}return function(rawArgsString){var lexer=new Lexer(rawArgsString,lexSpace),args=[];return lexer.run().forEach((function(item){var arg=item.text;switch(item.type){case Item.Error:throw new Error('unable to parse macro argument "'.concat(arg,'": ').concat(item.message));case Item.Bareword:if(varTest.test(arg))arg=State.getVar(arg);else if(/^(?:settings|setup)[.[]/.test(arg))try{arg=Scripting.evalTwineScript(arg)}catch(ex){throw new Error('unable to parse macro argument "'.concat(arg,'": ').concat(ex.message))}else if("null"===arg)arg=null;else if("undefined"===arg)arg=undefined;else if("true"===arg)arg=!0;else if("false"===arg)arg=!1;else if("NaN"===arg)arg=NaN;else{var argAsNum=Number(arg);Number.isNaN(argAsNum)||(arg=argAsNum)}break;case Item.Expression:if(""===(arg=arg.slice(1,-1).trim()))arg=undefined;else try{arg=Scripting.evalTwineScript("(".concat(arg,")"))}catch(ex){throw new Error('unable to parse macro argument expression "'.concat(arg,'": ').concat(ex.message))}break;case Item.String:try{arg=Scripting.evalJavaScript(arg)}catch(ex){throw new Error('unable to parse macro argument string "'.concat(arg,'": ').concat(ex.message))}break;case Item.SquareBracket:var markup=Wikifier.helpers.parseSquareBracketedMarkup({source:arg,matchStart:0});if(markup.hasOwnProperty("error"))throw new Error('unable to parse macro argument "'.concat(arg,'": ').concat(markup.error));if(markup.pos<arg.length)throw new Error('unable to parse macro argument "'.concat(arg,'": unexpected character(s) "').concat(arg.slice(markup.pos),'" (pos: ').concat(markup.pos,")"));markup.isLink?((arg={isLink:!0}).count=markup.hasOwnProperty("text")?2:1,arg.link=Wikifier.helpers.evalPassageId(markup.link),arg.text=markup.hasOwnProperty("text")?Wikifier.helpers.evalText(markup.text):arg.link,arg.external=!markup.forceInternal&&Wikifier.isExternalLink(arg.link),arg.setFn=markup.hasOwnProperty("setter")?Wikifier.helpers.createShadowSetterCallback(Scripting.parse(markup.setter)):null):markup.isImage&&(arg=function(source){var imgObj={source:source,isImage:!0};if("data:"!==source.slice(0,5)&&Story.has(source)){var passage=Story.get(source);passage.tags.includes("Twine.image")&&(imgObj.source=passage.text,imgObj.passage=passage.title)}return imgObj}(Wikifier.helpers.evalPassageId(markup.source)),markup.hasOwnProperty("align")&&(arg.align=markup.align),markup.hasOwnProperty("text")&&(arg.title=Wikifier.helpers.evalText(markup.text)),markup.hasOwnProperty("link")&&(arg.link=Wikifier.helpers.evalPassageId(markup.link),arg.external=!markup.forceInternal&&Wikifier.isExternalLink(arg.link)),arg.setFn=markup.hasOwnProperty("setter")?Wikifier.helpers.createShadowSetterCallback(Scripting.parse(markup.setter)):null)}args.push(arg)})),args}}()}),Wikifier.Parser.add({name:"link",profiles:["core"],match:"\\[\\[[^[]",handler:function(w){var markup=Wikifier.helpers.parseSquareBracketedMarkup(w);if(markup.hasOwnProperty("error"))w.outputText(w.output,w.matchStart,w.nextMatch);else{w.nextMatch=markup.pos;var link=Wikifier.helpers.evalPassageId(markup.link),text=markup.hasOwnProperty("text")?Wikifier.helpers.evalText(markup.text):link,setFn=markup.hasOwnProperty("setter")?Wikifier.helpers.createShadowSetterCallback(Scripting.parse(markup.setter)):null,output=(Config.debug?new DebugView(w.output,"link-markup","[[link]]",w.source.slice(w.matchStart,w.nextMatch)):w).output;markup.forceInternal||!Wikifier.isExternalLink(link)?Wikifier.createInternalLink(output,link,text,setFn):Wikifier.createExternalLink(output,link,text)}}}),Wikifier.Parser.add({name:"urlLink",profiles:["core"],match:Patterns.url,handler:function(w){w.outputText(Wikifier.createExternalLink(w.output,w.matchText),w.matchStart,w.nextMatch)}}),Wikifier.Parser.add({name:"image",profiles:["core"],match:"\\[[<>]?[Ii][Mm][Gg]\\[",handler:function(w){var markup=Wikifier.helpers.parseSquareBracketedMarkup(w);if(markup.hasOwnProperty("error"))w.outputText(w.output,w.matchStart,w.nextMatch);else{var debugView;w.nextMatch=markup.pos,Config.debug&&(debugView=new DebugView(w.output,"image-markup",markup.hasOwnProperty("link")?"[img[][link]]":"[img[]]",w.source.slice(w.matchStart,w.nextMatch))).modes({block:!0});var source,setFn=markup.hasOwnProperty("setter")?Wikifier.helpers.createShadowSetterCallback(Scripting.parse(markup.setter)):null,el=(Config.debug?debugView:w).output;if(markup.hasOwnProperty("link")){var link=Wikifier.helpers.evalPassageId(markup.link);(el=markup.forceInternal||!Wikifier.isExternalLink(link)?Wikifier.createInternalLink(el,link,null,setFn):Wikifier.createExternalLink(el,link)).classList.add("link-image")}if(el=jQuery(document.createElement("img")).appendTo(el).get(0),"data:"!==(source=Wikifier.helpers.evalPassageId(markup.source)).slice(0,5)&&Story.has(source)){var passage=Story.get(source);passage.tags.includes("Twine.image")&&(el.setAttribute("data-passage",passage.title),source=passage.text.trim())}el.src=source,markup.hasOwnProperty("text")&&(el.title=Wikifier.helpers.evalText(markup.text)),markup.hasOwnProperty("align")&&(el.align=markup.align)}}}),Wikifier.Parser.add({name:"monospacedByBlock",profiles:["block"],match:"^\\{\\{\\{\\n",lookahead:/^\{\{\{\n((?:^[^\n]*\n)+?)(^\}\}\}$\n?)/gm,handler:function(w){this.lookahead.lastIndex=w.matchStart;var match=this.lookahead.exec(w.source);if(match&&match.index===w.matchStart){var pre=jQuery(document.createElement("pre"));jQuery(document.createElement("code")).text(match[1]).appendTo(pre),pre.appendTo(w.output),w.nextMatch=this.lookahead.lastIndex}}}),Wikifier.Parser.add({name:"formatByChar",profiles:["core"],match:"''|//|__|\\^\\^|~~|==|\\{\\{\\{",handler:function(w){switch(w.matchText){case"''":w.subWikify(jQuery(document.createElement("strong")).appendTo(w.output).get(0),"''");break;case"//":w.subWikify(jQuery(document.createElement("em")).appendTo(w.output).get(0),"//");break;case"__":w.subWikify(jQuery(document.createElement("u")).appendTo(w.output).get(0),"__");break;case"^^":w.subWikify(jQuery(document.createElement("sup")).appendTo(w.output).get(0),"\\^\\^");break;case"~~":w.subWikify(jQuery(document.createElement("sub")).appendTo(w.output).get(0),"~~");break;case"==":w.subWikify(jQuery(document.createElement("s")).appendTo(w.output).get(0),"==");break;case"{{{":var lookahead=/\{\{\{((?:.|\n)*?)\}\}\}/gm;lookahead.lastIndex=w.matchStart;var match=lookahead.exec(w.source);match&&match.index===w.matchStart&&(jQuery(document.createElement("code")).text(match[1]).appendTo(w.output),w.nextMatch=lookahead.lastIndex)}}}),Wikifier.Parser.add({name:"customStyle",profiles:["core"],match:"@@",terminator:"@@",blockRe:/\s*\n/gm,handler:function(w){var css=Wikifier.helpers.inlineCss(w);this.blockRe.lastIndex=w.nextMatch;var blockMatch=this.blockRe.exec(w.source),blockLevel=blockMatch&&blockMatch.index===w.nextMatch,$el=jQuery(document.createElement(blockLevel?"div":"span")).appendTo(w.output);0===css.classes.length&&""===css.id&&0===Object.keys(css.styles).length?$el.addClass("marked"):(css.classes.forEach((function(className){return $el.addClass(className)})),""!==css.id&&$el.attr("id",css.id),$el.css(css.styles)),blockLevel?(w.nextMatch+=blockMatch[0].length,w.subWikify($el[0],"\\n?".concat(this.terminator))):w.subWikify($el[0],this.terminator)}}),Wikifier.Parser.add({name:"verbatimText",profiles:["core"],match:'"{3}|<[Nn][Oo][Ww][Ii][Kk][Ii]>',lookahead:/(?:"{3}((?:.|\n)*?)"{3})|(?:<[Nn][Oo][Ww][Ii][Kk][Ii]>((?:.|\n)*?)<\/[Nn][Oo][Ww][Ii][Kk][Ii]>)/gm,handler:function(w){this.lookahead.lastIndex=w.matchStart;var match=this.lookahead.exec(w.source);match&&match.index===w.matchStart&&(w.nextMatch=this.lookahead.lastIndex,jQuery(document.createElement("span")).addClass("verbatim").text(match[1]||match[2]).appendTo(w.output))}}),Wikifier.Parser.add({name:"horizontalRule",profiles:["core"],match:"^----+$\\n?|<[Hh][Rr]\\s*/?>\\n?",handler:function(w){jQuery(document.createElement("hr")).appendTo(w.output)}}),Wikifier.Parser.add({name:"emdash",profiles:["core"],match:"--",handler:function(w){jQuery(document.createTextNode("—")).appendTo(w.output)}}),Wikifier.Parser.add({name:"doubleDollarSign",profiles:["core"],match:"\\${2}",handler:function(w){jQuery(document.createTextNode("$")).appendTo(w.output)}}),Wikifier.Parser.add({name:"nakedVariable",profiles:["core"],match:"".concat(Patterns.variable,"(?:(?:\\.").concat(Patterns.identifier,")|(?:\\[\\d+\\])|(?:\\[\"(?:\\\\.|[^\"\\\\])+\"\\])|(?:\\['(?:\\\\.|[^'\\\\])+'\\])|(?:\\[").concat(Patterns.variable,"\\]))*"),handler:function(w){var result=State.getVar(w.matchText);null==result?jQuery(document.createTextNode(w.matchText)).appendTo(w.output):new Wikifier((Config.debug?new DebugView(w.output,"variable",w.matchText,w.matchText):w).output,stringFrom(result))}}),Wikifier.Parser.add({name:"template",profiles:["core"],match:"\\?".concat(Patterns.templateName),handler:function(w){var name=w.matchText.slice(1),template=Template.get(name),result=null;switch(template instanceof Array&&(template=template.random()),_typeof(template)){case"function":try{result=stringFrom(template.call({name:name}))}catch(ex){return throwError(w.output,"cannot execute function template ?".concat(name,": ").concat(ex.message),w.source.slice(w.matchStart,w.nextMatch))}break;case"string":result=template}null===result?jQuery(document.createTextNode(w.matchText)).appendTo(w.output):new Wikifier((Config.debug?new DebugView(w.output,"template",w.matchText,w.matchText):w).output,result)}}),Wikifier.Parser.add({name:"heading",profiles:["block"],match:"^!{1,6}",terminator:"\\n",handler:function(w){Wikifier.helpers.hasBlockContext(w.output.childNodes)?w.subWikify(jQuery(document.createElement("h".concat(w.matchLength))).appendTo(w.output).get(0),this.terminator):jQuery(w.output).append(document.createTextNode(w.matchText))}}),Wikifier.Parser.add({name:"table",profiles:["block"],match:"^\\|(?:[^\\n]*)\\|(?:[fhck]?)$",lookahead:/^\|([^\n]*)\|([fhck]?)$/gm,rowTerminator:"\\|(?:[cfhk]?)$\\n?",cellPattern:"(?:\\|([^\\n\\|]*)\\|)|(\\|[cfhk]?$\\n?)",cellTerminator:"(?:\\u0020*)\\|",rowTypes:{c:"caption",f:"tfoot",h:"thead","":"tbody"},handler:function(w){if(Wikifier.helpers.hasBlockContext(w.output.childNodes)){var matched,table=jQuery(document.createElement("table")).appendTo(w.output).get(0),prevColumns=[],curRowType=null,$rowContainer=null,rowCount=0;w.nextMatch=w.matchStart;do{this.lookahead.lastIndex=w.nextMatch;var match=this.lookahead.exec(w.source);if(matched=match&&match.index===w.nextMatch){var nextRowType=match[2];"k"===nextRowType?(table.className=match[1],w.nextMatch+=match[0].length+1):(nextRowType!==curRowType&&(curRowType=nextRowType,$rowContainer=jQuery(document.createElement(this.rowTypes[nextRowType])).appendTo(table)),"c"===curRowType?($rowContainer.css("caption-side",0===rowCount?"top":"bottom"),w.nextMatch+=1,w.subWikify($rowContainer[0],this.rowTerminator)):this.rowHandler(w,jQuery(document.createElement("tr")).appendTo($rowContainer).get(0),prevColumns),++rowCount)}}while(matched)}else jQuery(w.output).append(document.createTextNode(w.matchText))},rowHandler:function(w,rowEl,prevColumns){var matched,_this12=this,cellRe=new RegExp(this.cellPattern,"gm"),col=0,curColCount=1;do{cellRe.lastIndex=w.nextMatch;var cellMatch=cellRe.exec(w.source);if(matched=cellMatch&&cellMatch.index===w.nextMatch){if("~"===cellMatch[1]){var last=prevColumns[col];last&&(++last.rowCount,last.$element.attr("rowspan",last.rowCount).css("vertical-align","middle")),w.nextMatch=cellMatch.index+cellMatch[0].length-1}else if(">"===cellMatch[1])++curColCount,w.nextMatch=cellMatch.index+cellMatch[0].length-1;else{if(cellMatch[2]){w.nextMatch=cellMatch.index+cellMatch[0].length;break}!function(){++w.nextMatch;for(var css=Wikifier.helpers.inlineCss(w),spaceLeft=!1,spaceRight=!1,$cell=void 0;" "===w.source.substr(w.nextMatch,1);)spaceLeft=!0,++w.nextMatch;"!"===w.source.substr(w.nextMatch,1)?($cell=jQuery(document.createElement("th")).appendTo(rowEl),++w.nextMatch):$cell=jQuery(document.createElement("td")).appendTo(rowEl),prevColumns[col]={rowCount:1,$element:$cell},curColCount>1&&($cell.attr("colspan",curColCount),curColCount=1),w.subWikify($cell[0],_this12.cellTerminator)," "===w.matchText.substr(w.matchText.length-2,1)&&(spaceRight=!0),css.classes.forEach((function(className){return $cell.addClass(className)})),""!==css.id&&$cell.attr("id",css.id),spaceLeft&&spaceRight?css.styles["text-align"]="center":spaceLeft?css.styles["text-align"]="right":spaceRight&&(css.styles["text-align"]="left"),$cell.css(css.styles),w.nextMatch=w.nextMatch-1}()}++col}}while(matched)}}),Wikifier.Parser.add({name:"list",profiles:["block"],match:"^(?:(?:\\*+)|(?:#+))",lookahead:/^(?:(\*+)|(#+))/gm,terminator:"\\n",handler:function(w){if(Wikifier.helpers.hasBlockContext(w.output.childNodes)){w.nextMatch=w.matchStart;var matched,i,destStack=[w.output],curType=null,curLevel=0;do{this.lookahead.lastIndex=w.nextMatch;var match=this.lookahead.exec(w.source);if(matched=match&&match.index===w.nextMatch){var newType=match[2]?"ol":"ul",newLevel=match[0].length;if(w.nextMatch+=match[0].length,newLevel>curLevel)for(i=curLevel;i<newLevel;++i)destStack.push(jQuery(document.createElement(newType)).appendTo(destStack[destStack.length-1]).get(0));else if(newLevel<curLevel)for(i=curLevel;i>newLevel;--i)destStack.pop();else newLevel===curLevel&&newType!==curType&&(destStack.pop(),destStack.push(jQuery(document.createElement(newType)).appendTo(destStack[destStack.length-1]).get(0)));curLevel=newLevel,curType=newType,w.subWikify(jQuery(document.createElement("li")).appendTo(destStack[destStack.length-1]).get(0),this.terminator)}}while(matched)}else jQuery(w.output).append(document.createTextNode(w.matchText))}}),Wikifier.Parser.add({name:"commentByBlock",profiles:["core"],match:"(?:/(?:%|\\*))|(?:\x3c!--)",lookahead:/(?:\/(%|\*)(?:(?:.|\n)*?)\1\/)|(?:<!--(?:(?:.|\n)*?)-->)/gm,handler:function(w){this.lookahead.lastIndex=w.matchStart;var match=this.lookahead.exec(w.source);match&&match.index===w.matchStart&&(w.nextMatch=this.lookahead.lastIndex)}}),Wikifier.Parser.add({name:"lineContinuation",profiles:["core"],match:"\\\\".concat(Patterns.spaceNoTerminator,"*\\n|\\n").concat(Patterns.spaceNoTerminator,"*\\\\|\\n?\\\\").concat(Patterns.spaceNoTerminator,"*$|^").concat(Patterns.spaceNoTerminator,"*\\\\\\n?"),handler:function(w){w.nextMatch=w.matchStart+w.matchLength}}),Wikifier.Parser.add({name:"lineBreak",profiles:["core"],match:"\\n|<[Bb][Rr]\\s*/?>",handler:function(w){w.options.nobr||jQuery(document.createElement("br")).appendTo(w.output)}}),Wikifier.Parser.add({name:"htmlCharacterReference",profiles:["core"],match:"(?:(?:&#?[0-9A-Za-z]{2,8};|.)(?:&#?(?:x0*(?:3[0-6][0-9A-Fa-f]|1D[C-Fc-f][0-9A-Fa-f]|20[D-Fd-f][0-9A-Fa-f]|FE2[0-9A-Fa-f])|0*(?:76[89]|7[7-9][0-9]|8[0-7][0-9]|761[6-9]|76[2-7][0-9]|84[0-3][0-9]|844[0-7]|6505[6-9]|6506[0-9]|6507[0-1]));)+|&#?[0-9A-Za-z]{2,8};)",handler:function(w){jQuery(document.createDocumentFragment()).append(w.matchText).appendTo(w.output)}}),Wikifier.Parser.add({name:"xmlProlog",profiles:["core"],match:"<\\?[Xx][Mm][Ll][^>]*\\?>",handler:function(w){w.nextMatch=w.matchStart+w.matchLength}}),Wikifier.Parser.add({name:"verbatimHtml",profiles:["core"],match:"<[Hh][Tt][Mm][Ll]>",lookahead:/<[Hh][Tt][Mm][Ll]>((?:.|\n)*?)<\/[Hh][Tt][Mm][Ll]>/gm,handler:_verbatimTagHandler}),Wikifier.Parser.add({name:"verbatimScriptTag",profiles:["core"],match:"<[Ss][Cc][Rr][Ii][Pp][Tt][^>]*>",lookahead:/(<[Ss][Cc][Rr][Ii][Pp][Tt]*>(?:.|\n)*?<\/[Ss][Cc][Rr][Ii][Pp][Tt]>)/gm,handler:_verbatimTagHandler}),Wikifier.Parser.add({name:"styleTag",profiles:["core"],match:"<[Ss][Tt][Yy][Ll][Ee][^>]*>",lookahead:/(<[Ss][Tt][Yy][Ll][Ee]*>)((?:.|\n)*?)(<\/[Ss][Tt][Yy][Ll][Ee]>)/gm,imageMarkup:new RegExp(Patterns.cssImage,"g"),hasImageMarkup:new RegExp(Patterns.cssImage),handler:function(w){this.lookahead.lastIndex=w.matchStart;var match=this.lookahead.exec(w.source);if(match&&match.index===w.matchStart){w.nextMatch=this.lookahead.lastIndex;var css=match[2];this.hasImageMarkup.test(css)&&(this.imageMarkup.lastIndex=0,css=css.replace(this.imageMarkup,(function(wikiImage){var markup=Wikifier.helpers.parseSquareBracketedMarkup({source:wikiImage,matchStart:0});if(markup.hasOwnProperty("error")||markup.pos<wikiImage.length)return wikiImage;var source=markup.source;if("data:"!==source.slice(0,5)&&Story.has(source)){var passage=Story.get(source);passage.tags.includes("Twine.image")&&(source=passage.text)}return'url("'.concat(source.replace(/"/g,"%22"),'")')}))),jQuery(document.createDocumentFragment()).append(match[1]+css+match[3]).appendTo(w.output)}}}),Wikifier.Parser.add({name:"svgTag",profiles:["core"],match:"<[Ss][Vv][Gg][^>]*>",lookahead:/<(\/?)[Ss][Vv][Gg][^>]*>/gm,namespace:"http://www.w3.org/2000/svg",handler:function(w){var _this13=this;this.lookahead.lastIndex=w.nextMatch;for(var match,depth=1;depth>0&&null!==(match=this.lookahead.exec(w.source));)depth+="/"===match[1]?-1:1;if(0===depth){w.nextMatch=this.lookahead.lastIndex;var svgTag=w.source.slice(w.matchStart,this.lookahead.lastIndex),$frag=jQuery(document.createDocumentFragment()).append(svgTag);$frag.find("a[data-passage],image[data-passage]").each((function(_,el){var tagName=el.tagName.toLowerCase();try{_this13.processAttributeDirectives(el)}catch(ex){return throwError(w.output,"svg|<".concat(tagName,">: ").concat(ex.message),"".concat(w.matchText,"…"))}el.hasAttribute("data-passage")&&_this13.processDataAttributes(el,tagName)})),$frag.appendTo(w.output)}},processAttributeDirectives:function(el){_toConsumableArray(el.attributes).forEach((function(_ref10){var name=_ref10.name,value=_ref10.value,evalShorthand="@"===name[0];if(evalShorthand||name.startsWith("sc-eval:")){var result,newName=name.slice(evalShorthand?1:8);if("data-setter"===newName)throw new Error('evaluation directive is not allowed on the data-setter attribute: "'.concat(name,'"'));try{result=Scripting.evalTwineScript(value)}catch(ex){throw new Error('bad evaluation from attribute directive "'.concat(name,'": ').concat(ex.message))}try{el.setAttribute(newName,result),el.removeAttribute(name)}catch(ex){throw new Error('cannot transform attribute directive "'.concat(name,'" into attribute "').concat(newName,'"'))}}}))},processDataAttributes:function(el,tagName){var passage=el.getAttribute("data-passage");if(null!=passage){var evaluated=Wikifier.helpers.evalPassageId(passage);if(evaluated!==passage&&(passage=evaluated,el.setAttribute("data-passage",evaluated)),""!==passage)if("image"===tagName)"data:"!==passage.slice(0,5)&&Story.has(passage)&&(passage=Story.get(passage)).tags.includes("Twine.image")&&el.setAttribute("href",passage.text.trim());else{var setFn,setter=el.getAttribute("data-setter");null!=setter&&""!==(setter=String(setter).trim())&&(setFn=Wikifier.helpers.createShadowSetterCallback(Scripting.parse(setter))),Story.has(passage)?(el.classList.add("link-internal"),Config.addVisitedLinkClass&&State.hasPlayed(passage)&&el.classList.add("link-visited")):el.classList.add("link-broken"),jQuery(el).ariaClick({one:!0},(function(){"function"==typeof setFn&&setFn.call(this),Engine.play(passage)}))}}}}),Wikifier.Parser.add({name:"htmlTag",profiles:["core"],match:"<".concat(Patterns.htmlTagName,"(?:\\s+[^\\u0000-\\u001F\\u007F-\\u009F\\s\"'>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*?\"|'[^']*?'|[^\\s\"'=<>`]+))?)*\\s*\\/?>"),tagRe:new RegExp("^<(".concat(Patterns.htmlTagName,")")),mediaTags:["audio","img","source","track","video"],nobrTags:["audio","colgroup","datalist","dl","figure","meter","ol","optgroup","picture","progress","ruby","select","table","tbody","tfoot","thead","tr","ul","video"],voidTags:["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"],handler:function(w){var tagMatch=this.tagRe.exec(w.matchText),tag=tagMatch&&tagMatch[1],tagName=tag&&tag.toLowerCase();if(tagName){var terminator,terminatorMatch,isVoid=this.voidTags.includes(tagName)||w.matchText.endsWith("/>"),isNobr=this.nobrTags.includes(tagName);if(!isVoid){terminator="<\\/".concat(tagName,"\\s*>");var terminatorRe=new RegExp(terminator,"gim");terminatorRe.lastIndex=w.matchStart,terminatorMatch=terminatorRe.exec(w.source)}if(!isVoid&&!terminatorMatch)return throwError(w.output,"cannot find a closing tag for HTML <".concat(tag,">"),"".concat(w.matchText,"…"));var debugView,output=w.output,el=document.createElement(w.output.tagName);for(el.innerHTML=w.matchText;el.firstChild;)el=el.firstChild;try{this.processAttributeDirectives(el)}catch(ex){return throwError(w.output,"<".concat(tagName,">: ").concat(ex.message),"".concat(w.matchText,"…"))}if(el.hasAttribute("data-passage")&&(this.processDataAttributes(el,tagName),Config.debug&&((debugView=new DebugView(w.output,"html-".concat(tagName),tagName,w.matchText)).modes({block:"img"===tagName,nonvoid:terminatorMatch}),output=debugView.output)),terminatorMatch){try{Wikifier.Option.push({nobr:isNobr}),w.subWikify(el,terminator,{ignoreTerminatorCase:!0})}finally{Wikifier.Option.pop()}debugView&&jQuery(el).find(".debug.block").length>0&&debugView.modes({block:!0})}output.appendChild("track"===tagName?el.cloneNode(!0):el)}},processAttributeDirectives:function(el){_toConsumableArray(el.attributes).forEach((function(_ref11){var name=_ref11.name,value=_ref11.value,evalShorthand="@"===name[0];if(evalShorthand||name.startsWith("sc-eval:")){var result,newName=name.slice(evalShorthand?1:8);if("data-setter"===newName)throw new Error('evaluation directive is not allowed on the data-setter attribute: "'.concat(name,'"'));try{result=Scripting.evalTwineScript(value)}catch(ex){throw new Error('bad evaluation from attribute directive "'.concat(name,'": ').concat(ex.message))}try{el.setAttribute(newName,result),el.removeAttribute(name)}catch(ex){throw new Error('cannot transform attribute directive "'.concat(name,'" into attribute "').concat(newName,'"'))}}}))},processDataAttributes:function(el,tagName){var passage=el.getAttribute("data-passage");if(null!=passage){var evaluated=Wikifier.helpers.evalPassageId(passage);if(evaluated!==passage&&(passage=evaluated,el.setAttribute("data-passage",evaluated)),""!==passage)if(this.mediaTags.includes(tagName)){if("data:"!==passage.slice(0,5)&&Story.has(passage)){var parentName,twineTag;switch(passage=Story.get(passage),tagName){case"audio":case"video":twineTag="Twine.".concat(tagName);break;case"img":twineTag="Twine.image";break;case"track":twineTag="Twine.vtt";break;case"source":var $parent=$(el).closest("audio,picture,video");$parent.length&&(parentName=$parent.get(0).tagName.toLowerCase(),twineTag="Twine.".concat("picture"===parentName?"image":parentName))}passage.tags.includes(twineTag)&&(el["picture"===parentName?"srcset":"src"]=passage.text.trim())}}else{var setFn,setter=el.getAttribute("data-setter");null!=setter&&""!==(setter=String(setter).trim())&&(setFn=Wikifier.helpers.createShadowSetterCallback(Scripting.parse(setter))),Story.has(passage)?(el.classList.add("link-internal"),Config.addVisitedLinkClass&&State.hasPlayed(passage)&&el.classList.add("link-visited")):el.classList.add("link-broken"),jQuery(el).ariaClick({one:!0},(function(){"function"==typeof setFn&&setFn.call(this),Engine.play(passage)}))}}}})}();var Template=(_templates=new Map,_validNameRe=new RegExp("^(?:".concat(Patterns.templateName,")$")),_validType=function(template){var templateType=_typeof(template);return"function"===templateType||"string"===templateType},Object.freeze(Object.defineProperties({},{add:{value:function(name,template){if(!(_validType(template)||template instanceof Array&&template.length>0&&template.every(_validType)))throw new TypeError("invalid template type (".concat(name,"); templates must be: functions, strings, or an array of either"));(name instanceof Array?name:[name]).forEach((function(name){if(!_validNameRe.test(name))throw new Error('invalid template name "'.concat(name,'"'));if(_templates.has(name))throw new Error("cannot clobber existing template ?".concat(name));_templates.set(name,template)}))}},delete:{value:function(name){(name instanceof Array?name:[name]).forEach((function(name){return _templates.delete(name)}))}},get:{value:function(name){return _templates.has(name)?_templates.get(name):null}},has:{value:function(name){return _templates.has(name)}},size:{get:function(){return _templates.size}}}))),_templates,_validNameRe,_validType,Macro=function(){var _macros={},_tags={},_validNameRe=new RegExp("^(?:".concat(Patterns.macroName,")$"));function macrosHas(name){return _macros.hasOwnProperty(name)}function tagsRegister(parent,bodyTags){if(!parent)throw new Error("no parent specified");for(var endTags=["/".concat(parent),"end".concat(parent)],allTags=[].concat(endTags,Array.isArray(bodyTags)?bodyTags:[]),i=0;i<allTags.length;++i){var tag=allTags[i];if(macrosHas(tag))throw new Error("cannot register tag for an existing macro");tagsHas(tag)?_tags[tag].includes(parent)||(_tags[tag].push(parent),_tags[tag].sort()):_tags[tag]=[parent]}}function tagsUnregister(parent){if(!parent)throw new Error("no parent specified");Object.keys(_tags).forEach((function(tag){var i=_tags[tag].indexOf(parent);-1!==i&&(1===_tags[tag].length?delete _tags[tag]:_tags[tag].splice(i,1))}))}function tagsHas(name){return _tags.hasOwnProperty(name)}return Object.freeze(Object.defineProperties({},{add:{value:function macrosAdd(name,def){if(Array.isArray(name))name.forEach((function(name){return macrosAdd(name,def)}));else{if(!_validNameRe.test(name))throw new Error('invalid macro name "'.concat(name,'"'));if(macrosHas(name))throw new Error("cannot clobber existing macro <<".concat(name,">>"));if(tagsHas(name))throw new Error("cannot clobber child tag <<".concat(name,">> of parent macro").concat(1===_tags[name].length?"":"s"," <<").concat(_tags[name].join(">>, <<"),">>"));try{if("object"===_typeof(def))_macros[name]=Object.assign(Object.create(null),def,{_MACRO_API:!0});else{if(!macrosHas(def))throw new Error("cannot create alias of nonexistent macro <<".concat(def,">>"));_macros[name]=Object.create(_macros[def],{_ALIAS_OF:{enumerable:!0,value:def}})}Object.defineProperty(_macros,name,{writable:!1})}catch(ex){throw"TypeError"===ex.name?new Error("cannot clobber protected macro <<".concat(name,">>")):new Error("unknown error when attempting to add macro <<".concat(name,">>: [").concat(ex.name,"] ").concat(ex.message))}if(void 0!==_macros[name].tags)if(null==_macros[name].tags)tagsRegister(name);else{if(!Array.isArray(_macros[name].tags))throw new Error('bad value for "tags" property of macro <<'.concat(name,">>"));tagsRegister(name,_macros[name].tags)}}}},delete:{value:function macrosDelete(name){if(Array.isArray(name))name.forEach((function(name){return macrosDelete(name)}));else if(macrosHas(name)){void 0!==_macros[name].tags&&tagsUnregister(name);try{Object.defineProperty(_macros,name,{writable:!0}),delete _macros[name]}catch(ex){throw new Error("unknown error removing macro <<".concat(name,">>: ").concat(ex.message))}}else if(tagsHas(name))throw new Error("cannot remove child tag <<".concat(name,">> of parent macro <<").concat(_tags[name],">>"))}},isEmpty:{value:function(){return 0===Object.keys(_macros).length}},has:{value:macrosHas},get:{value:function(name){var macro=null;return macrosHas(name)&&"function"==typeof _macros[name].handler?macro=_macros[name]:macros.hasOwnProperty(name)&&"function"==typeof macros[name].handler&&(macro=macros[name]),macro}},init:{value:function(){var handler=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"init";Object.keys(_macros).forEach((function(name){"function"==typeof _macros[name][handler]&&_macros[name][handler](name)})),Object.keys(macros).forEach((function(name){"function"==typeof macros[name][handler]&&macros[name][handler](name)}))}},tags:{value:Object.freeze(Object.defineProperties({},{register:{value:tagsRegister},unregister:{value:tagsUnregister},has:{value:tagsHas},get:{value:function(name){return tagsHas(name)?_tags[name]:null}}}))},evalStatements:{value:function(){return Scripting.evalJavaScript.apply(Scripting,arguments)}}}))}(),MacroContext=function(){var MacroContext=function(){function MacroContext(contextData){_classCallCheck(this,MacroContext);var context=Object.assign({parent:null,macro:null,name:"",displayName:"",args:null,payload:null,parser:null,source:""},contextData);if(null===context.macro||""===context.name||null===context.parser)throw new TypeError("context object missing required properties");Object.defineProperties(this,{self:{value:context.macro},name:{value:void 0===context.macro._ALIAS_OF?context.name:context.macro._ALIAS_OF},displayName:{value:context.name},args:{value:context.args},payload:{value:context.payload},source:{value:context.source},parent:{value:context.parent},parser:{value:context.parser},_output:{value:context.parser.output},_shadows:{writable:!0,value:null},_debugView:{writable:!0,value:null},_debugViewEnabled:{writable:!0,value:Config.debug}})}return _createClass(MacroContext,[{key:"output",get:function(){return this._debugViewEnabled?this.debugView.output:this._output}},{key:"shadows",get:function(){return _toConsumableArray(this._shadows)}},{key:"shadowView",get:function(){var view=new Set;return this.contextSelectAll((function(ctx){return ctx._shadows})).forEach((function(ctx){return ctx._shadows.forEach((function(name){return view.add(name)}))})),_toConsumableArray(view)}},{key:"debugView",get:function(){return this._debugViewEnabled?null!==this._debugView?this._debugView:this.createDebugView():null}},{key:"contextHas",value:function(filter){for(var context=this;null!==(context=context.parent);)if(filter(context))return!0;return!1}},{key:"contextSelect",value:function(filter){for(var context=this;null!==(context=context.parent);)if(filter(context))return context;return null}},{key:"contextSelectAll",value:function(filter){for(var result=[],context=this;null!==(context=context.parent);)filter(context)&&result.push(context);return result}},{key:"addShadow",value:function(){var _this14=this;this._shadows||(this._shadows=new Set);for(var varRe=new RegExp("^".concat(Patterns.variable,"$")),_len14=arguments.length,names=new Array(_len14),_key14=0;_key14<_len14;_key14++)names[_key14]=arguments[_key14];names.flat(1/0).forEach((function(name){if("string"!=typeof name)throw new TypeError("variable name must be a string; type: ".concat(_typeof(name)));if(!varRe.test(name))throw new Error('invalid variable name "'.concat(name,'"'));_this14._shadows.add(name)}))}},{key:"createShadowWrapper",value:function(callback,doneCallback,startCallback){var shadowStore,shadowContext=this;return"function"==typeof callback&&(shadowStore={},this.shadowView.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;shadowStore[varName]=store[varKey]}))),function(){for(var _len15=arguments.length,args=new Array(_len15),_key15=0;_key15<_len15;_key15++)args[_key15]=arguments[_key15];if("function"==typeof startCallback&&startCallback.apply(this,args),"function"==typeof callback){var contextCache,shadowNames=Object.keys(shadowStore),valueCache=shadowNames.length>0?{}:null,macroParser=Wikifier.Parser.get("macro");try{shadowNames.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;store.hasOwnProperty(varKey)&&(valueCache[varKey]=store[varKey]),store[varKey]=shadowStore[varName]})),contextCache=macroParser.context,macroParser.context=shadowContext,callback.apply(this,args)}finally{contextCache!==undefined&&(macroParser.context=contextCache),shadowNames.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;shadowStore[varName]=store[varKey],valueCache.hasOwnProperty(varKey)?store[varKey]=valueCache[varKey]:delete store[varKey]}))}}"function"==typeof doneCallback&&doneCallback.apply(this,args)}}},{key:"createDebugView",value:function(name,title){return this._debugView=new DebugView(this._output,"macro",name||this.displayName,title||this.source),null!==this.payload&&this.payload.length>0&&this._debugView.modes({nonvoid:!0}),this._debugViewEnabled=!0,this._debugView}},{key:"removeDebugView",value:function(){null!==this._debugView&&(this._debugView.remove(),this._debugView=null),this._debugViewEnabled=!1}},{key:"error",value:function(message,source){return throwError(this._output,"<<".concat(this.displayName,">>: ").concat(message),source||this.source)}}]),MacroContext}();return MacroContext}();!function(){if(Macro.add("capture",{skipArgs:!0,tags:null,tsVarRe:new RegExp("(".concat(Patterns.variable,")"),"g"),handler:function(){if(0===this.args.raw.length)return this.error("no story/temporary variable list specified");var valueCache={};try{for(var match,tsVarRe=this.self.tsVarRe;null!==(match=tsVarRe.exec(this.args.raw));){var varName=match[1],varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;store.hasOwnProperty(varKey)&&(valueCache[varKey]=store[varKey]),this.addShadow(varName)}new Wikifier(this.output,this.payload[0].contents)}finally{this.shadows.forEach((function(varName){var varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary;valueCache.hasOwnProperty(varKey)?store[varKey]=valueCache[varKey]:delete store[varKey]}))}}}),Macro.add("set",{skipArgs:!0,handler:function(){if(0===this.args.full.length)return this.error("no expression specified");try{Scripting.evalJavaScript(this.args.full)}catch(ex){return this.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("unset",{skipArgs:!0,jsVarRe:new RegExp("State\\.(variables|temporary)\\.(".concat(Patterns.identifier,")"),"g"),handler:function(){if(0===this.args.full.length)return this.error("no story/temporary variable list specified");for(var match,jsVarRe=this.self.jsVarRe;null!==(match=jsVarRe.exec(this.args.full));){var store=State[match[1]],name=match[2];store.hasOwnProperty(name)&&delete store[name]}Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("remember",{skipArgs:!0,jsVarRe:new RegExp("State\\.variables\\.(".concat(Patterns.identifier,")"),"g"),handler:function(){if(0===this.args.full.length)return this.error("no expression specified");try{Scripting.evalJavaScript(this.args.full)}catch(ex){return this.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}for(var match,remember=storage.get("remember")||{},jsVarRe=this.self.jsVarRe;null!==(match=jsVarRe.exec(this.args.full));){var name=match[1];remember[name]=State.variables[name]}if(!storage.set("remember",remember))return this.error("unknown error, cannot remember: ".concat(this.args.raw));Config.debug&&this.debugView.modes({hidden:!0})},init:function(){var remember=storage.get("remember");remember&&Object.keys(remember).forEach((function(name){return State.variables[name]=remember[name]}))}}),Macro.add("forget",{skipArgs:!0,jsVarRe:new RegExp("State\\.variables\\.(".concat(Patterns.identifier,")"),"g"),handler:function(){if(0===this.args.full.length)return this.error("no story variable list specified");for(var match,remember=storage.get("remember"),jsVarRe=this.self.jsVarRe,needStore=!1;null!==(match=jsVarRe.exec(this.args.full));){var name=match[1];State.variables.hasOwnProperty(name)&&delete State.variables[name],remember&&remember.hasOwnProperty(name)&&(needStore=!0,delete remember[name])}if(needStore)if(0===Object.keys(remember).length){if(!storage.delete("remember"))return this.error("unknown error, cannot update remember store")}else if(!storage.set("remember",remember))return this.error("unknown error, cannot update remember store");Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("run","set"),Macro.add("script",{skipArgs:!0,tags:null,handler:function(){var output=document.createDocumentFragment();try{Scripting.evalJavaScript(this.payload[0].contents,output)}catch(ex){return this.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}Config.debug&&this.createDebugView(),output.hasChildNodes()&&this.output.appendChild(output)}}),Macro.add("include",{handler:function(){return 0===this.args.length?this.error("no passage specified"):(passage="object"===_typeof(this.args[0])?this.args[0].link:this.args[0],Story.has(passage)?(Config.debug&&this.debugView.modes({block:!0}),passage=Story.get(passage),void(this.args[1]?jQuery(document.createElement(this.args[1])).addClass("".concat(passage.domId," macro-").concat(this.name)).attr("data-passage",passage.title).appendTo(this.output):jQuery(this.output)).wiki(passage.processText())):this.error('passage "'.concat(passage,'" does not exist')));var passage}}),Macro.add("nobr",{skipArgs:!0,tags:null,handler:function(){new Wikifier(this.output,this.payload[0].contents.replace(/^\n+|\n+$/g,"").replace(/\n+/g," "))}}),Macro.add(["print","=","-"],{skipArgs:!0,handler:function(){if(0===this.args.full.length)return this.error("no expression specified");try{var result=stringFrom(Scripting.evalJavaScript(this.args.full));null!==result&&new Wikifier(this.output,"-"===this.name?Util.escape(result):result)}catch(ex){return this.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}}}),Macro.add("silently",{skipArgs:!0,tags:null,handler:function(){var frag=document.createDocumentFragment();if(new Wikifier(frag,this.payload[0].contents.trim()),Config.debug)this.debugView.modes({block:!0,hidden:!0}),this.output.appendChild(frag);else{var errList=_toConsumableArray(frag.querySelectorAll(".error")).map((function(errEl){return errEl.textContent}));if(errList.length>0)return this.error("error".concat(1===errList.length?"":"s"," within contents (").concat(errList.join("; "),")"))}}}),Macro.add("type",{isAsync:!0,tags:null,typeId:0,handler:function(){if(0===this.args.length)return this.error("no speed specified");var cursor,speed=Util.fromCssTime(this.args[0]);if(speed<0)return this.error("speed time value must be non-negative (received: ".concat(this.args[0],")"));for(var elClass="",elId="",elTag="div",skipKey=Config.macros.typeSkipKey,start=400,options=this.args.slice(1);options.length>0;){var option=options.shift();switch(option){case"class":if(0===options.length)return this.error("class option missing required class name(s)");if(""===(elClass=options.shift()))throw new Error('class option class name(s) must be non-empty (received: "")');break;case"element":if(0===options.length)return this.error("element option missing required element tag name");if(""===(elTag=options.shift()))throw new Error('element option tag name must be non-empty (received: "")');break;case"id":if(0===options.length)return this.error("id option missing required ID");if(""===(elId=options.shift()))throw new Error('id option ID must be non-empty (received: "")');break;case"keep":cursor="keep";break;case"none":cursor="none";break;case"skipkey":if(0===options.length)return this.error("skipkey option missing required key value");if(""===(skipKey=options.shift()))throw new Error('skipkey option key value must be non-empty (received: "")');break;case"start":if(0===options.length)return this.error("start option missing required time value");var value=options.shift();if((start=Util.fromCssTime(value))<0)throw new Error("start option time value must be non-negative (received: ".concat(value,")"));break;default:return this.error("unknown option: ".concat(option))}}var contents=this.payload[0].contents;if(""!==contents.trim()){Config.debug&&this.debugView.modes({block:!0});var className="macro-".concat(this.name),namespace=".".concat(className),$target=jQuery(document.createElement(elTag)).addClass("".concat(className," ").concat(className,"-target")).appendTo(this.output);TempState.macroTypeQueue||(TempState.macroTypeQueue=[],$(document).off(namespace).one(":passageinit".concat(namespace),(function(){return $(document).off(namespace)})));var startTyping=0===TempState.macroTypeQueue.length,selfId=++this.self.typeId;TempState.macroTypeQueue.push({id:selfId,handler:function(){var $wrapper=jQuery(document.createElement(elTag)).addClass(className);elId&&$wrapper.attr("id",elId),elClass&&$wrapper.addClass(elClass),new Wikifier($wrapper,contents);var passage=State.passage,turn=State.turns;if(!Config.macros.typeVisitedPassages&&State.passages.slice(0,-1).some((function(title){return title===passage}))||$wrapper.find(".error").length>0)return $target.replaceWith($wrapper),TempState.macroTypeQueue.shift(),void(TempState.macroTypeQueue.length>0&&TempState.macroTypeQueue.first().handler());var typer=new NodeTyper({targetNode:$wrapper.get(0),classNames:"none"===cursor?null:"".concat(className,"-cursor")});$target.replaceWith($wrapper);var keydownAndNS="keydown".concat(namespace),typingStopAndNS="".concat(":typingstop").concat(namespace);$(document).off(keydownAndNS).on(keydownAndNS,(function(ev){Util.scrubEventKey(ev.key)!==skipKey||ev.target!==document.body&&ev.target!==document.documentElement||(ev.preventDefault(),$(document).off(keydownAndNS),typer.finish())})).one(typingStopAndNS,(function(){TempState.macroTypeQueue&&(0===TempState.macroTypeQueue.length?jQuery.event.trigger(":typingcomplete"):TempState.macroTypeQueue.first().handler())}));var typeNode=function(){var typeNodeMember=function(typeIntervalId){State.passage===passage&&State.turns===turn&&typer.type()||(typeIntervalId&&clearInterval(typeIntervalId),TempState.macroTypeQueue&&TempState.macroTypeQueue.length>0&&TempState.macroTypeQueue.first().id===selfId&&TempState.macroTypeQueue.shift(),$wrapper.trigger(":typingstop"),$wrapper.addClass("".concat(className,"-done")),"keep"===cursor&&$wrapper.addClass("".concat(className,"-cursor")))};$wrapper.trigger(":typingstart"),typeNodeMember();var typeNodeMemberId=setInterval((function(){return typeNodeMember(typeNodeMemberId)}),speed)};start?setTimeout(typeNode,start):typeNode()}}),startTyping&&(Engine.isPlaying()?$(document).one(":passageend".concat(namespace),(function(){return TempState.macroTypeQueue.first().handler()})):TempState.macroTypeQueue.first().handler())}}}),Macro.add("display","include"),Macro.add("if",{skipArgs:!0,tags:["elseif","else"],elseifWsRe:/^\s*if\b/i,ifAssignRe:/[^!=&^|<>*/%+-]=[^=>]/,handler:function(){var i;try{var len=this.payload.length,elseifWsRe=this.self.elseifWsRe,ifAssignRe=this.self.ifAssignRe;for(i=0;i<len;++i)if("else"===this.payload[i].name){if(this.payload[i].args.raw.length>0)return elseifWsRe.test(this.payload[i].args.raw)?this.error('whitespace is not allowed between the "else" and "if" in <<elseif>> clause'.concat(i>0?" (#"+i+")":"")):this.error("<<else>> does not accept a conditional expression (perhaps you meant to use <<elseif>>), invalid: ".concat(this.payload[i].args.raw));if(i+1!==len)return this.error("<<else>> must be the final clause")}else{if(0===this.payload[i].args.full.length)return this.error("no conditional expression specified for <<".concat(this.payload[i].name,">> clause").concat(i>0?" (#"+i+")":""));if(Config.macros.ifAssignmentError&&ifAssignRe.test(this.payload[i].args.full))return this.error("assignment operator found within <<".concat(this.payload[i].name,">> clause").concat(i>0?" (#"+i+")":""," (perhaps you meant to use an equality operator: ==, ===, eq, is), invalid: ").concat(this.payload[i].args.raw))}var evalJavaScript=Scripting.evalJavaScript,success=!1;for(i=0;i<len;++i){if(Config.debug&&this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1}),"else"===this.payload[i].name||evalJavaScript(this.payload[i].args.full)){success=!0,new Wikifier(this.output,this.payload[i].contents);break}Config.debug&&this.debugView.modes({hidden:!0,invalid:!0})}if(Config.debug){for(++i;i<len;++i)this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1,hidden:!0,invalid:!0});this.createDebugView("/".concat(this.name),"<</".concat(this.name,">>")).modes({nonvoid:!1,hidden:!success,invalid:!success})}}catch(ex){return this.error("bad conditional expression in <<".concat(0===i?"if":"elseif",">> clause").concat(i>0?" (#"+i+")":"",": ").concat("object"===_typeof(ex)?ex.message:ex))}}}),Macro.add("switch",{skipArgs:["switch"],tags:["case","default"],handler:function(){if(0===this.args.full.length)return this.error("no expression specified");var i,result,len=this.payload.length;if(1===len)return this.error("no cases specified");for(i=1;i<len;++i)if("default"===this.payload[i].name){if(this.payload[i].args.length>0)return this.error("<<default>> does not accept values, invalid: ".concat(this.payload[i].args.raw));if(i+1!==len)return this.error("<<default>> must be the final case")}else if(0===this.payload[i].args.length)return this.error("no value(s) specified for <<".concat(this.payload[i].name,">> (#").concat(i,")"));try{result=Scripting.evalJavaScript(this.args.full)}catch(ex){return this.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}var debugView=this.debugView,success=!1;for(Config.debug&&debugView.modes({nonvoid:!1,hidden:!0}),i=1;i<len;++i){if(Config.debug&&this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1}),"default"===this.payload[i].name||this.payload[i].args.some((function(val){return val===result}))){success=!0,new Wikifier(this.output,this.payload[i].contents);break}Config.debug&&this.debugView.modes({hidden:!0,invalid:!0})}if(Config.debug){for(++i;i<len;++i)this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1,hidden:!0,invalid:!0});debugView.modes({nonvoid:!1,hidden:!0,invalid:!success}),this.createDebugView("/".concat(this.name),"<</".concat(this.name,">>")).modes({nonvoid:!1,hidden:!0,invalid:!success})}}}),Macro.add("for",{skipArgs:!0,tags:null,hasRangeRe:new RegExp("^\\S".concat(Patterns.anyChar,"*?\\s+range\\s+\\S").concat(Patterns.anyChar,"*?$")),rangeRe:new RegExp("^(?:State\\.(variables|temporary)\\.(".concat(Patterns.identifier,")\\s*,\\s*)?State\\.(variables|temporary)\\.(").concat(Patterns.identifier,")\\s+range\\s+(\\S").concat(Patterns.anyChar,"*?)$")),threePartRe:/^([^;]*?)\s*;\s*([^;]*?)\s*;\s*([^;]*?)$/,forInRe:/^\S+\s+in\s+\S+/i,forOfRe:/^\S+\s+of\s+\S+/i,handler:function(){var argsStr=this.args.full.trim(),payload=this.payload[0].contents.replace(/\n$/,"");if(0===argsStr.length)this.self.handleFor.call(this,payload,null,!0,null);else if(this.self.hasRangeRe.test(argsStr)){var parts=argsStr.match(this.self.rangeRe);if(null===parts)return this.error("invalid range form syntax, format: [index ,] value range collection");this.self.handleForRange.call(this,payload,{type:parts[1],name:parts[2]},{type:parts[3],name:parts[4]},parts[5])}else{var init,condition,post;if(-1===argsStr.indexOf(";")){if(this.self.forInRe.test(argsStr))return this.error("invalid syntax, for…in is not supported; see: for…range");if(this.self.forOfRe.test(argsStr))return this.error("invalid syntax, for…of is not supported; see: for…range");condition=argsStr}else{var _parts=argsStr.match(this.self.threePartRe);if(null===_parts)return this.error("invalid 3-part conditional form syntax, format: [init] ; [condition] ; [post]");init=_parts[1],condition=_parts[2].trim(),post=_parts[3],0===condition.length&&(condition=!0)}this.self.handleFor.call(this,payload,init,condition,post)}},handleFor:function(payload,init,condition,post){var evalJavaScript=Scripting.evalJavaScript,first=!0,safety=Config.macros.maxLoopIterations;Config.debug&&this.debugView.modes({block:!0});try{if(TempState.break=null,init)try{evalJavaScript(init)}catch(ex){return this.error("bad init expression: ".concat("object"===_typeof(ex)?ex.message:ex))}for(;evalJavaScript(condition);){if(--safety<0)return this.error("exceeded configured maximum loop iterations (".concat(Config.macros.maxLoopIterations,")"));if(new Wikifier(this.output,first?payload.replace(/^\n/,""):payload),first&&(first=!1),null!=TempState.break)if(1===TempState.break)TempState.break=null;else if(2===TempState.break){TempState.break=null;break}if(post)try{evalJavaScript(post)}catch(ex){return this.error("bad post expression: ".concat("object"===_typeof(ex)?ex.message:ex))}}}catch(ex){return this.error("bad conditional expression: ".concat("object"===_typeof(ex)?ex.message:ex))}finally{TempState.break=null}},handleForRange:function(payload,indexVar,valueVar,rangeExp){var rangeList,first=!0;try{rangeList=this.self.toRangeList(rangeExp)}catch(ex){return this.error(ex.message)}Config.debug&&this.debugView.modes({block:!0});try{TempState.break=null;for(var i=0;i<rangeList.length;++i)if(indexVar.name&&(State[indexVar.type][indexVar.name]=rangeList[i][0]),State[valueVar.type][valueVar.name]=rangeList[i][1],new Wikifier(this.output,first?payload.replace(/^\n/,""):payload),first&&(first=!1),null!=TempState.break)if(1===TempState.break)TempState.break=null;else if(2===TempState.break){TempState.break=null;break}}catch(ex){return this.error("object"===_typeof(ex)?ex.message:ex)}finally{TempState.break=null}},toRangeList:function(rangeExp){var value,list,evalJavaScript=Scripting.evalJavaScript;try{value=evalJavaScript("{"===rangeExp[0]?"(".concat(rangeExp,")"):rangeExp)}catch(ex){if("object"!==_typeof(ex))throw new Error("bad range expression: ".concat(ex));throw ex.message="bad range expression: ".concat(ex.message),ex}switch(_typeof(value)){case"string":list=[];for(var i=0;i<value.length;){var obj=Util.charAndPosAt(value,i);list.push([i,obj.char]),i=1+obj.end}break;case"object":if(Array.isArray(value))list=value.map((function(val,i){return[i,val]}));else if(value instanceof Set)list=_toConsumableArray(value).map((function(val,i){return[i,val]}));else if(value instanceof Map)list=_toConsumableArray(value.entries());else{if("Object"!==Util.toStringTag(value))throw new Error("unsupported range expression type: ".concat(Util.toStringTag(value)));list=Object.keys(value).map((function(key){return[key,value[key]]}))}break;default:throw new Error("unsupported range expression type: ".concat(_typeof(value)))}return list}}),Macro.add(["break","continue"],{skipArgs:!0,handler:function(){if(!this.contextHas((function(ctx){return"for"===ctx.name})))return this.error("must only be used in conjunction with its parent macro <<for>>");TempState.break="continue"===this.name?1:2,Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add(["button","link"],{isAsync:!0,tags:null,handler:function(){var _this15=this;if(0===this.args.length)return this.error("no ".concat("button"===this.name?"button":"link"," text specified"));var passage,$link=jQuery(document.createElement("button"===this.name?"button":"a"));if("object"===_typeof(this.args[0]))if(this.args[0].isImage){var $image=jQuery(document.createElement("img")).attr("src",this.args[0].source).appendTo($link);$link.addClass("link-image"),this.args[0].hasOwnProperty("passage")&&$image.attr("data-passage",this.args[0].passage),this.args[0].hasOwnProperty("title")&&$image.attr("title",this.args[0].title),this.args[0].hasOwnProperty("align")&&$image.attr("align",this.args[0].align),passage=this.args[0].link}else $link.append(document.createTextNode(this.args[0].text)),passage=this.args[0].link;else $link.wikiWithOptions({profile:"core"},this.args[0]),passage=this.args.length>1?this.args[1]:undefined;null!=passage?($link.attr("data-passage",passage),Story.has(passage)?($link.addClass("link-internal"),Config.addVisitedLinkClass&&State.hasPlayed(passage)&&$link.addClass("link-visited")):$link.addClass("link-broken")):$link.addClass("link-internal"),$link.addClass("macro-".concat(this.name)).ariaClick({namespace:".macros",role:null!=passage?"link":"button",one:null!=passage},this.createShadowWrapper(""!==this.payload[0].contents?function(){return Wikifier.wikifyEval(_this15.payload[0].contents.trim())}:null,null!=passage?function(){return Engine.play(passage)}:null)).appendTo(this.output)}}),Macro.add("checkbox",{isAsync:!0,handler:function(){if(this.args.length<3){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("unchecked value"),this.args.length<3&&errors.push("checked value"),this.error("no ".concat(errors.join(" or ")," specified"))}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'.concat(this.args[0],'" is missing its sigil ($ or _)'));var varId=Util.slugify(varName),uncheckValue=this.args[1],checkValue=this.args[2],el=document.createElement("input");switch(jQuery(el).attr({id:"".concat(this.name,"-").concat(varId),name:"".concat(this.name,"-").concat(varId),type:"checkbox",tabindex:0}).addClass("macro-".concat(this.name)).on("change.macros",this.createShadowWrapper((function(){State.setVar(varName,this.checked?checkValue:uncheckValue)}))).appendTo(this.output),this.args[3]){case"autocheck":State.getVar(varName)===checkValue?el.checked=!0:State.setVar(varName,uncheckValue);break;case"checked":el.checked=!0,State.setVar(varName,checkValue);break;default:State.setVar(varName,uncheckValue)}}}),Macro.add(["cycle","listbox"],{isAsync:!0,skipArgs:["optionsfrom"],tags:["option","optionsfrom"],handler:function(){var _this16=this;if(0===this.args.length)return this.error("no variable name specified");if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'.concat(this.args[0],'" is missing its sigil ($ or _)'));var varId=Util.slugify(varName),len=this.payload.length;if(1===len)return this.error("no options specified");for(var config={autoselect:!1,once:!1},i=1;i<this.args.length;++i){var arg=this.args[i];switch(arg){case"once":config.once=!0;break;case"autoselect":config.autoselect=!0;break;default:return this.error("unknown argument: ".concat(arg))}}for(var options=[],tagCount={option:0,optionsfrom:0},selectedIdx=-1,_i5=1;_i5<len;++_i5){var payload=this.payload[_i5];if("option"===payload.name){if(++tagCount.option,0===payload.args.length)return this.error("no arguments specified for <<".concat(payload.name,">> (#").concat(tagCount.option,")"));var option={label:String(payload.args[0])},isSelected=!1;switch(payload.args.length){case 1:option.value=payload.args[0];break;case 2:"selected"===payload.args[1]?(option.value=payload.args[0],isSelected=!0):option.value=payload.args[1];break;default:option.value=payload.args[1],"selected"===payload.args[2]&&(isSelected=!0)}if(options.push(option),isSelected){if(config.autoselect)return this.error("cannot specify both the autoselect and selected keywords");if(-1!==selectedIdx)return this.error("multiple selected keywords specified for <<".concat(payload.name,">> (#").concat(selectedIdx+1," & #").concat(tagCount.option,")"));selectedIdx=options.length-1}}else{var _ret=function(){if(++tagCount.optionsfrom,0===payload.args.full.length)return{v:_this16.error("no expression specified for <<".concat(payload.name,">> (#").concat(tagCount.optionsfrom,")"))};var result=void 0;try{var exp=payload.args.full;result=Scripting.evalJavaScript("{"===exp[0]?"(".concat(exp,")"):exp)}catch(ex){return{v:_this16.error("bad evaluation: ".concat("object"===_typeof(ex)?ex.message:ex))}}if("object"!==_typeof(result)||null===result)return{v:_this16.error("expression must yield a supported collection or generic object (type: ".concat(null===result?"null":_typeof(result),")"))};if(result instanceof Array||result instanceof Set)result.forEach((function(val){return options.push({label:String(val),value:val})}));else if(result instanceof Map)result.forEach((function(val,key){return options.push({label:String(key),value:val})}));else{var oType=Util.toStringTag(result);if("Object"!==oType)return{v:_this16.error("expression must yield a supported collection or generic object (object type: ".concat(oType,")"))};Object.keys(result).forEach((function(key){return options.push({label:key,value:result[key]})}))}}();if("object"===_typeof(_ret))return _ret.v}}if(-1===selectedIdx)if(config.autoselect){var sameValueZero=Util.sameValueZero,curValue=State.getVar(varName),curValueIdx=options.findIndex((function(opt){return sameValueZero(opt.value,curValue)}));selectedIdx=-1===curValueIdx?0:curValueIdx}else selectedIdx=0;if("cycle"===this.name){var lastIdx=options.length-1;if(config.once&&selectedIdx===lastIdx)jQuery(this.output).wikiWithOptions({profile:"core"},options[selectedIdx].label);else{var cycleIdx=selectedIdx;jQuery(document.createElement("a")).wikiWithOptions({profile:"core"},options[selectedIdx].label).attr("id","".concat(this.name,"-").concat(varId)).addClass("macro-".concat(this.name)).ariaClick({namespace:".macros",role:"button"},this.createShadowWrapper((function(){var $this=$(this);cycleIdx=(cycleIdx+1)%options.length,State.setVar(varName,options[cycleIdx].value),$this.empty().wikiWithOptions({profile:"core"},options[cycleIdx].label),config.once&&cycleIdx===lastIdx&&$this.off().contents().unwrap()}))).appendTo(this.output)}}else{var $select=jQuery(document.createElement("select"));options.forEach((function(opt,i){jQuery(document.createElement("option")).val(i).text(opt.label).appendTo($select)})),$select.attr({id:"".concat(this.name,"-").concat(varId),name:"".concat(this.name,"-").concat(varId),tabindex:0}).addClass("macro-".concat(this.name)).val(selectedIdx).on("change.macros",this.createShadowWrapper((function(){State.setVar(varName,options[Number(this.value)].value)}))).appendTo(this.output)}State.setVar(varName,options[selectedIdx].value)}}),Macro.add(["linkappend","linkprepend","linkreplace"],{isAsync:!0,tags:null,t8nRe:/^(?:transition|t8n)$/,handler:function(){var _this17=this;if(0===this.args.length)return this.error("no link text specified");var $link=jQuery(document.createElement("a")),$insert=jQuery(document.createElement("span")),transition=this.args.length>1&&this.self.t8nRe.test(this.args[1]);$link.wikiWithOptions({profile:"core"},this.args[0]).addClass("link-internal macro-".concat(this.name)).ariaClick({namespace:".macros",one:!0},this.createShadowWrapper((function(){if("linkreplace"===_this17.name?$link.remove():$link.wrap('<span class="macro-'.concat(_this17.name,'"></span>')).replaceWith((function(){return $link.html()})),""!==_this17.payload[0].contents){var frag=document.createDocumentFragment();new Wikifier(frag,_this17.payload[0].contents),$insert.append(frag)}transition&&setTimeout((function(){return $insert.removeClass("macro-".concat(_this17.name,"-in"))}),Engine.minDomActionDelay)}))).appendTo(this.output),$insert.addClass("macro-".concat(this.name,"-insert")),transition&&$insert.addClass("macro-".concat(this.name,"-in")),"linkprepend"===this.name?$insert.insertBefore($link):$insert.insertAfter($link)}}),Macro.add(["numberbox","textbox"],{isAsync:!0,handler:function(){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("default value"),this.error("no ".concat(errors.join(" or ")," specified"))}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'.concat(this.args[0],'" is missing its sigil ($ or _)'));Config.debug&&this.debugView.modes({block:!0});var asNumber="numberbox"===this.name,defaultValue=asNumber?Number(this.args[1]):this.args[1];if(asNumber&&Number.isNaN(defaultValue))return this.error('default value "'.concat(this.args[1],'" is neither a number nor can it be parsed into a number'));var passage,varId=Util.slugify(varName),el=document.createElement("input"),autofocus=!1;this.args.length>3?(passage=this.args[2],autofocus="autofocus"===this.args[3]):this.args.length>2&&("autofocus"===this.args[2]?autofocus=!0:passage=this.args[2]),"object"===_typeof(passage)&&(passage=passage.link),jQuery(el).attr({id:"".concat(this.name,"-").concat(varId),name:"".concat(this.name,"-").concat(varId),type:asNumber?"number":"text",inputmode:asNumber?"decimal":"text",tabindex:0}).addClass("macro-".concat(this.name)).on("change.macros",this.createShadowWrapper((function(){State.setVar(varName,asNumber?Number(this.value):this.value)}))).on("keypress.macros",this.createShadowWrapper((function(ev){13===ev.which&&(ev.preventDefault(),State.setVar(varName,asNumber?Number(this.value):this.value),null!=passage&&Engine.play(passage))}))).appendTo(this.output),asNumber&&(el.step="any"),State.setVar(varName,defaultValue),el.value=defaultValue,autofocus&&(el.setAttribute("autofocus","autofocus"),postdisplay["#autofocus:".concat(el.id)]=function(task){delete postdisplay[task],setTimeout((function(){return el.focus()}),Engine.minDomActionDelay)})}}),Macro.add("radiobutton",{isAsync:!0,handler:function(){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("checked value"),this.error("no ".concat(errors.join(" or ")," specified"))}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'.concat(this.args[0],'" is missing its sigil ($ or _)'));var varId=Util.slugify(varName),checkValue=this.args[1],el=document.createElement("input");switch(TempState.hasOwnProperty(this.name)||(TempState[this.name]={}),TempState[this.name].hasOwnProperty(varId)||(TempState[this.name][varId]=0),jQuery(el).attr({id:"".concat(this.name,"-").concat(varId,"-").concat(TempState[this.name][varId]++),name:"".concat(this.name,"-").concat(varId),type:"radio",tabindex:0}).addClass("macro-".concat(this.name)).on("change.macros",this.createShadowWrapper((function(){this.checked&&State.setVar(varName,checkValue)}))).appendTo(this.output),this.args[2]){case"autocheck":State.getVar(varName)===checkValue&&(el.checked=!0);break;case"checked":el.checked=!0,State.setVar(varName,checkValue)}}}),Macro.add("textarea",{isAsync:!0,handler:function(){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("variable name"),this.args.length<2&&errors.push("default value"),this.error("no ".concat(errors.join(" or ")," specified"))}if("string"!=typeof this.args[0])return this.error("variable name argument is not a string");var varName=this.args[0].trim();if("$"!==varName[0]&&"_"!==varName[0])return this.error('variable name "'.concat(this.args[0],'" is missing its sigil ($ or _)'));Config.debug&&this.debugView.modes({block:!0});var varId=Util.slugify(varName),defaultValue=this.args[1],autofocus="autofocus"===this.args[2],el=document.createElement("textarea");jQuery(el).attr({id:"".concat(this.name,"-").concat(varId),name:"".concat(this.name,"-").concat(varId),rows:4,tabindex:0}).addClass("macro-".concat(this.name)).on("change.macros",this.createShadowWrapper((function(){State.setVar(varName,this.value)}))).appendTo(this.output),State.setVar(varName,defaultValue),el.textContent=defaultValue,autofocus&&(el.setAttribute("autofocus","autofocus"),postdisplay["#autofocus:".concat(el.id)]=function(task){delete postdisplay[task],setTimeout((function(){return el.focus()}),Engine.minDomActionDelay)})}}),Macro.add("click","link"),Macro.add("actions",{handler:function(){for(var $list=jQuery(document.createElement("ul")).addClass(this.name).appendTo(this.output),i=0;i<this.args.length;++i){var passage=void 0,text=void 0,$image=void 0,setFn=void 0;if("object"===_typeof(this.args[i])?this.args[i].isImage?($image=jQuery(document.createElement("img")).attr("src",this.args[i].source),this.args[i].hasOwnProperty("passage")&&$image.attr("data-passage",this.args[i].passage),this.args[i].hasOwnProperty("title")&&$image.attr("title",this.args[i].title),this.args[i].hasOwnProperty("align")&&$image.attr("align",this.args[i].align),passage=this.args[i].link,setFn=this.args[i].setFn):(text=this.args[i].text,passage=this.args[i].link,setFn=this.args[i].setFn):text=passage=this.args[i],!(State.variables.hasOwnProperty("#actions")&&State.variables["#actions"].hasOwnProperty(passage)&&State.variables["#actions"][passage])){var $link=jQuery(Wikifier.createInternalLink(jQuery(document.createElement("li")).appendTo($list),passage,null,function(passage,fn){return function(){State.variables.hasOwnProperty("#actions")||(State.variables["#actions"]={}),State.variables["#actions"][passage]=!0,"function"==typeof fn&&fn()}}(passage,setFn))).addClass("macro-".concat(this.name)).append($image||document.createTextNode(text));$image&&$link.addClass("link-image")}}}}),Macro.add(["back","return"],{handler:function(){if(this.args.length>1)return this.error("too many arguments specified, check the documentation for details");var passage,text,$image,$link,momentIndex=-1;if(1===this.args.length&&("object"===_typeof(this.args[0])?this.args[0].isImage?($image=jQuery(document.createElement("img")).attr("src",this.args[0].source),this.args[0].hasOwnProperty("passage")&&$image.attr("data-passage",this.args[0].passage),this.args[0].hasOwnProperty("title")&&$image.attr("title",this.args[0].title),this.args[0].hasOwnProperty("align")&&$image.attr("align",this.args[0].align),this.args[0].hasOwnProperty("link")&&(passage=this.args[0].link)):(1===this.args[0].count||(text=this.args[0].text),passage=this.args[0].link):1===this.args.length&&(text=this.args[0])),null==passage){for(var i=State.length-2;i>=0;--i)if(State.history[i].title!==State.passage){momentIndex=i,passage=State.history[i].title;break}if(null==passage&&"return"===this.name)for(var _i6=State.expired.length-1;_i6>=0;--_i6)if(State.expired[_i6]!==State.passage){passage=State.expired[_i6];break}}else{if(!Story.has(passage))return this.error('passage "'.concat(passage,'" does not exist'));if("back"===this.name){for(var _i7=State.length-2;_i7>=0;--_i7)if(State.history[_i7].title===passage){momentIndex=_i7;break}if(-1===momentIndex)return this.error('cannot find passage "'.concat(passage,'" in the current story history'))}}if(null==passage)return this.error("cannot find passage");"back"!==this.name||-1!==momentIndex?($link=jQuery(document.createElement("a")).addClass("link-internal").ariaClick({one:!0},"return"===this.name?function(){return Engine.play(passage)}:function(){return Engine.goTo(momentIndex)}),$image&&$link.addClass("link-image")):$link=jQuery(document.createElement("span")).addClass("link-disabled"),$link.addClass("macro-".concat(this.name)).append($image||document.createTextNode(text||L10n.get("macro".concat(this.name.toUpperFirst(),"Text")))).appendTo(this.output)}}),Macro.add("choice",{handler:function(){if(0===this.args.length)return this.error("no passage specified");var passage,text,$image,setFn,$link,choiceId=State.passage;if(1===this.args.length?"object"===_typeof(this.args[0])?this.args[0].isImage?($image=jQuery(document.createElement("img")).attr("src",this.args[0].source),this.args[0].hasOwnProperty("passage")&&$image.attr("data-passage",this.args[0].passage),this.args[0].hasOwnProperty("title")&&$image.attr("title",this.args[0].title),this.args[0].hasOwnProperty("align")&&$image.attr("align",this.args[0].align),passage=this.args[0].link,setFn=this.args[0].setFn):(text=this.args[0].text,passage=this.args[0].link,setFn=this.args[0].setFn):text=passage=this.args[0]:(passage=this.args[0],text=this.args[1]),State.variables.hasOwnProperty("#choice")&&State.variables["#choice"].hasOwnProperty(choiceId)&&State.variables["#choice"][choiceId])return $link=jQuery(document.createElement("span")).addClass("link-disabled macro-".concat(this.name)).attr("tabindex",-1).append($image||document.createTextNode(text)).appendTo(this.output),void($image&&$link.addClass("link-image"));$link=jQuery(Wikifier.createInternalLink(this.output,passage,null,(function(){State.variables.hasOwnProperty("#choice")||(State.variables["#choice"]={}),State.variables["#choice"][choiceId]=!0,"function"==typeof setFn&&setFn()}))).addClass("macro-".concat(this.name)).append($image||document.createTextNode(text)),$image&&$link.addClass("link-image")}}),Macro.add(["addclass","toggleclass"],{handler:function(){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("selector"),this.args.length<2&&errors.push("class names"),this.error("no ".concat(errors.join(" or ")," specified"))}var $targets=jQuery(this.args[0]);if(0===$targets.length)return this.error('no elements matched the selector "'.concat(this.args[0],'"'));switch(this.name){case"addclass":$targets.addClass(this.args[1].trim());break;case"toggleclass":$targets.toggleClass(this.args[1].trim())}Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("removeclass",{handler:function(){if(0===this.args.length)return this.error("no selector specified");var $targets=jQuery(this.args[0]);if(0===$targets.length)return this.error('no elements matched the selector "'.concat(this.args[0],'"'));this.args.length>1?$targets.removeClass(this.args[1].trim()):$targets.removeClass(),Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("copy",{handler:function(){if(0===this.args.length)return this.error("no selector specified");var $targets=jQuery(this.args[0]);if(0===$targets.length)return this.error('no elements matched the selector "'.concat(this.args[0],'"'));jQuery(this.output).append($targets.html()),Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add(["append","prepend","replace"],{tags:null,t8nRe:/^(?:transition|t8n)$/,handler:function(){var _this18=this;if(0===this.args.length)return this.error("no selector specified");var $insert,$targets=jQuery(this.args[0]);if(0===$targets.length)return this.error('no elements matched the selector "'.concat(this.args[0],'"'));if(""!==this.payload[0].contents)switch(this.args.length>1&&this.self.t8nRe.test(this.args[1])?(($insert=jQuery(document.createElement("span"))).addClass("macro-".concat(this.name,"-insert macro-").concat(this.name,"-in")),setTimeout((function(){return $insert.removeClass("macro-".concat(_this18.name,"-in"))}),Engine.minDomActionDelay)):$insert=jQuery(document.createDocumentFragment()),$insert.wiki(this.payload[0].contents),this.name){case"replace":$targets.empty();case"append":$targets.append($insert);break;case"prepend":$targets.prepend($insert)}else"replace"===this.name&&$targets.empty();Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("remove",{handler:function(){if(0===this.args.length)return this.error("no selector specified");var $targets=jQuery(this.args[0]);if(0===$targets.length)return this.error('no elements matched the selector "'.concat(this.args[0],'"'));$targets.remove(),Config.debug&&this.debugView.modes({hidden:!0})}}),Has.audio){var errorOnePlaybackAction=function(cur,prev){return'only one playback action allowed per invocation, "'.concat(cur,'" cannot be combined with "').concat(prev,'"')};Macro.add("audio",{handler:function(){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("track and/or group IDs"),this.args.length<2&&errors.push("actions"),this.error("no ".concat(errors.join(" or ")," specified"))}var selected;try{selected=SimpleAudio.select(this.args[0])}catch(ex){return this.error(ex.message)}for(var action,fadeTo,loop,mute,passage,time,volume,args=this.args.slice(1),fadeOver=5;args.length>0;){var arg=args.shift(),raw=void 0;switch(arg){case"load":case"pause":case"play":case"stop":case"unload":if(action)return this.error(errorOnePlaybackAction(arg,action));action=arg;break;case"fadein":if(action)return this.error(errorOnePlaybackAction(arg,action));action="fade",fadeTo=1;break;case"fadeout":if(action)return this.error(errorOnePlaybackAction(arg,action));action="fade",fadeTo=0;break;case"fadeto":if(action)return this.error(errorOnePlaybackAction(arg,action));if(0===args.length)return this.error("fadeto missing required level value");if(action="fade",raw=args.shift(),fadeTo=Number.parseFloat(raw),Number.isNaN(fadeTo)||!Number.isFinite(fadeTo))return this.error("cannot parse fadeto: ".concat(raw));break;case"fadeoverto":if(action)return this.error(errorOnePlaybackAction(arg,action));if(args.length<2){var _errors=[];return args.length<1&&_errors.push("seconds"),args.length<2&&_errors.push("level"),this.error("fadeoverto missing required ".concat(_errors.join(" and ")," value").concat(_errors.length>1?"s":""))}if(action="fade",raw=args.shift(),fadeOver=Number.parseFloat(raw),Number.isNaN(fadeOver)||!Number.isFinite(fadeOver))return this.error("cannot parse fadeoverto: ".concat(raw));if(raw=args.shift(),fadeTo=Number.parseFloat(raw),Number.isNaN(fadeTo)||!Number.isFinite(fadeTo))return this.error("cannot parse fadeoverto: ".concat(raw));break;case"volume":if(0===args.length)return this.error("volume missing required level value");if(raw=args.shift(),volume=Number.parseFloat(raw),Number.isNaN(volume)||!Number.isFinite(volume))return this.error("cannot parse volume: ".concat(raw));break;case"mute":case"unmute":mute="mute"===arg;break;case"time":if(0===args.length)return this.error("time missing required seconds value");if(raw=args.shift(),time=Number.parseFloat(raw),Number.isNaN(time)||!Number.isFinite(time))return this.error("cannot parse time: ".concat(raw));break;case"loop":case"unloop":loop="loop"===arg;break;case"goto":if(0===args.length)return this.error("goto missing required passage title");if(raw=args.shift(),passage="object"===_typeof(raw)?raw.link:raw,!Story.has(passage))return this.error('passage "'.concat(passage,'" does not exist'));break;default:return this.error("unknown action: ".concat(arg))}}try{if(null!=volume&&selected.volume(volume),null!=time&&selected.time(time),null!=mute&&selected.mute(mute),null!=loop&&selected.loop(loop),null!=passage){var nsEnded="ended.macros.macro-".concat(this.name,"_goto");selected.off(nsEnded).one(nsEnded,(function(){selected.off(nsEnded),Engine.play(passage)}))}switch(action){case"fade":selected.fade(fadeOver,fadeTo);break;case"load":selected.load();break;case"pause":selected.pause();break;case"play":selected.playWhenAllowed();break;case"stop":selected.stop();break;case"unload":selected.unload()}Config.debug&&this.debugView.modes({hidden:!0})}catch(ex){return this.error("error executing action: ".concat(ex.message))}}}),Macro.add("cacheaudio",{handler:function(){var _this19=this;if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("track ID"),this.args.length<2&&errors.push("sources"),this.error("no ".concat(errors.join(" or ")," specified"))}var id=String(this.args[0]).trim(),oldFmtRe=/^format:\s*([\w-]+)\s*;\s*/i;try{SimpleAudio.tracks.add(id,this.args.slice(1).map((function(source){if(oldFmtRe.test(source)){if(Config.debug)return _this19.error('track ID "'.concat(id,'": format specifier migration required, "format:formatId;" → "formatId|"'));source=source.replace(oldFmtRe,"$1|")}return source})))}catch(ex){return this.error(ex.message)}if(Config.debug&&!SimpleAudio.tracks.get(id).hasSource())return this.error('track ID "'.concat(id,'": no supported audio sources found'));Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("createaudiogroup",{tags:["track"],handler:function(){if(0===this.args.length)return this.error("no group ID specified");if(1===this.payload.length)return this.error("no tracks defined via <<track>>");Config.debug&&this.debugView.modes({nonvoid:!1,hidden:!0});for(var groupId=String(this.args[0]).trim(),trackIds=[],i=1,len=this.payload.length;i<len;++i){if(this.payload[i].args.length<1)return this.error("no track ID specified");trackIds.push(String(this.payload[i].args[0]).trim()),Config.debug&&this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1,hidden:!0})}try{SimpleAudio.groups.add(groupId,trackIds)}catch(ex){return this.error(ex.message)}Config.debug&&this.createDebugView("/".concat(this.name),"<</".concat(this.name,">>")).modes({nonvoid:!1,hidden:!0})}}),Macro.add("createplaylist",{tags:["track"],handler:function(){if(0===this.args.length)return this.error("no list ID specified");if(1===this.payload.length)return this.error("no tracks defined via <<track>>");var playlist=Macro.get("playlist");if(null!==playlist.from&&"createplaylist"!==playlist.from)return this.error("a playlist has already been defined with <<setplaylist>>");Config.debug&&this.debugView.modes({nonvoid:!1,hidden:!0});for(var listId=String(this.args[0]).trim(),trackObjs=[],i=1,len=this.payload.length;i<len;++i){if(0===this.payload[i].args.length)return this.error("no track ID specified");for(var trackObj={id:String(this.payload[i].args[0]).trim()},args=this.payload[i].args.slice(1);args.length>0;){var arg=args.shift(),raw=void 0,parsed=void 0;switch(arg){case"copy":case"own":trackObj.own=!0;break;case"rate":args.length>0&&args.shift();break;case"volume":if(0===args.length)return this.error("volume missing required level value");if(raw=args.shift(),parsed=Number.parseFloat(raw),Number.isNaN(parsed)||!Number.isFinite(parsed))return this.error("cannot parse volume: ".concat(raw));trackObj.volume=parsed;break;default:return this.error("unknown action: ".concat(arg))}}trackObjs.push(trackObj),Config.debug&&this.createDebugView(this.payload[i].name,this.payload[i].source).modes({nonvoid:!1,hidden:!0})}try{SimpleAudio.lists.add(listId,trackObjs)}catch(ex){return this.error(ex.message)}null===playlist.from&&(playlist.from="createplaylist"),Config.debug&&this.createDebugView("/".concat(this.name),"<</".concat(this.name,">>")).modes({nonvoid:!1,hidden:!0})}}),Macro.add("masteraudio",{handler:function(){if(0===this.args.length)return this.error("no actions specified");for(var action,mute,muteOnHide,volume,args=this.args.slice(0);args.length>0;){var arg=args.shift(),raw=void 0;switch(arg){case"load":case"stop":case"unload":if(action)return this.error(errorOnePlaybackAction(arg,action));action=arg;break;case"mute":case"unmute":mute="mute"===arg;break;case"muteonhide":case"nomuteonhide":muteOnHide="muteonhide"===arg;break;case"volume":if(0===args.length)return this.error("volume missing required level value");if(raw=args.shift(),volume=Number.parseFloat(raw),Number.isNaN(volume)||!Number.isFinite(volume))return this.error("cannot parse volume: ".concat(raw));break;default:return this.error("unknown action: ".concat(arg))}}try{switch(null!=mute&&SimpleAudio.mute(mute),null!=muteOnHide&&SimpleAudio.muteOnHidden(muteOnHide),null!=volume&&SimpleAudio.volume(volume),action){case"load":SimpleAudio.load();break;case"stop":SimpleAudio.stop();break;case"unload":SimpleAudio.unload()}Config.debug&&this.debugView.modes({hidden:!0})}catch(ex){return this.error("error executing action: ".concat(ex.message))}}}),Macro.add("playlist",{from:null,handler:function(){var list,args,action,from=this.self.from;if(null===from)return this.error("no playlists have been created");if("createplaylist"===from){if(this.args.length<2){var errors=[];return this.args.length<1&&errors.push("list ID"),this.args.length<2&&errors.push("actions"),this.error("no ".concat(errors.join(" or ")," specified"))}var id=String(this.args[0]).trim();if(!SimpleAudio.lists.has(id))return this.error('playlist "'.concat(id,'" does not exist'));list=SimpleAudio.lists.get(id),args=this.args.slice(1)}else{if(0===this.args.length)return this.error("no actions specified");list=SimpleAudio.lists.get("setplaylist"),args=this.args.slice(0)}for(var fadeTo,loop,mute,shuffle,volume,fadeOver=5;args.length>0;){var arg=args.shift(),raw=void 0;switch(arg){case"load":case"pause":case"play":case"skip":case"stop":case"unload":if(action)return this.error(errorOnePlaybackAction(arg,action));action=arg;break;case"fadein":if(action)return this.error(errorOnePlaybackAction(arg,action));action="fade",fadeTo=1;break;case"fadeout":if(action)return this.error(errorOnePlaybackAction(arg,action));action="fade",fadeTo=0;break;case"fadeto":if(action)return this.error(errorOnePlaybackAction(arg,action));if(0===args.length)return this.error("fadeto missing required level value");if(action="fade",raw=args.shift(),fadeTo=Number.parseFloat(raw),Number.isNaN(fadeTo)||!Number.isFinite(fadeTo))return this.error("cannot parse fadeto: ".concat(raw));break;case"fadeoverto":if(action)return this.error(errorOnePlaybackAction(arg,action));if(args.length<2){var _errors2=[];return args.length<1&&_errors2.push("seconds"),args.length<2&&_errors2.push("level"),this.error("fadeoverto missing required ".concat(_errors2.join(" and ")," value").concat(_errors2.length>1?"s":""))}if(action="fade",raw=args.shift(),fadeOver=Number.parseFloat(raw),Number.isNaN(fadeOver)||!Number.isFinite(fadeOver))return this.error("cannot parse fadeoverto: ".concat(raw));if(raw=args.shift(),fadeTo=Number.parseFloat(raw),Number.isNaN(fadeTo)||!Number.isFinite(fadeTo))return this.error("cannot parse fadeoverto: ".concat(raw));break;case"volume":if(0===args.length)return this.error("volume missing required level value");if(raw=args.shift(),volume=Number.parseFloat(raw),Number.isNaN(volume)||!Number.isFinite(volume))return this.error("cannot parse volume: ".concat(raw));break;case"mute":case"unmute":mute="mute"===arg;break;case"loop":case"unloop":loop="loop"===arg;break;case"shuffle":case"unshuffle":shuffle="shuffle"===arg;break;default:return this.error("unknown action: ".concat(arg))}}try{switch(null!=volume&&list.volume(volume),null!=mute&&list.mute(mute),null!=loop&&list.loop(loop),null!=shuffle&&list.shuffle(shuffle),action){case"fade":list.fade(fadeOver,fadeTo);break;case"load":list.load();break;case"pause":list.pause();break;case"play":list.playWhenAllowed();break;case"skip":list.skip();break;case"stop":list.stop();break;case"unload":list.unload()}Config.debug&&this.debugView.modes({hidden:!0})}catch(ex){return this.error("error executing action: ".concat(ex.message))}}}),Macro.add("removeaudiogroup",{handler:function(){if(0===this.args.length)return this.error("no group ID specified");var id=String(this.args[0]).trim();if(!SimpleAudio.groups.has(id))return this.error('group "'.concat(id,'" does not exist'));SimpleAudio.groups.delete(id),Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("removeplaylist",{handler:function(){if(0===this.args.length)return this.error("no list ID specified");var id=String(this.args[0]).trim();if(!SimpleAudio.lists.has(id))return this.error('playlist "'.concat(id,'" does not exist'));SimpleAudio.lists.delete(id),Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("waitforaudio",{skipArgs:!0,handler:function(){SimpleAudio.loadWithScreen()}}),Macro.add("setplaylist",{handler:function(){if(0===this.args.length)return this.error("no track ID(s) specified");var playlist=Macro.get("playlist");if(null!==playlist.from&&"setplaylist"!==playlist.from)return this.error("playlists have already been defined with <<createplaylist>>");try{SimpleAudio.lists.add("setplaylist",this.args.slice(0))}catch(ex){return this.error(ex.message)}null===playlist.from&&(playlist.from="setplaylist"),Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("stopallaudio",{skipArgs:!0,handler:function(){SimpleAudio.select(":all").stop(),Config.debug&&this.debugView.modes({hidden:!0})}})}else Macro.add(["audio","cacheaudio","createaudiogroup","createplaylist","masteraudio","playlist","removeaudiogroup","removeplaylist","waitforaudio","setplaylist","stopallaudio"],{skipArgs:!0,handler:function(){Config.debug&&this.debugView.modes({hidden:!0})}});Macro.add("done",{skipArgs:!0,tags:null,handler:function(){var contents=this.payload[0].contents.trim();""!==contents&&setTimeout(this.createShadowWrapper((function(){return $.wiki(contents)})),Engine.minDomActionDelay)}}),Macro.add("goto",{handler:function(){return 0===this.args.length?this.error("no passage specified"):(passage="object"===_typeof(this.args[0])?this.args[0].link:this.args[0],Story.has(passage)?void setTimeout((function(){return Engine.play(passage)}),Engine.minDomActionDelay):this.error('passage "'.concat(passage,'" does not exist')));var passage}}),Macro.add("repeat",{isAsync:!0,tags:null,timers:new Set,t8nRe:/^(?:transition|t8n)$/,handler:function(){var delay,_this20=this;if(0===this.args.length)return this.error("no time value specified");try{delay=Math.max(Engine.minDomActionDelay,Util.fromCssTime(this.args[0]))}catch(ex){return this.error(ex.message)}Config.debug&&this.debugView.modes({block:!0});var transition=this.args.length>1&&this.self.t8nRe.test(this.args[1]),$wrapper=jQuery(document.createElement("span")).addClass("macro-".concat(this.name)).appendTo(this.output);this.self.registerInterval(this.createShadowWrapper((function(){var frag=document.createDocumentFragment();new Wikifier(frag,_this20.payload[0].contents);var $output=$wrapper;transition&&($output=jQuery(document.createElement("span")).addClass("macro-repeat-insert macro-repeat-in").appendTo($output)),$output.append(frag),transition&&setTimeout((function(){return $output.removeClass("macro-repeat-in")}),Engine.minDomActionDelay)})),delay)},registerInterval:function(callback,delay){var _this21=this;if("function"!=typeof callback)throw new TypeError("callback parameter must be a function");var passage=State.passage,turn=State.turns,timers=this.timers,timerId=null;timerId=setInterval((function(){if(State.passage!==passage||State.turns!==turn)return clearInterval(timerId),void timers.delete(timerId);var timerIdCache;try{TempState.break=null,TempState.hasOwnProperty("repeatTimerId")&&(timerIdCache=TempState.repeatTimerId),TempState.repeatTimerId=timerId,callback.call(_this21)}finally{void 0!==timerIdCache?TempState.repeatTimerId=timerIdCache:delete TempState.repeatTimerId,TempState.break=null}}),delay),timers.add(timerId),prehistory.hasOwnProperty("#repeat-timers-cleanup")||(prehistory["#repeat-timers-cleanup"]=function(task){delete prehistory[task],timers.forEach((function(timerId){return clearInterval(timerId)})),timers.clear()})}}),Macro.add("stop",{skipArgs:!0,handler:function(){if(!TempState.hasOwnProperty("repeatTimerId"))return this.error("must only be used in conjunction with its parent macro <<repeat>>");var timers=Macro.get("repeat").timers,timerId=TempState.repeatTimerId;clearInterval(timerId),timers.delete(timerId),TempState.break=2,Config.debug&&this.debugView.modes({hidden:!0})}}),Macro.add("timed",{isAsync:!0,tags:["next"],timers:new Set,t8nRe:/^(?:transition|t8n)$/,handler:function(){if(0===this.args.length)return this.error("no time value specified in <<timed>>");var i,items=[];try{items.push({name:this.name,source:this.source,delay:Math.max(Engine.minDomActionDelay,Util.fromCssTime(this.args[0])),content:this.payload[0].contents})}catch(ex){return this.error("".concat(ex.message," in <<timed>>"))}if(this.payload.length>1)try{var len;for(i=1,len=this.payload.length;i<len;++i)items.push({name:this.payload[i].name,source:this.payload[i].source,delay:0===this.payload[i].args.length?items[items.length-1].delay:Math.max(Engine.minDomActionDelay,Util.fromCssTime(this.payload[i].args[0])),content:this.payload[i].contents})}catch(ex){return this.error("".concat(ex.message," in <<next>> (#").concat(i,")"))}Config.debug&&this.debugView.modes({block:!0});var transition=this.args.length>1&&this.self.t8nRe.test(this.args[1]),$wrapper=jQuery(document.createElement("span")).addClass("macro-".concat(this.name)).appendTo(this.output);this.self.registerTimeout(this.createShadowWrapper((function(item){var frag=document.createDocumentFragment();new Wikifier(frag,item.content);var $output=$wrapper;Config.debug&&"next"===item.name&&($output=jQuery(new DebugView($output[0],"macro",item.name,item.source).output)),transition&&($output=jQuery(document.createElement("span")).addClass("macro-timed-insert macro-timed-in").appendTo($output)),$output.append(frag),transition&&setTimeout((function(){return $output.removeClass("macro-timed-in")}),Engine.minDomActionDelay)})),items)},registerTimeout:function(callback,items){if("function"!=typeof callback)throw new TypeError("callback parameter must be a function");var passage=State.passage,turn=State.turns,timers=this.timers,timerId=null,nextItem=items.shift();timerId=setTimeout((function worker(){if(timers.delete(timerId),State.passage===passage&&State.turns===turn){var curItem=nextItem;null!=(nextItem=items.shift())&&(timerId=setTimeout(worker,nextItem.delay),timers.add(timerId)),callback.call(this,curItem)}}),nextItem.delay),timers.add(timerId),prehistory.hasOwnProperty("#timed-timers-cleanup")||(prehistory["#timed-timers-cleanup"]=function(task){delete prehistory[task],timers.forEach((function(timerId){return clearTimeout(timerId)})),timers.clear()})}}),Macro.add("widget",{tags:null,handler:function(){if(0===this.args.length)return this.error("no widget name specified");var widgetCode,widgetName=this.args[0],isNonVoid=this.args.length>1&&"container"===this.args[1];if(Macro.has(widgetName)){if(!Macro.get(widgetName).isWidget)return this.error('cannot clobber existing macro "'.concat(widgetName,'"'));Macro.delete(widgetName)}try{var widgetDef={isWidget:!0,handler:(widgetCode=this.payload[0].contents,function(){var shadowStore={};State.temporary.hasOwnProperty("args")&&(shadowStore._args=State.temporary.args),State.temporary.args=_toConsumableArray(this.args),State.temporary.args.raw=this.args.raw,State.temporary.args.full=this.args.full,this.addShadow("_args"),isNonVoid&&(State.temporary.hasOwnProperty("contents")&&(shadowStore._contents=State.temporary.contents),State.temporary.contents=this.payload[0].contents,this.addShadow("_contents")),State.variables.hasOwnProperty("args")&&(shadowStore.$args=State.variables.args),State.variables.args=State.temporary.args,this.addShadow("$args");try{var resFrag=document.createDocumentFragment(),errList=[];if(new Wikifier(resFrag,widgetCode),Array.from(resFrag.querySelectorAll(".error")).forEach((function(errEl){errList.push(errEl.textContent)})),0!==errList.length)return this.error("error".concat(errList.length>1?"s":""," within widget code (").concat(errList.join("; "),")"));this.output.appendChild(resFrag)}catch(ex){return this.error("cannot execute widget: ".concat(ex.message))}finally{shadowStore.hasOwnProperty("_args")?State.temporary.args=shadowStore._args:delete State.temporary.args,isNonVoid&&(shadowStore.hasOwnProperty("_contents")?State.temporary.contents=shadowStore._contents:delete State.temporary.contents),shadowStore.hasOwnProperty("$args")?State.variables.args=shadowStore.$args:delete State.variables.args}})};isNonVoid&&(widgetDef.tags=[]),Macro.add(widgetName,widgetDef),Config.debug&&this.debugView.modes({hidden:!0})}catch(ex){return this.error('cannot create widget macro "'.concat(widgetName,'": ').concat(ex.message))}}})}();var Dialog=function(){var _$overlay=null,_$dialog=null,_$dialogTitle=null,_$dialogBody=null,_lastActive=null,_scrollbarWidth=0,_dialogObserver=null;function dialogClose(ev){return _$dialogBody.trigger(":dialogclosing"),jQuery(document).off(".dialog-close"),_dialogObserver?(_dialogObserver.disconnect(),_dialogObserver=null):_$dialogBody.off(".dialog-resize"),jQuery(window).off(".dialog-resize"),_$dialog.removeClass("open").css({left:"",right:"",top:"",bottom:""}),jQuery("#ui-bar,#story").find("[tabindex=-2]").removeAttr("aria-hidden").attr("tabindex",0),jQuery("body>[tabindex=-3]").removeAttr("aria-hidden").removeAttr("tabindex"),_$overlay.removeClass("open"),jQuery(document.documentElement).removeAttr("data-dialog"),_$dialogTitle.empty(),_$dialogBody.empty().removeClass(),null!==_lastActive&&(jQuery(_lastActive).focus(),_lastActive=null),ev&&ev.data&&"function"==typeof ev.data.closeFn&&ev.data.closeFn(ev),_$dialogBody.trigger(":dialogclose"),_$dialogBody.trigger(":dialogclosed"),Dialog}function dialogIsOpen(classNames){return _$dialog.hasClass("open")&&(!classNames||classNames.splitOrEmpty(/\s+/).every((function(cn){return _$dialogBody.hasClass(cn)})))}function dialogOpen(options,closeFn){_$dialogBody.trigger(":dialogopening");var top=jQuery.extend({top:50},options).top;return dialogIsOpen()||(_lastActive=safeActiveElement()),jQuery(document.documentElement).attr("data-dialog","open"),_$overlay.addClass("open"),null!==_$dialogBody[0].querySelector("img")&&_$dialogBody.imagesLoaded().always((function(){return _resizeHandler({data:{top:top}})})),jQuery("body>:not(script,#store-area,tw-storydata,#ui-bar,#ui-overlay,#ui-dialog)").attr("tabindex",-3).attr("aria-hidden",!0),jQuery("#ui-bar,#story").find("[tabindex]:not([tabindex^=-])").attr("tabindex",-2).attr("aria-hidden",!0),_$dialog.css(_calcPosition(top)).addClass("open").focus(),jQuery(window).on("resize.dialog-resize",null,{top:top},jQuery.throttle(40,_resizeHandler)),Has.mutationObserver?(_dialogObserver=new MutationObserver((function(mutations){for(var i=0;i<mutations.length;++i)if("childList"===mutations[i].type){_resizeHandler({data:{top:top}});break}}))).observe(_$dialogBody[0],{childList:!0,subtree:!0}):_$dialogBody.on("DOMNodeInserted.dialog-resize DOMNodeRemoved.dialog-resize",null,{top:top},jQuery.throttle(40,_resizeHandler)),jQuery(document).one("click.dialog-close",".ui-close",{closeFn:closeFn},(function(ev){dialogClose(ev)})).one("keypress.dialog-close",".ui-close",(function(ev){13!==ev.which&&32!==ev.which||jQuery(this).trigger("click")})),_$dialogBody.trigger(":dialogopen"),_$dialogBody.trigger(":dialogopened"),Dialog}function _calcPosition(topPos){var top=null!=topPos?topPos:50,$parent=jQuery(window),dialogPos={left:"",right:"",top:"",bottom:""};_$dialog.css(dialogPos);var horzSpace=$parent.width()-_$dialog.outerWidth(!0)-1,vertSpace=$parent.height()-_$dialog.outerHeight(!0)-1;return horzSpace<=32+_scrollbarWidth&&(vertSpace-=_scrollbarWidth),vertSpace<=32+_scrollbarWidth&&(horzSpace-=_scrollbarWidth),dialogPos.left=dialogPos.right=horzSpace<=32?16:horzSpace/2>>0,dialogPos.top=vertSpace<=32?dialogPos.bottom=16:vertSpace/2>top?top:dialogPos.bottom=vertSpace/2>>0,Object.keys(dialogPos).forEach((function(key){""!==dialogPos[key]&&(dialogPos[key]+="px")})),dialogPos}function _resizeHandler(ev){var top=ev&&ev.data&&void 0!==ev.data.top?ev.data.top:50;"block"===_$dialog.css("display")&&(_$dialog.css({display:"none"}),_$dialog.css(jQuery.extend({display:""},_calcPosition(top))))}return Object.freeze(Object.defineProperties({},{append:{value:function(){var _$dialogBody2;return(_$dialogBody2=_$dialogBody).append.apply(_$dialogBody2,arguments),Dialog}},body:{value:function(){return _$dialogBody.get(0)}},close:{value:dialogClose},init:{value:function(){if(!document.getElementById("ui-dialog")){_scrollbarWidth=function(){var scrollbarWidth;try{var inner=document.createElement("p"),outer=document.createElement("div");inner.style.width="100%",inner.style.height="200px",outer.style.position="absolute",outer.style.left="0px",outer.style.top="0px",outer.style.width="100px",outer.style.height="100px",outer.style.visibility="hidden",outer.style.overflow="hidden",outer.appendChild(inner),document.body.appendChild(outer);var w1=inner.offsetWidth;outer.style.overflow="auto";var w2=inner.offsetWidth;w1===w2&&(w2=outer.clientWidth),document.body.removeChild(outer),scrollbarWidth=w1-w2}catch(ex){}return scrollbarWidth||17}();var $elems=jQuery(document.createDocumentFragment()).append('<div id="ui-overlay" class="ui-close"></div><div id="ui-dialog" tabindex="0" role="dialog" aria-labelledby="ui-dialog-title"><div id="ui-dialog-titlebar"><h1 id="ui-dialog-title"></h1>'+'<button id="ui-dialog-close" class="ui-close" tabindex="0" aria-label="'.concat(L10n.get("close"),'"></button>')+'</div><div id="ui-dialog-body"></div></div>');_$overlay=jQuery($elems.find("#ui-overlay").get(0)),_$dialog=jQuery($elems.find("#ui-dialog").get(0)),_$dialogTitle=jQuery($elems.find("#ui-dialog-title").get(0)),_$dialogBody=jQuery($elems.find("#ui-dialog-body").get(0)),$elems.insertBefore("body>script#script-sugarcube")}}},isOpen:{value:dialogIsOpen},open:{value:dialogOpen},resize:{value:function(data){return _resizeHandler("object"===_typeof(data)?{data:data}:undefined)}},setup:{value:function(title,classNames){return _$dialogBody.empty().removeClass(),null!=classNames&&_$dialogBody.addClass(classNames),_$dialogTitle.empty().append((null!=title?String(title):"")||" "),_$dialogBody.get(0)}},wiki:{value:function(){var _$dialogBody3;return(_$dialogBody3=_$dialogBody).wiki.apply(_$dialogBody3,arguments),Dialog}},addClickHandler:{value:function(targets,options,startFn,doneFn,closeFn){return jQuery(targets).ariaClick((function(ev){ev.preventDefault(),"function"==typeof startFn&&startFn(ev),dialogOpen(options,closeFn),"function"==typeof doneFn&&doneFn(ev)}))}}}))}(),Engine=function(){var States=Util.toEnum({Idle:"idle",Playing:"playing",Rendering:"rendering"}),_initDebugViews=[],_state=States.Idle,_lastPlay=null,_outlinePatch=null,_updating=null;function engineGo(offset){var succeded=State.go(offset);return succeded&&engineShow(),succeded}function engineShow(){return enginePlay(State.passage,!0)}function enginePlay(title,noHistory){var passageReadyOutput,passageDoneOutput,passageTitle=title;if(_state=States.Playing,TempState={},State.clearTemporary(),"function"==typeof Config.navigation.override)try{var overrideTitle=Config.navigation.override(passageTitle);overrideTitle&&(passageTitle=overrideTitle)}catch(ex){}var passage=Story.get(passageTitle);if(jQuery.event.trigger({type:":passageinit",passage:passage}),Object.keys(prehistory).forEach((function(task){"function"==typeof prehistory[task]&&prehistory[task].call(passage,task)})),noHistory||State.create(passage.title),document.body.className&&(document.body.className=""),_lastPlay=Util.now(),Object.keys(predisplay).forEach((function(task){"function"==typeof predisplay[task]&&predisplay[task].call(passage,task)})),Story.has("PassageReady"))try{passageReadyOutput=Wikifier.wikifyEval(Story.get("PassageReady").text)}catch(ex){console.error(ex),Alert.error("PassageReady",ex.message)}_state=States.Rendering;var dataTags=passage.tags.length>0?passage.tags.join(" "):null,passageEl=document.createElement("div");jQuery(passageEl).attr({id:passage.domId,"data-passage":passage.title,"data-tags":dataTags}).addClass("passage ".concat(passage.className)),jQuery(document.body).attr("data-tags",dataTags).addClass(passage.className),jQuery(document.documentElement).attr("data-tags",dataTags),jQuery.event.trigger({type:":passagestart",content:passageEl,passage:passage}),Object.keys(prerender).forEach((function(task){"function"==typeof prerender[task]&&prerender[task].call(passage,passageEl,task)})),Story.has("PassageHeader")&&new Wikifier(passageEl,Story.get("PassageHeader").processText()),passageEl.appendChild(passage.render()),Story.has("PassageFooter")&&new Wikifier(passageEl,Story.get("PassageFooter").processText()),jQuery.event.trigger({type:":passagerender",content:passageEl,passage:passage}),Object.keys(postrender).forEach((function(task){"function"==typeof postrender[task]&&postrender[task].call(passage,passageEl,task)}));var debugView,containerEl=document.getElementById("passages");if(containerEl.hasChildNodes()&&("number"==typeof Config.passages.transitionOut||"string"==typeof Config.passages.transitionOut&&""!==Config.passages.transitionOut&&Has.transitionEndEvent?_toConsumableArray(containerEl.childNodes).forEach((function(outgoing){var $outgoing=jQuery(outgoing);if(outgoing.nodeType===Node.ELEMENT_NODE&&$outgoing.hasClass("passage")){if($outgoing.hasClass("passage-out"))return;$outgoing.attr({id:"out-".concat($outgoing.attr("id")),"aria-live":"off"}).addClass("passage-out"),"string"==typeof Config.passages.transitionOut?$outgoing.on(Has.transitionEndEvent,(function(ev){ev.propertyName===Config.passages.transitionOut&&$outgoing.remove()})):setTimeout((function(){return $outgoing.remove()}),Math.max(40,Config.passages.transitionOut))}else $outgoing.remove()})):jQuery(containerEl).empty()),jQuery(passageEl).addClass("passage-in").appendTo(containerEl),setTimeout((function(){return jQuery(passageEl).removeClass("passage-in")}),40),Story.has("StoryDisplayTitle")?null===_updating&&Config.ui.updateStoryElements||setDisplayTitle(Story.get("StoryDisplayTitle").processText()):Config.passages.displayTitles&&passage.title!==Config.passages.start&&(document.title="".concat(passage.title," | ").concat(Story.title)),window.scroll(0,0),_state=States.Playing,Story.has("PassageDone"))try{passageDoneOutput=Wikifier.wikifyEval(Story.get("PassageDone").text)}catch(ex){console.error(ex),Alert.error("PassageDone",ex.message)}(jQuery.event.trigger({type:":passagedisplay",content:passageEl,passage:passage}),Object.keys(postdisplay).forEach((function(task){"function"==typeof postdisplay[task]&&postdisplay[task].call(passage,task)})),null!==_updating?_updating.forEach((function(pair){jQuery(pair.element).empty(),new Wikifier(pair.element,Story.get(pair.passage).processText().trim())})):Config.ui.updateStoryElements&&UIBar.update(),Config.debug)&&(null!=passageReadyOutput&&((debugView=new DebugView(document.createDocumentFragment(),"special","PassageReady","PassageReady")).modes({hidden:!0}),debugView.append(passageReadyOutput),jQuery(passageEl).prepend(debugView.output)),null!=passageDoneOutput&&((debugView=new DebugView(document.createDocumentFragment(),"special","PassageDone","PassageDone")).modes({hidden:!0}),debugView.append(passageDoneOutput),jQuery(passageEl).append(debugView.output)),1===State.turns&&_initDebugViews.length>0&&jQuery(passageEl).prepend(_initDebugViews));switch(jQuery("#story").find("a[href]:not(.link-external)").addClass("link-external").end().find("a,link,button,input,select,textarea").not("[tabindex]").attr("tabindex",0),_typeof(Config.saves.autosave)){case"boolean":Config.saves.autosave&&Save.autosave.save();break;case"object":passage.tags.some((function(tag){return Config.saves.autosave.includes(tag)}))&&Save.autosave.save();break;case"function":Config.saves.autosave()&&Save.autosave.save()}return jQuery.event.trigger({type:":passageend",content:passageEl,passage:passage}),_state=States.Idle,_lastPlay=Util.now(),passageEl}function _hideOutlines(){_outlinePatch.set("*:focus{outline:none;}")}return Object.freeze(Object.defineProperties({},{States:{value:States},minDomActionDelay:{value:40},init:{value:function(){var _lastOutlineEvent;jQuery("#init-no-js,#init-lacking").remove(),function(){var $elems=jQuery(document.createDocumentFragment()),markup=Story.has("StoryInterface")&&Story.get("StoryInterface").text.trim();if(markup){UIBar.destroy(),jQuery(document.head).find("#style-core-display").remove(),$elems.append(markup);var $passages=$elems.find("#passages");if(0===$passages.length)throw new Error('no element with ID "passages" found within "StoryInterface" special passage');$passages.empty().not("[aria-live]").attr("aria-live","polite").end(),$elems.find("[data-init-passage]").each((function(i,el){if("passages"===el.id)throw new Error('"StoryInterface" element <'.concat(el.nodeName.toLowerCase(),' id="passages"> must not contain a "data-init-passage" content attribute'));var passage=el.getAttribute("data-init-passage").trim();if(el.hasAttribute("data-passage"))throw new Error('"StoryInterface" element <'.concat(el.nodeName.toLowerCase(),' data-init-passage="').concat(passage,'"> must not contain a "data-passage" content attribute'));if(null!==el.firstElementChild)throw new Error('"StoryInterface" element <'.concat(el.nodeName.toLowerCase(),' data-init-passage="').concat(passage,'"> contains child elements'));Story.has(passage)&&jQuery(el).empty().wiki(Story.get(passage).processText().trim())}));var updating=[];$elems.find("[data-passage]").each((function(i,el){if("passages"===el.id)throw new Error('"StoryInterface" element <'.concat(el.nodeName.toLowerCase(),' id="passages"> must not contain a "data-passage" content attribute'));var passage=el.getAttribute("data-passage").trim();if(null!==el.firstElementChild)throw new Error('"StoryInterface" element <'.concat(el.nodeName.toLowerCase(),' data-passage="').concat(passage,'"> contains child elements'));Story.has(passage)&&updating.push({passage:passage,element:el})})),updating.length>0&&(_updating=updating),Config.ui.updateStoryElements=!1}else $elems.append('<div id="story" role="main"><div id="passages" aria-live="polite"></div></div>');$elems.insertBefore("body>script#script-sugarcube")}(),_outlinePatch=new StyleWrapper(jQuery(document.createElement("style")).attr({id:"style-aria-outlines",type:"text/css"}).appendTo(document.head).get(0)),_hideOutlines(),jQuery(document).on("mousedown.aria-outlines keydown.aria-outlines",(function(ev){ev.type!==_lastOutlineEvent&&(_lastOutlineEvent=ev.type,"keydown"===ev.type?_outlinePatch.clear():_hideOutlines())}))}},start:{value:function(){if(Story.getAllInit().forEach((function(passage){try{var debugBuffer=Wikifier.wikifyEval(passage.text);if(Config.debug){var debugView=new DebugView(document.createDocumentFragment(),"special","".concat(passage.title," [init-tagged]"),"".concat(passage.title," [init-tagged]"));debugView.modes({hidden:!0}),debugView.append(debugBuffer),_initDebugViews.push(debugView.output)}}catch(ex){console.error(ex),Alert.error("".concat(passage.title," [init-tagged]"),"object"===_typeof(ex)?ex.message:ex)}})),Story.has("StoryInit"))try{var debugBuffer=Wikifier.wikifyEval(Story.get("StoryInit").text);if(Config.debug){var debugView=new DebugView(document.createDocumentFragment(),"special","StoryInit","StoryInit");debugView.modes({hidden:!0}),debugView.append(debugBuffer),_initDebugViews.push(debugView.output)}}catch(ex){console.error(ex),Alert.error("StoryInit","object"===_typeof(ex)?ex.message:ex)}if(null==Config.passages.start)throw new Error("starting passage not selected");if(!Story.has(Config.passages.start))throw new Error('starting passage ("'.concat(Config.passages.start,'") not found'));if(jQuery(document.documentElement).focus(),State.restore())engineShow();else{var loadStart=!0;switch(_typeof(Config.saves.autoload)){case"boolean":Config.saves.autoload&&Save.autosave.ok()&&Save.autosave.has()&&(loadStart=!Save.autosave.load());break;case"string":"prompt"===Config.saves.autoload&&Save.autosave.ok()&&Save.autosave.has()&&(loadStart=!1,UI.buildAutoload(),Dialog.open());break;case"function":Save.autosave.ok()&&Save.autosave.has()&&Config.saves.autoload()&&(loadStart=!Save.autosave.load())}loadStart&&enginePlay(Config.passages.start)}}},restart:{value:function(){LoadScreen.show(),window.scroll(0,0),State.reset(),jQuery.event.trigger(":enginerestart"),window.location.reload()}},state:{get:function(){return _state}},isIdle:{value:function(){return _state===States.Idle}},isPlaying:{value:function(){return _state!==States.Idle}},isRendering:{value:function(){return _state===States.Rendering}},lastPlay:{get:function(){return _lastPlay}},goTo:{value:function(idx){var succeded=State.goTo(idx);return succeded&&engineShow(),succeded}},go:{value:engineGo},backward:{value:function(){return engineGo(-1)}},forward:{value:function(){return engineGo(1)}},show:{value:engineShow},play:{value:enginePlay},display:{value:function(title,link,option){var noHistory=!1;switch(option){case undefined:break;case"replace":case"back":noHistory=!0;break;default:throw new Error('Engine.display option parameter called with obsolete value "'.concat(option,'"; please notify the developer'))}enginePlay(title,noHistory)}}}))}(),Passage=(_tagsToSkip=/^(?:debug|nobr|passage|widget|twine\..*)$/i,function(){function Passage(title,el){var _this22=this;_classCallCheck(this,Passage),Object.defineProperties(this,{title:{value:Util.unescape(title)},element:{value:el||null},tags:{value:Object.freeze(el&&el.hasAttribute("tags")?Array.from(new Set(el.getAttribute("tags").trim().splitOrEmpty(/\s+/))):[])},_excerpt:{writable:!0,value:null}}),Object.defineProperties(this,{domId:{value:"passage-".concat(Util.slugify(this.title))},classes:{value:Object.freeze(0===this.tags.length?[]:_this22.tags.filter((function(tag){return!_tagsToSkip.test(tag)})).map((function(tag){return Util.slugify(tag)})))}})}return _createClass(Passage,[{key:"className",get:function(){return this.classes.join(" ")}},{key:"text",get:function(){if(null==this.element){var passage=Util.escapeMarkup(this.title),mesg="".concat(L10n.get("errorTitle"),": ").concat(L10n.get("errorNonexistentPassage",{passage:passage}));return'<div class="error-view"><span class="error">'.concat(mesg,"</span></div>")}return this.element.textContent.replace(/\r/g,"")}},{key:"description",value:function(){var descriptions=Config.passages.descriptions;switch(_typeof(descriptions)){case"boolean":if(descriptions)return this.title;break;case"object":if(descriptions.hasOwnProperty(this.title))return descriptions[this.title];break;case"function":var result=descriptions.call(this);if(result)return result}return null===this._excerpt&&(this._excerpt=Passage.getExcerptFromText(this.text)),this._excerpt}},{key:"processText",value:function(){if(null==this.element)return this.text;if(this.tags.includes("Twine.image"))return"[img[".concat(this.text,"]]");var processed=this.text;return Config.passages.onProcess&&(processed=Config.passages.onProcess.call(null,{title:this.title,tags:this.tags,text:processed})),(Config.passages.nobr||this.tags.includes("nobr"))&&(processed=processed.replace(/^\n+|\n+$/g,"").replace(/\n+/g," ")),processed}},{key:"render",value:function(options){var frag=document.createDocumentFragment();return new Wikifier(frag,this.processText(),options),this._excerpt=Passage.getExcerptFromNode(frag),frag}}],[{key:"getExcerptFromNode",value:function(node,count){if(!node.hasChildNodes())return"";var excerpt=node.textContent.trim();if(""!==excerpt){var excerptRe=new RegExp("(\\S+(?:\\s+\\S+){0,".concat(count>0?count-1:7,"})"));excerpt=excerpt.replace(/\s+/g," ").match(excerptRe)}return excerpt?"".concat(excerpt[1],"…"):"…"}},{key:"getExcerptFromText",value:function(text,count){if(""===text)return"";var excerptRe=new RegExp("(\\S+(?:\\s+\\S+){0,".concat(count>0?count-1:7,"})")),excerpt=text.replace(/<<.*?>>/g," ").replace(/<.*?>/g," ").trim().replace(/^\s*\|.*\|.*?$/gm,"").replace(/\[[<>]?img\[[^\]]*\]\]/g,"").replace(/\[\[([^|\]]*?)(?:(?:\||->|<-)[^\]]*)?\]\]/g,"$1").replace(/^\s*!+(.*?)$/gm,"$1").replace(/'{2}|\/{2}|_{2}|@{2}/g,"").trim().replace(/\s+/g," ").match(excerptRe);return excerpt?"".concat(excerpt[1],"…"):"…"}}]),Passage}()),_tagsToSkip,Save=function(){var Type=Util.toEnum({Autosave:"autosave",Disk:"disk",Serialize:"serialize",Slot:"slot"}),_slotsUBound=-1,_onLoadHandlers=new Set,_onSaveHandlers=new Set;function savesObjGet(){var saves=storage.get("saves");return null===saves?{autosave:null,slots:_appendSlots([],Config.saves.slots)}:saves}function savesObjClear(){return storage.delete("saves"),!0}function autosaveOk(){return"cookie"!==storage.name&&void 0!==Config.saves.autosave}function slotsOk(){return"cookie"!==storage.name&&-1!==_slotsUBound}function slotsCount(){if(!slotsOk())return 0;for(var saves=savesObjGet(),count=0,i=0,iend=saves.slots.length;i<iend;++i)null!==saves.slots[i]&&++count;return count}function _appendSlots(array,num){for(var i=0;i<num;++i)array.push(null);return array}function _savesObjIsEmpty(saves){for(var slots=saves.slots,isSlotsEmpty=!0,i=0,iend=slots.length;i<iend;++i)if(null!==slots[i]){isSlotsEmpty=!1;break}return null===saves.autosave&&isSlotsEmpty}function _savesObjSave(saves){return _savesObjIsEmpty(saves)?(storage.delete("saves"),!0):storage.set("saves",saves)}function _savesObjUpdate(saveObj){if(null==saveObj||"object"!==_typeof(saveObj))return!1;var updated=!1;return saveObj.hasOwnProperty("state")&&saveObj.state.hasOwnProperty("delta")&&saveObj.state.hasOwnProperty("index")||(saveObj.hasOwnProperty("data")?(delete saveObj.mode,saveObj.state={delta:State.deltaEncode(saveObj.data)},delete saveObj.data):saveObj.state.hasOwnProperty("delta")?saveObj.state.hasOwnProperty("index")||delete saveObj.state.mode:(delete saveObj.state.mode,saveObj.state.delta=State.deltaEncode(saveObj.state.history),delete saveObj.state.history),saveObj.state.index=saveObj.state.delta.length-1,updated=!0),saveObj.state.hasOwnProperty("rseed")&&(saveObj.state.seed=saveObj.state.rseed,delete saveObj.state.rseed,saveObj.state.delta.forEach((function(_,i,delta){delta[i].hasOwnProperty("rcount")&&(delta[i].pull=delta[i].rcount,delete delta[i].rcount)})),updated=!0),(saveObj.state.hasOwnProperty("expired")&&"number"==typeof saveObj.state.expired||saveObj.state.hasOwnProperty("unique")||saveObj.state.hasOwnProperty("last"))&&(saveObj.state.hasOwnProperty("expired")&&"number"==typeof saveObj.state.expired&&delete saveObj.state.expired,(saveObj.state.hasOwnProperty("unique")||saveObj.state.hasOwnProperty("last"))&&(saveObj.state.expired=[],saveObj.state.hasOwnProperty("unique")&&(saveObj.state.expired.push(saveObj.state.unique),delete saveObj.state.unique),saveObj.state.hasOwnProperty("last")&&(saveObj.state.expired.push(saveObj.state.last),delete saveObj.state.last)),updated=!0),updated}function _marshal(supplemental,details){if(null!=supplemental&&"object"!==_typeof(supplemental))throw new Error("supplemental parameter must be an object");var saveObj=Object.assign({},supplemental,{id:Config.saves.id,state:State.marshalForSave()});return Config.saves.version&&(saveObj.version=Config.saves.version),_onSaveHandlers.forEach((function(fn){return fn(saveObj,details)})),saveObj.state.delta=State.deltaEncode(saveObj.state.history),delete saveObj.state.history,saveObj}function _unmarshal(saveObj){try{if(_savesObjUpdate(saveObj),!saveObj||!saveObj.hasOwnProperty("id")||!saveObj.hasOwnProperty("state"))throw new Error(L10n.get("errorSaveMissingData"));if(saveObj.state.history=State.deltaDecode(saveObj.state.delta),delete saveObj.state.delta,_onLoadHandlers.forEach((function(fn){return fn(saveObj)})),saveObj.id!==Config.saves.id)throw new Error(L10n.get("errorSaveIdMismatch"));State.unmarshalForSave(saveObj.state),Engine.show()}catch(ex){return UI.alert("".concat(ex.message.toUpperFirst(),".</p><p>").concat(L10n.get("aborting"),".")),!1}return!0}return Object.freeze(Object.defineProperties({},{init:{value:function(){if("cookie"===storage.name)return savesObjClear(),Config.saves.autoload=undefined,Config.saves.autosave=undefined,Config.saves.slots=0,!1;var saves=savesObjGet(),updated=!1;Array.isArray(saves)&&(saves={autosave:null,slots:saves},updated=!0),Config.saves.slots!==saves.slots.length&&(Config.saves.slots<saves.slots.length?(saves.slots.reverse(),saves.slots=saves.slots.filter((function(val){return!(null===val&&this.count>0)||(--this.count,!1)}),{count:saves.slots.length-Config.saves.slots}),saves.slots.reverse()):Config.saves.slots>saves.slots.length&&_appendSlots(saves.slots,Config.saves.slots-saves.slots.length),updated=!0),_savesObjUpdate(saves.autosave)&&(updated=!0);for(var i=0;i<saves.slots.length;++i)_savesObjUpdate(saves.slots[i])&&(updated=!0);return _savesObjIsEmpty(saves)&&(storage.delete("saves"),updated=!1),updated&&_savesObjSave(saves),_slotsUBound=saves.slots.length-1,!0}},get:{value:savesObjGet},clear:{value:savesObjClear},ok:{value:function(){return autosaveOk()||slotsOk()}},autosave:{value:Object.freeze(Object.defineProperties({},{ok:{value:autosaveOk},has:{value:function(){return null!==savesObjGet().autosave}},get:{value:function(){return savesObjGet().autosave}},load:{value:function(){var saves=savesObjGet();return null!==saves.autosave&&_unmarshal(saves.autosave)}},save:{value:function(title,metadata){if("function"==typeof Config.saves.isAllowed&&!Config.saves.isAllowed())return!1;var saves=savesObjGet(),supplemental={title:title||Story.get(State.passage).description(),date:Date.now()};return null!=metadata&&(supplemental.metadata=metadata),saves.autosave=_marshal(supplemental,{type:Type.Autosave}),_savesObjSave(saves)}},delete:{value:function(){var saves=savesObjGet();return saves.autosave=null,_savesObjSave(saves)}}}))},slots:{value:Object.freeze(Object.defineProperties({},{ok:{value:slotsOk},length:{get:function(){return _slotsUBound+1}},isEmpty:{value:function(){return 0===slotsCount()}},count:{value:slotsCount},has:{value:function(slot){if(slot<0||slot>_slotsUBound)return!1;var saves=savesObjGet();return!(slot>=saves.slots.length||null===saves.slots[slot])}},get:{value:function(slot){if(slot<0||slot>_slotsUBound)return null;var saves=savesObjGet();return slot>=saves.slots.length?null:saves.slots[slot]}},load:{value:function(slot){if(slot<0||slot>_slotsUBound)return!1;var saves=savesObjGet();return!(slot>=saves.slots.length||null===saves.slots[slot])&&_unmarshal(saves.slots[slot])}},save:{value:function(slot,title,metadata){if("function"==typeof Config.saves.isAllowed&&!Config.saves.isAllowed())return Dialog.isOpen()?$(document).one(":dialogclosed",(function(){return UI.alert(L10n.get("savesDisallowed"))})):UI.alert(L10n.get("savesDisallowed")),!1;if(slot<0||slot>_slotsUBound)return!1;var saves=savesObjGet();if(slot>=saves.slots.length)return!1;var supplemental={title:title||Story.get(State.passage).description(),date:Date.now()};return null!=metadata&&(supplemental.metadata=metadata),saves.slots[slot]=_marshal(supplemental,{type:Type.Slot}),_savesObjSave(saves)}},delete:{value:function(slot){if(slot<0||slot>_slotsUBound)return!1;var saves=savesObjGet();return!(slot>=saves.slots.length)&&(saves.slots[slot]=null,_savesObjSave(saves))}}}))},export:{value:function(filename,metadata){if("function"!=typeof Config.saves.isAllowed||Config.saves.isAllowed()){var str,now,MM,DD,hh,mm,ss,baseName=null==filename?Story.domId:(str=filename,Util.sanitizeFilename(str).replace(/[_\s\u2013\u2014-]+/g,"-")),saveName="".concat(baseName,"-").concat((now=new Date,MM=now.getMonth()+1,DD=now.getDate(),hh=now.getHours(),mm=now.getMinutes(),ss=now.getSeconds(),MM<10&&(MM="0".concat(MM)),DD<10&&(DD="0".concat(DD)),hh<10&&(hh="0".concat(hh)),mm<10&&(mm="0".concat(mm)),ss<10&&(ss="0".concat(ss)),"".concat(now.getFullYear()).concat(MM).concat(DD,"-").concat(hh).concat(mm).concat(ss)),".save"),supplemental=null==metadata?{}:{metadata:metadata},saveObj=LZString.compressToBase64(JSON.stringify(_marshal(supplemental,{type:Type.Disk})));saveAs(new Blob([saveObj],{type:"text/plain;charset=UTF-8"}),saveName)}else Dialog.isOpen()?$(document).one(":dialogclosed",(function(){return UI.alert(L10n.get("savesDisallowed"))})):UI.alert(L10n.get("savesDisallowed"))}},import:{value:function(event){var file=event.target.files[0],reader=new FileReader;jQuery(reader).one("loadend",(function(){if(reader.error){var ex=reader.error;UI.alert("".concat(L10n.get("errorSaveDiskLoadFailed").toUpperFirst()," (").concat(ex.name,": ").concat(ex.message,").</p><p>").concat(L10n.get("aborting"),"."))}else{var saveObj;try{saveObj=JSON.parse(/\.json$/i.test(file.name)||/^\{/.test(reader.result)?reader.result:LZString.decompressFromBase64(reader.result))}catch(ex){}_unmarshal(saveObj)}})),reader.readAsText(file)}},serialize:{value:function(metadata){if("function"==typeof Config.saves.isAllowed&&!Config.saves.isAllowed())return Dialog.isOpen()?$(document).one(":dialogclosed",(function(){return UI.alert(L10n.get("savesDisallowed"))})):UI.alert(L10n.get("savesDisallowed")),null;var supplemental=null==metadata?{}:{metadata:metadata};return LZString.compressToBase64(JSON.stringify(_marshal(supplemental,{type:Type.Serialize})))}},deserialize:{value:function(base64Str){var saveObj;try{saveObj=JSON.parse(LZString.decompressFromBase64(base64Str))}catch(ex){}return _unmarshal(saveObj)?saveObj.metadata:null}},onLoad:{value:Object.freeze(Object.defineProperties({},{add:{value:function(handler){var valueType=Util.getType(handler);if("function"!==valueType)throw new TypeError("Save.onLoad.add handler parameter must be a function (received: ".concat(valueType,")"));_onLoadHandlers.add(handler)}},clear:{value:function(){_onLoadHandlers.clear()}},delete:{value:function(handler){return _onLoadHandlers.delete(handler)}},size:{get:function(){return _onLoadHandlers.size}}}))},onSave:{value:Object.freeze(Object.defineProperties({},{add:{value:function(handler){var valueType=Util.getType(handler);if("function"!==valueType)throw new TypeError("Save.onSave.add handler parameter must be a function (received: ".concat(valueType,")"));_onSaveHandlers.add(handler)}},clear:{value:function(){_onSaveHandlers.clear()}},delete:{value:function(handler){return _onSaveHandlers.delete(handler)}},size:{get:function(){return _onSaveHandlers.size}}}))}}))}(),Setting=function(){var Types=Util.toEnum({Header:0,Toggle:1,List:2,Range:3}),_definitions=[];function settingsCreate(){return Object.create(null)}function settingsSave(){var savedSettings=settingsCreate();return Object.keys(settings).length>0&&_definitions.filter((function(def){return def.type!==Types.Header&&settings[def.name]!==def.default})).forEach((function(def){return savedSettings[def.name]=settings[def.name]})),0===Object.keys(savedSettings).length?(storage.delete("settings"),!0):storage.set("settings",savedSettings)}function settingsLoad(){var defaultSettings=settingsCreate(),loadedSettings=storage.get("settings")||settingsCreate();_definitions.filter((function(def){return def.type!==Types.Header})).forEach((function(def){return defaultSettings[def.name]=def.default})),window.SugarCube.settings=settings=Object.assign(defaultSettings,loadedSettings)}function settingsClear(){return window.SugarCube.settings=settings=settingsCreate(),storage.delete("settings"),!0}function definitionsAdd(type,name,def){if(arguments.length<3){var errors=[];throw arguments.length<1&&errors.push("type"),arguments.length<2&&errors.push("name"),arguments.length<3&&errors.push("definition"),new Error("missing parameters, no ".concat(errors.join(" or ")," specified"))}if("object"!==_typeof(def))throw new TypeError("definition parameter must be an object");if(definitionsHas(name))throw new Error('cannot clobber existing setting "'.concat(name,'"'));var str,pos,definition={type:type,name:name,label:"string"==typeof def.label?def.label.trim():""};if("string"==typeof def.desc){var desc=def.desc.trim();""!==desc&&(definition.desc=desc)}switch(type){case Types.Header:break;case Types.Toggle:definition.default=!!def.default;break;case Types.List:if(!def.hasOwnProperty("list"))throw new Error("no list specified");if(!Array.isArray(def.list))throw new TypeError("list must be an array");if(0===def.list.length)throw new Error("list must not be empty");if(definition.list=Object.freeze(def.list),null==def.default)definition.default=def.list[0];else{var defaultIndex=def.list.indexOf(def.default);if(-1===defaultIndex)throw new Error("list does not contain default");definition.default=def.list[defaultIndex]}break;case Types.Range:if(!def.hasOwnProperty("min"))throw new Error("no min specified");if("number"!=typeof def.min||Number.isNaN(def.min)||!Number.isFinite(def.min))throw new TypeError("min must be a finite number");if(!def.hasOwnProperty("max"))throw new Error("no max specified");if("number"!=typeof def.max||Number.isNaN(def.max)||!Number.isFinite(def.max))throw new TypeError("max must be a finite number");if(!def.hasOwnProperty("step"))throw new Error("no step specified");if("number"!=typeof def.step||Number.isNaN(def.step)||!Number.isFinite(def.step)||def.step<=0)throw new TypeError("step must be a finite number greater than zero");var stepValidate=function(value){if(fracDigits>0){var ma=Number("".concat(def.min,"e").concat(fracDigits)),sa=Number("".concat(def.step,"e").concat(fracDigits)),_va=Number("".concat(value,"e").concat(fracDigits))-ma;return Number("".concat(_va-_va%sa+ma,"e-").concat(fracDigits))}var va=value-def.min;return va-va%def.step+def.min},fracDigits=(str=String(def.step),-1===(pos=str.lastIndexOf("."))?0:str.length-pos-1);if(stepValidate(def.max)!==def.max)throw new RangeError("max (".concat(def.max,") is not a multiple of the step (").concat(def.step,") plus the min (").concat(def.min,")"));if(definition.max=def.max,definition.min=def.min,definition.step=def.step,null==def.default)definition.default=def.max;else{if("number"!=typeof def.default||Number.isNaN(def.default)||!Number.isFinite(def.default))throw new TypeError("default must be a finite number");if(def.default<def.min)throw new RangeError("default (".concat(def.default,") is less than min (").concat(def.min,")"));if(def.default>def.max)throw new RangeError("default (".concat(def.default,") is greater than max (").concat(def.max,")"));definition.default=def.default}break;default:throw new Error("unknown Setting type: ".concat(type))}"function"==typeof def.onInit&&(definition.onInit=Object.freeze(def.onInit)),"function"==typeof def.onChange&&(definition.onChange=Object.freeze(def.onChange)),_definitions.push(Object.freeze(definition))}function definitionsHas(name){return _definitions.some((function(definition){return definition.name===name}))}function definitionsGet(name){return _definitions.find((function(definition){return definition.name===name}))}return Object.freeze(Object.defineProperties({},{Types:{value:Types},init:{value:function(){if(storage.has("options")){var old=storage.get("options");null!==old&&(window.SugarCube.settings=settings=Object.assign(settingsCreate(),old)),settingsSave(),storage.delete("options")}settingsLoad(),_definitions.forEach((function(def){if(def.hasOwnProperty("onInit")){var thisArg={name:def.name,value:settings[def.name],default:def.default};def.hasOwnProperty("list")&&(thisArg.list=def.list),def.onInit.call(thisArg)}}))}},create:{value:settingsCreate},save:{value:settingsSave},load:{value:settingsLoad},clear:{value:settingsClear},reset:{value:function(name){if(0===arguments.length)settingsClear(),settingsLoad();else{if(null==name||!definitionsHas(name))throw new Error('nonexistent setting "'.concat(name,'"'));var def=definitionsGet(name);def.type!==Types.Header&&(settings[name]=def.default)}return settingsSave()}},forEach:{value:function(callback,thisArg){_definitions.forEach(callback,thisArg)}},add:{value:definitionsAdd},addHeader:{value:function(name,desc){definitionsAdd(Types.Header,name,{desc:desc})}},addToggle:{value:function(){for(var _len16=arguments.length,args=new Array(_len16),_key16=0;_key16<_len16;_key16++)args[_key16]=arguments[_key16];definitionsAdd.apply(void 0,[Types.Toggle].concat(args))}},addList:{value:function(){for(var _len17=arguments.length,args=new Array(_len17),_key17=0;_key17<_len17;_key17++)args[_key17]=arguments[_key17];definitionsAdd.apply(void 0,[Types.List].concat(args))}},addRange:{value:function(){for(var _len18=arguments.length,args=new Array(_len18),_key18=0;_key18<_len18;_key18++)args[_key18]=arguments[_key18];definitionsAdd.apply(void 0,[Types.Range].concat(args))}},isEmpty:{value:function(){return 0===_definitions.length}},has:{value:definitionsHas},get:{value:definitionsGet},delete:{value:function definitionsDelete(name){definitionsHas(name)&&delete settings[name];for(var i=0;i<_definitions.length;++i)if(_definitions[i].name===name){_definitions.splice(i,1),definitionsDelete(name);break}}}}))}(),Story=function(){var _passages={},_inits=[],_scripts=[],_styles=[],_widgets=[],_title="",_ifId="",_domId="";function _storySetTitle(rawTitle){if(null==rawTitle)throw new Error("story title must not be null or undefined");var title=Util.unescape(String(rawTitle)).trim();if(""===title)throw new Error("story title must not be empty or consist solely of whitespace");if(document.title=_title=title,""===(_domId=Util.slugify(_title)))if(""!==_ifId)_domId=_ifId;else for(var i=0,len=_title.length;i<len;++i){var _Util$charAndPosAt2=Util.charAndPosAt(_title,i),char=_Util$charAndPosAt2.char,start=_Util$charAndPosAt2.start,end=_Util$charAndPosAt2.end;_domId+=char.codePointAt(0).toString(16),i+=end-start}}return Object.freeze(Object.defineProperties({},{load:{value:function(){var validationCodeTags=["init","widget"],validationNoCodeTagPassages=["PassageDone","PassageFooter","PassageHeader","PassageReady","StoryAuthor","StoryBanner","StoryCaption","StoryInit","StoryMenu","StoryShare","StorySubtitle"];function validateStartingPassage(passage){if(passage.tags.includesAny(validationCodeTags))throw new Error('starting passage "'.concat(passage.title,'" contains special tags; invalid: "').concat(passage.tags.filter((function(tag){return validationCodeTags.includes(tag)})).sort().join('", "'),'"'))}function validateSpecialPassages(passage){if(validationNoCodeTagPassages.includes(passage.title)){for(var _len19=arguments.length,tags=new Array(_len19>1?_len19-1:0),_key19=1;_key19<_len19;_key19++)tags[_key19-1]=arguments[_key19];throw new Error('special passage "'.concat(passage.title,'" contains special tags; invalid: "').concat(tags.sort().join('", "'),'"'))}var codeTags=[].concat(validationCodeTags),foundTags=[];if(passage.tags.forEach((function(tag){codeTags.includes(tag)&&foundTags.push.apply(foundTags,_toConsumableArray(codeTags.delete(tag)))})),foundTags.length>1)throw new Error('passage "'.concat(passage.title,'" contains multiple special tags; invalid: "').concat(foundTags.sort().join('", "'),'"'))}var $storydata=jQuery("tw-storydata"),startNode=$storydata.attr("startnode")||"";Config.passages.start=null,Config.debug=/\bdebug\b/.test($storydata.attr("options")),$storydata.children("style").each((function(i){_styles.push(new Passage("tw-user-style-".concat(i),this))})),$storydata.children("script").each((function(i){_scripts.push(new Passage("tw-user-script-".concat(i),this))})),$storydata.children('tw-passagedata:not([tags~="Twine.private"],[tags~="annotation"])').each((function(){var $this=jQuery(this),pid=$this.attr("pid")||"",passage=new Passage($this.attr("name"),this);pid===startNode&&""!==startNode?(Config.passages.start=passage.title,validateStartingPassage(passage),_passages[passage.title]=passage):passage.tags.includes("init")?(validateSpecialPassages(passage,"init"),_inits.push(passage)):passage.tags.includes("widget")?(validateSpecialPassages(passage,"widget"),_widgets.push(passage)):_passages[passage.title]=passage})),_ifId=$storydata.attr("ifid"),_storySetTitle("Another RPG Engine"),Config.saves.id=Story.domId}},init:{value:function(){var storyStyle;storyStyle=document.createElement("style"),new StyleWrapper(storyStyle).add(_styles.map((function(style){return style.text.trim()})).join("\n")),jQuery(storyStyle).appendTo(document.head).attr({id:"style-story",type:"text/css"});for(var i=0;i<_scripts.length;++i)try{Scripting.evalJavaScript(_scripts[i].text)}catch(ex){console.error(ex),Alert.error(_scripts[i].title,"object"===_typeof(ex)?ex.message:ex)}for(var _i8=0;_i8<_widgets.length;++_i8)try{Wikifier.wikifyEval(_widgets[_i8].processText())}catch(ex){console.error(ex),Alert.error(_widgets[_i8].title,"object"===_typeof(ex)?ex.message:ex)}}},title:{get:function(){return _title}},domId:{get:function(){return _domId}},ifId:{get:function(){return _ifId}},add:{value:function(passage){if(!(passage instanceof Passage))throw new TypeError("Story.add passage parameter must be an instance of Passage");var title=passage.title;return!_passages.hasOwnProperty(title)&&(_passages[title]=passage,!0)}},has:{value:function(title){var type=_typeof(title);switch(type){case"number":case"string":return _passages.hasOwnProperty(String(title));case"undefined":break;case"object":type=null===title?"null":"an object";break;default:type="a ".concat(type)}throw new TypeError("Story.has title parameter cannot be ".concat(type))}},get:{value:function(title){var type=_typeof(title);switch(type){case"number":case"string":var id=String(title);return _passages.hasOwnProperty(id)?_passages[id]:new Passage(id||"(unknown)");case"undefined":break;case"object":type=null===title?"null":"an object";break;default:type="a ".concat(type)}throw new TypeError("Story.get title parameter cannot be ".concat(type))}},getAllInit:{value:function(){return Object.freeze(Array.from(_inits))}},getAllRegular:{value:function(){return Object.freeze(Object.assign({},_passages))}},getAllScript:{value:function(){return Object.freeze(Array.from(_scripts))}},getAllStylesheet:{value:function(){return Object.freeze(Array.from(_styles))}},getAllWidget:{value:function(){return Object.freeze(Array.from(_widgets))}},lookup:{value:function(key,value){var sortKey=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"title",results=[];return Object.keys(_passages).forEach((function(name){var passage=_passages[name];"object"===_typeof(passage[key])&&null!==passage[key]?passage[key]instanceof Array&&passage[key].some((function(m){return Util.sameValueZero(m,value)}))&&results.push(passage):Util.sameValueZero(passage[key],value)&&results.push(passage)})),results.sort((function(a,b){return a[sortKey]==b[sortKey]?0:a[sortKey]<b[sortKey]?-1:1})),results}},lookupWith:{value:function(predicate){var sortKey=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"title";if("function"!=typeof predicate)throw new TypeError("Story.lookupWith predicate parameter must be a function");var results=[];return Object.keys(_passages).forEach((function(name){var passage=_passages[name];predicate(passage)&&results.push(passage)})),results.sort((function(a,b){return a[sortKey]==b[sortKey]?0:a[sortKey]<b[sortKey]?-1:1})),results}}}))}(),UI=function(){function uiAssembleLinkList(passage,listEl){var list=listEl,debugState=Config.debug,cleanState=Config.cleanupWikifierOutput;Config.debug=!1,Config.cleanupWikifierOutput=!1;try{null==list&&(list=document.createElement("ul"));var frag=document.createDocumentFragment();new Wikifier(frag,Story.get(passage).processText().trim());var errors=_toConsumableArray(frag.querySelectorAll(".error")).map((function(errEl){return errEl.textContent.replace(errorPrologRegExp,"")}));if(errors.length>0)throw new Error(errors.join("; "));for(;frag.hasChildNodes();){var node=frag.firstChild;if(node.nodeType===Node.ELEMENT_NODE&&"A"===node.nodeName.toUpperCase()){var li=document.createElement("li");list.appendChild(li),li.appendChild(node)}else frag.removeChild(node)}}finally{Config.cleanupWikifierOutput=cleanState,Config.debug=debugState}return list}function uiOpenAlert(message){jQuery(Dialog.setup(L10n.get("alertTitle"),"alert")).append("<p>".concat(message,'</p><ul class="buttons">')+'<li><button id="alert-ok" class="ui-close">'.concat(L10n.get(["alertOk","ok"]),"</button></li>")+"</ul>");for(var _len20=arguments.length,args=new Array(_len20>1?_len20-1:0),_key20=1;_key20<_len20;_key20++)args[_key20-1]=arguments[_key20];Dialog.open.apply(Dialog,args)}function uiBuildAutoload(){return jQuery(Dialog.setup(L10n.get("autoloadTitle"),"autoload")).append("<p>".concat(L10n.get("autoloadPrompt"),'</p><ul class="buttons">')+'<li><button id="autoload-ok" class="ui-close">'.concat(L10n.get(["autoloadOk","ok"]),"</button></li>")+'<li><button id="autoload-cancel" class="ui-close">'.concat(L10n.get(["autoloadCancel","cancel"]),"</button></li>")+"</ul>"),jQuery(document).one("click.autoload",".ui-close",(function(ev){var isAutoloadOk="autoload-ok"===ev.target.id;jQuery(document).one(":dialogclosed",(function(){isAutoloadOk&&Save.autosave.load()||Engine.play(Config.passages.start)}))})),!0}function uiBuildJumpto(){var list=document.createElement("ul");jQuery(Dialog.setup(L10n.get("jumptoTitle"),"jumpto list")).append(list);for(var expired=State.expired.length,i=State.size-1;i>=0;--i)if(i!==State.activeIndex){var passage=Story.get(State.history[i].title);passage&&passage.tags.includes("bookmark")&&jQuery(document.createElement("li")).append(jQuery(document.createElement("a")).ariaClick({one:!0},function(idx){return function(){return jQuery(document).one(":dialogclosed",(function(){return Engine.goTo(idx)}))}}(i)).addClass("ui-close").text("".concat(L10n.get("jumptoTurn")," ").concat(expired+i+1,": ").concat(passage.description()))).appendTo(list)}list.hasChildNodes()||jQuery(list).append("<li><a><em>".concat(L10n.get("jumptoUnavailable"),"</em></a></li>"))}function uiBuildRestart(){return jQuery(Dialog.setup(L10n.get("restartTitle"),"restart")).append("<p>".concat(L10n.get("restartPrompt"),'</p><ul class="buttons">')+'<li><button id="restart-ok">'.concat(L10n.get(["restartOk","ok"]),"</button></li>")+'<li><button id="restart-cancel" class="ui-close">'.concat(L10n.get(["restartCancel","cancel"]),"</button></li>")+"</ul>").find("#restart-ok").ariaClick({one:!0},(function(){jQuery(document).one(":dialogclosed",(function(){return Engine.restart()})),Dialog.close()})),!0}function uiBuildSaves(){var savesAllowed="function"!=typeof Config.saves.isAllowed||Config.saves.isAllowed();function createActionItem(bId,bClass,bText,bAction){var $btn=jQuery(document.createElement("button")).attr("id","saves-".concat(bId)).html(bText);return bClass&&$btn.addClass(bClass),bAction?$btn.ariaClick(bAction):$btn.ariaDisabled(!0),jQuery(document.createElement("li")).append($btn)}var $dialogBody=jQuery(Dialog.setup(L10n.get("savesTitle"),"saves")),savesOk=Save.ok(),fileOk=Has.fileAPI&&(Config.saves.tryDiskOnMobile||!Browser.isMobile.any());if(savesOk&&$dialogBody.append(function(){function createButton(bId,bClass,bText,bSlot,bAction){var $btn=jQuery(document.createElement("button")).attr("id","saves-".concat(bId,"-").concat(bSlot)).addClass(bId).html(bText);return bClass&&$btn.addClass(bClass),bAction?"auto"===bSlot?$btn.ariaClick({label:"".concat(bText," ").concat(L10n.get("savesLabelAuto"))},(function(){return bAction()})):$btn.ariaClick({label:"".concat(bText," ").concat(L10n.get("savesLabelSlot")," ").concat(bSlot+1)},(function(){return bAction(bSlot)})):$btn.ariaDisabled(!0),$btn}var saves=Save.get(),$tbody=jQuery(document.createElement("tbody"));if(Save.autosave.ok()){var $tdSlot=jQuery(document.createElement("td")),$tdLoad=jQuery(document.createElement("td")),$tdDesc=jQuery(document.createElement("td")),$tdDele=jQuery(document.createElement("td"));jQuery(document.createElement("b")).attr({title:L10n.get("savesLabelAuto"),"aria-label":L10n.get("savesLabelAuto")}).text("A").appendTo($tdSlot),saves.autosave?($tdLoad.append(createButton("load","ui-close",L10n.get("savesLabelLoad"),"auto",(function(){jQuery(document).one(":dialogclosed",(function(){return Save.autosave.load()}))}))),jQuery(document.createElement("div")).text(saves.autosave.title).appendTo($tdDesc),jQuery(document.createElement("div")).addClass("datestamp").html(saves.autosave.date?"".concat(new Date(saves.autosave.date).toLocaleString()):"<em>".concat(L10n.get("savesUnknownDate"),"</em>")).appendTo($tdDesc),$tdDele.append(createButton("delete",null,L10n.get("savesLabelDelete"),"auto",(function(){Save.autosave.delete(),uiBuildSaves()})))):($tdLoad.append(createButton("load",null,L10n.get("savesLabelLoad"),"auto")),$tdDesc.addClass("empty").text("•  •  •"),$tdDele.append(createButton("delete",null,L10n.get("savesLabelDelete"),"auto"))),jQuery(document.createElement("tr")).append($tdSlot).append($tdLoad).append($tdDesc).append($tdDele).appendTo($tbody)}for(var i=0,iend=saves.slots.length;i<iend;++i){var _$tdSlot=jQuery(document.createElement("td")),_$tdLoad=jQuery(document.createElement("td")),_$tdDesc=jQuery(document.createElement("td")),_$tdDele=jQuery(document.createElement("td"));_$tdSlot.append(document.createTextNode(i+1)),saves.slots[i]?(_$tdLoad.append(createButton("load","ui-close",L10n.get("savesLabelLoad"),i,(function(slot){jQuery(document).one(":dialogclosed",(function(){return Save.slots.load(slot)}))}))),jQuery(document.createElement("div")).text(saves.slots[i].title).appendTo(_$tdDesc),jQuery(document.createElement("div")).addClass("datestamp").html(saves.slots[i].date?"".concat(new Date(saves.slots[i].date).toLocaleString()):"<em>".concat(L10n.get("savesUnknownDate"),"</em>")).appendTo(_$tdDesc),_$tdDele.append(createButton("delete",null,L10n.get("savesLabelDelete"),i,(function(slot){Save.slots.delete(slot),uiBuildSaves()})))):(_$tdLoad.append(createButton("save","ui-close",L10n.get("savesLabelSave"),i,savesAllowed?Save.slots.save:null)),_$tdDesc.addClass("empty").text("•  •  •"),_$tdDele.append(createButton("delete",null,L10n.get("savesLabelDelete"),i))),jQuery(document.createElement("tr")).append(_$tdSlot).append(_$tdLoad).append(_$tdDesc).append(_$tdDele).appendTo($tbody)}return jQuery(document.createElement("table")).attr("id","saves-list").append($tbody)}()),savesOk||fileOk){var $btnBar=jQuery(document.createElement("ul")).addClass("buttons").appendTo($dialogBody);return fileOk&&($btnBar.append(createActionItem("export","ui-close",L10n.get("savesLabelExport"),savesAllowed?function(){return Save.export()}:null)),$btnBar.append(createActionItem("import",null,L10n.get("savesLabelImport"),(function(){return $dialogBody.find("#saves-import-file").trigger("click")}))),jQuery(document.createElement("input")).css({display:"block",visibility:"hidden",position:"fixed",left:"-9999px",top:"-9999px",width:"1px",height:"1px"}).attr({type:"file",id:"saves-import-file",tabindex:-1,"aria-hidden":!0}).on("change",(function(ev){jQuery(document).one(":dialogclosed",(function(){return Save.import(ev)})),Dialog.close()})).appendTo($dialogBody)),savesOk&&$btnBar.append(createActionItem("clear",null,L10n.get("savesLabelClear"),Save.autosave.has()||!Save.slots.isEmpty()?function(){Save.clear(),uiBuildSaves()}:null)),!0}return uiOpenAlert(L10n.get("savesIncapable")),!1}function uiBuildSettings(){var $dialogBody=jQuery(Dialog.setup(L10n.get("settingsTitle"),"settings"));return Setting.forEach((function(control){if(control.type===Setting.Types.Header){var _name=control.name,_id=Util.slugify(_name),$header=jQuery(document.createElement("div")),$heading=jQuery(document.createElement("h2"));return $header.attr("id","header-body-".concat(_id)).append($heading).appendTo($dialogBody),$heading.attr("id","header-heading-".concat(_id)).wiki(_name),void(control.desc&&jQuery(document.createElement("p")).attr("id","header-desc-".concat(_id)).wiki(control.desc).appendTo($header))}var $control,name=control.name,id=Util.slugify(name),$setting=jQuery(document.createElement("div")),$label=jQuery(document.createElement("label")),$controlBox=jQuery(document.createElement("div"));switch(jQuery(document.createElement("div")).append($label).append($controlBox).appendTo($setting),control.desc&&jQuery(document.createElement("p")).attr("id","setting-desc-".concat(id)).wiki(control.desc).appendTo($setting),$label.attr({id:"setting-label-".concat(id),for:"setting-control-".concat(id)}).wiki(control.label),null==settings[name]&&(settings[name]=control.default),control.type){case Setting.Types.Toggle:$control=jQuery(document.createElement("button")),settings[name]?$control.addClass("enabled").text(L10n.get("settingsOn")):$control.text(L10n.get("settingsOff")),$control.ariaClick((function(){settings[name]?(jQuery(this).removeClass("enabled").text(L10n.get("settingsOff")),settings[name]=!1):(jQuery(this).addClass("enabled").text(L10n.get("settingsOn")),settings[name]=!0),Setting.save(),control.hasOwnProperty("onChange")&&control.onChange.call({name:name,value:settings[name],default:control.default})}));break;case Setting.Types.List:$control=jQuery(document.createElement("select"));for(var i=0,iend=control.list.length;i<iend;++i)jQuery(document.createElement("option")).val(i).text(control.list[i]).appendTo($control);$control.val(control.list.indexOf(settings[name])).attr("tabindex",0).on("change",(function(){settings[name]=control.list[Number(this.value)],Setting.save(),control.hasOwnProperty("onChange")&&control.onChange.call({name:name,value:settings[name],default:control.default,list:control.list})}));break;case Setting.Types.Range:($control=jQuery(document.createElement("input"))).attr({type:"range",min:control.min,max:control.max,step:control.step,value:settings[name],tabindex:0}).on("change input",(function(){settings[name]=Number(this.value),Setting.save(),control.hasOwnProperty("onChange")&&control.onChange.call({name:name,value:settings[name],default:control.default,min:control.min,max:control.max,step:control.step})})).on("keypress",(function(ev){13===ev.which&&(ev.preventDefault(),$control.trigger("change"))}))}$control.attr("id","setting-control-".concat(id)).appendTo($controlBox),$setting.attr("id","setting-body-".concat(id)).appendTo($dialogBody)})),$dialogBody.append('<ul class="buttons">'+'<li><button id="settings-ok" class="ui-close">'.concat(L10n.get(["settingsOk","ok"]),"</button></li>")+'<li><button id="settings-reset">'.concat(L10n.get("settingsReset"),"</button></li>")+"</ul>").find("#settings-reset").ariaClick({one:!0},(function(){jQuery(document).one(":dialogclosed",(function(){Setting.reset(),window.location.reload()})),Dialog.close()})),!0}function uiBuildShare(){try{jQuery(Dialog.setup(L10n.get("shareTitle"),"share list")).append(uiAssembleLinkList("StoryShare"))}catch(ex){return console.error(ex),Alert.error("StoryShare",ex.message),!1}return!0}return Object.freeze(Object.defineProperties({},{assembleLinkList:{value:uiAssembleLinkList},alert:{value:uiOpenAlert},jumpto:{value:function(){uiBuildJumpto(),Dialog.open.apply(Dialog,arguments)}},restart:{value:function(){uiBuildRestart(),Dialog.open.apply(Dialog,arguments)}},saves:{value:function(){uiBuildSaves(),Dialog.open.apply(Dialog,arguments)}},settings:{value:function(){uiBuildSettings(),Dialog.open.apply(Dialog,arguments)}},share:{value:function(){uiBuildShare(),Dialog.open.apply(Dialog,arguments)}},buildAutoload:{value:uiBuildAutoload},buildJumpto:{value:uiBuildJumpto},buildRestart:{value:uiBuildRestart},buildSaves:{value:uiBuildSaves},buildSettings:{value:uiBuildSettings},buildShare:{value:uiBuildShare},stow:{value:function(){return UIBar.stow()}},unstow:{value:function(){return UIBar.unstow()}},setStoryElements:{value:function(){return UIBar.update()}},isOpen:{value:function(){return Dialog.isOpen.apply(Dialog,arguments)}},body:{value:function(){return Dialog.body()}},setup:{value:function(){return Dialog.setup.apply(Dialog,arguments)}},addClickHandler:{value:function(){return Dialog.addClickHandler.apply(Dialog,arguments)}},open:{value:function(){return Dialog.open.apply(Dialog,arguments)}},close:{value:function(){return Dialog.close.apply(Dialog,arguments)}},resize:{value:function(){return Dialog.resize()}},buildDialogAutoload:{value:uiBuildAutoload},buildDialogJumpto:{value:uiBuildJumpto},buildDialogRestart:{value:uiBuildRestart},buildDialogSaves:{value:uiBuildSaves},buildDialogSettings:{value:uiBuildSettings},buildDialogShare:{value:uiBuildShare},buildLinkListFromPassage:{value:uiAssembleLinkList}}))}(),UIBar=function(){var _$uiBar=null;function uiBarStow(noAnimation){var $story;_$uiBar&&!_$uiBar.hasClass("stowed")&&(noAnimation&&(($story=jQuery("#story")).addClass("no-transition"),_$uiBar.addClass("no-transition")),_$uiBar.addClass("stowed"),noAnimation&&setTimeout((function(){$story.removeClass("no-transition"),_$uiBar.removeClass("no-transition")}),Engine.minDomActionDelay));return this}function uiBarUpdate(){if(Story.has("StoryDisplayTitle")&&setDisplayTitle(Story.get("StoryDisplayTitle").processText()),_$uiBar){setPageElement("story-banner","StoryBanner"),setPageElement("story-subtitle","StorySubtitle"),setPageElement("story-author","StoryAuthor"),setPageElement("story-caption","StoryCaption");var menuStory=document.getElementById("menu-story");if(null!==menuStory&&(jQuery(menuStory).empty(),Story.has("StoryMenu")))try{UI.assembleLinkList("StoryMenu",menuStory)}catch(ex){console.error(ex),Alert.error("StoryMenu",ex.message)}}}return Object.freeze(Object.defineProperties({},{destroy:{value:function(){_$uiBar&&(_$uiBar.hide(),jQuery(document).off(".ui-bar"),jQuery(document.head).find("#style-ui-bar").remove(),_$uiBar.remove(),_$uiBar=null)}},hide:{value:function(){return _$uiBar&&_$uiBar.hide(),this}},init:{value:function(){if(!document.getElementById("ui-bar")){var toggleLabel,backwardLabel,jumptoLabel,forwardLabel,$backward,$forward,$elems=(toggleLabel=L10n.get("uiBarToggle"),backwardLabel=L10n.get("uiBarBackward"),jumptoLabel=L10n.get("uiBarJumpto"),forwardLabel=L10n.get("uiBarForward"),jQuery(document.createDocumentFragment()).append('<div id="ui-bar" aria-live="polite"><div id="ui-bar-tray">'+'<button id="ui-bar-toggle" tabindex="0" title="'.concat(toggleLabel,'" aria-label="').concat(toggleLabel,'"></button>')+'<div id="ui-bar-history">'+'<button id="history-backward" tabindex="0" title="'.concat(backwardLabel,'" aria-label="').concat(backwardLabel,'"></button>')+'<button id="history-jumpto" tabindex="0" title="'.concat(jumptoLabel,'" aria-label="').concat(jumptoLabel,'"></button>')+'<button id="history-forward" tabindex="0" title="'.concat(forwardLabel,'" aria-label="').concat(forwardLabel,'"></button>')+'</div></div><div id="ui-bar-body"><header id="title" role="banner"><div id="story-banner"></div><h1 id="story-title"></h1><div id="story-subtitle"></div><div id="story-title-separator"></div><p id="story-author"></p></header><div id="story-caption"></div><nav id="menu" role="navigation"><ul id="menu-story"></ul><ul id="menu-core">'+'<li id="menu-item-saves"><a tabindex="0">'.concat(L10n.get("savesTitle"),"</a></li>")+'<li id="menu-item-settings"><a tabindex="0">'.concat(L10n.get("settingsTitle"),"</a></li>")+'<li id="menu-item-restart"><a tabindex="0">'.concat(L10n.get("restartTitle"),"</a></li>")+'<li id="menu-item-share"><a tabindex="0">'.concat(L10n.get("shareTitle"),"</a></li>")+"</ul></nav></div></div>"));_$uiBar=jQuery($elems.find("#ui-bar").get(0)),$elems.insertBefore("body>script#script-sugarcube"),jQuery(document).on(":historyupdate.ui-bar",($backward=jQuery("#history-backward"),$forward=jQuery("#history-forward"),function(){$backward.ariaDisabled(State.length<2),$forward.ariaDisabled(State.length===State.size)}))}}},isHidden:{value:function(){return _$uiBar&&"none"===_$uiBar.css("display")}},isStowed:{value:function(){return _$uiBar&&_$uiBar.hasClass("stowed")}},show:{value:function(){return _$uiBar&&_$uiBar.show(),this}},start:{value:function(){_$uiBar&&(("boolean"==typeof Config.ui.stowBarInitially?Config.ui.stowBarInitially:jQuery(window).width()<=Config.ui.stowBarInitially)&&uiBarStow(!0),jQuery("#ui-bar-toggle").ariaClick({label:L10n.get("uiBarToggle")},(function(){return _$uiBar.toggleClass("stowed")})),Config.history.controls?(jQuery("#history-backward").ariaDisabled(State.length<2).ariaClick({label:L10n.get("uiBarBackward")},(function(){return Engine.backward()})),Story.lookup("tags","bookmark").length>0?jQuery("#history-jumpto").ariaClick({label:L10n.get("uiBarJumpto")},(function(){return UI.jumpto()})):jQuery("#history-jumpto").remove(),jQuery("#history-forward").ariaDisabled(State.length===State.size).ariaClick({label:L10n.get("uiBarForward")},(function(){return Engine.forward()}))):jQuery("#ui-bar-history").remove(),Story.has("StoryDisplayTitle")?setDisplayTitle(Story.get("StoryDisplayTitle").processText()):jQuery("#story-title").text(Story.title),Story.has("StoryCaption")||jQuery("#story-caption").remove(),Story.has("StoryMenu")||jQuery("#menu-story").remove(),Config.ui.updateStoryElements||uiBarUpdate(),jQuery("#menu-item-saves a").ariaClick({role:"button"},(function(ev){ev.preventDefault(),UI.buildSaves(),Dialog.open()})).text(L10n.get("savesTitle")),Setting.isEmpty()?jQuery("#menu-item-settings").remove():jQuery("#menu-item-settings a").ariaClick({role:"button"},(function(ev){ev.preventDefault(),UI.buildSettings(),Dialog.open()})).text(L10n.get("settingsTitle")),jQuery("#menu-item-restart a").ariaClick({role:"button"},(function(ev){ev.preventDefault(),UI.buildRestart(),Dialog.open()})).text(L10n.get("restartTitle")),Story.has("StoryShare")?jQuery("#menu-item-share a").ariaClick({role:"button"},(function(ev){ev.preventDefault(),UI.buildShare(),Dialog.open()})).text(L10n.get("shareTitle")):jQuery("#menu-item-share").remove())}},stow:{value:uiBarStow},unstow:{value:function(noAnimation){var $story;return _$uiBar&&_$uiBar.hasClass("stowed")&&(noAnimation&&(($story=jQuery("#story")).addClass("no-transition"),_$uiBar.addClass("no-transition")),_$uiBar.removeClass("stowed"),noAnimation&&setTimeout((function(){$story.removeClass("no-transition"),_$uiBar.removeClass("no-transition")}),Engine.minDomActionDelay)),this}},update:{value:uiBarUpdate},setStoryElements:{value:uiBarUpdate}}))}(),DebugBar=function(){var _variableRe=new RegExp("^".concat(Patterns.variable,"$")),_numericKeyRe=/^\d+$/,_watchList=[],_$debugBar=null,_$watchBody=null,_$watchList=null,_$turnSelect=null,_stowed=!0;function debugBarStow(){_$debugBar.css("right","-".concat(_$debugBar.outerWidth(),"px")),_stowed=!0,_updateSession()}function debugBarUnstow(){_$debugBar.css("right",0),_stowed=!1,_updateSession()}function debugBarToggle(){_stowed?debugBarUnstow():debugBarStow()}function debugBarWatchAdd(varName){_variableRe.test(varName)&&(_watchList.pushUnique(varName),_watchList.sort(),_updateWatchBody(),_updateWatchList(),_updateSession())}function debugBarWatchAddAll(){Object.keys(State.variables).map((function(name){return _watchList.pushUnique("$".concat(name))})),Object.keys(State.temporary).map((function(name){return _watchList.pushUnique("_".concat(name))})),_watchList.sort(),_updateWatchBody(),_updateWatchList(),_updateSession()}function debugBarWatchClear(){for(var i=_watchList.length-1;i>=0;--i)_watchList.pop();_updateWatchBody(),_updateWatchList(),_updateSession()}function debugBarWatchDelete(varName){_watchList.delete(varName),_updateWatchBody(),_updateWatchList(),_updateSession()}function debugBarWatchDisable(){_debugBarWatchDisableNoUpdate(),_updateSession()}function debugBarWatchEnable(){_debugBarWatchEnableNoUpdate(),_updateSession()}function debugBarWatchIsEnabled(){return!_$watchBody.attr("hidden")}function debugBarWatchToggle(){_$watchBody.attr("hidden")?debugBarWatchEnable():debugBarWatchDisable()}function _debugBarWatchDisableNoUpdate(){_$watchBody.attr({"aria-hidden":!0,hidden:"hidden"})}function _debugBarWatchEnableNoUpdate(){_$watchBody.removeAttr("aria-hidden hidden")}function _clearSession(){session.delete("debugState")}function _hasSession(){return session.has("debugState")}function _updateSession(){session.set("debugState",{stowed:_stowed,watchList:_watchList,watchEnabled:debugBarWatchIsEnabled(),viewsEnabled:DebugView.isEnabled()})}function _updateWatchBody(){if(0!==_watchList.length){for(var delLabel=L10n.get("debugBarDeleteWatch"),$table=jQuery(document.createElement("table")),$tbody=jQuery(document.createElement("tbody")),_loop4=function(i,len){var varName=_watchList[i],varKey=varName.slice(1),store="$"===varName[0]?State.variables:State.temporary,$row=jQuery(document.createElement("tr")),$delBtn=jQuery(document.createElement("button")),$code=jQuery(document.createElement("code"));$delBtn.addClass("watch-delete").attr("data-name",varName).ariaClick({one:!0,label:delLabel},(function(){return debugBarWatchDelete(varName)})),$code.text(_toWatchString(store[varKey])),jQuery(document.createElement("td")).append($delBtn).appendTo($row),jQuery(document.createElement("td")).text(varName).appendTo($row),jQuery(document.createElement("td")).append($code).appendTo($row),$row.appendTo($tbody)},i=0,len=_watchList.length;i<len;++i)_loop4(i);$table.append($tbody),_$watchBody.empty().append($table)}else _$watchBody.empty().append("<div>".concat(L10n.get("debugBarNoWatches"),"</div>"))}function _updateWatchList(){var svn=Object.keys(State.variables),tvn=Object.keys(State.temporary);if(0!==svn.length||0!==tvn.length){var names=[].concat(_toConsumableArray(svn.map((function(name){return"$".concat(name)}))),_toConsumableArray(tvn.map((function(name){return"_".concat(name)})))).sort(),options=document.createDocumentFragment();names.delete(_watchList);for(var i=0,len=names.length;i<len;++i)jQuery(document.createElement("option")).val(names[i]).appendTo(options);_$watchList.empty().append(options)}else _$watchList.empty()}function _updateTurnSelect(){for(var histLen=State.size,expLen=State.expired.length,options=document.createDocumentFragment(),i=0;i<histLen;++i)jQuery(document.createElement("option")).val(i).text("".concat(expLen+i+1,". ").concat(Util.escape(State.history[i].title))).appendTo(options);_$turnSelect.empty().ariaDisabled(histLen<2).append(options).val(State.activeIndex)}function _toWatchString(value){if(null===value)return"null";switch(_typeof(value)){case"number":if(Number.isNaN(value))return"NaN";if(!Number.isFinite(value))return"Infinity";case"boolean":case"symbol":case"undefined":return String(value);case"string":return JSON.stringify(value);case"function":return"Function"}var objType=Util.toStringTag(value);if("Date"===objType)return"Date {".concat(value.toLocaleString(),"}");if("RegExp"===objType)return"RegExp ".concat(value.toString());var result=[];if(value instanceof Array||value instanceof Set){for(var list=value instanceof Array?value:Array.from(value),i=0,len=list.length;i<len;++i)result.push(list.hasOwnProperty(i)?_toWatchString(list[i]):"<empty>");return Object.keys(list).filter((function(key){return!_numericKeyRe.test(key)})).forEach((function(key){return result.push("".concat(_toWatchString(key),": ").concat(_toWatchString(list[key])))})),"".concat(objType,"(").concat(list.length,") [").concat(result.join(", "),"]")}return value instanceof Map?(value.forEach((function(val,key){return result.push("".concat(_toWatchString(key)," → ").concat(_toWatchString(val)))})),"".concat(objType,"(").concat(value.size,") {").concat(result.join(", "),"}")):(Object.keys(value).forEach((function(key){return result.push("".concat(_toWatchString(key),": ").concat(_toWatchString(value[key])))})),"".concat(objType," {").concat(result.join(", "),"}"))}return Object.freeze(Object.defineProperties({},{init:{value:function(){var barToggleLabel=L10n.get("debugBarToggle"),watchAddLabel=L10n.get("debugBarAddWatch"),watchAllLabel=L10n.get("debugBarWatchAll"),watchNoneLabel=L10n.get("debugBarWatchNone"),watchToggleLabel=L10n.get("debugBarWatchToggle"),viewsToggleLabel=L10n.get("debugBarViewsToggle");jQuery(document.createDocumentFragment()).append('<div id="debug-bar"><div id="debug-bar-watch">'+"<div>".concat(L10n.get("debugBarNoWatches"),"</div>>")+"</div><div>"+'<button id="debug-bar-watch-toggle" tabindex="0" title="'.concat(watchToggleLabel,'" aria-label="').concat(watchToggleLabel,'">').concat(L10n.get("debugBarLabelWatch"),"</button>")+'<label id="debug-bar-watch-label" for="debug-bar-watch-input">'.concat(L10n.get("debugBarLabelAdd"),"</label>")+'<input id="debug-bar-watch-input" name="debug-bar-watch-input" type="text" list="debug-bar-watch-list" tabindex="0"><datalist id="debug-bar-watch-list" aria-hidden="true" hidden="hidden"></datalist>'+'<button id="debug-bar-watch-add" tabindex="0" title="'.concat(watchAddLabel,'" aria-label="').concat(watchAddLabel,'"></button>')+'<button id="debug-bar-watch-all" tabindex="0" title="'.concat(watchAllLabel,'" aria-label="').concat(watchAllLabel,'"></button>')+'<button id="debug-bar-watch-none" tabindex="0" title="'.concat(watchNoneLabel,'" aria-label="').concat(watchNoneLabel,'"></button>')+"</div><div>"+'<button id="debug-bar-views-toggle" tabindex="0" title="'.concat(viewsToggleLabel,'" aria-label="').concat(viewsToggleLabel,'">').concat(L10n.get("debugBarLabelViews"),"</button>")+'<label id="debug-bar-turn-label" for="debug-bar-turn-select">'.concat(L10n.get("debugBarLabelTurn"),"</label>")+'<select id="debug-bar-turn-select" tabindex="0"></select></div>'+'<button id="debug-bar-toggle" tabindex="0" title="'.concat(barToggleLabel,'" aria-label="').concat(barToggleLabel,'"></button>')+'</div><div id="debug-bar-hint"></div>').appendTo("body"),_$debugBar=jQuery("#debug-bar"),_$watchBody=jQuery(_$debugBar.find("#debug-bar-watch").get(0)),_$watchList=jQuery(_$debugBar.find("#debug-bar-watch-list").get(0)),_$turnSelect=jQuery(_$debugBar.find("#debug-bar-turn-select").get(0));var $barToggle=jQuery(_$debugBar.find("#debug-bar-toggle").get(0)),$watchToggle=jQuery(_$debugBar.find("#debug-bar-watch-toggle").get(0)),$watchInput=jQuery(_$debugBar.find("#debug-bar-watch-input").get(0)),$watchAdd=jQuery(_$debugBar.find("#debug-bar-watch-add").get(0)),$watchAll=jQuery(_$debugBar.find("#debug-bar-watch-all").get(0)),$watchNone=jQuery(_$debugBar.find("#debug-bar-watch-none").get(0)),$viewsToggle=jQuery(_$debugBar.find("#debug-bar-views-toggle").get(0));$barToggle.ariaClick(debugBarToggle),$watchToggle.ariaClick(debugBarWatchToggle),$watchInput.on(":addwatch",(function(){debugBarWatchAdd(this.value.trim()),this.value=""})).on("keypress",(function(ev){13===ev.which&&(ev.preventDefault(),$watchInput.trigger(":addwatch"))})),$watchAdd.ariaClick((function(){return $watchInput.trigger(":addwatch")})),$watchAll.ariaClick(debugBarWatchAddAll),$watchNone.ariaClick(debugBarWatchClear),_$turnSelect.on("change",(function(){Engine.goTo(Number(this.value))})),$viewsToggle.ariaClick((function(){DebugView.toggle(),_updateSession()})),jQuery(document).on(":historyupdate.debug-bar",_updateTurnSelect).on(":passageend.debug-bar",(function(){_updateWatchBody(),_updateWatchList()})).on(":enginerestart.debug-bar",_clearSession),_hasSession()||DebugView.enable()}},isStowed:{value:function(){return _stowed}},start:{value:function(){(function(){if(!_hasSession())return!1;var debugState=session.get("debugState");_stowed=debugState.stowed,_watchList.push.apply(_watchList,_toConsumableArray(debugState.watchList)),debugState.watchEnabled?_debugBarWatchEnableNoUpdate():_debugBarWatchDisableNoUpdate();debugState.viewsEnabled?DebugView.enable():DebugView.disable()})(),_stowed?debugBarStow():debugBarUnstow(),_updateTurnSelect(),_updateWatchBody(),_updateWatchList()}},stow:{value:debugBarStow},toggle:{value:debugBarToggle},unstow:{value:debugBarUnstow},watch:{value:Object.freeze(Object.defineProperties({},{add:{value:debugBarWatchAdd},all:{value:debugBarWatchAddAll},clear:{value:debugBarWatchClear},delete:{value:debugBarWatchDelete},disable:{value:debugBarWatchDisable},enable:{value:debugBarWatchEnable},isEnabled:{value:debugBarWatchIsEnabled},toggle:{value:debugBarWatchToggle}}))}}))}(),LoadScreen=function(){var _locks=new Set,_autoId=0;function loadScreenHide(){jQuery(document.documentElement).removeAttr("data-init")}function loadScreenShow(){jQuery(document.documentElement).attr("data-init","loading")}return Object.freeze(Object.defineProperties({},{init:{value:function(){jQuery(document).on("readystatechange.SugarCube",(function(){_locks.size>0||("complete"===document.readyState?"loading"===jQuery(document.documentElement).attr("data-init")&&(Config.loadDelay>0?setTimeout((function(){0===_locks.size&&loadScreenHide()}),Math.max(Engine.minDomActionDelay,Config.loadDelay)):loadScreenHide()):loadScreenShow())}))}},clear:{value:function(){jQuery(document).off("readystatechange.SugarCube"),_locks.clear(),loadScreenHide()}},hide:{value:loadScreenHide},show:{value:loadScreenShow},lock:{value:function(){return++_autoId,_locks.add(_autoId),loadScreenShow(),_autoId}},unlock:{value:function(id){if(null==id)throw new Error("LoadScreen.unlock called with a null or undefined ID");_locks.has(id)&&_locks.delete(id),0===_locks.size&&jQuery(document).trigger("readystatechange")}}}))}(),version=Object.freeze({title:"SugarCube",major:2,minor:36,patch:1,prerelease:null,build:9717,date:new Date("2021-12-22T05:37:33.467Z"),extensions:{},toString:function(){var prerelease=this.prerelease?"-".concat(this.prerelease):"";return"".concat(this.major,".").concat(this.minor,".").concat(this.patch).concat(prerelease,"+").concat(this.build)},short:function(){var prerelease=this.prerelease?"-".concat(this.prerelease):"";return"".concat(this.title," (v").concat(this.major,".").concat(this.minor,".").concat(this.patch).concat(prerelease,")")},long:function(){return"".concat(this.title," v").concat(this.toString()," (").concat(this.date.toUTCString(),")")}}),TempState={},macros={},postdisplay={},postrender={},predisplay={},prehistory={},prerender={},session=null,settings={},setup={},storage=null,browser=Browser,config=Config,has=Has,History=State,state=State,tale=Story,TempVariables=State.temporary;window.SugarCube={},jQuery((function(){try{var lockId=LoadScreen.lock();LoadScreen.init(),document.normalize&&document.normalize(),Story.load(),storage=SimpleStore.create(Story.domId,!0),session=SimpleStore.create(Story.domId,!1),Dialog.init(),UIBar.init(),Engine.init(),Story.init(),L10n.init(),session.has("rcWarn")||"cookie"!==storage.name||(session.set("rcWarn",1),window.alert(L10n.get("warningNoWebStorage"))),Save.init(),Setting.init(),Macro.init(),Engine.start(),Config.debug&&DebugBar.init();var $window=$(window),vprCheckId=setInterval((function(){$window.width()&&(clearInterval(vprCheckId),UIBar.start(),Config.debug&&DebugBar.start(),jQuery.event.trigger({type:":storyready"}),setTimeout((function(){return LoadScreen.unlock(lockId)}),2*Engine.minDomActionDelay))}),Engine.minDomActionDelay);Object.defineProperty(window,"SugarCube",{value:Object.seal(Object.assign(Object.create(null),{Browser:Browser,Config:Config,Dialog:Dialog,Engine:Engine,Fullscreen:Fullscreen,Has:Has,L10n:L10n,Macro:Macro,Passage:Passage,Save:Save,Scripting:Scripting,Setting:Setting,SimpleAudio:SimpleAudio,State:State,Story:Story,UI:UI,UIBar:UIBar,DebugBar:DebugBar,Util:Util,Visibility:Visibility,Wikifier:Wikifier,session:session,settings:settings,setup:setup,storage:storage,version:version}))})}catch(ex){return console.error(ex),LoadScreen.clear(),Alert.fatal(null,ex.message,ex)}}))})(window,window.document,jQuery);}
	</script>
</body>
</html>
